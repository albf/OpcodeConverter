#ifdef __cplusplus
extern "C" {
#endif

#include "vm.h"
#include "syscall.h"
#include <inttypes.h>
#include <stdio.h>
#include <stdlib.h>
#include "journal.h"

#include "HAL.h"

/*
 * Central processing unit. It continuously fetches and executes
 * instructions.
 */

/* Register file. */
uint32_t RF[32];
/*VM memory vector*/
uint8_t VM_memory[VM_MEMORY_SZ] = {0};

uint32_t PC = 0;
uint32_t nPC = 4;
uint8_t rt,rd,rs;
int16_t immediate;

void advance_pc(int32_t offset)
{
	PC  =  nPC;
	nPC  += offset;
}

void xor() {
  RF[rd] = RF[rs] ^ RF[rt];    
}

void addi() {
  RF[rt] = RF[rs] + immediate; //Implementar trap!
}

void lw() {
  RF[rt] = ((uint32_t)(VM_memory[RF[rs] + immediate]) << 24) | ((uint32_t)(VM_memory[RF[rs] + immediate + 1]) << 16) | ((uint32_t)(VM_memory[RF[rs] + immediate + 2]) << 8) | ((uint32_t)VM_memory[RF[rs] + immediate + 3]);
}

void vm_cpu(uint32_t newPC, int opt)
{
#if COUNTING
	int instruct_cnt = 0;
#endif
#if COUNTING_STACK
	int max_stack = VM_MEMORY_SZ;
#endif
	PC = newPC;
	nPC = 4;
	RF[0] = 0; //Register $zero must always be zero
	RF[31] = 1; //Return default (if the program does not set to zero, should put error)
	uint32_t HI = 0, LO = 0;  
	uint32_t offset = 4;
	uint8_t halted = 0;
	
	while (!halted) 
	{
		uint32_t instr = fetch(PC);
		uint8_t op = (instr >> 26) & 0x3F;
		rs = (instr >> 21) & 0x1F;
		rt = (instr >> 16) & 0x1F;
		rd = (instr >> 11) & 0x1F;
		immediate = (instr >> 0) & 0xFFFF;
		uint32_t address = (instr >> 0) & 0x3FFFFFF;
		
		offset = 4; //default offset for non-branching instructions
		//TODO Handle events here!
		switch (op) 
		{
			case 0x0: { // 000000 => Register encoding.
				uint8_t shamt = (instr >> 6) & 0x1F;
				uint8_t funct = (instr >> 0) & 0x3F;
			  
				switch (funct) {
					case 0b100110: { // xor		100110  ArithLog	$d = $s ^ $t
						//RF[rd] = RF[rs] ^ RF[rt];    
						xor();
						break;
					}
					case 0b001100: { // syscall 	001100	syscall		$2		seen on the .s generated by the ecc compiler
						if (syscall((uint8_t)RF[2])) //registers $4 and $5 useb by hallcall (sensid and retval respectively)
						{
							halted = 1; //Syscall returned 1, exit code
#if PRINTING
							printf("Vm stopped by exit signal\n");
#endif
						}
						break; 
					}	
					default:
					{
		#if PRINTING
						if (instr != 0)	printf("\n(ERROR)Invalid instruction %x at PC: %x\n",instr, PC);
		#endif
					}
					break;
				}      
				break; // case 0x0
			}
			
			//Immediate encoding
			case 0b001000: { //addi    001000  ArithLogI       $t = $s + SE(i)
				addi();
				//RF[rt] = RF[rs] + immediate; //Implementar trap!
				break;
			}
			case 0b001001: { //addiu   001001  ArithLogI       $t = $s + SE(i)
				RF[rt] = (RF[rs] + immediate);
				break;
			}
			case 0b100011: { //lw      100011  LoadStore       $t = MEM [$s + i]:4
				lw();
			  	//RF[rt] = ((uint32_t)(VM_memory[RF[rs] + immediate]) << 24) | ((uint32_t)(VM_memory[RF[rs] + immediate + 1]) << 16) | ((uint32_t)(VM_memory[RF[rs] + immediate + 2]) << 8) | ((uint32_t)VM_memory[RF[rs] + immediate + 3]);
				break;
			}
			
			break; //op
			default:
			{
				break;
			}
		}
		advance_pc(offset);//Advances the PC
	}
	
}


uint32_t fetch(uint32_t PC)
{
	uint32_t ret_val = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
	return ret_val;
}
    
#ifdef __cplusplus
}
#endif
