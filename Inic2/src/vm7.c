#include "vm.h"
#include "syscall.h"
#include <inttypes.h>
#include <stdio.h>

#define FIX_OP 43
#define INDIRECT_DEBUG 0
#define T_SIZE 110
/* Register file. */
extern uint32_t RF[32];
/*VM memory vector*/
extern uint8_t VM_memory[VM_MEMORY_SZ];

extern uint32_t PC;
extern uint32_t nPC;
extern int32_t mark3[VM_MEMORY_SZ];

struct pointer {
  void * code;
  struct pointer * next_level;
};
void vm_cpu_super_3(uint32_t newPC, int opt) {
  PC = newPC;
  nPC = 4;
  RF[0] = 0; //Register $zero must always be zero
  RF[31] = 1; //Return default (if the program does not set to zero, should put error)
  uint32_t HI = 0, LO = 0;
  uint32_t offset = 4;
  uint8_t halted = 0;
  int ii;
  
  for (ii = 0; ii<VM_MEMORY_SZ; ii++) {
   mark3[ii] = -1; 
  }
  
  uint8_t rs;
  uint8_t rt;
  uint8_t rd;
  int16_t immediate;
  uint32_t address;
  
  uint8_t shamt;
  uint8_t funct;
  
  uint64_t mult;
  
  #if INDIRECT_DEBUG
  int counter=0;
  #endif
  
  uint32_t instr0;
  uint8_t op0;
  uint32_t instr1;
  uint8_t op1;
  uint32_t instr2;
  uint8_t op2;

struct pointer * p;
struct pointer arraysltuPLUSbeq[T_SIZE] = {  { &&sltuPLUSbeqPLUSsll, NULL }  ,  { &&sltuPLUSbeq, NULL }  ,  { &&sltuPLUSbeq, NULL }  ,  { &&sltuPLUSbeq, NULL }  ,  { &&sltuPLUSbeq, NULL }  ,  { &&sltuPLUSbeq, NULL }  ,  { &&sltuPLUSbeq, NULL }  ,  { &&sltuPLUSbeq, NULL }  ,  { &&sltuPLUSbeq, NULL }  ,  { &&sltuPLUSbeq, NULL } 
 ,  { &&sltuPLUSbeq, NULL }  ,  { &&sltuPLUSbeq, NULL }  ,  { &&sltuPLUSbeq, NULL }  ,  { &&sltuPLUSbeq, NULL }  ,  { &&sltuPLUSbeq, NULL }  ,  { &&sltuPLUSbeq, NULL }  ,  { &&sltuPLUSbeq, NULL }  ,  { &&sltuPLUSbeq, NULL }  ,  { &&sltuPLUSbeq, NULL }  ,  { &&sltuPLUSbeq, NULL } 
 ,  { &&sltuPLUSbeq, NULL }  ,  { &&sltuPLUSbeq, NULL }  ,  { &&sltuPLUSbeq, NULL }  ,  { &&sltuPLUSbeq, NULL }  ,  { &&sltuPLUSbeq, NULL }  ,  { &&sltuPLUSbeq, NULL }  ,  { &&sltuPLUSbeq, NULL }  ,  { &&sltuPLUSbeq, NULL }  ,  { &&sltuPLUSbeq, NULL }  ,  { &&sltuPLUSbeq, NULL } 
 ,  { &&sltuPLUSbeq, NULL }  ,  { &&sltuPLUSbeq, NULL }  ,  { &&sltuPLUSbeq, NULL }  ,  { &&sltuPLUSbeq, NULL }  ,  { &&sltuPLUSbeq, NULL }  ,  { &&sltuPLUSbeq, NULL }  ,  { &&sltuPLUSbeq, NULL }  ,  { &&sltuPLUSbeq, NULL }  ,  { &&sltuPLUSbeq, NULL }  ,  { &&sltuPLUSbeq, NULL } 
 ,  { &&sltuPLUSbeq, NULL }  ,  { &&sltuPLUSbeq, NULL }  ,  { &&sltuPLUSbeq, NULL }  ,  { &&sltuPLUSbeq, NULL }  ,  { &&sltuPLUSbeq, NULL }  ,  { &&sltuPLUSbeq, NULL }  ,  { &&sltuPLUSbeq, NULL }  ,  { &&sltuPLUSbeq, NULL }  ,  { &&sltuPLUSbeq, NULL }  ,  { &&sltuPLUSbeq, NULL } 
 ,  { &&sltuPLUSbeq, NULL }  ,  { &&sltuPLUSbeq, NULL }  ,  { &&sltuPLUSbeqPLUSaddiu, NULL }  ,  { &&sltuPLUSbeq, NULL }  ,  { &&sltuPLUSbeq, NULL }  ,  { &&sltuPLUSbeq, NULL }  ,  { &&sltuPLUSbeq, NULL }  ,  { &&sltuPLUSbeq, NULL }  ,  { &&sltuPLUSbeq, NULL }  ,  { &&sltuPLUSbeq, NULL } 
 ,  { &&sltuPLUSbeq, NULL }  ,  { &&sltuPLUSbeq, NULL }  ,  { &&sltuPLUSbeq, NULL }  ,  { &&sltuPLUSbeq, NULL }  ,  { &&sltuPLUSbeq, NULL }  ,  { &&sltuPLUSbeq, NULL }  ,  { &&sltuPLUSbeq, NULL }  ,  { &&sltuPLUSbeq, NULL }  ,  { &&sltuPLUSbeq, NULL }  ,  { &&sltuPLUSbeq, NULL } 
 ,  { &&sltuPLUSbeq, NULL }  ,  { &&sltuPLUSbeq, NULL }  ,  { &&sltuPLUSbeq, NULL }  ,  { &&sltuPLUSbeq, NULL }  ,  { &&sltuPLUSbeq, NULL }  ,  { &&sltuPLUSbeq, NULL }  ,  { &&sltuPLUSbeq, NULL }  ,  { &&sltuPLUSbeq, NULL }  ,  { &&sltuPLUSbeq, NULL }  ,  { &&sltuPLUSbeq, NULL } 
 ,  { &&sltuPLUSbeq, NULL }  ,  { &&sltuPLUSbeq, NULL }  ,  { &&sltuPLUSbeq, NULL }  ,  { &&sltuPLUSbeq, NULL }  ,  { &&sltuPLUSbeq, NULL }  ,  { &&sltuPLUSbeq, NULL }  ,  { &&sltuPLUSbeq, NULL }  ,  { &&sltuPLUSbeq, NULL }  ,  { &&sltuPLUSbeq, NULL }  ,  { &&sltuPLUSbeq, NULL } 
 ,  { &&sltuPLUSbeq, NULL }  ,  { &&sltuPLUSbeq, NULL }  ,  { &&sltuPLUSbeq, NULL }  ,  { &&sltuPLUSbeq, NULL }  ,  { &&sltuPLUSbeq, NULL }  ,  { &&sltuPLUSbeq, NULL }  ,  { &&sltuPLUSbeq, NULL }  ,  { &&sltuPLUSbeq, NULL }  ,  { &&sltuPLUSbeq, NULL }  ,  { &&sltuPLUSbeq, NULL } 
 ,  { &&sltuPLUSbeq, NULL }  ,  { &&sltuPLUSbeq, NULL }  ,  { &&sltuPLUSbeq, NULL }  ,  { &&sltuPLUSbeq, NULL }  ,  { &&sltuPLUSbeq, NULL }  ,  { &&sltuPLUSbeq, NULL }  ,  { &&sltuPLUSbeq, NULL }  ,  { &&sltuPLUSbeq, NULL }  ,  { &&sltuPLUSbeq, NULL }  ,  { &&sltuPLUSbeq, NULL } 
 }; 

struct pointer arrayaddiuPLUSslt[T_SIZE] = {  { &&addiuPLUSslt, NULL }  ,  { &&addiuPLUSslt, NULL }  ,  { &&addiuPLUSslt, NULL }  ,  { &&addiuPLUSslt, NULL }  ,  { &&addiuPLUSslt, NULL }  ,  { &&addiuPLUSslt, NULL }  ,  { &&addiuPLUSslt, NULL }  ,  { &&addiuPLUSslt, NULL }  ,  { &&addiuPLUSslt, NULL }  ,  { &&addiuPLUSslt, NULL } 
 ,  { &&addiuPLUSslt, NULL }  ,  { &&addiuPLUSslt, NULL }  ,  { &&addiuPLUSslt, NULL }  ,  { &&addiuPLUSslt, NULL }  ,  { &&addiuPLUSslt, NULL }  ,  { &&addiuPLUSslt, NULL }  ,  { &&addiuPLUSslt, NULL }  ,  { &&addiuPLUSslt, NULL }  ,  { &&addiuPLUSslt, NULL }  ,  { &&addiuPLUSslt, NULL } 
 ,  { &&addiuPLUSslt, NULL }  ,  { &&addiuPLUSslt, NULL }  ,  { &&addiuPLUSslt, NULL }  ,  { &&addiuPLUSslt, NULL }  ,  { &&addiuPLUSslt, NULL }  ,  { &&addiuPLUSslt, NULL }  ,  { &&addiuPLUSslt, NULL }  ,  { &&addiuPLUSslt, NULL }  ,  { &&addiuPLUSslt, NULL }  ,  { &&addiuPLUSslt, NULL } 
 ,  { &&addiuPLUSslt, NULL }  ,  { &&addiuPLUSslt, NULL }  ,  { &&addiuPLUSslt, NULL }  ,  { &&addiuPLUSslt, NULL }  ,  { &&addiuPLUSslt, NULL }  ,  { &&addiuPLUSslt, NULL }  ,  { &&addiuPLUSslt, NULL }  ,  { &&addiuPLUSslt, NULL }  ,  { &&addiuPLUSslt, NULL }  ,  { &&addiuPLUSslt, NULL } 
 ,  { &&addiuPLUSslt, NULL }  ,  { &&addiuPLUSslt, NULL }  ,  { &&addiuPLUSslt, NULL }  ,  { &&addiuPLUSslt, NULL }  ,  { &&addiuPLUSslt, NULL }  ,  { &&addiuPLUSslt, NULL }  ,  { &&addiuPLUSslt, NULL }  ,  { &&addiuPLUSsltPLUSbeq, NULL }  ,  { &&addiuPLUSsltPLUSbne, NULL }  ,  { &&addiuPLUSslt, NULL } 
 ,  { &&addiuPLUSslt, NULL }  ,  { &&addiuPLUSslt, NULL }  ,  { &&addiuPLUSslt, NULL }  ,  { &&addiuPLUSslt, NULL }  ,  { &&addiuPLUSslt, NULL }  ,  { &&addiuPLUSslt, NULL }  ,  { &&addiuPLUSslt, NULL }  ,  { &&addiuPLUSslt, NULL }  ,  { &&addiuPLUSslt, NULL }  ,  { &&addiuPLUSslt, NULL } 
 ,  { &&addiuPLUSslt, NULL }  ,  { &&addiuPLUSslt, NULL }  ,  { &&addiuPLUSslt, NULL }  ,  { &&addiuPLUSslt, NULL }  ,  { &&addiuPLUSslt, NULL }  ,  { &&addiuPLUSslt, NULL }  ,  { &&addiuPLUSslt, NULL }  ,  { &&addiuPLUSslt, NULL }  ,  { &&addiuPLUSslt, NULL }  ,  { &&addiuPLUSslt, NULL } 
 ,  { &&addiuPLUSslt, NULL }  ,  { &&addiuPLUSslt, NULL }  ,  { &&addiuPLUSslt, NULL }  ,  { &&addiuPLUSslt, NULL }  ,  { &&addiuPLUSslt, NULL }  ,  { &&addiuPLUSslt, NULL }  ,  { &&addiuPLUSslt, NULL }  ,  { &&addiuPLUSslt, NULL }  ,  { &&addiuPLUSslt, NULL }  ,  { &&addiuPLUSslt, NULL } 
 ,  { &&addiuPLUSslt, NULL }  ,  { &&addiuPLUSslt, NULL }  ,  { &&addiuPLUSslt, NULL }  ,  { &&addiuPLUSslt, NULL }  ,  { &&addiuPLUSslt, NULL }  ,  { &&addiuPLUSslt, NULL }  ,  { &&addiuPLUSslt, NULL }  ,  { &&addiuPLUSslt, NULL }  ,  { &&addiuPLUSslt, NULL }  ,  { &&addiuPLUSslt, NULL } 
 ,  { &&addiuPLUSslt, NULL }  ,  { &&addiuPLUSslt, NULL }  ,  { &&addiuPLUSslt, NULL }  ,  { &&addiuPLUSslt, NULL }  ,  { &&addiuPLUSslt, NULL }  ,  { &&addiuPLUSslt, NULL }  ,  { &&addiuPLUSslt, NULL }  ,  { &&addiuPLUSslt, NULL }  ,  { &&addiuPLUSslt, NULL }  ,  { &&addiuPLUSslt, NULL } 
 ,  { &&addiuPLUSslt, NULL }  ,  { &&addiuPLUSslt, NULL }  ,  { &&addiuPLUSslt, NULL }  ,  { &&addiuPLUSslt, NULL }  ,  { &&addiuPLUSslt, NULL }  ,  { &&addiuPLUSslt, NULL }  ,  { &&addiuPLUSslt, NULL }  ,  { &&addiuPLUSslt, NULL }  ,  { &&addiuPLUSslt, NULL }  ,  { &&addiuPLUSslt, NULL } 
 }; 

struct pointer arrayaddiuPLUSsll[T_SIZE] = {  { &&addiuPLUSsll, NULL }  ,  { &&addiuPLUSsll, NULL }  ,  { &&addiuPLUSsll, NULL }  ,  { &&addiuPLUSsll, NULL }  ,  { &&addiuPLUSsll, NULL }  ,  { &&addiuPLUSsll, NULL }  ,  { &&addiuPLUSsll, NULL }  ,  { &&addiuPLUSsll, NULL }  ,  { &&addiuPLUSsll, NULL }  ,  { &&addiuPLUSsll, NULL } 
 ,  { &&addiuPLUSsll, NULL }  ,  { &&addiuPLUSsll, NULL }  ,  { &&addiuPLUSsll, NULL }  ,  { &&addiuPLUSsll, NULL }  ,  { &&addiuPLUSsll, NULL }  ,  { &&addiuPLUSsll, NULL }  ,  { &&addiuPLUSsll, NULL }  ,  { &&addiuPLUSsll, NULL }  ,  { &&addiuPLUSsll, NULL }  ,  { &&addiuPLUSsll, NULL } 
 ,  { &&addiuPLUSsll, NULL }  ,  { &&addiuPLUSsll, NULL }  ,  { &&addiuPLUSsll, NULL }  ,  { &&addiuPLUSsll, NULL }  ,  { &&addiuPLUSsll, NULL }  ,  { &&addiuPLUSsll, NULL }  ,  { &&addiuPLUSsll, NULL }  ,  { &&addiuPLUSsll, NULL }  ,  { &&addiuPLUSsll, NULL }  ,  { &&addiuPLUSsll, NULL } 
 ,  { &&addiuPLUSsll, NULL }  ,  { &&addiuPLUSsll, NULL }  ,  { &&addiuPLUSsll, NULL }  ,  { &&addiuPLUSsllPLUSaddu, NULL }  ,  { &&addiuPLUSsll, NULL }  ,  { &&addiuPLUSsll, NULL }  ,  { &&addiuPLUSsll, NULL }  ,  { &&addiuPLUSsll, NULL }  ,  { &&addiuPLUSsll, NULL }  ,  { &&addiuPLUSsll, NULL } 
 ,  { &&addiuPLUSsll, NULL }  ,  { &&addiuPLUSsll, NULL }  ,  { &&addiuPLUSsll, NULL }  ,  { &&addiuPLUSsll, NULL }  ,  { &&addiuPLUSsll, NULL }  ,  { &&addiuPLUSsll, NULL }  ,  { &&addiuPLUSsll, NULL }  ,  { &&addiuPLUSsll, NULL }  ,  { &&addiuPLUSsll, NULL }  ,  { &&addiuPLUSsll, NULL } 
 ,  { &&addiuPLUSsll, NULL }  ,  { &&addiuPLUSsll, NULL }  ,  { &&addiuPLUSsll, NULL }  ,  { &&addiuPLUSsll, NULL }  ,  { &&addiuPLUSsll, NULL }  ,  { &&addiuPLUSsllPLUSandi, NULL }  ,  { &&addiuPLUSsll, NULL }  ,  { &&addiuPLUSsll, NULL }  ,  { &&addiuPLUSsll, NULL }  ,  { &&addiuPLUSsll, NULL } 
 ,  { &&addiuPLUSsll, NULL }  ,  { &&addiuPLUSsll, NULL }  ,  { &&addiuPLUSsll, NULL }  ,  { &&addiuPLUSsll, NULL }  ,  { &&addiuPLUSsll, NULL }  ,  { &&addiuPLUSsll, NULL }  ,  { &&addiuPLUSsll, NULL }  ,  { &&addiuPLUSsll, NULL }  ,  { &&addiuPLUSsll, NULL }  ,  { &&addiuPLUSsll, NULL } 
 ,  { &&addiuPLUSsll, NULL }  ,  { &&addiuPLUSsll, NULL }  ,  { &&addiuPLUSsll, NULL }  ,  { &&addiuPLUSsll, NULL }  ,  { &&addiuPLUSsll, NULL }  ,  { &&addiuPLUSsll, NULL }  ,  { &&addiuPLUSsll, NULL }  ,  { &&addiuPLUSsll, NULL }  ,  { &&addiuPLUSsll, NULL }  ,  { &&addiuPLUSsll, NULL } 
 ,  { &&addiuPLUSsll, NULL }  ,  { &&addiuPLUSsll, NULL }  ,  { &&addiuPLUSsll, NULL }  ,  { &&addiuPLUSsll, NULL }  ,  { &&addiuPLUSsll, NULL }  ,  { &&addiuPLUSsll, NULL }  ,  { &&addiuPLUSsll, NULL }  ,  { &&addiuPLUSsll, NULL }  ,  { &&addiuPLUSsll, NULL }  ,  { &&addiuPLUSsll, NULL } 
 ,  { &&addiuPLUSsll, NULL }  ,  { &&addiuPLUSsll, NULL }  ,  { &&addiuPLUSsll, NULL }  ,  { &&addiuPLUSsll, NULL }  ,  { &&addiuPLUSsll, NULL }  ,  { &&addiuPLUSsll, NULL }  ,  { &&addiuPLUSsll, NULL }  ,  { &&addiuPLUSsll, NULL }  ,  { &&addiuPLUSsll, NULL }  ,  { &&addiuPLUSsll, NULL } 
 ,  { &&addiuPLUSsll, NULL }  ,  { &&addiuPLUSsll, NULL }  ,  { &&addiuPLUSsll, NULL }  ,  { &&addiuPLUSsll, NULL }  ,  { &&addiuPLUSsll, NULL }  ,  { &&addiuPLUSsll, NULL }  ,  { &&addiuPLUSsll, NULL }  ,  { &&addiuPLUSsll, NULL }  ,  { &&addiuPLUSsll, NULL }  ,  { &&addiuPLUSsll, NULL } 
 }; 

struct pointer arraysllPLUSbne[T_SIZE] = {  { &&sllPLUSbne, NULL }  ,  { &&sllPLUSbne, NULL }  ,  { &&sllPLUSbne, NULL }  ,  { &&sllPLUSbne, NULL }  ,  { &&sllPLUSbne, NULL }  ,  { &&sllPLUSbne, NULL }  ,  { &&sllPLUSbne, NULL }  ,  { &&sllPLUSbne, NULL }  ,  { &&sllPLUSbne, NULL }  ,  { &&sllPLUSbne, NULL } 
 ,  { &&sllPLUSbne, NULL }  ,  { &&sllPLUSbne, NULL }  ,  { &&sllPLUSbne, NULL }  ,  { &&sllPLUSbne, NULL }  ,  { &&sllPLUSbne, NULL }  ,  { &&sllPLUSbne, NULL }  ,  { &&sllPLUSbne, NULL }  ,  { &&sllPLUSbne, NULL }  ,  { &&sllPLUSbne, NULL }  ,  { &&sllPLUSbne, NULL } 
 ,  { &&sllPLUSbne, NULL }  ,  { &&sllPLUSbne, NULL }  ,  { &&sllPLUSbne, NULL }  ,  { &&sllPLUSbne, NULL }  ,  { &&sllPLUSbne, NULL }  ,  { &&sllPLUSbne, NULL }  ,  { &&sllPLUSbne, NULL }  ,  { &&sllPLUSbne, NULL }  ,  { &&sllPLUSbne, NULL }  ,  { &&sllPLUSbne, NULL } 
 ,  { &&sllPLUSbne, NULL }  ,  { &&sllPLUSbne, NULL }  ,  { &&sllPLUSbne, NULL }  ,  { &&sllPLUSbne, NULL }  ,  { &&sllPLUSbne, NULL }  ,  { &&sllPLUSbne, NULL }  ,  { &&sllPLUSbne, NULL }  ,  { &&sllPLUSbne, NULL }  ,  { &&sllPLUSbne, NULL }  ,  { &&sllPLUSbne, NULL } 
 ,  { &&sllPLUSbne, NULL }  ,  { &&sllPLUSbne, NULL }  ,  { &&sllPLUSbne, NULL }  ,  { &&sllPLUSbne, NULL }  ,  { &&sllPLUSbne, NULL }  ,  { &&sllPLUSbne, NULL }  ,  { &&sllPLUSbne, NULL }  ,  { &&sllPLUSbne, NULL }  ,  { &&sllPLUSbne, NULL }  ,  { &&sllPLUSbne, NULL } 
 ,  { &&sllPLUSbne, NULL }  ,  { &&sllPLUSbne, NULL }  ,  { &&sllPLUSbnePLUSaddiu, NULL }  ,  { &&sllPLUSbne, NULL }  ,  { &&sllPLUSbne, NULL }  ,  { &&sllPLUSbne, NULL }  ,  { &&sllPLUSbne, NULL }  ,  { &&sllPLUSbne, NULL }  ,  { &&sllPLUSbne, NULL }  ,  { &&sllPLUSbne, NULL } 
 ,  { &&sllPLUSbne, NULL }  ,  { &&sllPLUSbne, NULL }  ,  { &&sllPLUSbne, NULL }  ,  { &&sllPLUSbne, NULL }  ,  { &&sllPLUSbne, NULL }  ,  { &&sllPLUSbne, NULL }  ,  { &&sllPLUSbne, NULL }  ,  { &&sllPLUSbne, NULL }  ,  { &&sllPLUSbne, NULL }  ,  { &&sllPLUSbne, NULL } 
 ,  { &&sllPLUSbne, NULL }  ,  { &&sllPLUSbne, NULL }  ,  { &&sllPLUSbne, NULL }  ,  { &&sllPLUSbne, NULL }  ,  { &&sllPLUSbne, NULL }  ,  { &&sllPLUSbne, NULL }  ,  { &&sllPLUSbne, NULL }  ,  { &&sllPLUSbne, NULL }  ,  { &&sllPLUSbne, NULL }  ,  { &&sllPLUSbne, NULL } 
 ,  { &&sllPLUSbne, NULL }  ,  { &&sllPLUSbne, NULL }  ,  { &&sllPLUSbne, NULL }  ,  { &&sllPLUSbne, NULL }  ,  { &&sllPLUSbne, NULL }  ,  { &&sllPLUSbne, NULL }  ,  { &&sllPLUSbne, NULL }  ,  { &&sllPLUSbne, NULL }  ,  { &&sllPLUSbne, NULL }  ,  { &&sllPLUSbne, NULL } 
 ,  { &&sllPLUSbne, NULL }  ,  { &&sllPLUSbne, NULL }  ,  { &&sllPLUSbne, NULL }  ,  { &&sllPLUSbne, NULL }  ,  { &&sllPLUSbne, NULL }  ,  { &&sllPLUSbne, NULL }  ,  { &&sllPLUSbne, NULL }  ,  { &&sllPLUSbne, NULL }  ,  { &&sllPLUSbne, NULL }  ,  { &&sllPLUSbne, NULL } 
 ,  { &&sllPLUSbne, NULL }  ,  { &&sllPLUSbne, NULL }  ,  { &&sllPLUSbne, NULL }  ,  { &&sllPLUSbne, NULL }  ,  { &&sllPLUSbne, NULL }  ,  { &&sllPLUSbne, NULL }  ,  { &&sllPLUSbne, NULL }  ,  { &&sllPLUSbne, NULL }  ,  { &&sllPLUSbne, NULL }  ,  { &&sllPLUSbne, NULL } 
 }; 

struct pointer arraysyscPLUSjr[T_SIZE] = {  { &&syscPLUSjrPLUSsll, NULL }  ,  { &&syscPLUSjr, NULL }  ,  { &&syscPLUSjr, NULL }  ,  { &&syscPLUSjr, NULL }  ,  { &&syscPLUSjr, NULL }  ,  { &&syscPLUSjr, NULL }  ,  { &&syscPLUSjr, NULL }  ,  { &&syscPLUSjr, NULL }  ,  { &&syscPLUSjr, NULL }  ,  { &&syscPLUSjr, NULL } 
 ,  { &&syscPLUSjr, NULL }  ,  { &&syscPLUSjr, NULL }  ,  { &&syscPLUSjr, NULL }  ,  { &&syscPLUSjr, NULL }  ,  { &&syscPLUSjr, NULL }  ,  { &&syscPLUSjr, NULL }  ,  { &&syscPLUSjr, NULL }  ,  { &&syscPLUSjr, NULL }  ,  { &&syscPLUSjr, NULL }  ,  { &&syscPLUSjr, NULL } 
 ,  { &&syscPLUSjr, NULL }  ,  { &&syscPLUSjr, NULL }  ,  { &&syscPLUSjr, NULL }  ,  { &&syscPLUSjr, NULL }  ,  { &&syscPLUSjr, NULL }  ,  { &&syscPLUSjr, NULL }  ,  { &&syscPLUSjr, NULL }  ,  { &&syscPLUSjr, NULL }  ,  { &&syscPLUSjr, NULL }  ,  { &&syscPLUSjr, NULL } 
 ,  { &&syscPLUSjr, NULL }  ,  { &&syscPLUSjr, NULL }  ,  { &&syscPLUSjr, NULL }  ,  { &&syscPLUSjr, NULL }  ,  { &&syscPLUSjr, NULL }  ,  { &&syscPLUSjr, NULL }  ,  { &&syscPLUSjr, NULL }  ,  { &&syscPLUSjr, NULL }  ,  { &&syscPLUSjr, NULL }  ,  { &&syscPLUSjr, NULL } 
 ,  { &&syscPLUSjr, NULL }  ,  { &&syscPLUSjr, NULL }  ,  { &&syscPLUSjr, NULL }  ,  { &&syscPLUSjr, NULL }  ,  { &&syscPLUSjr, NULL }  ,  { &&syscPLUSjr, NULL }  ,  { &&syscPLUSjr, NULL }  ,  { &&syscPLUSjr, NULL }  ,  { &&syscPLUSjr, NULL }  ,  { &&syscPLUSjr, NULL } 
 ,  { &&syscPLUSjr, NULL }  ,  { &&syscPLUSjr, NULL }  ,  { &&syscPLUSjr, NULL }  ,  { &&syscPLUSjr, NULL }  ,  { &&syscPLUSjr, NULL }  ,  { &&syscPLUSjr, NULL }  ,  { &&syscPLUSjr, NULL }  ,  { &&syscPLUSjr, NULL }  ,  { &&syscPLUSjr, NULL }  ,  { &&syscPLUSjr, NULL } 
 ,  { &&syscPLUSjr, NULL }  ,  { &&syscPLUSjr, NULL }  ,  { &&syscPLUSjr, NULL }  ,  { &&syscPLUSjr, NULL }  ,  { &&syscPLUSjr, NULL }  ,  { &&syscPLUSjr, NULL }  ,  { &&syscPLUSjr, NULL }  ,  { &&syscPLUSjr, NULL }  ,  { &&syscPLUSjr, NULL }  ,  { &&syscPLUSjr, NULL } 
 ,  { &&syscPLUSjr, NULL }  ,  { &&syscPLUSjr, NULL }  ,  { &&syscPLUSjr, NULL }  ,  { &&syscPLUSjr, NULL }  ,  { &&syscPLUSjr, NULL }  ,  { &&syscPLUSjr, NULL }  ,  { &&syscPLUSjr, NULL }  ,  { &&syscPLUSjr, NULL }  ,  { &&syscPLUSjr, NULL }  ,  { &&syscPLUSjr, NULL } 
 ,  { &&syscPLUSjr, NULL }  ,  { &&syscPLUSjr, NULL }  ,  { &&syscPLUSjr, NULL }  ,  { &&syscPLUSjr, NULL }  ,  { &&syscPLUSjr, NULL }  ,  { &&syscPLUSjr, NULL }  ,  { &&syscPLUSjr, NULL }  ,  { &&syscPLUSjr, NULL }  ,  { &&syscPLUSjr, NULL }  ,  { &&syscPLUSjr, NULL } 
 ,  { &&syscPLUSjr, NULL }  ,  { &&syscPLUSjr, NULL }  ,  { &&syscPLUSjr, NULL }  ,  { &&syscPLUSjr, NULL }  ,  { &&syscPLUSjr, NULL }  ,  { &&syscPLUSjr, NULL }  ,  { &&syscPLUSjr, NULL }  ,  { &&syscPLUSjr, NULL }  ,  { &&syscPLUSjr, NULL }  ,  { &&syscPLUSjr, NULL } 
 ,  { &&syscPLUSjr, NULL }  ,  { &&syscPLUSjr, NULL }  ,  { &&syscPLUSjr, NULL }  ,  { &&syscPLUSjr, NULL }  ,  { &&syscPLUSjr, NULL }  ,  { &&syscPLUSjr, NULL }  ,  { &&syscPLUSjr, NULL }  ,  { &&syscPLUSjr, NULL }  ,  { &&syscPLUSjr, NULL }  ,  { &&syscPLUSjr, NULL } 
 }; 

struct pointer arraysltiPLUSmovn[T_SIZE] = {  { &&sltiPLUSmovnPLUSsll, NULL }  ,  { &&sltiPLUSmovn, NULL }  ,  { &&sltiPLUSmovn, NULL }  ,  { &&sltiPLUSmovn, NULL }  ,  { &&sltiPLUSmovn, NULL }  ,  { &&sltiPLUSmovn, NULL }  ,  { &&sltiPLUSmovn, NULL }  ,  { &&sltiPLUSmovn, NULL }  ,  { &&sltiPLUSmovn, NULL }  ,  { &&sltiPLUSmovn, NULL } 
 ,  { &&sltiPLUSmovn, NULL }  ,  { &&sltiPLUSmovn, NULL }  ,  { &&sltiPLUSmovn, NULL }  ,  { &&sltiPLUSmovn, NULL }  ,  { &&sltiPLUSmovn, NULL }  ,  { &&sltiPLUSmovn, NULL }  ,  { &&sltiPLUSmovn, NULL }  ,  { &&sltiPLUSmovn, NULL }  ,  { &&sltiPLUSmovn, NULL }  ,  { &&sltiPLUSmovn, NULL } 
 ,  { &&sltiPLUSmovn, NULL }  ,  { &&sltiPLUSmovn, NULL }  ,  { &&sltiPLUSmovn, NULL }  ,  { &&sltiPLUSmovn, NULL }  ,  { &&sltiPLUSmovn, NULL }  ,  { &&sltiPLUSmovn, NULL }  ,  { &&sltiPLUSmovn, NULL }  ,  { &&sltiPLUSmovn, NULL }  ,  { &&sltiPLUSmovn, NULL }  ,  { &&sltiPLUSmovn, NULL } 
 ,  { &&sltiPLUSmovn, NULL }  ,  { &&sltiPLUSmovn, NULL }  ,  { &&sltiPLUSmovn, NULL }  ,  { &&sltiPLUSmovn, NULL }  ,  { &&sltiPLUSmovn, NULL }  ,  { &&sltiPLUSmovn, NULL }  ,  { &&sltiPLUSmovn, NULL }  ,  { &&sltiPLUSmovn, NULL }  ,  { &&sltiPLUSmovn, NULL }  ,  { &&sltiPLUSmovn, NULL } 
 ,  { &&sltiPLUSmovn, NULL }  ,  { &&sltiPLUSmovn, NULL }  ,  { &&sltiPLUSmovn, NULL }  ,  { &&sltiPLUSmovn, NULL }  ,  { &&sltiPLUSmovn, NULL }  ,  { &&sltiPLUSmovn, NULL }  ,  { &&sltiPLUSmovn, NULL }  ,  { &&sltiPLUSmovn, NULL }  ,  { &&sltiPLUSmovnPLUSbne, NULL }  ,  { &&sltiPLUSmovn, NULL } 
 ,  { &&sltiPLUSmovn, NULL }  ,  { &&sltiPLUSmovn, NULL }  ,  { &&sltiPLUSmovnPLUSaddiu, NULL }  ,  { &&sltiPLUSmovn, NULL }  ,  { &&sltiPLUSmovn, NULL }  ,  { &&sltiPLUSmovnPLUSandi, NULL }  ,  { &&sltiPLUSmovn, NULL }  ,  { &&sltiPLUSmovn, NULL }  ,  { &&sltiPLUSmovn, NULL }  ,  { &&sltiPLUSmovn, NULL } 
 ,  { &&sltiPLUSmovn, NULL }  ,  { &&sltiPLUSmovn, NULL }  ,  { &&sltiPLUSmovn, NULL }  ,  { &&sltiPLUSmovn, NULL }  ,  { &&sltiPLUSmovn, NULL }  ,  { &&sltiPLUSmovn, NULL }  ,  { &&sltiPLUSmovn, NULL }  ,  { &&sltiPLUSmovn, NULL }  ,  { &&sltiPLUSmovn, NULL }  ,  { &&sltiPLUSmovn, NULL } 
 ,  { &&sltiPLUSmovn, NULL }  ,  { &&sltiPLUSmovn, NULL }  ,  { &&sltiPLUSmovn, NULL }  ,  { &&sltiPLUSmovn, NULL }  ,  { &&sltiPLUSmovn, NULL }  ,  { &&sltiPLUSmovn, NULL }  ,  { &&sltiPLUSmovn, NULL }  ,  { &&sltiPLUSmovn, NULL }  ,  { &&sltiPLUSmovn, NULL }  ,  { &&sltiPLUSmovn, NULL } 
 ,  { &&sltiPLUSmovn, NULL }  ,  { &&sltiPLUSmovn, NULL }  ,  { &&sltiPLUSmovn, NULL }  ,  { &&sltiPLUSmovn, NULL }  ,  { &&sltiPLUSmovn, NULL }  ,  { &&sltiPLUSmovn, NULL }  ,  { &&sltiPLUSmovn, NULL }  ,  { &&sltiPLUSmovn, NULL }  ,  { &&sltiPLUSmovn, NULL }  ,  { &&sltiPLUSmovn, NULL } 
 ,  { &&sltiPLUSmovn, NULL }  ,  { &&sltiPLUSmovn, NULL }  ,  { &&sltiPLUSmovn, NULL }  ,  { &&sltiPLUSmovn, NULL }  ,  { &&sltiPLUSmovn, NULL }  ,  { &&sltiPLUSmovn, NULL }  ,  { &&sltiPLUSmovn, NULL }  ,  { &&sltiPLUSmovn, NULL }  ,  { &&sltiPLUSmovn, NULL }  ,  { &&sltiPLUSmovn, NULL } 
 ,  { &&sltiPLUSmovn, NULL }  ,  { &&sltiPLUSmovn, NULL }  ,  { &&sltiPLUSmovn, NULL }  ,  { &&sltiPLUSmovn, NULL }  ,  { &&sltiPLUSmovn, NULL }  ,  { &&sltiPLUSmovn, NULL }  ,  { &&sltiPLUSmovn, NULL }  ,  { &&sltiPLUSmovn, NULL }  ,  { &&sltiPLUSmovn, NULL }  ,  { &&sltiPLUSmovn, NULL } 
 }; 

struct pointer arraysllPLUSlui[T_SIZE] = {  { &&sllPLUSlui, NULL }  ,  { &&sllPLUSlui, NULL }  ,  { &&sllPLUSlui, NULL }  ,  { &&sllPLUSlui, NULL }  ,  { &&sllPLUSlui, NULL }  ,  { &&sllPLUSlui, NULL }  ,  { &&sllPLUSlui, NULL }  ,  { &&sllPLUSlui, NULL }  ,  { &&sllPLUSlui, NULL }  ,  { &&sllPLUSlui, NULL } 
 ,  { &&sllPLUSlui, NULL }  ,  { &&sllPLUSlui, NULL }  ,  { &&sllPLUSlui, NULL }  ,  { &&sllPLUSlui, NULL }  ,  { &&sllPLUSlui, NULL }  ,  { &&sllPLUSlui, NULL }  ,  { &&sllPLUSlui, NULL }  ,  { &&sllPLUSlui, NULL }  ,  { &&sllPLUSlui, NULL }  ,  { &&sllPLUSlui, NULL } 
 ,  { &&sllPLUSlui, NULL }  ,  { &&sllPLUSlui, NULL }  ,  { &&sllPLUSlui, NULL }  ,  { &&sllPLUSlui, NULL }  ,  { &&sllPLUSlui, NULL }  ,  { &&sllPLUSlui, NULL }  ,  { &&sllPLUSlui, NULL }  ,  { &&sllPLUSlui, NULL }  ,  { &&sllPLUSlui, NULL }  ,  { &&sllPLUSlui, NULL } 
 ,  { &&sllPLUSlui, NULL }  ,  { &&sllPLUSlui, NULL }  ,  { &&sllPLUSlui, NULL }  ,  { &&sllPLUSlui, NULL }  ,  { &&sllPLUSlui, NULL }  ,  { &&sllPLUSlui, NULL }  ,  { &&sllPLUSlui, NULL }  ,  { &&sllPLUSlui, NULL }  ,  { &&sllPLUSlui, NULL }  ,  { &&sllPLUSlui, NULL } 
 ,  { &&sllPLUSlui, NULL }  ,  { &&sllPLUSlui, NULL }  ,  { &&sllPLUSlui, NULL }  ,  { &&sllPLUSlui, NULL }  ,  { &&sllPLUSlui, NULL }  ,  { &&sllPLUSlui, NULL }  ,  { &&sllPLUSluiPLUSjal, NULL }  ,  { &&sllPLUSlui, NULL }  ,  { &&sllPLUSlui, NULL }  ,  { &&sllPLUSlui, NULL } 
 ,  { &&sllPLUSlui, NULL }  ,  { &&sllPLUSlui, NULL }  ,  { &&sllPLUSluiPLUSaddiu, NULL }  ,  { &&sllPLUSlui, NULL }  ,  { &&sllPLUSlui, NULL }  ,  { &&sllPLUSlui, NULL }  ,  { &&sllPLUSluiPLUSori, NULL }  ,  { &&sllPLUSlui, NULL }  ,  { &&sllPLUSlui, NULL }  ,  { &&sllPLUSlui, NULL } 
 ,  { &&sllPLUSlui, NULL }  ,  { &&sllPLUSlui, NULL }  ,  { &&sllPLUSlui, NULL }  ,  { &&sllPLUSlui, NULL }  ,  { &&sllPLUSlui, NULL }  ,  { &&sllPLUSlui, NULL }  ,  { &&sllPLUSlui, NULL }  ,  { &&sllPLUSlui, NULL }  ,  { &&sllPLUSlui, NULL }  ,  { &&sllPLUSlui, NULL } 
 ,  { &&sllPLUSlui, NULL }  ,  { &&sllPLUSlui, NULL }  ,  { &&sllPLUSlui, NULL }  ,  { &&sllPLUSlui, NULL }  ,  { &&sllPLUSlui, NULL }  ,  { &&sllPLUSlui, NULL }  ,  { &&sllPLUSlui, NULL }  ,  { &&sllPLUSlui, NULL }  ,  { &&sllPLUSlui, NULL }  ,  { &&sllPLUSlui, NULL } 
 ,  { &&sllPLUSlui, NULL }  ,  { &&sllPLUSlui, NULL }  ,  { &&sllPLUSlui, NULL }  ,  { &&sllPLUSlui, NULL }  ,  { &&sllPLUSlui, NULL }  ,  { &&sllPLUSlui, NULL }  ,  { &&sllPLUSluiPLUSsw, NULL }  ,  { &&sllPLUSlui, NULL }  ,  { &&sllPLUSlui, NULL }  ,  { &&sllPLUSlui, NULL } 
 ,  { &&sllPLUSlui, NULL }  ,  { &&sllPLUSlui, NULL }  ,  { &&sllPLUSlui, NULL }  ,  { &&sllPLUSlui, NULL }  ,  { &&sllPLUSlui, NULL }  ,  { &&sllPLUSlui, NULL }  ,  { &&sllPLUSlui, NULL }  ,  { &&sllPLUSlui, NULL }  ,  { &&sllPLUSlui, NULL }  ,  { &&sllPLUSlui, NULL } 
 ,  { &&sllPLUSlui, NULL }  ,  { &&sllPLUSlui, NULL }  ,  { &&sllPLUSlui, NULL }  ,  { &&sllPLUSlui, NULL }  ,  { &&sllPLUSlui, NULL }  ,  { &&sllPLUSlui, NULL }  ,  { &&sllPLUSlui, NULL }  ,  { &&sllPLUSlui, NULL }  ,  { &&sllPLUSlui, NULL }  ,  { &&sllPLUSlui, NULL } 
 }; 

struct pointer arraybnePLUSsll[T_SIZE] = {  { &&bnePLUSsllPLUSsll, NULL }  ,  { &&bnePLUSsll, NULL }  ,  { &&bnePLUSsll, NULL }  ,  { &&bnePLUSsll, NULL }  ,  { &&bnePLUSsll, NULL }  ,  { &&bnePLUSsll, NULL }  ,  { &&bnePLUSsll, NULL }  ,  { &&bnePLUSsll, NULL }  ,  { &&bnePLUSsll, NULL }  ,  { &&bnePLUSsll, NULL } 
 ,  { &&bnePLUSsll, NULL }  ,  { &&bnePLUSsll, NULL }  ,  { &&bnePLUSsll, NULL }  ,  { &&bnePLUSsll, NULL }  ,  { &&bnePLUSsll, NULL }  ,  { &&bnePLUSsll, NULL }  ,  { &&bnePLUSsll, NULL }  ,  { &&bnePLUSsll, NULL }  ,  { &&bnePLUSsll, NULL }  ,  { &&bnePLUSsll, NULL } 
 ,  { &&bnePLUSsll, NULL }  ,  { &&bnePLUSsll, NULL }  ,  { &&bnePLUSsll, NULL }  ,  { &&bnePLUSsll, NULL }  ,  { &&bnePLUSsll, NULL }  ,  { &&bnePLUSsll, NULL }  ,  { &&bnePLUSsll, NULL }  ,  { &&bnePLUSsll, NULL }  ,  { &&bnePLUSsll, NULL }  ,  { &&bnePLUSsll, NULL } 
 ,  { &&bnePLUSsll, NULL }  ,  { &&bnePLUSsll, NULL }  ,  { &&bnePLUSsll, NULL }  ,  { &&bnePLUSsll, NULL }  ,  { &&bnePLUSsll, NULL }  ,  { &&bnePLUSsll, NULL }  ,  { &&bnePLUSsll, NULL }  ,  { &&bnePLUSsllPLUSor, NULL }  ,  { &&bnePLUSsll, NULL }  ,  { &&bnePLUSsll, NULL } 
 ,  { &&bnePLUSsll, NULL }  ,  { &&bnePLUSsll, NULL }  ,  { &&bnePLUSsllPLUSslt, NULL }  ,  { &&bnePLUSsll, NULL }  ,  { &&bnePLUSsll, NULL }  ,  { &&bnePLUSsllPLUSjump, NULL }  ,  { &&bnePLUSsll, NULL }  ,  { &&bnePLUSsll, NULL }  ,  { &&bnePLUSsll, NULL }  ,  { &&bnePLUSsllPLUSblez, NULL } 
 ,  { &&bnePLUSsll, NULL }  ,  { &&bnePLUSsll, NULL }  ,  { &&bnePLUSsllPLUSaddiu, NULL }  ,  { &&bnePLUSsll, NULL }  ,  { &&bnePLUSsll, NULL }  ,  { &&bnePLUSsllPLUSandi, NULL }  ,  { &&bnePLUSsll, NULL }  ,  { &&bnePLUSsll, NULL }  ,  { &&bnePLUSsllPLUSlui, NULL }  ,  { &&bnePLUSsll, NULL } 
 ,  { &&bnePLUSsll, NULL }  ,  { &&bnePLUSsll, NULL }  ,  { &&bnePLUSsll, NULL }  ,  { &&bnePLUSsll, NULL }  ,  { &&bnePLUSsll, NULL }  ,  { &&bnePLUSsll, NULL }  ,  { &&bnePLUSsll, NULL }  ,  { &&bnePLUSsll, NULL }  ,  { &&bnePLUSsll, NULL }  ,  { &&bnePLUSsll, NULL } 
 ,  { &&bnePLUSsll, NULL }  ,  { &&bnePLUSsll, NULL }  ,  { &&bnePLUSsll, NULL }  ,  { &&bnePLUSsll, NULL }  ,  { &&bnePLUSsll, NULL }  ,  { &&bnePLUSsll, NULL }  ,  { &&bnePLUSsll, NULL }  ,  { &&bnePLUSsll, NULL }  ,  { &&bnePLUSsllPLUSlw, NULL }  ,  { &&bnePLUSsllPLUSlbu, NULL } 
 ,  { &&bnePLUSsll, NULL }  ,  { &&bnePLUSsll, NULL }  ,  { &&bnePLUSsll, NULL }  ,  { &&bnePLUSsll, NULL }  ,  { &&bnePLUSsll, NULL }  ,  { &&bnePLUSsll, NULL }  ,  { &&bnePLUSsllPLUSsw, NULL }  ,  { &&bnePLUSsll, NULL }  ,  { &&bnePLUSsll, NULL }  ,  { &&bnePLUSsll, NULL } 
 ,  { &&bnePLUSsll, NULL }  ,  { &&bnePLUSsll, NULL }  ,  { &&bnePLUSsll, NULL }  ,  { &&bnePLUSsll, NULL }  ,  { &&bnePLUSsll, NULL }  ,  { &&bnePLUSsll, NULL }  ,  { &&bnePLUSsll, NULL }  ,  { &&bnePLUSsll, NULL }  ,  { &&bnePLUSsll, NULL }  ,  { &&bnePLUSsll, NULL } 
 ,  { &&bnePLUSsll, NULL }  ,  { &&bnePLUSsll, NULL }  ,  { &&bnePLUSsll, NULL }  ,  { &&bnePLUSsll, NULL }  ,  { &&bnePLUSsll, NULL }  ,  { &&bnePLUSsll, NULL }  ,  { &&bnePLUSsll, NULL }  ,  { &&bnePLUSsll, NULL }  ,  { &&bnePLUSsll, NULL }  ,  { &&bnePLUSsll, NULL } 
 }; 

struct pointer arrayaddiuPLUSbne[T_SIZE] = {  { &&addiuPLUSbnePLUSsll, NULL }  ,  { &&addiuPLUSbne, NULL }  ,  { &&addiuPLUSbne, NULL }  ,  { &&addiuPLUSbne, NULL }  ,  { &&addiuPLUSbne, NULL }  ,  { &&addiuPLUSbne, NULL }  ,  { &&addiuPLUSbne, NULL }  ,  { &&addiuPLUSbne, NULL }  ,  { &&addiuPLUSbne, NULL }  ,  { &&addiuPLUSbne, NULL } 
 ,  { &&addiuPLUSbne, NULL }  ,  { &&addiuPLUSbne, NULL }  ,  { &&addiuPLUSbne, NULL }  ,  { &&addiuPLUSbne, NULL }  ,  { &&addiuPLUSbne, NULL }  ,  { &&addiuPLUSbne, NULL }  ,  { &&addiuPLUSbne, NULL }  ,  { &&addiuPLUSbne, NULL }  ,  { &&addiuPLUSbne, NULL }  ,  { &&addiuPLUSbne, NULL } 
 ,  { &&addiuPLUSbne, NULL }  ,  { &&addiuPLUSbne, NULL }  ,  { &&addiuPLUSbne, NULL }  ,  { &&addiuPLUSbne, NULL }  ,  { &&addiuPLUSbne, NULL }  ,  { &&addiuPLUSbne, NULL }  ,  { &&addiuPLUSbne, NULL }  ,  { &&addiuPLUSbne, NULL }  ,  { &&addiuPLUSbne, NULL }  ,  { &&addiuPLUSbne, NULL } 
 ,  { &&addiuPLUSbne, NULL }  ,  { &&addiuPLUSbne, NULL }  ,  { &&addiuPLUSbne, NULL }  ,  { &&addiuPLUSbne, NULL }  ,  { &&addiuPLUSbne, NULL }  ,  { &&addiuPLUSbne, NULL }  ,  { &&addiuPLUSbne, NULL }  ,  { &&addiuPLUSbne, NULL }  ,  { &&addiuPLUSbne, NULL }  ,  { &&addiuPLUSbne, NULL } 
 ,  { &&addiuPLUSbne, NULL }  ,  { &&addiuPLUSbne, NULL }  ,  { &&addiuPLUSbne, NULL }  ,  { &&addiuPLUSbne, NULL }  ,  { &&addiuPLUSbne, NULL }  ,  { &&addiuPLUSbne, NULL }  ,  { &&addiuPLUSbne, NULL }  ,  { &&addiuPLUSbne, NULL }  ,  { &&addiuPLUSbne, NULL }  ,  { &&addiuPLUSbne, NULL } 
 ,  { &&addiuPLUSbne, NULL }  ,  { &&addiuPLUSbne, NULL }  ,  { &&addiuPLUSbnePLUSaddiu, NULL }  ,  { &&addiuPLUSbne, NULL }  ,  { &&addiuPLUSbne, NULL }  ,  { &&addiuPLUSbne, NULL }  ,  { &&addiuPLUSbne, NULL }  ,  { &&addiuPLUSbne, NULL }  ,  { &&addiuPLUSbne, NULL }  ,  { &&addiuPLUSbne, NULL } 
 ,  { &&addiuPLUSbne, NULL }  ,  { &&addiuPLUSbne, NULL }  ,  { &&addiuPLUSbne, NULL }  ,  { &&addiuPLUSbne, NULL }  ,  { &&addiuPLUSbne, NULL }  ,  { &&addiuPLUSbne, NULL }  ,  { &&addiuPLUSbne, NULL }  ,  { &&addiuPLUSbne, NULL }  ,  { &&addiuPLUSbne, NULL }  ,  { &&addiuPLUSbne, NULL } 
 ,  { &&addiuPLUSbne, NULL }  ,  { &&addiuPLUSbne, NULL }  ,  { &&addiuPLUSbne, NULL }  ,  { &&addiuPLUSbne, NULL }  ,  { &&addiuPLUSbne, NULL }  ,  { &&addiuPLUSbne, NULL }  ,  { &&addiuPLUSbne, NULL }  ,  { &&addiuPLUSbne, NULL }  ,  { &&addiuPLUSbne, NULL }  ,  { &&addiuPLUSbne, NULL } 
 ,  { &&addiuPLUSbne, NULL }  ,  { &&addiuPLUSbne, NULL }  ,  { &&addiuPLUSbne, NULL }  ,  { &&addiuPLUSbne, NULL }  ,  { &&addiuPLUSbne, NULL }  ,  { &&addiuPLUSbne, NULL }  ,  { &&addiuPLUSbne, NULL }  ,  { &&addiuPLUSbne, NULL }  ,  { &&addiuPLUSbne, NULL }  ,  { &&addiuPLUSbne, NULL } 
 ,  { &&addiuPLUSbne, NULL }  ,  { &&addiuPLUSbne, NULL }  ,  { &&addiuPLUSbne, NULL }  ,  { &&addiuPLUSbne, NULL }  ,  { &&addiuPLUSbne, NULL }  ,  { &&addiuPLUSbne, NULL }  ,  { &&addiuPLUSbne, NULL }  ,  { &&addiuPLUSbne, NULL }  ,  { &&addiuPLUSbne, NULL }  ,  { &&addiuPLUSbne, NULL } 
 ,  { &&addiuPLUSbne, NULL }  ,  { &&addiuPLUSbne, NULL }  ,  { &&addiuPLUSbne, NULL }  ,  { &&addiuPLUSbne, NULL }  ,  { &&addiuPLUSbne, NULL }  ,  { &&addiuPLUSbne, NULL }  ,  { &&addiuPLUSbne, NULL }  ,  { &&addiuPLUSbne, NULL }  ,  { &&addiuPLUSbne, NULL }  ,  { &&addiuPLUSbne, NULL } 
 }; 

struct pointer arrayswPLUSjump[T_SIZE] = {  { &&swPLUSjumpPLUSsll, NULL }  ,  { &&swPLUSjump, NULL }  ,  { &&swPLUSjump, NULL }  ,  { &&swPLUSjump, NULL }  ,  { &&swPLUSjump, NULL }  ,  { &&swPLUSjump, NULL }  ,  { &&swPLUSjump, NULL }  ,  { &&swPLUSjump, NULL }  ,  { &&swPLUSjump, NULL }  ,  { &&swPLUSjump, NULL } 
 ,  { &&swPLUSjump, NULL }  ,  { &&swPLUSjump, NULL }  ,  { &&swPLUSjump, NULL }  ,  { &&swPLUSjump, NULL }  ,  { &&swPLUSjump, NULL }  ,  { &&swPLUSjump, NULL }  ,  { &&swPLUSjump, NULL }  ,  { &&swPLUSjump, NULL }  ,  { &&swPLUSjump, NULL }  ,  { &&swPLUSjump, NULL } 
 ,  { &&swPLUSjump, NULL }  ,  { &&swPLUSjump, NULL }  ,  { &&swPLUSjump, NULL }  ,  { &&swPLUSjump, NULL }  ,  { &&swPLUSjump, NULL }  ,  { &&swPLUSjump, NULL }  ,  { &&swPLUSjump, NULL }  ,  { &&swPLUSjump, NULL }  ,  { &&swPLUSjump, NULL }  ,  { &&swPLUSjump, NULL } 
 ,  { &&swPLUSjump, NULL }  ,  { &&swPLUSjump, NULL }  ,  { &&swPLUSjump, NULL }  ,  { &&swPLUSjump, NULL }  ,  { &&swPLUSjump, NULL }  ,  { &&swPLUSjump, NULL }  ,  { &&swPLUSjump, NULL }  ,  { &&swPLUSjump, NULL }  ,  { &&swPLUSjump, NULL }  ,  { &&swPLUSjump, NULL } 
 ,  { &&swPLUSjump, NULL }  ,  { &&swPLUSjump, NULL }  ,  { &&swPLUSjump, NULL }  ,  { &&swPLUSjump, NULL }  ,  { &&swPLUSjump, NULL }  ,  { &&swPLUSjump, NULL }  ,  { &&swPLUSjump, NULL }  ,  { &&swPLUSjump, NULL }  ,  { &&swPLUSjump, NULL }  ,  { &&swPLUSjump, NULL } 
 ,  { &&swPLUSjump, NULL }  ,  { &&swPLUSjump, NULL }  ,  { &&swPLUSjump, NULL }  ,  { &&swPLUSjump, NULL }  ,  { &&swPLUSjump, NULL }  ,  { &&swPLUSjump, NULL }  ,  { &&swPLUSjump, NULL }  ,  { &&swPLUSjump, NULL }  ,  { &&swPLUSjump, NULL }  ,  { &&swPLUSjump, NULL } 
 ,  { &&swPLUSjump, NULL }  ,  { &&swPLUSjump, NULL }  ,  { &&swPLUSjump, NULL }  ,  { &&swPLUSjump, NULL }  ,  { &&swPLUSjump, NULL }  ,  { &&swPLUSjump, NULL }  ,  { &&swPLUSjump, NULL }  ,  { &&swPLUSjump, NULL }  ,  { &&swPLUSjump, NULL }  ,  { &&swPLUSjump, NULL } 
 ,  { &&swPLUSjump, NULL }  ,  { &&swPLUSjump, NULL }  ,  { &&swPLUSjump, NULL }  ,  { &&swPLUSjump, NULL }  ,  { &&swPLUSjump, NULL }  ,  { &&swPLUSjump, NULL }  ,  { &&swPLUSjump, NULL }  ,  { &&swPLUSjump, NULL }  ,  { &&swPLUSjump, NULL }  ,  { &&swPLUSjump, NULL } 
 ,  { &&swPLUSjump, NULL }  ,  { &&swPLUSjump, NULL }  ,  { &&swPLUSjump, NULL }  ,  { &&swPLUSjump, NULL }  ,  { &&swPLUSjump, NULL }  ,  { &&swPLUSjump, NULL }  ,  { &&swPLUSjump, NULL }  ,  { &&swPLUSjump, NULL }  ,  { &&swPLUSjump, NULL }  ,  { &&swPLUSjump, NULL } 
 ,  { &&swPLUSjump, NULL }  ,  { &&swPLUSjump, NULL }  ,  { &&swPLUSjump, NULL }  ,  { &&swPLUSjump, NULL }  ,  { &&swPLUSjump, NULL }  ,  { &&swPLUSjump, NULL }  ,  { &&swPLUSjump, NULL }  ,  { &&swPLUSjump, NULL }  ,  { &&swPLUSjump, NULL }  ,  { &&swPLUSjump, NULL } 
 ,  { &&swPLUSjump, NULL }  ,  { &&swPLUSjump, NULL }  ,  { &&swPLUSjump, NULL }  ,  { &&swPLUSjump, NULL }  ,  { &&swPLUSjump, NULL }  ,  { &&swPLUSjump, NULL }  ,  { &&swPLUSjump, NULL }  ,  { &&swPLUSjump, NULL }  ,  { &&swPLUSjump, NULL }  ,  { &&swPLUSjump, NULL } 
 }; 

struct pointer arraysltiPLUSsw[T_SIZE] = {  { &&sltiPLUSsw, NULL }  ,  { &&sltiPLUSsw, NULL }  ,  { &&sltiPLUSsw, NULL }  ,  { &&sltiPLUSsw, NULL }  ,  { &&sltiPLUSsw, NULL }  ,  { &&sltiPLUSsw, NULL }  ,  { &&sltiPLUSsw, NULL }  ,  { &&sltiPLUSsw, NULL }  ,  { &&sltiPLUSsw, NULL }  ,  { &&sltiPLUSsw, NULL } 
 ,  { &&sltiPLUSsw, NULL }  ,  { &&sltiPLUSsw, NULL }  ,  { &&sltiPLUSsw, NULL }  ,  { &&sltiPLUSsw, NULL }  ,  { &&sltiPLUSsw, NULL }  ,  { &&sltiPLUSsw, NULL }  ,  { &&sltiPLUSsw, NULL }  ,  { &&sltiPLUSsw, NULL }  ,  { &&sltiPLUSsw, NULL }  ,  { &&sltiPLUSsw, NULL } 
 ,  { &&sltiPLUSsw, NULL }  ,  { &&sltiPLUSsw, NULL }  ,  { &&sltiPLUSsw, NULL }  ,  { &&sltiPLUSsw, NULL }  ,  { &&sltiPLUSsw, NULL }  ,  { &&sltiPLUSsw, NULL }  ,  { &&sltiPLUSsw, NULL }  ,  { &&sltiPLUSsw, NULL }  ,  { &&sltiPLUSsw, NULL }  ,  { &&sltiPLUSsw, NULL } 
 ,  { &&sltiPLUSsw, NULL }  ,  { &&sltiPLUSsw, NULL }  ,  { &&sltiPLUSsw, NULL }  ,  { &&sltiPLUSsw, NULL }  ,  { &&sltiPLUSsw, NULL }  ,  { &&sltiPLUSsw, NULL }  ,  { &&sltiPLUSsw, NULL }  ,  { &&sltiPLUSsw, NULL }  ,  { &&sltiPLUSsw, NULL }  ,  { &&sltiPLUSsw, NULL } 
 ,  { &&sltiPLUSsw, NULL }  ,  { &&sltiPLUSsw, NULL }  ,  { &&sltiPLUSsw, NULL }  ,  { &&sltiPLUSsw, NULL }  ,  { &&sltiPLUSsw, NULL }  ,  { &&sltiPLUSsw, NULL }  ,  { &&sltiPLUSsw, NULL }  ,  { &&sltiPLUSsw, NULL }  ,  { &&sltiPLUSsw, NULL }  ,  { &&sltiPLUSsw, NULL } 
 ,  { &&sltiPLUSsw, NULL }  ,  { &&sltiPLUSsw, NULL }  ,  { &&sltiPLUSswPLUSaddiu, NULL }  ,  { &&sltiPLUSswPLUSslti, NULL }  ,  { &&sltiPLUSsw, NULL }  ,  { &&sltiPLUSsw, NULL }  ,  { &&sltiPLUSsw, NULL }  ,  { &&sltiPLUSsw, NULL }  ,  { &&sltiPLUSsw, NULL }  ,  { &&sltiPLUSsw, NULL } 
 ,  { &&sltiPLUSsw, NULL }  ,  { &&sltiPLUSsw, NULL }  ,  { &&sltiPLUSsw, NULL }  ,  { &&sltiPLUSsw, NULL }  ,  { &&sltiPLUSsw, NULL }  ,  { &&sltiPLUSsw, NULL }  ,  { &&sltiPLUSsw, NULL }  ,  { &&sltiPLUSsw, NULL }  ,  { &&sltiPLUSsw, NULL }  ,  { &&sltiPLUSsw, NULL } 
 ,  { &&sltiPLUSsw, NULL }  ,  { &&sltiPLUSsw, NULL }  ,  { &&sltiPLUSsw, NULL }  ,  { &&sltiPLUSsw, NULL }  ,  { &&sltiPLUSsw, NULL }  ,  { &&sltiPLUSsw, NULL }  ,  { &&sltiPLUSsw, NULL }  ,  { &&sltiPLUSsw, NULL }  ,  { &&sltiPLUSsw, NULL }  ,  { &&sltiPLUSsw, NULL } 
 ,  { &&sltiPLUSsw, NULL }  ,  { &&sltiPLUSsw, NULL }  ,  { &&sltiPLUSsw, NULL }  ,  { &&sltiPLUSsw, NULL }  ,  { &&sltiPLUSsw, NULL }  ,  { &&sltiPLUSsw, NULL }  ,  { &&sltiPLUSsw, NULL }  ,  { &&sltiPLUSsw, NULL }  ,  { &&sltiPLUSsw, NULL }  ,  { &&sltiPLUSsw, NULL } 
 ,  { &&sltiPLUSsw, NULL }  ,  { &&sltiPLUSsw, NULL }  ,  { &&sltiPLUSsw, NULL }  ,  { &&sltiPLUSsw, NULL }  ,  { &&sltiPLUSsw, NULL }  ,  { &&sltiPLUSsw, NULL }  ,  { &&sltiPLUSsw, NULL }  ,  { &&sltiPLUSsw, NULL }  ,  { &&sltiPLUSsw, NULL }  ,  { &&sltiPLUSsw, NULL } 
 ,  { &&sltiPLUSsw, NULL }  ,  { &&sltiPLUSsw, NULL }  ,  { &&sltiPLUSsw, NULL }  ,  { &&sltiPLUSsw, NULL }  ,  { &&sltiPLUSsw, NULL }  ,  { &&sltiPLUSsw, NULL }  ,  { &&sltiPLUSsw, NULL }  ,  { &&sltiPLUSsw, NULL }  ,  { &&sltiPLUSsw, NULL }  ,  { &&sltiPLUSsw, NULL } 
 }; 

struct pointer arrayorPLUSaddu[T_SIZE] = {  { &&orPLUSaddu, NULL }  ,  { &&orPLUSaddu, NULL }  ,  { &&orPLUSaddu, NULL }  ,  { &&orPLUSaddu, NULL }  ,  { &&orPLUSaddu, NULL }  ,  { &&orPLUSaddu, NULL }  ,  { &&orPLUSaddu, NULL }  ,  { &&orPLUSaddu, NULL }  ,  { &&orPLUSaddu, NULL }  ,  { &&orPLUSaddu, NULL } 
 ,  { &&orPLUSaddu, NULL }  ,  { &&orPLUSaddu, NULL }  ,  { &&orPLUSaddu, NULL }  ,  { &&orPLUSaddu, NULL }  ,  { &&orPLUSaddu, NULL }  ,  { &&orPLUSaddu, NULL }  ,  { &&orPLUSaddu, NULL }  ,  { &&orPLUSaddu, NULL }  ,  { &&orPLUSaddu, NULL }  ,  { &&orPLUSaddu, NULL } 
 ,  { &&orPLUSaddu, NULL }  ,  { &&orPLUSaddu, NULL }  ,  { &&orPLUSaddu, NULL }  ,  { &&orPLUSaddu, NULL }  ,  { &&orPLUSaddu, NULL }  ,  { &&orPLUSaddu, NULL }  ,  { &&orPLUSaddu, NULL }  ,  { &&orPLUSaddu, NULL }  ,  { &&orPLUSaddu, NULL }  ,  { &&orPLUSaddu, NULL } 
 ,  { &&orPLUSaddu, NULL }  ,  { &&orPLUSaddu, NULL }  ,  { &&orPLUSaddu, NULL }  ,  { &&orPLUSaddu, NULL }  ,  { &&orPLUSaddu, NULL }  ,  { &&orPLUSaddu, NULL }  ,  { &&orPLUSaddu, NULL }  ,  { &&orPLUSaddu, NULL }  ,  { &&orPLUSaddu, NULL }  ,  { &&orPLUSaddu, NULL } 
 ,  { &&orPLUSaddu, NULL }  ,  { &&orPLUSaddu, NULL }  ,  { &&orPLUSaddu, NULL }  ,  { &&orPLUSaddu, NULL }  ,  { &&orPLUSaddu, NULL }  ,  { &&orPLUSaddu, NULL }  ,  { &&orPLUSadduPLUSjal, NULL }  ,  { &&orPLUSaddu, NULL }  ,  { &&orPLUSaddu, NULL }  ,  { &&orPLUSaddu, NULL } 
 ,  { &&orPLUSaddu, NULL }  ,  { &&orPLUSaddu, NULL }  ,  { &&orPLUSaddu, NULL }  ,  { &&orPLUSaddu, NULL }  ,  { &&orPLUSaddu, NULL }  ,  { &&orPLUSaddu, NULL }  ,  { &&orPLUSaddu, NULL }  ,  { &&orPLUSaddu, NULL }  ,  { &&orPLUSaddu, NULL }  ,  { &&orPLUSaddu, NULL } 
 ,  { &&orPLUSaddu, NULL }  ,  { &&orPLUSaddu, NULL }  ,  { &&orPLUSaddu, NULL }  ,  { &&orPLUSaddu, NULL }  ,  { &&orPLUSaddu, NULL }  ,  { &&orPLUSaddu, NULL }  ,  { &&orPLUSaddu, NULL }  ,  { &&orPLUSaddu, NULL }  ,  { &&orPLUSaddu, NULL }  ,  { &&orPLUSaddu, NULL } 
 ,  { &&orPLUSaddu, NULL }  ,  { &&orPLUSaddu, NULL }  ,  { &&orPLUSaddu, NULL }  ,  { &&orPLUSaddu, NULL }  ,  { &&orPLUSaddu, NULL }  ,  { &&orPLUSaddu, NULL }  ,  { &&orPLUSaddu, NULL }  ,  { &&orPLUSaddu, NULL }  ,  { &&orPLUSaddu, NULL }  ,  { &&orPLUSaddu, NULL } 
 ,  { &&orPLUSaddu, NULL }  ,  { &&orPLUSaddu, NULL }  ,  { &&orPLUSaddu, NULL }  ,  { &&orPLUSaddu, NULL }  ,  { &&orPLUSaddu, NULL }  ,  { &&orPLUSaddu, NULL }  ,  { &&orPLUSaddu, NULL }  ,  { &&orPLUSaddu, NULL }  ,  { &&orPLUSaddu, NULL }  ,  { &&orPLUSaddu, NULL } 
 ,  { &&orPLUSaddu, NULL }  ,  { &&orPLUSaddu, NULL }  ,  { &&orPLUSaddu, NULL }  ,  { &&orPLUSaddu, NULL }  ,  { &&orPLUSaddu, NULL }  ,  { &&orPLUSaddu, NULL }  ,  { &&orPLUSaddu, NULL }  ,  { &&orPLUSaddu, NULL }  ,  { &&orPLUSaddu, NULL }  ,  { &&orPLUSaddu, NULL } 
 ,  { &&orPLUSaddu, NULL }  ,  { &&orPLUSaddu, NULL }  ,  { &&orPLUSaddu, NULL }  ,  { &&orPLUSaddu, NULL }  ,  { &&orPLUSaddu, NULL }  ,  { &&orPLUSaddu, NULL }  ,  { &&orPLUSaddu, NULL }  ,  { &&orPLUSaddu, NULL }  ,  { &&orPLUSaddu, NULL }  ,  { &&orPLUSaddu, NULL } 
 }; 

struct pointer arrayaddiuPLUSjal[T_SIZE] = {  { &&addiuPLUSjal, NULL }  ,  { &&addiuPLUSjal, NULL }  ,  { &&addiuPLUSjal, NULL }  ,  { &&addiuPLUSjal, NULL }  ,  { &&addiuPLUSjal, NULL }  ,  { &&addiuPLUSjal, NULL }  ,  { &&addiuPLUSjal, NULL }  ,  { &&addiuPLUSjal, NULL }  ,  { &&addiuPLUSjal, NULL }  ,  { &&addiuPLUSjal, NULL } 
 ,  { &&addiuPLUSjal, NULL }  ,  { &&addiuPLUSjal, NULL }  ,  { &&addiuPLUSjal, NULL }  ,  { &&addiuPLUSjal, NULL }  ,  { &&addiuPLUSjal, NULL }  ,  { &&addiuPLUSjal, NULL }  ,  { &&addiuPLUSjal, NULL }  ,  { &&addiuPLUSjal, NULL }  ,  { &&addiuPLUSjal, NULL }  ,  { &&addiuPLUSjal, NULL } 
 ,  { &&addiuPLUSjal, NULL }  ,  { &&addiuPLUSjal, NULL }  ,  { &&addiuPLUSjal, NULL }  ,  { &&addiuPLUSjal, NULL }  ,  { &&addiuPLUSjal, NULL }  ,  { &&addiuPLUSjal, NULL }  ,  { &&addiuPLUSjal, NULL }  ,  { &&addiuPLUSjal, NULL }  ,  { &&addiuPLUSjal, NULL }  ,  { &&addiuPLUSjal, NULL } 
 ,  { &&addiuPLUSjal, NULL }  ,  { &&addiuPLUSjal, NULL }  ,  { &&addiuPLUSjal, NULL }  ,  { &&addiuPLUSjalPLUSaddu, NULL }  ,  { &&addiuPLUSjal, NULL }  ,  { &&addiuPLUSjal, NULL }  ,  { &&addiuPLUSjal, NULL }  ,  { &&addiuPLUSjal, NULL }  ,  { &&addiuPLUSjal, NULL }  ,  { &&addiuPLUSjal, NULL } 
 ,  { &&addiuPLUSjal, NULL }  ,  { &&addiuPLUSjal, NULL }  ,  { &&addiuPLUSjal, NULL }  ,  { &&addiuPLUSjal, NULL }  ,  { &&addiuPLUSjal, NULL }  ,  { &&addiuPLUSjal, NULL }  ,  { &&addiuPLUSjal, NULL }  ,  { &&addiuPLUSjal, NULL }  ,  { &&addiuPLUSjal, NULL }  ,  { &&addiuPLUSjal, NULL } 
 ,  { &&addiuPLUSjal, NULL }  ,  { &&addiuPLUSjal, NULL }  ,  { &&addiuPLUSjalPLUSaddiu, NULL }  ,  { &&addiuPLUSjal, NULL }  ,  { &&addiuPLUSjal, NULL }  ,  { &&addiuPLUSjal, NULL }  ,  { &&addiuPLUSjal, NULL }  ,  { &&addiuPLUSjal, NULL }  ,  { &&addiuPLUSjal, NULL }  ,  { &&addiuPLUSjal, NULL } 
 ,  { &&addiuPLUSjal, NULL }  ,  { &&addiuPLUSjal, NULL }  ,  { &&addiuPLUSjal, NULL }  ,  { &&addiuPLUSjal, NULL }  ,  { &&addiuPLUSjal, NULL }  ,  { &&addiuPLUSjal, NULL }  ,  { &&addiuPLUSjal, NULL }  ,  { &&addiuPLUSjal, NULL }  ,  { &&addiuPLUSjal, NULL }  ,  { &&addiuPLUSjal, NULL } 
 ,  { &&addiuPLUSjal, NULL }  ,  { &&addiuPLUSjal, NULL }  ,  { &&addiuPLUSjal, NULL }  ,  { &&addiuPLUSjal, NULL }  ,  { &&addiuPLUSjal, NULL }  ,  { &&addiuPLUSjal, NULL }  ,  { &&addiuPLUSjal, NULL }  ,  { &&addiuPLUSjal, NULL }  ,  { &&addiuPLUSjal, NULL }  ,  { &&addiuPLUSjal, NULL } 
 ,  { &&addiuPLUSjal, NULL }  ,  { &&addiuPLUSjal, NULL }  ,  { &&addiuPLUSjal, NULL }  ,  { &&addiuPLUSjal, NULL }  ,  { &&addiuPLUSjal, NULL }  ,  { &&addiuPLUSjal, NULL }  ,  { &&addiuPLUSjal, NULL }  ,  { &&addiuPLUSjal, NULL }  ,  { &&addiuPLUSjal, NULL }  ,  { &&addiuPLUSjal, NULL } 
 ,  { &&addiuPLUSjal, NULL }  ,  { &&addiuPLUSjal, NULL }  ,  { &&addiuPLUSjal, NULL }  ,  { &&addiuPLUSjal, NULL }  ,  { &&addiuPLUSjal, NULL }  ,  { &&addiuPLUSjal, NULL }  ,  { &&addiuPLUSjal, NULL }  ,  { &&addiuPLUSjal, NULL }  ,  { &&addiuPLUSjal, NULL }  ,  { &&addiuPLUSjal, NULL } 
 ,  { &&addiuPLUSjal, NULL }  ,  { &&addiuPLUSjal, NULL }  ,  { &&addiuPLUSjal, NULL }  ,  { &&addiuPLUSjal, NULL }  ,  { &&addiuPLUSjal, NULL }  ,  { &&addiuPLUSjal, NULL }  ,  { &&addiuPLUSjal, NULL }  ,  { &&addiuPLUSjal, NULL }  ,  { &&addiuPLUSjal, NULL }  ,  { &&addiuPLUSjal, NULL } 
 }; 

struct pointer arrayaddiuPLUSmult[T_SIZE] = {  { &&addiuPLUSmult, NULL }  ,  { &&addiuPLUSmult, NULL }  ,  { &&addiuPLUSmult, NULL }  ,  { &&addiuPLUSmult, NULL }  ,  { &&addiuPLUSmult, NULL }  ,  { &&addiuPLUSmult, NULL }  ,  { &&addiuPLUSmult, NULL }  ,  { &&addiuPLUSmult, NULL }  ,  { &&addiuPLUSmult, NULL }  ,  { &&addiuPLUSmult, NULL } 
 ,  { &&addiuPLUSmult, NULL }  ,  { &&addiuPLUSmult, NULL }  ,  { &&addiuPLUSmult, NULL }  ,  { &&addiuPLUSmult, NULL }  ,  { &&addiuPLUSmult, NULL }  ,  { &&addiuPLUSmult, NULL }  ,  { &&addiuPLUSmultPLUSmfhi, NULL }  ,  { &&addiuPLUSmult, NULL }  ,  { &&addiuPLUSmult, NULL }  ,  { &&addiuPLUSmult, NULL } 
 ,  { &&addiuPLUSmult, NULL }  ,  { &&addiuPLUSmult, NULL }  ,  { &&addiuPLUSmult, NULL }  ,  { &&addiuPLUSmult, NULL }  ,  { &&addiuPLUSmult, NULL }  ,  { &&addiuPLUSmult, NULL }  ,  { &&addiuPLUSmult, NULL }  ,  { &&addiuPLUSmult, NULL }  ,  { &&addiuPLUSmult, NULL }  ,  { &&addiuPLUSmult, NULL } 
 ,  { &&addiuPLUSmult, NULL }  ,  { &&addiuPLUSmult, NULL }  ,  { &&addiuPLUSmult, NULL }  ,  { &&addiuPLUSmult, NULL }  ,  { &&addiuPLUSmult, NULL }  ,  { &&addiuPLUSmult, NULL }  ,  { &&addiuPLUSmult, NULL }  ,  { &&addiuPLUSmult, NULL }  ,  { &&addiuPLUSmult, NULL }  ,  { &&addiuPLUSmult, NULL } 
 ,  { &&addiuPLUSmult, NULL }  ,  { &&addiuPLUSmult, NULL }  ,  { &&addiuPLUSmult, NULL }  ,  { &&addiuPLUSmult, NULL }  ,  { &&addiuPLUSmult, NULL }  ,  { &&addiuPLUSmult, NULL }  ,  { &&addiuPLUSmult, NULL }  ,  { &&addiuPLUSmult, NULL }  ,  { &&addiuPLUSmult, NULL }  ,  { &&addiuPLUSmult, NULL } 
 ,  { &&addiuPLUSmult, NULL }  ,  { &&addiuPLUSmult, NULL }  ,  { &&addiuPLUSmult, NULL }  ,  { &&addiuPLUSmult, NULL }  ,  { &&addiuPLUSmult, NULL }  ,  { &&addiuPLUSmult, NULL }  ,  { &&addiuPLUSmult, NULL }  ,  { &&addiuPLUSmult, NULL }  ,  { &&addiuPLUSmult, NULL }  ,  { &&addiuPLUSmult, NULL } 
 ,  { &&addiuPLUSmult, NULL }  ,  { &&addiuPLUSmult, NULL }  ,  { &&addiuPLUSmult, NULL }  ,  { &&addiuPLUSmult, NULL }  ,  { &&addiuPLUSmult, NULL }  ,  { &&addiuPLUSmult, NULL }  ,  { &&addiuPLUSmult, NULL }  ,  { &&addiuPLUSmult, NULL }  ,  { &&addiuPLUSmult, NULL }  ,  { &&addiuPLUSmult, NULL } 
 ,  { &&addiuPLUSmult, NULL }  ,  { &&addiuPLUSmult, NULL }  ,  { &&addiuPLUSmult, NULL }  ,  { &&addiuPLUSmult, NULL }  ,  { &&addiuPLUSmult, NULL }  ,  { &&addiuPLUSmult, NULL }  ,  { &&addiuPLUSmult, NULL }  ,  { &&addiuPLUSmult, NULL }  ,  { &&addiuPLUSmult, NULL }  ,  { &&addiuPLUSmult, NULL } 
 ,  { &&addiuPLUSmult, NULL }  ,  { &&addiuPLUSmult, NULL }  ,  { &&addiuPLUSmult, NULL }  ,  { &&addiuPLUSmult, NULL }  ,  { &&addiuPLUSmult, NULL }  ,  { &&addiuPLUSmult, NULL }  ,  { &&addiuPLUSmult, NULL }  ,  { &&addiuPLUSmult, NULL }  ,  { &&addiuPLUSmult, NULL }  ,  { &&addiuPLUSmult, NULL } 
 ,  { &&addiuPLUSmult, NULL }  ,  { &&addiuPLUSmult, NULL }  ,  { &&addiuPLUSmult, NULL }  ,  { &&addiuPLUSmult, NULL }  ,  { &&addiuPLUSmult, NULL }  ,  { &&addiuPLUSmult, NULL }  ,  { &&addiuPLUSmult, NULL }  ,  { &&addiuPLUSmult, NULL }  ,  { &&addiuPLUSmult, NULL }  ,  { &&addiuPLUSmult, NULL } 
 ,  { &&addiuPLUSmult, NULL }  ,  { &&addiuPLUSmult, NULL }  ,  { &&addiuPLUSmult, NULL }  ,  { &&addiuPLUSmult, NULL }  ,  { &&addiuPLUSmult, NULL }  ,  { &&addiuPLUSmult, NULL }  ,  { &&addiuPLUSmult, NULL }  ,  { &&addiuPLUSmult, NULL }  ,  { &&addiuPLUSmult, NULL }  ,  { &&addiuPLUSmult, NULL } 
 }; 

struct pointer arrayblezPLUSaddiu[T_SIZE] = {  { &&blezPLUSaddiu, NULL }  ,  { &&blezPLUSaddiu, NULL }  ,  { &&blezPLUSaddiu, NULL }  ,  { &&blezPLUSaddiu, NULL }  ,  { &&blezPLUSaddiu, NULL }  ,  { &&blezPLUSaddiu, NULL }  ,  { &&blezPLUSaddiu, NULL }  ,  { &&blezPLUSaddiu, NULL }  ,  { &&blezPLUSaddiu, NULL }  ,  { &&blezPLUSaddiu, NULL } 
 ,  { &&blezPLUSaddiu, NULL }  ,  { &&blezPLUSaddiu, NULL }  ,  { &&blezPLUSaddiu, NULL }  ,  { &&blezPLUSaddiu, NULL }  ,  { &&blezPLUSaddiu, NULL }  ,  { &&blezPLUSaddiu, NULL }  ,  { &&blezPLUSaddiu, NULL }  ,  { &&blezPLUSaddiu, NULL }  ,  { &&blezPLUSaddiu, NULL }  ,  { &&blezPLUSaddiu, NULL } 
 ,  { &&blezPLUSaddiu, NULL }  ,  { &&blezPLUSaddiu, NULL }  ,  { &&blezPLUSaddiu, NULL }  ,  { &&blezPLUSaddiu, NULL }  ,  { &&blezPLUSaddiu, NULL }  ,  { &&blezPLUSaddiu, NULL }  ,  { &&blezPLUSaddiu, NULL }  ,  { &&blezPLUSaddiu, NULL }  ,  { &&blezPLUSaddiu, NULL }  ,  { &&blezPLUSaddiu, NULL } 
 ,  { &&blezPLUSaddiu, NULL }  ,  { &&blezPLUSaddiu, NULL }  ,  { &&blezPLUSaddiu, NULL }  ,  { &&blezPLUSaddiuPLUSaddu, NULL }  ,  { &&blezPLUSaddiu, NULL }  ,  { &&blezPLUSaddiu, NULL }  ,  { &&blezPLUSaddiu, NULL }  ,  { &&blezPLUSaddiu, NULL }  ,  { &&blezPLUSaddiu, NULL }  ,  { &&blezPLUSaddiu, NULL } 
 ,  { &&blezPLUSaddiu, NULL }  ,  { &&blezPLUSaddiu, NULL }  ,  { &&blezPLUSaddiu, NULL }  ,  { &&blezPLUSaddiu, NULL }  ,  { &&blezPLUSaddiu, NULL }  ,  { &&blezPLUSaddiu, NULL }  ,  { &&blezPLUSaddiu, NULL }  ,  { &&blezPLUSaddiu, NULL }  ,  { &&blezPLUSaddiu, NULL }  ,  { &&blezPLUSaddiu, NULL } 
 ,  { &&blezPLUSaddiu, NULL }  ,  { &&blezPLUSaddiu, NULL }  ,  { &&blezPLUSaddiu, NULL }  ,  { &&blezPLUSaddiu, NULL }  ,  { &&blezPLUSaddiu, NULL }  ,  { &&blezPLUSaddiu, NULL }  ,  { &&blezPLUSaddiu, NULL }  ,  { &&blezPLUSaddiu, NULL }  ,  { &&blezPLUSaddiu, NULL }  ,  { &&blezPLUSaddiu, NULL } 
 ,  { &&blezPLUSaddiu, NULL }  ,  { &&blezPLUSaddiu, NULL }  ,  { &&blezPLUSaddiu, NULL }  ,  { &&blezPLUSaddiu, NULL }  ,  { &&blezPLUSaddiu, NULL }  ,  { &&blezPLUSaddiu, NULL }  ,  { &&blezPLUSaddiu, NULL }  ,  { &&blezPLUSaddiu, NULL }  ,  { &&blezPLUSaddiu, NULL }  ,  { &&blezPLUSaddiu, NULL } 
 ,  { &&blezPLUSaddiu, NULL }  ,  { &&blezPLUSaddiu, NULL }  ,  { &&blezPLUSaddiu, NULL }  ,  { &&blezPLUSaddiu, NULL }  ,  { &&blezPLUSaddiu, NULL }  ,  { &&blezPLUSaddiu, NULL }  ,  { &&blezPLUSaddiu, NULL }  ,  { &&blezPLUSaddiu, NULL }  ,  { &&blezPLUSaddiu, NULL }  ,  { &&blezPLUSaddiu, NULL } 
 ,  { &&blezPLUSaddiu, NULL }  ,  { &&blezPLUSaddiu, NULL }  ,  { &&blezPLUSaddiu, NULL }  ,  { &&blezPLUSaddiu, NULL }  ,  { &&blezPLUSaddiu, NULL }  ,  { &&blezPLUSaddiu, NULL }  ,  { &&blezPLUSaddiu, NULL }  ,  { &&blezPLUSaddiu, NULL }  ,  { &&blezPLUSaddiu, NULL }  ,  { &&blezPLUSaddiu, NULL } 
 ,  { &&blezPLUSaddiu, NULL }  ,  { &&blezPLUSaddiu, NULL }  ,  { &&blezPLUSaddiu, NULL }  ,  { &&blezPLUSaddiu, NULL }  ,  { &&blezPLUSaddiu, NULL }  ,  { &&blezPLUSaddiu, NULL }  ,  { &&blezPLUSaddiu, NULL }  ,  { &&blezPLUSaddiu, NULL }  ,  { &&blezPLUSaddiu, NULL }  ,  { &&blezPLUSaddiu, NULL } 
 ,  { &&blezPLUSaddiu, NULL }  ,  { &&blezPLUSaddiu, NULL }  ,  { &&blezPLUSaddiu, NULL }  ,  { &&blezPLUSaddiu, NULL }  ,  { &&blezPLUSaddiu, NULL }  ,  { &&blezPLUSaddiu, NULL }  ,  { &&blezPLUSaddiu, NULL }  ,  { &&blezPLUSaddiu, NULL }  ,  { &&blezPLUSaddiu, NULL }  ,  { &&blezPLUSaddiu, NULL } 
 }; 

struct pointer arraysubuPLUSsw[T_SIZE] = {  { &&subuPLUSsw, NULL }  ,  { &&subuPLUSsw, NULL }  ,  { &&subuPLUSsw, NULL }  ,  { &&subuPLUSsw, NULL }  ,  { &&subuPLUSsw, NULL }  ,  { &&subuPLUSsw, NULL }  ,  { &&subuPLUSsw, NULL }  ,  { &&subuPLUSsw, NULL }  ,  { &&subuPLUSsw, NULL }  ,  { &&subuPLUSsw, NULL } 
 ,  { &&subuPLUSsw, NULL }  ,  { &&subuPLUSsw, NULL }  ,  { &&subuPLUSsw, NULL }  ,  { &&subuPLUSsw, NULL }  ,  { &&subuPLUSsw, NULL }  ,  { &&subuPLUSsw, NULL }  ,  { &&subuPLUSsw, NULL }  ,  { &&subuPLUSsw, NULL }  ,  { &&subuPLUSsw, NULL }  ,  { &&subuPLUSsw, NULL } 
 ,  { &&subuPLUSsw, NULL }  ,  { &&subuPLUSsw, NULL }  ,  { &&subuPLUSsw, NULL }  ,  { &&subuPLUSsw, NULL }  ,  { &&subuPLUSsw, NULL }  ,  { &&subuPLUSsw, NULL }  ,  { &&subuPLUSsw, NULL }  ,  { &&subuPLUSsw, NULL }  ,  { &&subuPLUSsw, NULL }  ,  { &&subuPLUSsw, NULL } 
 ,  { &&subuPLUSsw, NULL }  ,  { &&subuPLUSsw, NULL }  ,  { &&subuPLUSsw, NULL }  ,  { &&subuPLUSsw, NULL }  ,  { &&subuPLUSsw, NULL }  ,  { &&subuPLUSsw, NULL }  ,  { &&subuPLUSsw, NULL }  ,  { &&subuPLUSsw, NULL }  ,  { &&subuPLUSsw, NULL }  ,  { &&subuPLUSsw, NULL } 
 ,  { &&subuPLUSsw, NULL }  ,  { &&subuPLUSsw, NULL }  ,  { &&subuPLUSsw, NULL }  ,  { &&subuPLUSsw, NULL }  ,  { &&subuPLUSsw, NULL }  ,  { &&subuPLUSsw, NULL }  ,  { &&subuPLUSsw, NULL }  ,  { &&subuPLUSsw, NULL }  ,  { &&subuPLUSsw, NULL }  ,  { &&subuPLUSsw, NULL } 
 ,  { &&subuPLUSsw, NULL }  ,  { &&subuPLUSsw, NULL }  ,  { &&subuPLUSsw, NULL }  ,  { &&subuPLUSsw, NULL }  ,  { &&subuPLUSsw, NULL }  ,  { &&subuPLUSsw, NULL }  ,  { &&subuPLUSsw, NULL }  ,  { &&subuPLUSsw, NULL }  ,  { &&subuPLUSsw, NULL }  ,  { &&subuPLUSsw, NULL } 
 ,  { &&subuPLUSsw, NULL }  ,  { &&subuPLUSsw, NULL }  ,  { &&subuPLUSsw, NULL }  ,  { &&subuPLUSsw, NULL }  ,  { &&subuPLUSsw, NULL }  ,  { &&subuPLUSsw, NULL }  ,  { &&subuPLUSsw, NULL }  ,  { &&subuPLUSsw, NULL }  ,  { &&subuPLUSsw, NULL }  ,  { &&subuPLUSsw, NULL } 
 ,  { &&subuPLUSsw, NULL }  ,  { &&subuPLUSsw, NULL }  ,  { &&subuPLUSsw, NULL }  ,  { &&subuPLUSsw, NULL }  ,  { &&subuPLUSsw, NULL }  ,  { &&subuPLUSsw, NULL }  ,  { &&subuPLUSsw, NULL }  ,  { &&subuPLUSsw, NULL }  ,  { &&subuPLUSsw, NULL }  ,  { &&subuPLUSsw, NULL } 
 ,  { &&subuPLUSsw, NULL }  ,  { &&subuPLUSsw, NULL }  ,  { &&subuPLUSsw, NULL }  ,  { &&subuPLUSsw, NULL }  ,  { &&subuPLUSsw, NULL }  ,  { &&subuPLUSsw, NULL }  ,  { &&subuPLUSswPLUSsw, NULL }  ,  { &&subuPLUSsw, NULL }  ,  { &&subuPLUSsw, NULL }  ,  { &&subuPLUSsw, NULL } 
 ,  { &&subuPLUSsw, NULL }  ,  { &&subuPLUSsw, NULL }  ,  { &&subuPLUSsw, NULL }  ,  { &&subuPLUSsw, NULL }  ,  { &&subuPLUSsw, NULL }  ,  { &&subuPLUSsw, NULL }  ,  { &&subuPLUSsw, NULL }  ,  { &&subuPLUSsw, NULL }  ,  { &&subuPLUSsw, NULL }  ,  { &&subuPLUSsw, NULL } 
 ,  { &&subuPLUSsw, NULL }  ,  { &&subuPLUSsw, NULL }  ,  { &&subuPLUSsw, NULL }  ,  { &&subuPLUSsw, NULL }  ,  { &&subuPLUSsw, NULL }  ,  { &&subuPLUSsw, NULL }  ,  { &&subuPLUSsw, NULL }  ,  { &&subuPLUSsw, NULL }  ,  { &&subuPLUSsw, NULL }  ,  { &&subuPLUSsw, NULL } 
 }; 

struct pointer arraysllPLUSsrl[T_SIZE] = {  { &&sllPLUSsrl, NULL }  ,  { &&sllPLUSsrl, NULL }  ,  { &&sllPLUSsrl, NULL }  ,  { &&sllPLUSsrl, NULL }  ,  { &&sllPLUSsrl, NULL }  ,  { &&sllPLUSsrl, NULL }  ,  { &&sllPLUSsrl, NULL }  ,  { &&sllPLUSsrl, NULL }  ,  { &&sllPLUSsrl, NULL }  ,  { &&sllPLUSsrl, NULL } 
 ,  { &&sllPLUSsrl, NULL }  ,  { &&sllPLUSsrl, NULL }  ,  { &&sllPLUSsrl, NULL }  ,  { &&sllPLUSsrl, NULL }  ,  { &&sllPLUSsrl, NULL }  ,  { &&sllPLUSsrl, NULL }  ,  { &&sllPLUSsrl, NULL }  ,  { &&sllPLUSsrl, NULL }  ,  { &&sllPLUSsrl, NULL }  ,  { &&sllPLUSsrl, NULL } 
 ,  { &&sllPLUSsrl, NULL }  ,  { &&sllPLUSsrl, NULL }  ,  { &&sllPLUSsrl, NULL }  ,  { &&sllPLUSsrl, NULL }  ,  { &&sllPLUSsrl, NULL }  ,  { &&sllPLUSsrl, NULL }  ,  { &&sllPLUSsrl, NULL }  ,  { &&sllPLUSsrl, NULL }  ,  { &&sllPLUSsrl, NULL }  ,  { &&sllPLUSsrl, NULL } 
 ,  { &&sllPLUSsrl, NULL }  ,  { &&sllPLUSsrl, NULL }  ,  { &&sllPLUSsrl, NULL }  ,  { &&sllPLUSsrl, NULL }  ,  { &&sllPLUSsrl, NULL }  ,  { &&sllPLUSsrl, NULL }  ,  { &&sllPLUSsrl, NULL }  ,  { &&sllPLUSsrlPLUSor, NULL }  ,  { &&sllPLUSsrl, NULL }  ,  { &&sllPLUSsrl, NULL } 
 ,  { &&sllPLUSsrl, NULL }  ,  { &&sllPLUSsrl, NULL }  ,  { &&sllPLUSsrl, NULL }  ,  { &&sllPLUSsrl, NULL }  ,  { &&sllPLUSsrl, NULL }  ,  { &&sllPLUSsrl, NULL }  ,  { &&sllPLUSsrl, NULL }  ,  { &&sllPLUSsrl, NULL }  ,  { &&sllPLUSsrl, NULL }  ,  { &&sllPLUSsrl, NULL } 
 ,  { &&sllPLUSsrl, NULL }  ,  { &&sllPLUSsrl, NULL }  ,  { &&sllPLUSsrl, NULL }  ,  { &&sllPLUSsrl, NULL }  ,  { &&sllPLUSsrl, NULL }  ,  { &&sllPLUSsrl, NULL }  ,  { &&sllPLUSsrl, NULL }  ,  { &&sllPLUSsrl, NULL }  ,  { &&sllPLUSsrl, NULL }  ,  { &&sllPLUSsrl, NULL } 
 ,  { &&sllPLUSsrl, NULL }  ,  { &&sllPLUSsrl, NULL }  ,  { &&sllPLUSsrl, NULL }  ,  { &&sllPLUSsrl, NULL }  ,  { &&sllPLUSsrl, NULL }  ,  { &&sllPLUSsrl, NULL }  ,  { &&sllPLUSsrl, NULL }  ,  { &&sllPLUSsrl, NULL }  ,  { &&sllPLUSsrl, NULL }  ,  { &&sllPLUSsrl, NULL } 
 ,  { &&sllPLUSsrl, NULL }  ,  { &&sllPLUSsrl, NULL }  ,  { &&sllPLUSsrl, NULL }  ,  { &&sllPLUSsrl, NULL }  ,  { &&sllPLUSsrl, NULL }  ,  { &&sllPLUSsrl, NULL }  ,  { &&sllPLUSsrl, NULL }  ,  { &&sllPLUSsrl, NULL }  ,  { &&sllPLUSsrl, NULL }  ,  { &&sllPLUSsrl, NULL } 
 ,  { &&sllPLUSsrl, NULL }  ,  { &&sllPLUSsrl, NULL }  ,  { &&sllPLUSsrl, NULL }  ,  { &&sllPLUSsrl, NULL }  ,  { &&sllPLUSsrl, NULL }  ,  { &&sllPLUSsrl, NULL }  ,  { &&sllPLUSsrl, NULL }  ,  { &&sllPLUSsrl, NULL }  ,  { &&sllPLUSsrl, NULL }  ,  { &&sllPLUSsrl, NULL } 
 ,  { &&sllPLUSsrl, NULL }  ,  { &&sllPLUSsrl, NULL }  ,  { &&sllPLUSsrl, NULL }  ,  { &&sllPLUSsrl, NULL }  ,  { &&sllPLUSsrl, NULL }  ,  { &&sllPLUSsrl, NULL }  ,  { &&sllPLUSsrl, NULL }  ,  { &&sllPLUSsrl, NULL }  ,  { &&sllPLUSsrl, NULL }  ,  { &&sllPLUSsrl, NULL } 
 ,  { &&sllPLUSsrl, NULL }  ,  { &&sllPLUSsrl, NULL }  ,  { &&sllPLUSsrl, NULL }  ,  { &&sllPLUSsrl, NULL }  ,  { &&sllPLUSsrl, NULL }  ,  { &&sllPLUSsrl, NULL }  ,  { &&sllPLUSsrl, NULL }  ,  { &&sllPLUSsrl, NULL }  ,  { &&sllPLUSsrl, NULL }  ,  { &&sllPLUSsrl, NULL } 
 }; 

struct pointer arraylwPLUSaddiu[T_SIZE] = {  { &&lwPLUSaddiu, NULL }  ,  { &&lwPLUSaddiu, NULL }  ,  { &&lwPLUSaddiu, NULL }  ,  { &&lwPLUSaddiu, NULL }  ,  { &&lwPLUSaddiu, NULL }  ,  { &&lwPLUSaddiu, NULL }  ,  { &&lwPLUSaddiu, NULL }  ,  { &&lwPLUSaddiu, NULL }  ,  { &&lwPLUSaddiuPLUSjr, NULL }  ,  { &&lwPLUSaddiu, NULL } 
 ,  { &&lwPLUSaddiu, NULL }  ,  { &&lwPLUSaddiu, NULL }  ,  { &&lwPLUSaddiu, NULL }  ,  { &&lwPLUSaddiu, NULL }  ,  { &&lwPLUSaddiu, NULL }  ,  { &&lwPLUSaddiu, NULL }  ,  { &&lwPLUSaddiu, NULL }  ,  { &&lwPLUSaddiu, NULL }  ,  { &&lwPLUSaddiu, NULL }  ,  { &&lwPLUSaddiu, NULL } 
 ,  { &&lwPLUSaddiu, NULL }  ,  { &&lwPLUSaddiu, NULL }  ,  { &&lwPLUSaddiu, NULL }  ,  { &&lwPLUSaddiu, NULL }  ,  { &&lwPLUSaddiu, NULL }  ,  { &&lwPLUSaddiu, NULL }  ,  { &&lwPLUSaddiu, NULL }  ,  { &&lwPLUSaddiu, NULL }  ,  { &&lwPLUSaddiu, NULL }  ,  { &&lwPLUSaddiu, NULL } 
 ,  { &&lwPLUSaddiu, NULL }  ,  { &&lwPLUSaddiu, NULL }  ,  { &&lwPLUSaddiu, NULL }  ,  { &&lwPLUSaddiu, NULL }  ,  { &&lwPLUSaddiu, NULL }  ,  { &&lwPLUSaddiu, NULL }  ,  { &&lwPLUSaddiu, NULL }  ,  { &&lwPLUSaddiu, NULL }  ,  { &&lwPLUSaddiu, NULL }  ,  { &&lwPLUSaddiu, NULL } 
 ,  { &&lwPLUSaddiu, NULL }  ,  { &&lwPLUSaddiu, NULL }  ,  { &&lwPLUSaddiu, NULL }  ,  { &&lwPLUSaddiu, NULL }  ,  { &&lwPLUSaddiu, NULL }  ,  { &&lwPLUSaddiuPLUSjump, NULL }  ,  { &&lwPLUSaddiu, NULL }  ,  { &&lwPLUSaddiuPLUSbeq, NULL }  ,  { &&lwPLUSaddiu, NULL }  ,  { &&lwPLUSaddiu, NULL } 
 ,  { &&lwPLUSaddiu, NULL }  ,  { &&lwPLUSaddiu, NULL }  ,  { &&lwPLUSaddiuPLUSaddiu, NULL }  ,  { &&lwPLUSaddiuPLUSslti, NULL }  ,  { &&lwPLUSaddiu, NULL }  ,  { &&lwPLUSaddiu, NULL }  ,  { &&lwPLUSaddiu, NULL }  ,  { &&lwPLUSaddiu, NULL }  ,  { &&lwPLUSaddiu, NULL }  ,  { &&lwPLUSaddiu, NULL } 
 ,  { &&lwPLUSaddiu, NULL }  ,  { &&lwPLUSaddiu, NULL }  ,  { &&lwPLUSaddiu, NULL }  ,  { &&lwPLUSaddiu, NULL }  ,  { &&lwPLUSaddiu, NULL }  ,  { &&lwPLUSaddiu, NULL }  ,  { &&lwPLUSaddiu, NULL }  ,  { &&lwPLUSaddiu, NULL }  ,  { &&lwPLUSaddiu, NULL }  ,  { &&lwPLUSaddiu, NULL } 
 ,  { &&lwPLUSaddiu, NULL }  ,  { &&lwPLUSaddiu, NULL }  ,  { &&lwPLUSaddiu, NULL }  ,  { &&lwPLUSaddiu, NULL }  ,  { &&lwPLUSaddiu, NULL }  ,  { &&lwPLUSaddiu, NULL }  ,  { &&lwPLUSaddiu, NULL }  ,  { &&lwPLUSaddiu, NULL }  ,  { &&lwPLUSaddiuPLUSlw, NULL }  ,  { &&lwPLUSaddiu, NULL } 
 ,  { &&lwPLUSaddiu, NULL }  ,  { &&lwPLUSaddiu, NULL }  ,  { &&lwPLUSaddiu, NULL }  ,  { &&lwPLUSaddiu, NULL }  ,  { &&lwPLUSaddiu, NULL }  ,  { &&lwPLUSaddiu, NULL }  ,  { &&lwPLUSaddiuPLUSsw, NULL }  ,  { &&lwPLUSaddiu, NULL }  ,  { &&lwPLUSaddiu, NULL }  ,  { &&lwPLUSaddiu, NULL } 
 ,  { &&lwPLUSaddiu, NULL }  ,  { &&lwPLUSaddiu, NULL }  ,  { &&lwPLUSaddiu, NULL }  ,  { &&lwPLUSaddiu, NULL }  ,  { &&lwPLUSaddiu, NULL }  ,  { &&lwPLUSaddiu, NULL }  ,  { &&lwPLUSaddiu, NULL }  ,  { &&lwPLUSaddiu, NULL }  ,  { &&lwPLUSaddiu, NULL }  ,  { &&lwPLUSaddiu, NULL } 
 ,  { &&lwPLUSaddiu, NULL }  ,  { &&lwPLUSaddiu, NULL }  ,  { &&lwPLUSaddiu, NULL }  ,  { &&lwPLUSaddiu, NULL }  ,  { &&lwPLUSaddiu, NULL }  ,  { &&lwPLUSaddiu, NULL }  ,  { &&lwPLUSaddiu, NULL }  ,  { &&lwPLUSaddiu, NULL }  ,  { &&lwPLUSaddiu, NULL }  ,  { &&lwPLUSaddiu, NULL } 
 }; 

struct pointer arraysllPLUSsll[T_SIZE] = {  { &&sllPLUSsllPLUSsll, NULL }  ,  { &&sllPLUSsll, NULL }  ,  { &&sllPLUSsll, NULL }  ,  { &&sllPLUSsll, NULL }  ,  { &&sllPLUSsll, NULL }  ,  { &&sllPLUSsll, NULL }  ,  { &&sllPLUSsll, NULL }  ,  { &&sllPLUSsll, NULL }  ,  { &&sllPLUSsll, NULL }  ,  { &&sllPLUSsll, NULL } 
 ,  { &&sllPLUSsll, NULL }  ,  { &&sllPLUSsll, NULL }  ,  { &&sllPLUSsll, NULL }  ,  { &&sllPLUSsll, NULL }  ,  { &&sllPLUSsll, NULL }  ,  { &&sllPLUSsll, NULL }  ,  { &&sllPLUSsll, NULL }  ,  { &&sllPLUSsll, NULL }  ,  { &&sllPLUSsll, NULL }  ,  { &&sllPLUSsll, NULL } 
 ,  { &&sllPLUSsll, NULL }  ,  { &&sllPLUSsll, NULL }  ,  { &&sllPLUSsll, NULL }  ,  { &&sllPLUSsll, NULL }  ,  { &&sllPLUSsll, NULL }  ,  { &&sllPLUSsll, NULL }  ,  { &&sllPLUSsll, NULL }  ,  { &&sllPLUSsll, NULL }  ,  { &&sllPLUSsll, NULL }  ,  { &&sllPLUSsll, NULL } 
 ,  { &&sllPLUSsll, NULL }  ,  { &&sllPLUSsll, NULL }  ,  { &&sllPLUSsll, NULL }  ,  { &&sllPLUSsllPLUSaddu, NULL }  ,  { &&sllPLUSsll, NULL }  ,  { &&sllPLUSsll, NULL }  ,  { &&sllPLUSsll, NULL }  ,  { &&sllPLUSsll, NULL }  ,  { &&sllPLUSsllPLUSxor, NULL }  ,  { &&sllPLUSsll, NULL } 
 ,  { &&sllPLUSsll, NULL }  ,  { &&sllPLUSsll, NULL }  ,  { &&sllPLUSsllPLUSslt, NULL }  ,  { &&sllPLUSsll, NULL }  ,  { &&sllPLUSsll, NULL }  ,  { &&sllPLUSsll, NULL }  ,  { &&sllPLUSsll, NULL }  ,  { &&sllPLUSsll, NULL }  ,  { &&sllPLUSsll, NULL }  ,  { &&sllPLUSsll, NULL } 
 ,  { &&sllPLUSsll, NULL }  ,  { &&sllPLUSsll, NULL }  ,  { &&sllPLUSsll, NULL }  ,  { &&sllPLUSsll, NULL }  ,  { &&sllPLUSsll, NULL }  ,  { &&sllPLUSsll, NULL }  ,  { &&sllPLUSsll, NULL }  ,  { &&sllPLUSsll, NULL }  ,  { &&sllPLUSsll, NULL }  ,  { &&sllPLUSsll, NULL } 
 ,  { &&sllPLUSsll, NULL }  ,  { &&sllPLUSsll, NULL }  ,  { &&sllPLUSsll, NULL }  ,  { &&sllPLUSsll, NULL }  ,  { &&sllPLUSsll, NULL }  ,  { &&sllPLUSsll, NULL }  ,  { &&sllPLUSsll, NULL }  ,  { &&sllPLUSsll, NULL }  ,  { &&sllPLUSsll, NULL }  ,  { &&sllPLUSsll, NULL } 
 ,  { &&sllPLUSsll, NULL }  ,  { &&sllPLUSsll, NULL }  ,  { &&sllPLUSsll, NULL }  ,  { &&sllPLUSsll, NULL }  ,  { &&sllPLUSsll, NULL }  ,  { &&sllPLUSsll, NULL }  ,  { &&sllPLUSsll, NULL }  ,  { &&sllPLUSsll, NULL }  ,  { &&sllPLUSsll, NULL }  ,  { &&sllPLUSsll, NULL } 
 ,  { &&sllPLUSsll, NULL }  ,  { &&sllPLUSsll, NULL }  ,  { &&sllPLUSsll, NULL }  ,  { &&sllPLUSsll, NULL }  ,  { &&sllPLUSsll, NULL }  ,  { &&sllPLUSsll, NULL }  ,  { &&sllPLUSsll, NULL }  ,  { &&sllPLUSsll, NULL }  ,  { &&sllPLUSsll, NULL }  ,  { &&sllPLUSsll, NULL } 
 ,  { &&sllPLUSsll, NULL }  ,  { &&sllPLUSsll, NULL }  ,  { &&sllPLUSsll, NULL }  ,  { &&sllPLUSsll, NULL }  ,  { &&sllPLUSsll, NULL }  ,  { &&sllPLUSsll, NULL }  ,  { &&sllPLUSsll, NULL }  ,  { &&sllPLUSsll, NULL }  ,  { &&sllPLUSsll, NULL }  ,  { &&sllPLUSsll, NULL } 
 ,  { &&sllPLUSsll, NULL }  ,  { &&sllPLUSsll, NULL }  ,  { &&sllPLUSsll, NULL }  ,  { &&sllPLUSsll, NULL }  ,  { &&sllPLUSsll, NULL }  ,  { &&sllPLUSsll, NULL }  ,  { &&sllPLUSsll, NULL }  ,  { &&sllPLUSsll, NULL }  ,  { &&sllPLUSsll, NULL }  ,  { &&sllPLUSsll, NULL } 
 }; 

struct pointer arraysllPLUSxor[T_SIZE] = {  { &&sllPLUSxorPLUSsll, NULL }  ,  { &&sllPLUSxor, NULL }  ,  { &&sllPLUSxorPLUSsrl, NULL }  ,  { &&sllPLUSxor, NULL }  ,  { &&sllPLUSxor, NULL }  ,  { &&sllPLUSxor, NULL }  ,  { &&sllPLUSxor, NULL }  ,  { &&sllPLUSxor, NULL }  ,  { &&sllPLUSxor, NULL }  ,  { &&sllPLUSxor, NULL } 
 ,  { &&sllPLUSxor, NULL }  ,  { &&sllPLUSxor, NULL }  ,  { &&sllPLUSxor, NULL }  ,  { &&sllPLUSxor, NULL }  ,  { &&sllPLUSxor, NULL }  ,  { &&sllPLUSxor, NULL }  ,  { &&sllPLUSxor, NULL }  ,  { &&sllPLUSxor, NULL }  ,  { &&sllPLUSxor, NULL }  ,  { &&sllPLUSxor, NULL } 
 ,  { &&sllPLUSxor, NULL }  ,  { &&sllPLUSxor, NULL }  ,  { &&sllPLUSxor, NULL }  ,  { &&sllPLUSxor, NULL }  ,  { &&sllPLUSxor, NULL }  ,  { &&sllPLUSxor, NULL }  ,  { &&sllPLUSxor, NULL }  ,  { &&sllPLUSxor, NULL }  ,  { &&sllPLUSxor, NULL }  ,  { &&sllPLUSxor, NULL } 
 ,  { &&sllPLUSxor, NULL }  ,  { &&sllPLUSxor, NULL }  ,  { &&sllPLUSxor, NULL }  ,  { &&sllPLUSxor, NULL }  ,  { &&sllPLUSxor, NULL }  ,  { &&sllPLUSxor, NULL }  ,  { &&sllPLUSxor, NULL }  ,  { &&sllPLUSxor, NULL }  ,  { &&sllPLUSxorPLUSxor, NULL }  ,  { &&sllPLUSxor, NULL } 
 ,  { &&sllPLUSxor, NULL }  ,  { &&sllPLUSxor, NULL }  ,  { &&sllPLUSxor, NULL }  ,  { &&sllPLUSxor, NULL }  ,  { &&sllPLUSxor, NULL }  ,  { &&sllPLUSxor, NULL }  ,  { &&sllPLUSxor, NULL }  ,  { &&sllPLUSxor, NULL }  ,  { &&sllPLUSxor, NULL }  ,  { &&sllPLUSxor, NULL } 
 ,  { &&sllPLUSxor, NULL }  ,  { &&sllPLUSxor, NULL }  ,  { &&sllPLUSxor, NULL }  ,  { &&sllPLUSxorPLUSslti, NULL }  ,  { &&sllPLUSxor, NULL }  ,  { &&sllPLUSxorPLUSandi, NULL }  ,  { &&sllPLUSxor, NULL }  ,  { &&sllPLUSxor, NULL }  ,  { &&sllPLUSxor, NULL }  ,  { &&sllPLUSxor, NULL } 
 ,  { &&sllPLUSxor, NULL }  ,  { &&sllPLUSxor, NULL }  ,  { &&sllPLUSxor, NULL }  ,  { &&sllPLUSxor, NULL }  ,  { &&sllPLUSxor, NULL }  ,  { &&sllPLUSxor, NULL }  ,  { &&sllPLUSxor, NULL }  ,  { &&sllPLUSxor, NULL }  ,  { &&sllPLUSxor, NULL }  ,  { &&sllPLUSxor, NULL } 
 ,  { &&sllPLUSxor, NULL }  ,  { &&sllPLUSxor, NULL }  ,  { &&sllPLUSxor, NULL }  ,  { &&sllPLUSxor, NULL }  ,  { &&sllPLUSxor, NULL }  ,  { &&sllPLUSxor, NULL }  ,  { &&sllPLUSxor, NULL }  ,  { &&sllPLUSxor, NULL }  ,  { &&sllPLUSxor, NULL }  ,  { &&sllPLUSxor, NULL } 
 ,  { &&sllPLUSxor, NULL }  ,  { &&sllPLUSxor, NULL }  ,  { &&sllPLUSxor, NULL }  ,  { &&sllPLUSxor, NULL }  ,  { &&sllPLUSxor, NULL }  ,  { &&sllPLUSxor, NULL }  ,  { &&sllPLUSxor, NULL }  ,  { &&sllPLUSxor, NULL }  ,  { &&sllPLUSxor, NULL }  ,  { &&sllPLUSxor, NULL } 
 ,  { &&sllPLUSxor, NULL }  ,  { &&sllPLUSxor, NULL }  ,  { &&sllPLUSxor, NULL }  ,  { &&sllPLUSxor, NULL }  ,  { &&sllPLUSxor, NULL }  ,  { &&sllPLUSxor, NULL }  ,  { &&sllPLUSxor, NULL }  ,  { &&sllPLUSxor, NULL }  ,  { &&sllPLUSxor, NULL }  ,  { &&sllPLUSxor, NULL } 
 ,  { &&sllPLUSxor, NULL }  ,  { &&sllPLUSxor, NULL }  ,  { &&sllPLUSxor, NULL }  ,  { &&sllPLUSxor, NULL }  ,  { &&sllPLUSxor, NULL }  ,  { &&sllPLUSxor, NULL }  ,  { &&sllPLUSxor, NULL }  ,  { &&sllPLUSxor, NULL }  ,  { &&sllPLUSxor, NULL }  ,  { &&sllPLUSxor, NULL } 
 }; 

struct pointer arraysltPLUSbne[T_SIZE] = {  { &&sltPLUSbnePLUSsll, NULL }  ,  { &&sltPLUSbne, NULL }  ,  { &&sltPLUSbne, NULL }  ,  { &&sltPLUSbne, NULL }  ,  { &&sltPLUSbne, NULL }  ,  { &&sltPLUSbne, NULL }  ,  { &&sltPLUSbne, NULL }  ,  { &&sltPLUSbne, NULL }  ,  { &&sltPLUSbne, NULL }  ,  { &&sltPLUSbne, NULL } 
 ,  { &&sltPLUSbne, NULL }  ,  { &&sltPLUSbne, NULL }  ,  { &&sltPLUSbne, NULL }  ,  { &&sltPLUSbne, NULL }  ,  { &&sltPLUSbne, NULL }  ,  { &&sltPLUSbne, NULL }  ,  { &&sltPLUSbne, NULL }  ,  { &&sltPLUSbne, NULL }  ,  { &&sltPLUSbne, NULL }  ,  { &&sltPLUSbne, NULL } 
 ,  { &&sltPLUSbne, NULL }  ,  { &&sltPLUSbne, NULL }  ,  { &&sltPLUSbne, NULL }  ,  { &&sltPLUSbne, NULL }  ,  { &&sltPLUSbne, NULL }  ,  { &&sltPLUSbne, NULL }  ,  { &&sltPLUSbne, NULL }  ,  { &&sltPLUSbne, NULL }  ,  { &&sltPLUSbne, NULL }  ,  { &&sltPLUSbne, NULL } 
 ,  { &&sltPLUSbne, NULL }  ,  { &&sltPLUSbne, NULL }  ,  { &&sltPLUSbne, NULL }  ,  { &&sltPLUSbne, NULL }  ,  { &&sltPLUSbne, NULL }  ,  { &&sltPLUSbne, NULL }  ,  { &&sltPLUSbne, NULL }  ,  { &&sltPLUSbne, NULL }  ,  { &&sltPLUSbne, NULL }  ,  { &&sltPLUSbne, NULL } 
 ,  { &&sltPLUSbne, NULL }  ,  { &&sltPLUSbne, NULL }  ,  { &&sltPLUSbne, NULL }  ,  { &&sltPLUSbne, NULL }  ,  { &&sltPLUSbne, NULL }  ,  { &&sltPLUSbne, NULL }  ,  { &&sltPLUSbne, NULL }  ,  { &&sltPLUSbne, NULL }  ,  { &&sltPLUSbne, NULL }  ,  { &&sltPLUSbne, NULL } 
 ,  { &&sltPLUSbne, NULL }  ,  { &&sltPLUSbne, NULL }  ,  { &&sltPLUSbnePLUSaddiu, NULL }  ,  { &&sltPLUSbne, NULL }  ,  { &&sltPLUSbne, NULL }  ,  { &&sltPLUSbne, NULL }  ,  { &&sltPLUSbne, NULL }  ,  { &&sltPLUSbne, NULL }  ,  { &&sltPLUSbne, NULL }  ,  { &&sltPLUSbne, NULL } 
 ,  { &&sltPLUSbne, NULL }  ,  { &&sltPLUSbne, NULL }  ,  { &&sltPLUSbne, NULL }  ,  { &&sltPLUSbne, NULL }  ,  { &&sltPLUSbne, NULL }  ,  { &&sltPLUSbne, NULL }  ,  { &&sltPLUSbne, NULL }  ,  { &&sltPLUSbne, NULL }  ,  { &&sltPLUSbne, NULL }  ,  { &&sltPLUSbne, NULL } 
 ,  { &&sltPLUSbne, NULL }  ,  { &&sltPLUSbne, NULL }  ,  { &&sltPLUSbne, NULL }  ,  { &&sltPLUSbne, NULL }  ,  { &&sltPLUSbne, NULL }  ,  { &&sltPLUSbne, NULL }  ,  { &&sltPLUSbne, NULL }  ,  { &&sltPLUSbne, NULL }  ,  { &&sltPLUSbne, NULL }  ,  { &&sltPLUSbne, NULL } 
 ,  { &&sltPLUSbne, NULL }  ,  { &&sltPLUSbne, NULL }  ,  { &&sltPLUSbne, NULL }  ,  { &&sltPLUSbne, NULL }  ,  { &&sltPLUSbne, NULL }  ,  { &&sltPLUSbne, NULL }  ,  { &&sltPLUSbne, NULL }  ,  { &&sltPLUSbne, NULL }  ,  { &&sltPLUSbne, NULL }  ,  { &&sltPLUSbne, NULL } 
 ,  { &&sltPLUSbne, NULL }  ,  { &&sltPLUSbne, NULL }  ,  { &&sltPLUSbne, NULL }  ,  { &&sltPLUSbne, NULL }  ,  { &&sltPLUSbne, NULL }  ,  { &&sltPLUSbne, NULL }  ,  { &&sltPLUSbne, NULL }  ,  { &&sltPLUSbne, NULL }  ,  { &&sltPLUSbne, NULL }  ,  { &&sltPLUSbne, NULL } 
 ,  { &&sltPLUSbne, NULL }  ,  { &&sltPLUSbne, NULL }  ,  { &&sltPLUSbne, NULL }  ,  { &&sltPLUSbne, NULL }  ,  { &&sltPLUSbne, NULL }  ,  { &&sltPLUSbne, NULL }  ,  { &&sltPLUSbne, NULL }  ,  { &&sltPLUSbne, NULL }  ,  { &&sltPLUSbne, NULL }  ,  { &&sltPLUSbne, NULL } 
 }; 

struct pointer arraysllPLUSslt[T_SIZE] = {  { &&sllPLUSslt, NULL }  ,  { &&sllPLUSslt, NULL }  ,  { &&sllPLUSslt, NULL }  ,  { &&sllPLUSslt, NULL }  ,  { &&sllPLUSslt, NULL }  ,  { &&sllPLUSslt, NULL }  ,  { &&sllPLUSslt, NULL }  ,  { &&sllPLUSslt, NULL }  ,  { &&sllPLUSslt, NULL }  ,  { &&sllPLUSslt, NULL } 
 ,  { &&sllPLUSslt, NULL }  ,  { &&sllPLUSslt, NULL }  ,  { &&sllPLUSslt, NULL }  ,  { &&sllPLUSslt, NULL }  ,  { &&sllPLUSslt, NULL }  ,  { &&sllPLUSslt, NULL }  ,  { &&sllPLUSslt, NULL }  ,  { &&sllPLUSslt, NULL }  ,  { &&sllPLUSslt, NULL }  ,  { &&sllPLUSslt, NULL } 
 ,  { &&sllPLUSslt, NULL }  ,  { &&sllPLUSslt, NULL }  ,  { &&sllPLUSslt, NULL }  ,  { &&sllPLUSslt, NULL }  ,  { &&sllPLUSslt, NULL }  ,  { &&sllPLUSslt, NULL }  ,  { &&sllPLUSslt, NULL }  ,  { &&sllPLUSslt, NULL }  ,  { &&sllPLUSslt, NULL }  ,  { &&sllPLUSslt, NULL } 
 ,  { &&sllPLUSslt, NULL }  ,  { &&sllPLUSslt, NULL }  ,  { &&sllPLUSslt, NULL }  ,  { &&sllPLUSsltPLUSaddu, NULL }  ,  { &&sllPLUSslt, NULL }  ,  { &&sllPLUSslt, NULL }  ,  { &&sllPLUSslt, NULL }  ,  { &&sllPLUSslt, NULL }  ,  { &&sllPLUSslt, NULL }  ,  { &&sllPLUSslt, NULL } 
 ,  { &&sllPLUSslt, NULL }  ,  { &&sllPLUSslt, NULL }  ,  { &&sllPLUSslt, NULL }  ,  { &&sllPLUSslt, NULL }  ,  { &&sllPLUSslt, NULL }  ,  { &&sllPLUSslt, NULL }  ,  { &&sllPLUSslt, NULL }  ,  { &&sllPLUSsltPLUSbeq, NULL }  ,  { &&sllPLUSsltPLUSbne, NULL }  ,  { &&sllPLUSslt, NULL } 
 ,  { &&sllPLUSslt, NULL }  ,  { &&sllPLUSslt, NULL }  ,  { &&sllPLUSslt, NULL }  ,  { &&sllPLUSslt, NULL }  ,  { &&sllPLUSslt, NULL }  ,  { &&sllPLUSslt, NULL }  ,  { &&sllPLUSslt, NULL }  ,  { &&sllPLUSslt, NULL }  ,  { &&sllPLUSslt, NULL }  ,  { &&sllPLUSslt, NULL } 
 ,  { &&sllPLUSslt, NULL }  ,  { &&sllPLUSslt, NULL }  ,  { &&sllPLUSslt, NULL }  ,  { &&sllPLUSslt, NULL }  ,  { &&sllPLUSslt, NULL }  ,  { &&sllPLUSslt, NULL }  ,  { &&sllPLUSslt, NULL }  ,  { &&sllPLUSslt, NULL }  ,  { &&sllPLUSslt, NULL }  ,  { &&sllPLUSslt, NULL } 
 ,  { &&sllPLUSslt, NULL }  ,  { &&sllPLUSslt, NULL }  ,  { &&sllPLUSslt, NULL }  ,  { &&sllPLUSslt, NULL }  ,  { &&sllPLUSslt, NULL }  ,  { &&sllPLUSslt, NULL }  ,  { &&sllPLUSslt, NULL }  ,  { &&sllPLUSslt, NULL }  ,  { &&sllPLUSslt, NULL }  ,  { &&sllPLUSslt, NULL } 
 ,  { &&sllPLUSslt, NULL }  ,  { &&sllPLUSslt, NULL }  ,  { &&sllPLUSslt, NULL }  ,  { &&sllPLUSslt, NULL }  ,  { &&sllPLUSslt, NULL }  ,  { &&sllPLUSslt, NULL }  ,  { &&sllPLUSslt, NULL }  ,  { &&sllPLUSslt, NULL }  ,  { &&sllPLUSslt, NULL }  ,  { &&sllPLUSslt, NULL } 
 ,  { &&sllPLUSslt, NULL }  ,  { &&sllPLUSslt, NULL }  ,  { &&sllPLUSslt, NULL }  ,  { &&sllPLUSslt, NULL }  ,  { &&sllPLUSslt, NULL }  ,  { &&sllPLUSslt, NULL }  ,  { &&sllPLUSslt, NULL }  ,  { &&sllPLUSslt, NULL }  ,  { &&sllPLUSslt, NULL }  ,  { &&sllPLUSslt, NULL } 
 ,  { &&sllPLUSslt, NULL }  ,  { &&sllPLUSslt, NULL }  ,  { &&sllPLUSslt, NULL }  ,  { &&sllPLUSslt, NULL }  ,  { &&sllPLUSslt, NULL }  ,  { &&sllPLUSslt, NULL }  ,  { &&sllPLUSslt, NULL }  ,  { &&sllPLUSslt, NULL }  ,  { &&sllPLUSslt, NULL }  ,  { &&sllPLUSslt, NULL } 
 }; 

struct pointer arraysrlPLUSor[T_SIZE] = {  { &&srlPLUSorPLUSsll, NULL }  ,  { &&srlPLUSor, NULL }  ,  { &&srlPLUSor, NULL }  ,  { &&srlPLUSor, NULL }  ,  { &&srlPLUSor, NULL }  ,  { &&srlPLUSor, NULL }  ,  { &&srlPLUSor, NULL }  ,  { &&srlPLUSor, NULL }  ,  { &&srlPLUSor, NULL }  ,  { &&srlPLUSor, NULL } 
 ,  { &&srlPLUSor, NULL }  ,  { &&srlPLUSor, NULL }  ,  { &&srlPLUSor, NULL }  ,  { &&srlPLUSor, NULL }  ,  { &&srlPLUSor, NULL }  ,  { &&srlPLUSor, NULL }  ,  { &&srlPLUSor, NULL }  ,  { &&srlPLUSor, NULL }  ,  { &&srlPLUSor, NULL }  ,  { &&srlPLUSor, NULL } 
 ,  { &&srlPLUSor, NULL }  ,  { &&srlPLUSor, NULL }  ,  { &&srlPLUSor, NULL }  ,  { &&srlPLUSor, NULL }  ,  { &&srlPLUSor, NULL }  ,  { &&srlPLUSor, NULL }  ,  { &&srlPLUSor, NULL }  ,  { &&srlPLUSor, NULL }  ,  { &&srlPLUSor, NULL }  ,  { &&srlPLUSor, NULL } 
 ,  { &&srlPLUSor, NULL }  ,  { &&srlPLUSor, NULL }  ,  { &&srlPLUSor, NULL }  ,  { &&srlPLUSor, NULL }  ,  { &&srlPLUSor, NULL }  ,  { &&srlPLUSor, NULL }  ,  { &&srlPLUSor, NULL }  ,  { &&srlPLUSor, NULL }  ,  { &&srlPLUSor, NULL }  ,  { &&srlPLUSor, NULL } 
 ,  { &&srlPLUSor, NULL }  ,  { &&srlPLUSor, NULL }  ,  { &&srlPLUSor, NULL }  ,  { &&srlPLUSor, NULL }  ,  { &&srlPLUSor, NULL }  ,  { &&srlPLUSor, NULL }  ,  { &&srlPLUSor, NULL }  ,  { &&srlPLUSor, NULL }  ,  { &&srlPLUSor, NULL }  ,  { &&srlPLUSor, NULL } 
 ,  { &&srlPLUSor, NULL }  ,  { &&srlPLUSor, NULL }  ,  { &&srlPLUSor, NULL }  ,  { &&srlPLUSor, NULL }  ,  { &&srlPLUSor, NULL }  ,  { &&srlPLUSor, NULL }  ,  { &&srlPLUSor, NULL }  ,  { &&srlPLUSor, NULL }  ,  { &&srlPLUSor, NULL }  ,  { &&srlPLUSor, NULL } 
 ,  { &&srlPLUSor, NULL }  ,  { &&srlPLUSor, NULL }  ,  { &&srlPLUSor, NULL }  ,  { &&srlPLUSor, NULL }  ,  { &&srlPLUSor, NULL }  ,  { &&srlPLUSor, NULL }  ,  { &&srlPLUSor, NULL }  ,  { &&srlPLUSor, NULL }  ,  { &&srlPLUSor, NULL }  ,  { &&srlPLUSor, NULL } 
 ,  { &&srlPLUSor, NULL }  ,  { &&srlPLUSor, NULL }  ,  { &&srlPLUSor, NULL }  ,  { &&srlPLUSor, NULL }  ,  { &&srlPLUSor, NULL }  ,  { &&srlPLUSor, NULL }  ,  { &&srlPLUSor, NULL }  ,  { &&srlPLUSor, NULL }  ,  { &&srlPLUSor, NULL }  ,  { &&srlPLUSor, NULL } 
 ,  { &&srlPLUSor, NULL }  ,  { &&srlPLUSor, NULL }  ,  { &&srlPLUSor, NULL }  ,  { &&srlPLUSor, NULL }  ,  { &&srlPLUSor, NULL }  ,  { &&srlPLUSor, NULL }  ,  { &&srlPLUSor, NULL }  ,  { &&srlPLUSor, NULL }  ,  { &&srlPLUSor, NULL }  ,  { &&srlPLUSor, NULL } 
 ,  { &&srlPLUSor, NULL }  ,  { &&srlPLUSor, NULL }  ,  { &&srlPLUSor, NULL }  ,  { &&srlPLUSor, NULL }  ,  { &&srlPLUSor, NULL }  ,  { &&srlPLUSor, NULL }  ,  { &&srlPLUSor, NULL }  ,  { &&srlPLUSor, NULL }  ,  { &&srlPLUSor, NULL }  ,  { &&srlPLUSor, NULL } 
 ,  { &&srlPLUSor, NULL }  ,  { &&srlPLUSor, NULL }  ,  { &&srlPLUSor, NULL }  ,  { &&srlPLUSor, NULL }  ,  { &&srlPLUSor, NULL }  ,  { &&srlPLUSor, NULL }  ,  { &&srlPLUSor, NULL }  ,  { &&srlPLUSor, NULL }  ,  { &&srlPLUSor, NULL }  ,  { &&srlPLUSor, NULL } 
 }; 

struct pointer arrayaddiuPLUSsubu[T_SIZE] = {  { &&addiuPLUSsubu, NULL }  ,  { &&addiuPLUSsubu, NULL }  ,  { &&addiuPLUSsubu, NULL }  ,  { &&addiuPLUSsubu, NULL }  ,  { &&addiuPLUSsubu, NULL }  ,  { &&addiuPLUSsubu, NULL }  ,  { &&addiuPLUSsubu, NULL }  ,  { &&addiuPLUSsubu, NULL }  ,  { &&addiuPLUSsubu, NULL }  ,  { &&addiuPLUSsubu, NULL } 
 ,  { &&addiuPLUSsubu, NULL }  ,  { &&addiuPLUSsubu, NULL }  ,  { &&addiuPLUSsubu, NULL }  ,  { &&addiuPLUSsubu, NULL }  ,  { &&addiuPLUSsubu, NULL }  ,  { &&addiuPLUSsubu, NULL }  ,  { &&addiuPLUSsubu, NULL }  ,  { &&addiuPLUSsubu, NULL }  ,  { &&addiuPLUSsubu, NULL }  ,  { &&addiuPLUSsubu, NULL } 
 ,  { &&addiuPLUSsubu, NULL }  ,  { &&addiuPLUSsubu, NULL }  ,  { &&addiuPLUSsubu, NULL }  ,  { &&addiuPLUSsubu, NULL }  ,  { &&addiuPLUSsubu, NULL }  ,  { &&addiuPLUSsubu, NULL }  ,  { &&addiuPLUSsubu, NULL }  ,  { &&addiuPLUSsubu, NULL }  ,  { &&addiuPLUSsubu, NULL }  ,  { &&addiuPLUSsubu, NULL } 
 ,  { &&addiuPLUSsubu, NULL }  ,  { &&addiuPLUSsubu, NULL }  ,  { &&addiuPLUSsubu, NULL }  ,  { &&addiuPLUSsubu, NULL }  ,  { &&addiuPLUSsubu, NULL }  ,  { &&addiuPLUSsubu, NULL }  ,  { &&addiuPLUSsubuPLUSand, NULL }  ,  { &&addiuPLUSsubu, NULL }  ,  { &&addiuPLUSsubu, NULL }  ,  { &&addiuPLUSsubu, NULL } 
 ,  { &&addiuPLUSsubu, NULL }  ,  { &&addiuPLUSsubu, NULL }  ,  { &&addiuPLUSsubu, NULL }  ,  { &&addiuPLUSsubu, NULL }  ,  { &&addiuPLUSsubu, NULL }  ,  { &&addiuPLUSsubu, NULL }  ,  { &&addiuPLUSsubu, NULL }  ,  { &&addiuPLUSsubu, NULL }  ,  { &&addiuPLUSsubu, NULL }  ,  { &&addiuPLUSsubu, NULL } 
 ,  { &&addiuPLUSsubu, NULL }  ,  { &&addiuPLUSsubu, NULL }  ,  { &&addiuPLUSsubuPLUSaddiu, NULL }  ,  { &&addiuPLUSsubu, NULL }  ,  { &&addiuPLUSsubu, NULL }  ,  { &&addiuPLUSsubu, NULL }  ,  { &&addiuPLUSsubu, NULL }  ,  { &&addiuPLUSsubu, NULL }  ,  { &&addiuPLUSsubu, NULL }  ,  { &&addiuPLUSsubu, NULL } 
 ,  { &&addiuPLUSsubu, NULL }  ,  { &&addiuPLUSsubu, NULL }  ,  { &&addiuPLUSsubu, NULL }  ,  { &&addiuPLUSsubu, NULL }  ,  { &&addiuPLUSsubu, NULL }  ,  { &&addiuPLUSsubu, NULL }  ,  { &&addiuPLUSsubu, NULL }  ,  { &&addiuPLUSsubu, NULL }  ,  { &&addiuPLUSsubu, NULL }  ,  { &&addiuPLUSsubu, NULL } 
 ,  { &&addiuPLUSsubu, NULL }  ,  { &&addiuPLUSsubu, NULL }  ,  { &&addiuPLUSsubu, NULL }  ,  { &&addiuPLUSsubu, NULL }  ,  { &&addiuPLUSsubu, NULL }  ,  { &&addiuPLUSsubu, NULL }  ,  { &&addiuPLUSsubu, NULL }  ,  { &&addiuPLUSsubu, NULL }  ,  { &&addiuPLUSsubu, NULL }  ,  { &&addiuPLUSsubu, NULL } 
 ,  { &&addiuPLUSsubu, NULL }  ,  { &&addiuPLUSsubu, NULL }  ,  { &&addiuPLUSsubu, NULL }  ,  { &&addiuPLUSsubu, NULL }  ,  { &&addiuPLUSsubu, NULL }  ,  { &&addiuPLUSsubu, NULL }  ,  { &&addiuPLUSsubu, NULL }  ,  { &&addiuPLUSsubu, NULL }  ,  { &&addiuPLUSsubu, NULL }  ,  { &&addiuPLUSsubu, NULL } 
 ,  { &&addiuPLUSsubu, NULL }  ,  { &&addiuPLUSsubu, NULL }  ,  { &&addiuPLUSsubu, NULL }  ,  { &&addiuPLUSsubu, NULL }  ,  { &&addiuPLUSsubu, NULL }  ,  { &&addiuPLUSsubu, NULL }  ,  { &&addiuPLUSsubu, NULL }  ,  { &&addiuPLUSsubu, NULL }  ,  { &&addiuPLUSsubu, NULL }  ,  { &&addiuPLUSsubu, NULL } 
 ,  { &&addiuPLUSsubu, NULL }  ,  { &&addiuPLUSsubu, NULL }  ,  { &&addiuPLUSsubu, NULL }  ,  { &&addiuPLUSsubu, NULL }  ,  { &&addiuPLUSsubu, NULL }  ,  { &&addiuPLUSsubu, NULL }  ,  { &&addiuPLUSsubu, NULL }  ,  { &&addiuPLUSsubu, NULL }  ,  { &&addiuPLUSsubu, NULL }  ,  { &&addiuPLUSsubu, NULL } 
 }; 

struct pointer arrayswPLUSjal[T_SIZE] = {  { &&swPLUSjal, NULL }  ,  { &&swPLUSjal, NULL }  ,  { &&swPLUSjal, NULL }  ,  { &&swPLUSjal, NULL }  ,  { &&swPLUSjal, NULL }  ,  { &&swPLUSjal, NULL }  ,  { &&swPLUSjal, NULL }  ,  { &&swPLUSjal, NULL }  ,  { &&swPLUSjal, NULL }  ,  { &&swPLUSjal, NULL } 
 ,  { &&swPLUSjal, NULL }  ,  { &&swPLUSjal, NULL }  ,  { &&swPLUSjal, NULL }  ,  { &&swPLUSjal, NULL }  ,  { &&swPLUSjal, NULL }  ,  { &&swPLUSjal, NULL }  ,  { &&swPLUSjal, NULL }  ,  { &&swPLUSjal, NULL }  ,  { &&swPLUSjal, NULL }  ,  { &&swPLUSjal, NULL } 
 ,  { &&swPLUSjal, NULL }  ,  { &&swPLUSjal, NULL }  ,  { &&swPLUSjal, NULL }  ,  { &&swPLUSjal, NULL }  ,  { &&swPLUSjal, NULL }  ,  { &&swPLUSjal, NULL }  ,  { &&swPLUSjal, NULL }  ,  { &&swPLUSjal, NULL }  ,  { &&swPLUSjal, NULL }  ,  { &&swPLUSjal, NULL } 
 ,  { &&swPLUSjal, NULL }  ,  { &&swPLUSjal, NULL }  ,  { &&swPLUSjal, NULL }  ,  { &&swPLUSjal, NULL }  ,  { &&swPLUSjal, NULL }  ,  { &&swPLUSjal, NULL }  ,  { &&swPLUSjal, NULL }  ,  { &&swPLUSjal, NULL }  ,  { &&swPLUSjal, NULL }  ,  { &&swPLUSjal, NULL } 
 ,  { &&swPLUSjal, NULL }  ,  { &&swPLUSjal, NULL }  ,  { &&swPLUSjal, NULL }  ,  { &&swPLUSjal, NULL }  ,  { &&swPLUSjal, NULL }  ,  { &&swPLUSjal, NULL }  ,  { &&swPLUSjal, NULL }  ,  { &&swPLUSjal, NULL }  ,  { &&swPLUSjal, NULL }  ,  { &&swPLUSjal, NULL } 
 ,  { &&swPLUSjal, NULL }  ,  { &&swPLUSjal, NULL }  ,  { &&swPLUSjalPLUSaddiu, NULL }  ,  { &&swPLUSjal, NULL }  ,  { &&swPLUSjal, NULL }  ,  { &&swPLUSjal, NULL }  ,  { &&swPLUSjal, NULL }  ,  { &&swPLUSjal, NULL }  ,  { &&swPLUSjal, NULL }  ,  { &&swPLUSjal, NULL } 
 ,  { &&swPLUSjal, NULL }  ,  { &&swPLUSjal, NULL }  ,  { &&swPLUSjal, NULL }  ,  { &&swPLUSjal, NULL }  ,  { &&swPLUSjal, NULL }  ,  { &&swPLUSjal, NULL }  ,  { &&swPLUSjal, NULL }  ,  { &&swPLUSjal, NULL }  ,  { &&swPLUSjal, NULL }  ,  { &&swPLUSjal, NULL } 
 ,  { &&swPLUSjal, NULL }  ,  { &&swPLUSjal, NULL }  ,  { &&swPLUSjal, NULL }  ,  { &&swPLUSjal, NULL }  ,  { &&swPLUSjal, NULL }  ,  { &&swPLUSjal, NULL }  ,  { &&swPLUSjal, NULL }  ,  { &&swPLUSjal, NULL }  ,  { &&swPLUSjal, NULL }  ,  { &&swPLUSjal, NULL } 
 ,  { &&swPLUSjal, NULL }  ,  { &&swPLUSjal, NULL }  ,  { &&swPLUSjal, NULL }  ,  { &&swPLUSjal, NULL }  ,  { &&swPLUSjal, NULL }  ,  { &&swPLUSjal, NULL }  ,  { &&swPLUSjal, NULL }  ,  { &&swPLUSjal, NULL }  ,  { &&swPLUSjal, NULL }  ,  { &&swPLUSjal, NULL } 
 ,  { &&swPLUSjal, NULL }  ,  { &&swPLUSjal, NULL }  ,  { &&swPLUSjal, NULL }  ,  { &&swPLUSjal, NULL }  ,  { &&swPLUSjal, NULL }  ,  { &&swPLUSjal, NULL }  ,  { &&swPLUSjal, NULL }  ,  { &&swPLUSjal, NULL }  ,  { &&swPLUSjal, NULL }  ,  { &&swPLUSjal, NULL } 
 ,  { &&swPLUSjal, NULL }  ,  { &&swPLUSjal, NULL }  ,  { &&swPLUSjal, NULL }  ,  { &&swPLUSjal, NULL }  ,  { &&swPLUSjal, NULL }  ,  { &&swPLUSjal, NULL }  ,  { &&swPLUSjal, NULL }  ,  { &&swPLUSjal, NULL }  ,  { &&swPLUSjal, NULL }  ,  { &&swPLUSjal, NULL } 
 }; 

struct pointer arrayaddiuPLUSslti[T_SIZE] = {  { &&addiuPLUSslti, NULL }  ,  { &&addiuPLUSslti, NULL }  ,  { &&addiuPLUSslti, NULL }  ,  { &&addiuPLUSslti, NULL }  ,  { &&addiuPLUSslti, NULL }  ,  { &&addiuPLUSslti, NULL }  ,  { &&addiuPLUSslti, NULL }  ,  { &&addiuPLUSslti, NULL }  ,  { &&addiuPLUSslti, NULL }  ,  { &&addiuPLUSslti, NULL } 
 ,  { &&addiuPLUSslti, NULL }  ,  { &&addiuPLUSslti, NULL }  ,  { &&addiuPLUSslti, NULL }  ,  { &&addiuPLUSslti, NULL }  ,  { &&addiuPLUSslti, NULL }  ,  { &&addiuPLUSslti, NULL }  ,  { &&addiuPLUSslti, NULL }  ,  { &&addiuPLUSslti, NULL }  ,  { &&addiuPLUSslti, NULL }  ,  { &&addiuPLUSslti, NULL } 
 ,  { &&addiuPLUSslti, NULL }  ,  { &&addiuPLUSslti, NULL }  ,  { &&addiuPLUSslti, NULL }  ,  { &&addiuPLUSslti, NULL }  ,  { &&addiuPLUSslti, NULL }  ,  { &&addiuPLUSslti, NULL }  ,  { &&addiuPLUSslti, NULL }  ,  { &&addiuPLUSslti, NULL }  ,  { &&addiuPLUSslti, NULL }  ,  { &&addiuPLUSslti, NULL } 
 ,  { &&addiuPLUSslti, NULL }  ,  { &&addiuPLUSslti, NULL }  ,  { &&addiuPLUSslti, NULL }  ,  { &&addiuPLUSslti, NULL }  ,  { &&addiuPLUSslti, NULL }  ,  { &&addiuPLUSslti, NULL }  ,  { &&addiuPLUSslti, NULL }  ,  { &&addiuPLUSslti, NULL }  ,  { &&addiuPLUSslti, NULL }  ,  { &&addiuPLUSslti, NULL } 
 ,  { &&addiuPLUSslti, NULL }  ,  { &&addiuPLUSslti, NULL }  ,  { &&addiuPLUSslti, NULL }  ,  { &&addiuPLUSslti, NULL }  ,  { &&addiuPLUSslti, NULL }  ,  { &&addiuPLUSslti, NULL }  ,  { &&addiuPLUSslti, NULL }  ,  { &&addiuPLUSsltiPLUSbeq, NULL }  ,  { &&addiuPLUSsltiPLUSbne, NULL }  ,  { &&addiuPLUSslti, NULL } 
 ,  { &&addiuPLUSslti, NULL }  ,  { &&addiuPLUSslti, NULL }  ,  { &&addiuPLUSslti, NULL }  ,  { &&addiuPLUSslti, NULL }  ,  { &&addiuPLUSslti, NULL }  ,  { &&addiuPLUSslti, NULL }  ,  { &&addiuPLUSslti, NULL }  ,  { &&addiuPLUSslti, NULL }  ,  { &&addiuPLUSslti, NULL }  ,  { &&addiuPLUSslti, NULL } 
 ,  { &&addiuPLUSslti, NULL }  ,  { &&addiuPLUSslti, NULL }  ,  { &&addiuPLUSslti, NULL }  ,  { &&addiuPLUSslti, NULL }  ,  { &&addiuPLUSslti, NULL }  ,  { &&addiuPLUSslti, NULL }  ,  { &&addiuPLUSslti, NULL }  ,  { &&addiuPLUSslti, NULL }  ,  { &&addiuPLUSslti, NULL }  ,  { &&addiuPLUSslti, NULL } 
 ,  { &&addiuPLUSslti, NULL }  ,  { &&addiuPLUSslti, NULL }  ,  { &&addiuPLUSslti, NULL }  ,  { &&addiuPLUSslti, NULL }  ,  { &&addiuPLUSslti, NULL }  ,  { &&addiuPLUSslti, NULL }  ,  { &&addiuPLUSslti, NULL }  ,  { &&addiuPLUSslti, NULL }  ,  { &&addiuPLUSslti, NULL }  ,  { &&addiuPLUSslti, NULL } 
 ,  { &&addiuPLUSslti, NULL }  ,  { &&addiuPLUSslti, NULL }  ,  { &&addiuPLUSslti, NULL }  ,  { &&addiuPLUSslti, NULL }  ,  { &&addiuPLUSslti, NULL }  ,  { &&addiuPLUSslti, NULL }  ,  { &&addiuPLUSslti, NULL }  ,  { &&addiuPLUSslti, NULL }  ,  { &&addiuPLUSslti, NULL }  ,  { &&addiuPLUSslti, NULL } 
 ,  { &&addiuPLUSslti, NULL }  ,  { &&addiuPLUSslti, NULL }  ,  { &&addiuPLUSslti, NULL }  ,  { &&addiuPLUSslti, NULL }  ,  { &&addiuPLUSslti, NULL }  ,  { &&addiuPLUSslti, NULL }  ,  { &&addiuPLUSslti, NULL }  ,  { &&addiuPLUSslti, NULL }  ,  { &&addiuPLUSslti, NULL }  ,  { &&addiuPLUSslti, NULL } 
 ,  { &&addiuPLUSslti, NULL }  ,  { &&addiuPLUSslti, NULL }  ,  { &&addiuPLUSslti, NULL }  ,  { &&addiuPLUSslti, NULL }  ,  { &&addiuPLUSslti, NULL }  ,  { &&addiuPLUSslti, NULL }  ,  { &&addiuPLUSslti, NULL }  ,  { &&addiuPLUSslti, NULL }  ,  { &&addiuPLUSslti, NULL }  ,  { &&addiuPLUSslti, NULL } 
 }; 

struct pointer arrayaddiuPLUSsltu[T_SIZE] = {  { &&addiuPLUSsltu, NULL }  ,  { &&addiuPLUSsltu, NULL }  ,  { &&addiuPLUSsltu, NULL }  ,  { &&addiuPLUSsltu, NULL }  ,  { &&addiuPLUSsltu, NULL }  ,  { &&addiuPLUSsltu, NULL }  ,  { &&addiuPLUSsltu, NULL }  ,  { &&addiuPLUSsltu, NULL }  ,  { &&addiuPLUSsltu, NULL }  ,  { &&addiuPLUSsltu, NULL } 
 ,  { &&addiuPLUSsltu, NULL }  ,  { &&addiuPLUSsltu, NULL }  ,  { &&addiuPLUSsltu, NULL }  ,  { &&addiuPLUSsltu, NULL }  ,  { &&addiuPLUSsltu, NULL }  ,  { &&addiuPLUSsltu, NULL }  ,  { &&addiuPLUSsltu, NULL }  ,  { &&addiuPLUSsltu, NULL }  ,  { &&addiuPLUSsltu, NULL }  ,  { &&addiuPLUSsltu, NULL } 
 ,  { &&addiuPLUSsltu, NULL }  ,  { &&addiuPLUSsltu, NULL }  ,  { &&addiuPLUSsltu, NULL }  ,  { &&addiuPLUSsltu, NULL }  ,  { &&addiuPLUSsltu, NULL }  ,  { &&addiuPLUSsltu, NULL }  ,  { &&addiuPLUSsltu, NULL }  ,  { &&addiuPLUSsltu, NULL }  ,  { &&addiuPLUSsltu, NULL }  ,  { &&addiuPLUSsltu, NULL } 
 ,  { &&addiuPLUSsltu, NULL }  ,  { &&addiuPLUSsltu, NULL }  ,  { &&addiuPLUSsltu, NULL }  ,  { &&addiuPLUSsltu, NULL }  ,  { &&addiuPLUSsltu, NULL }  ,  { &&addiuPLUSsltu, NULL }  ,  { &&addiuPLUSsltu, NULL }  ,  { &&addiuPLUSsltu, NULL }  ,  { &&addiuPLUSsltu, NULL }  ,  { &&addiuPLUSsltu, NULL } 
 ,  { &&addiuPLUSsltu, NULL }  ,  { &&addiuPLUSsltu, NULL }  ,  { &&addiuPLUSsltu, NULL }  ,  { &&addiuPLUSsltu, NULL }  ,  { &&addiuPLUSsltu, NULL }  ,  { &&addiuPLUSsltu, NULL }  ,  { &&addiuPLUSsltu, NULL }  ,  { &&addiuPLUSsltuPLUSbeq, NULL }  ,  { &&addiuPLUSsltu, NULL }  ,  { &&addiuPLUSsltu, NULL } 
 ,  { &&addiuPLUSsltu, NULL }  ,  { &&addiuPLUSsltu, NULL }  ,  { &&addiuPLUSsltu, NULL }  ,  { &&addiuPLUSsltu, NULL }  ,  { &&addiuPLUSsltu, NULL }  ,  { &&addiuPLUSsltu, NULL }  ,  { &&addiuPLUSsltu, NULL }  ,  { &&addiuPLUSsltu, NULL }  ,  { &&addiuPLUSsltu, NULL }  ,  { &&addiuPLUSsltu, NULL } 
 ,  { &&addiuPLUSsltu, NULL }  ,  { &&addiuPLUSsltu, NULL }  ,  { &&addiuPLUSsltu, NULL }  ,  { &&addiuPLUSsltu, NULL }  ,  { &&addiuPLUSsltu, NULL }  ,  { &&addiuPLUSsltu, NULL }  ,  { &&addiuPLUSsltu, NULL }  ,  { &&addiuPLUSsltu, NULL }  ,  { &&addiuPLUSsltu, NULL }  ,  { &&addiuPLUSsltu, NULL } 
 ,  { &&addiuPLUSsltu, NULL }  ,  { &&addiuPLUSsltu, NULL }  ,  { &&addiuPLUSsltu, NULL }  ,  { &&addiuPLUSsltu, NULL }  ,  { &&addiuPLUSsltu, NULL }  ,  { &&addiuPLUSsltu, NULL }  ,  { &&addiuPLUSsltu, NULL }  ,  { &&addiuPLUSsltu, NULL }  ,  { &&addiuPLUSsltu, NULL }  ,  { &&addiuPLUSsltu, NULL } 
 ,  { &&addiuPLUSsltu, NULL }  ,  { &&addiuPLUSsltu, NULL }  ,  { &&addiuPLUSsltu, NULL }  ,  { &&addiuPLUSsltu, NULL }  ,  { &&addiuPLUSsltu, NULL }  ,  { &&addiuPLUSsltu, NULL }  ,  { &&addiuPLUSsltu, NULL }  ,  { &&addiuPLUSsltu, NULL }  ,  { &&addiuPLUSsltu, NULL }  ,  { &&addiuPLUSsltu, NULL } 
 ,  { &&addiuPLUSsltu, NULL }  ,  { &&addiuPLUSsltu, NULL }  ,  { &&addiuPLUSsltu, NULL }  ,  { &&addiuPLUSsltu, NULL }  ,  { &&addiuPLUSsltu, NULL }  ,  { &&addiuPLUSsltu, NULL }  ,  { &&addiuPLUSsltu, NULL }  ,  { &&addiuPLUSsltu, NULL }  ,  { &&addiuPLUSsltu, NULL }  ,  { &&addiuPLUSsltu, NULL } 
 ,  { &&addiuPLUSsltu, NULL }  ,  { &&addiuPLUSsltu, NULL }  ,  { &&addiuPLUSsltu, NULL }  ,  { &&addiuPLUSsltu, NULL }  ,  { &&addiuPLUSsltu, NULL }  ,  { &&addiuPLUSsltu, NULL }  ,  { &&addiuPLUSsltu, NULL }  ,  { &&addiuPLUSsltu, NULL }  ,  { &&addiuPLUSsltu, NULL }  ,  { &&addiuPLUSsltu, NULL } 
 }; 

struct pointer arraysllPLUSandi[T_SIZE] = {  { &&sllPLUSandiPLUSsll, NULL }  ,  { &&sllPLUSandi, NULL }  ,  { &&sllPLUSandi, NULL }  ,  { &&sllPLUSandi, NULL }  ,  { &&sllPLUSandi, NULL }  ,  { &&sllPLUSandi, NULL }  ,  { &&sllPLUSandi, NULL }  ,  { &&sllPLUSandi, NULL }  ,  { &&sllPLUSandi, NULL }  ,  { &&sllPLUSandi, NULL } 
 ,  { &&sllPLUSandi, NULL }  ,  { &&sllPLUSandi, NULL }  ,  { &&sllPLUSandi, NULL }  ,  { &&sllPLUSandi, NULL }  ,  { &&sllPLUSandi, NULL }  ,  { &&sllPLUSandi, NULL }  ,  { &&sllPLUSandi, NULL }  ,  { &&sllPLUSandi, NULL }  ,  { &&sllPLUSandi, NULL }  ,  { &&sllPLUSandi, NULL } 
 ,  { &&sllPLUSandi, NULL }  ,  { &&sllPLUSandi, NULL }  ,  { &&sllPLUSandi, NULL }  ,  { &&sllPLUSandi, NULL }  ,  { &&sllPLUSandi, NULL }  ,  { &&sllPLUSandi, NULL }  ,  { &&sllPLUSandi, NULL }  ,  { &&sllPLUSandi, NULL }  ,  { &&sllPLUSandi, NULL }  ,  { &&sllPLUSandi, NULL } 
 ,  { &&sllPLUSandi, NULL }  ,  { &&sllPLUSandi, NULL }  ,  { &&sllPLUSandi, NULL }  ,  { &&sllPLUSandi, NULL }  ,  { &&sllPLUSandi, NULL }  ,  { &&sllPLUSandi, NULL }  ,  { &&sllPLUSandi, NULL }  ,  { &&sllPLUSandiPLUSor, NULL }  ,  { &&sllPLUSandi, NULL }  ,  { &&sllPLUSandi, NULL } 
 ,  { &&sllPLUSandi, NULL }  ,  { &&sllPLUSandi, NULL }  ,  { &&sllPLUSandi, NULL }  ,  { &&sllPLUSandi, NULL }  ,  { &&sllPLUSandi, NULL }  ,  { &&sllPLUSandi, NULL }  ,  { &&sllPLUSandi, NULL }  ,  { &&sllPLUSandi, NULL }  ,  { &&sllPLUSandi, NULL }  ,  { &&sllPLUSandi, NULL } 
 ,  { &&sllPLUSandi, NULL }  ,  { &&sllPLUSandi, NULL }  ,  { &&sllPLUSandi, NULL }  ,  { &&sllPLUSandi, NULL }  ,  { &&sllPLUSandi, NULL }  ,  { &&sllPLUSandi, NULL }  ,  { &&sllPLUSandi, NULL }  ,  { &&sllPLUSandi, NULL }  ,  { &&sllPLUSandi, NULL }  ,  { &&sllPLUSandi, NULL } 
 ,  { &&sllPLUSandi, NULL }  ,  { &&sllPLUSandi, NULL }  ,  { &&sllPLUSandi, NULL }  ,  { &&sllPLUSandi, NULL }  ,  { &&sllPLUSandi, NULL }  ,  { &&sllPLUSandi, NULL }  ,  { &&sllPLUSandi, NULL }  ,  { &&sllPLUSandi, NULL }  ,  { &&sllPLUSandi, NULL }  ,  { &&sllPLUSandi, NULL } 
 ,  { &&sllPLUSandi, NULL }  ,  { &&sllPLUSandi, NULL }  ,  { &&sllPLUSandi, NULL }  ,  { &&sllPLUSandi, NULL }  ,  { &&sllPLUSandi, NULL }  ,  { &&sllPLUSandi, NULL }  ,  { &&sllPLUSandi, NULL }  ,  { &&sllPLUSandi, NULL }  ,  { &&sllPLUSandi, NULL }  ,  { &&sllPLUSandi, NULL } 
 ,  { &&sllPLUSandi, NULL }  ,  { &&sllPLUSandi, NULL }  ,  { &&sllPLUSandi, NULL }  ,  { &&sllPLUSandi, NULL }  ,  { &&sllPLUSandi, NULL }  ,  { &&sllPLUSandi, NULL }  ,  { &&sllPLUSandi, NULL }  ,  { &&sllPLUSandi, NULL }  ,  { &&sllPLUSandi, NULL }  ,  { &&sllPLUSandi, NULL } 
 ,  { &&sllPLUSandi, NULL }  ,  { &&sllPLUSandi, NULL }  ,  { &&sllPLUSandi, NULL }  ,  { &&sllPLUSandi, NULL }  ,  { &&sllPLUSandi, NULL }  ,  { &&sllPLUSandi, NULL }  ,  { &&sllPLUSandi, NULL }  ,  { &&sllPLUSandi, NULL }  ,  { &&sllPLUSandi, NULL }  ,  { &&sllPLUSandi, NULL } 
 ,  { &&sllPLUSandi, NULL }  ,  { &&sllPLUSandi, NULL }  ,  { &&sllPLUSandi, NULL }  ,  { &&sllPLUSandi, NULL }  ,  { &&sllPLUSandi, NULL }  ,  { &&sllPLUSandi, NULL }  ,  { &&sllPLUSandi, NULL }  ,  { &&sllPLUSandi, NULL }  ,  { &&sllPLUSandi, NULL }  ,  { &&sllPLUSandi, NULL } 
 }; 

struct pointer arrayluiPLUSsrl[T_SIZE] = {  { &&luiPLUSsrl, NULL }  ,  { &&luiPLUSsrl, NULL }  ,  { &&luiPLUSsrl, NULL }  ,  { &&luiPLUSsrl, NULL }  ,  { &&luiPLUSsrl, NULL }  ,  { &&luiPLUSsrl, NULL }  ,  { &&luiPLUSsrl, NULL }  ,  { &&luiPLUSsrl, NULL }  ,  { &&luiPLUSsrl, NULL }  ,  { &&luiPLUSsrl, NULL } 
 ,  { &&luiPLUSsrl, NULL }  ,  { &&luiPLUSsrl, NULL }  ,  { &&luiPLUSsrl, NULL }  ,  { &&luiPLUSsrl, NULL }  ,  { &&luiPLUSsrl, NULL }  ,  { &&luiPLUSsrl, NULL }  ,  { &&luiPLUSsrl, NULL }  ,  { &&luiPLUSsrl, NULL }  ,  { &&luiPLUSsrl, NULL }  ,  { &&luiPLUSsrl, NULL } 
 ,  { &&luiPLUSsrl, NULL }  ,  { &&luiPLUSsrl, NULL }  ,  { &&luiPLUSsrl, NULL }  ,  { &&luiPLUSsrl, NULL }  ,  { &&luiPLUSsrl, NULL }  ,  { &&luiPLUSsrl, NULL }  ,  { &&luiPLUSsrl, NULL }  ,  { &&luiPLUSsrl, NULL }  ,  { &&luiPLUSsrl, NULL }  ,  { &&luiPLUSsrl, NULL } 
 ,  { &&luiPLUSsrl, NULL }  ,  { &&luiPLUSsrl, NULL }  ,  { &&luiPLUSsrl, NULL }  ,  { &&luiPLUSsrl, NULL }  ,  { &&luiPLUSsrl, NULL }  ,  { &&luiPLUSsrl, NULL }  ,  { &&luiPLUSsrl, NULL }  ,  { &&luiPLUSsrl, NULL }  ,  { &&luiPLUSsrl, NULL }  ,  { &&luiPLUSsrl, NULL } 
 ,  { &&luiPLUSsrl, NULL }  ,  { &&luiPLUSsrl, NULL }  ,  { &&luiPLUSsrl, NULL }  ,  { &&luiPLUSsrl, NULL }  ,  { &&luiPLUSsrl, NULL }  ,  { &&luiPLUSsrl, NULL }  ,  { &&luiPLUSsrl, NULL }  ,  { &&luiPLUSsrl, NULL }  ,  { &&luiPLUSsrl, NULL }  ,  { &&luiPLUSsrl, NULL } 
 ,  { &&luiPLUSsrl, NULL }  ,  { &&luiPLUSsrl, NULL }  ,  { &&luiPLUSsrl, NULL }  ,  { &&luiPLUSsrl, NULL }  ,  { &&luiPLUSsrl, NULL }  ,  { &&luiPLUSsrl, NULL }  ,  { &&luiPLUSsrlPLUSori, NULL }  ,  { &&luiPLUSsrl, NULL }  ,  { &&luiPLUSsrl, NULL }  ,  { &&luiPLUSsrl, NULL } 
 ,  { &&luiPLUSsrl, NULL }  ,  { &&luiPLUSsrl, NULL }  ,  { &&luiPLUSsrl, NULL }  ,  { &&luiPLUSsrl, NULL }  ,  { &&luiPLUSsrl, NULL }  ,  { &&luiPLUSsrl, NULL }  ,  { &&luiPLUSsrl, NULL }  ,  { &&luiPLUSsrl, NULL }  ,  { &&luiPLUSsrl, NULL }  ,  { &&luiPLUSsrl, NULL } 
 ,  { &&luiPLUSsrl, NULL }  ,  { &&luiPLUSsrl, NULL }  ,  { &&luiPLUSsrl, NULL }  ,  { &&luiPLUSsrl, NULL }  ,  { &&luiPLUSsrl, NULL }  ,  { &&luiPLUSsrl, NULL }  ,  { &&luiPLUSsrl, NULL }  ,  { &&luiPLUSsrl, NULL }  ,  { &&luiPLUSsrl, NULL }  ,  { &&luiPLUSsrl, NULL } 
 ,  { &&luiPLUSsrl, NULL }  ,  { &&luiPLUSsrl, NULL }  ,  { &&luiPLUSsrl, NULL }  ,  { &&luiPLUSsrl, NULL }  ,  { &&luiPLUSsrl, NULL }  ,  { &&luiPLUSsrl, NULL }  ,  { &&luiPLUSsrl, NULL }  ,  { &&luiPLUSsrl, NULL }  ,  { &&luiPLUSsrl, NULL }  ,  { &&luiPLUSsrl, NULL } 
 ,  { &&luiPLUSsrl, NULL }  ,  { &&luiPLUSsrl, NULL }  ,  { &&luiPLUSsrl, NULL }  ,  { &&luiPLUSsrl, NULL }  ,  { &&luiPLUSsrl, NULL }  ,  { &&luiPLUSsrl, NULL }  ,  { &&luiPLUSsrl, NULL }  ,  { &&luiPLUSsrl, NULL }  ,  { &&luiPLUSsrl, NULL }  ,  { &&luiPLUSsrl, NULL } 
 ,  { &&luiPLUSsrl, NULL }  ,  { &&luiPLUSsrl, NULL }  ,  { &&luiPLUSsrl, NULL }  ,  { &&luiPLUSsrl, NULL }  ,  { &&luiPLUSsrl, NULL }  ,  { &&luiPLUSsrl, NULL }  ,  { &&luiPLUSsrl, NULL }  ,  { &&luiPLUSsrl, NULL }  ,  { &&luiPLUSsrl, NULL }  ,  { &&luiPLUSsrl, NULL } 
 }; 

struct pointer arraysrlPLUSxor[T_SIZE] = {  { &&srlPLUSxor, NULL }  ,  { &&srlPLUSxorPLUSerror, NULL }  ,  { &&srlPLUSxorPLUSsrl, NULL }  ,  { &&srlPLUSxor, NULL }  ,  { &&srlPLUSxor, NULL }  ,  { &&srlPLUSxorPLUSerror, NULL }  ,  { &&srlPLUSxor, NULL }  ,  { &&srlPLUSxor, NULL }  ,  { &&srlPLUSxor, NULL }  ,  { &&srlPLUSxor, NULL } 
 ,  { &&srlPLUSxor, NULL }  ,  { &&srlPLUSxor, NULL }  ,  { &&srlPLUSxor, NULL }  ,  { &&srlPLUSxorPLUSerror, NULL }  ,  { &&srlPLUSxorPLUSerror, NULL }  ,  { &&srlPLUSxorPLUSerror, NULL }  ,  { &&srlPLUSxor, NULL }  ,  { &&srlPLUSxor, NULL }  ,  { &&srlPLUSxor, NULL }  ,  { &&srlPLUSxor, NULL } 
 ,  { &&srlPLUSxorPLUSerror, NULL }  ,  { &&srlPLUSxorPLUSerror, NULL }  ,  { &&srlPLUSxorPLUSerror, NULL }  ,  { &&srlPLUSxorPLUSerror, NULL }  ,  { &&srlPLUSxor, NULL }  ,  { &&srlPLUSxor, NULL }  ,  { &&srlPLUSxor, NULL }  ,  { &&srlPLUSxor, NULL }  ,  { &&srlPLUSxorPLUSerror, NULL }  ,  { &&srlPLUSxorPLUSerror, NULL } 
 ,  { &&srlPLUSxorPLUSerror, NULL }  ,  { &&srlPLUSxorPLUSerror, NULL }  ,  { &&srlPLUSxor, NULL }  ,  { &&srlPLUSxor, NULL }  ,  { &&srlPLUSxor, NULL }  ,  { &&srlPLUSxor, NULL }  ,  { &&srlPLUSxor, NULL }  ,  { &&srlPLUSxor, NULL }  ,  { &&srlPLUSxor, NULL }  ,  { &&srlPLUSxor, NULL } 
 ,  { &&srlPLUSxorPLUSerror, NULL }  ,  { &&srlPLUSxorPLUSerror, NULL }  ,  { &&srlPLUSxor, NULL }  ,  { &&srlPLUSxor, NULL }  ,  { &&srlPLUSxor, NULL }  ,  { &&srlPLUSxor, NULL }  ,  { &&srlPLUSxor, NULL }  ,  { &&srlPLUSxor, NULL }  ,  { &&srlPLUSxor, NULL }  ,  { &&srlPLUSxor, NULL } 
 ,  { &&srlPLUSxor, NULL }  ,  { &&srlPLUSxor, NULL }  ,  { &&srlPLUSxor, NULL }  ,  { &&srlPLUSxor, NULL }  ,  { &&srlPLUSxor, NULL }  ,  { &&srlPLUSxor, NULL }  ,  { &&srlPLUSxor, NULL }  ,  { &&srlPLUSxor, NULL }  ,  { &&srlPLUSxor, NULL }  ,  { &&srlPLUSxorPLUSerror, NULL } 
 ,  { &&srlPLUSxorPLUSerror, NULL }  ,  { &&srlPLUSxorPLUSerror, NULL }  ,  { &&srlPLUSxorPLUSerror, NULL }  ,  { &&srlPLUSxorPLUSerror, NULL }  ,  { &&srlPLUSxorPLUSerror, NULL }  ,  { &&srlPLUSxorPLUSerror, NULL }  ,  { &&srlPLUSxorPLUSerror, NULL }  ,  { &&srlPLUSxor, NULL }  ,  { &&srlPLUSxor, NULL }  ,  { &&srlPLUSxor, NULL } 
 ,  { &&srlPLUSxorPLUSerror, NULL }  ,  { &&srlPLUSxorPLUSerror, NULL }  ,  { &&srlPLUSxorPLUSerror, NULL }  ,  { &&srlPLUSxorPLUSerror, NULL }  ,  { &&srlPLUSxorPLUSerror, NULL }  ,  { &&srlPLUSxor, NULL }  ,  { &&srlPLUSxor, NULL }  ,  { &&srlPLUSxor, NULL }  ,  { &&srlPLUSxor, NULL }  ,  { &&srlPLUSxor, NULL } 
 ,  { &&srlPLUSxor, NULL }  ,  { &&srlPLUSxor, NULL }  ,  { &&srlPLUSxorPLUSerror, NULL }  ,  { &&srlPLUSxor, NULL }  ,  { &&srlPLUSxor, NULL }  ,  { &&srlPLUSxor, NULL }  ,  { &&srlPLUSxorPLUSsw, NULL }  ,  { &&srlPLUSxorPLUSerror, NULL }  ,  { &&srlPLUSxorPLUSerror, NULL }  ,  { &&srlPLUSxor, NULL } 
 ,  { &&srlPLUSxorPLUSerror, NULL }  ,  { &&srlPLUSxorPLUSerror, NULL }  ,  { &&srlPLUSxorPLUSerror, NULL }  ,  { &&srlPLUSxorPLUSerror, NULL }  ,  { &&srlPLUSxorPLUSerror, NULL }  ,  { &&srlPLUSxorPLUSerror, NULL }  ,  { &&srlPLUSxorPLUSerror, NULL }  ,  { &&srlPLUSxorPLUSerror, NULL }  ,  { &&srlPLUSxorPLUSerror, NULL }  ,  { &&srlPLUSxorPLUSerror, NULL } 
 ,  { &&srlPLUSxorPLUSerror, NULL }  ,  { &&srlPLUSxorPLUSerror, NULL }  ,  { &&srlPLUSxorPLUSerror, NULL }  ,  { &&srlPLUSxorPLUSerror, NULL }  ,  { &&srlPLUSxorPLUSerror, NULL }  ,  { &&srlPLUSxorPLUSerror, NULL }  ,  { &&srlPLUSxorPLUSerror, NULL }  ,  { &&srlPLUSxorPLUSerror, NULL }  ,  { &&srlPLUSxorPLUSerror, NULL }  ,  { &&srlPLUSxorPLUSerror, NULL } 
 }; 

struct pointer arrayandiPLUSsll[T_SIZE] = {  { &&andiPLUSsll, NULL }  ,  { &&andiPLUSsll, NULL }  ,  { &&andiPLUSsll, NULL }  ,  { &&andiPLUSsll, NULL }  ,  { &&andiPLUSsll, NULL }  ,  { &&andiPLUSsll, NULL }  ,  { &&andiPLUSsll, NULL }  ,  { &&andiPLUSsll, NULL }  ,  { &&andiPLUSsll, NULL }  ,  { &&andiPLUSsll, NULL } 
 ,  { &&andiPLUSsll, NULL }  ,  { &&andiPLUSsll, NULL }  ,  { &&andiPLUSsll, NULL }  ,  { &&andiPLUSsll, NULL }  ,  { &&andiPLUSsll, NULL }  ,  { &&andiPLUSsll, NULL }  ,  { &&andiPLUSsll, NULL }  ,  { &&andiPLUSsll, NULL }  ,  { &&andiPLUSsll, NULL }  ,  { &&andiPLUSsll, NULL } 
 ,  { &&andiPLUSsll, NULL }  ,  { &&andiPLUSsll, NULL }  ,  { &&andiPLUSsll, NULL }  ,  { &&andiPLUSsll, NULL }  ,  { &&andiPLUSsll, NULL }  ,  { &&andiPLUSsll, NULL }  ,  { &&andiPLUSsll, NULL }  ,  { &&andiPLUSsll, NULL }  ,  { &&andiPLUSsll, NULL }  ,  { &&andiPLUSsll, NULL } 
 ,  { &&andiPLUSsll, NULL }  ,  { &&andiPLUSsll, NULL }  ,  { &&andiPLUSsll, NULL }  ,  { &&andiPLUSsllPLUSaddu, NULL }  ,  { &&andiPLUSsll, NULL }  ,  { &&andiPLUSsll, NULL }  ,  { &&andiPLUSsll, NULL }  ,  { &&andiPLUSsllPLUSor, NULL }  ,  { &&andiPLUSsllPLUSxor, NULL }  ,  { &&andiPLUSsll, NULL } 
 ,  { &&andiPLUSsll, NULL }  ,  { &&andiPLUSsll, NULL }  ,  { &&andiPLUSsll, NULL }  ,  { &&andiPLUSsll, NULL }  ,  { &&andiPLUSsll, NULL }  ,  { &&andiPLUSsll, NULL }  ,  { &&andiPLUSsll, NULL }  ,  { &&andiPLUSsll, NULL }  ,  { &&andiPLUSsll, NULL }  ,  { &&andiPLUSsll, NULL } 
 ,  { &&andiPLUSsll, NULL }  ,  { &&andiPLUSsll, NULL }  ,  { &&andiPLUSsll, NULL }  ,  { &&andiPLUSsll, NULL }  ,  { &&andiPLUSsll, NULL }  ,  { &&andiPLUSsllPLUSandi, NULL }  ,  { &&andiPLUSsll, NULL }  ,  { &&andiPLUSsll, NULL }  ,  { &&andiPLUSsll, NULL }  ,  { &&andiPLUSsll, NULL } 
 ,  { &&andiPLUSsll, NULL }  ,  { &&andiPLUSsll, NULL }  ,  { &&andiPLUSsll, NULL }  ,  { &&andiPLUSsll, NULL }  ,  { &&andiPLUSsll, NULL }  ,  { &&andiPLUSsll, NULL }  ,  { &&andiPLUSsll, NULL }  ,  { &&andiPLUSsll, NULL }  ,  { &&andiPLUSsll, NULL }  ,  { &&andiPLUSsll, NULL } 
 ,  { &&andiPLUSsll, NULL }  ,  { &&andiPLUSsll, NULL }  ,  { &&andiPLUSsll, NULL }  ,  { &&andiPLUSsll, NULL }  ,  { &&andiPLUSsll, NULL }  ,  { &&andiPLUSsll, NULL }  ,  { &&andiPLUSsll, NULL }  ,  { &&andiPLUSsll, NULL }  ,  { &&andiPLUSsll, NULL }  ,  { &&andiPLUSsll, NULL } 
 ,  { &&andiPLUSsll, NULL }  ,  { &&andiPLUSsll, NULL }  ,  { &&andiPLUSsll, NULL }  ,  { &&andiPLUSsll, NULL }  ,  { &&andiPLUSsll, NULL }  ,  { &&andiPLUSsll, NULL }  ,  { &&andiPLUSsll, NULL }  ,  { &&andiPLUSsll, NULL }  ,  { &&andiPLUSsll, NULL }  ,  { &&andiPLUSsll, NULL } 
 ,  { &&andiPLUSsll, NULL }  ,  { &&andiPLUSsll, NULL }  ,  { &&andiPLUSsll, NULL }  ,  { &&andiPLUSsll, NULL }  ,  { &&andiPLUSsll, NULL }  ,  { &&andiPLUSsll, NULL }  ,  { &&andiPLUSsll, NULL }  ,  { &&andiPLUSsll, NULL }  ,  { &&andiPLUSsll, NULL }  ,  { &&andiPLUSsll, NULL } 
 ,  { &&andiPLUSsll, NULL }  ,  { &&andiPLUSsll, NULL }  ,  { &&andiPLUSsll, NULL }  ,  { &&andiPLUSsll, NULL }  ,  { &&andiPLUSsll, NULL }  ,  { &&andiPLUSsll, NULL }  ,  { &&andiPLUSsll, NULL }  ,  { &&andiPLUSsll, NULL }  ,  { &&andiPLUSsll, NULL }  ,  { &&andiPLUSsll, NULL } 
 }; 

struct pointer arraymovnPLUSjump[T_SIZE] = {  { &&movnPLUSjump, NULL }  ,  { &&movnPLUSjump, NULL }  ,  { &&movnPLUSjump, NULL }  ,  { &&movnPLUSjump, NULL }  ,  { &&movnPLUSjump, NULL }  ,  { &&movnPLUSjump, NULL }  ,  { &&movnPLUSjump, NULL }  ,  { &&movnPLUSjump, NULL }  ,  { &&movnPLUSjump, NULL }  ,  { &&movnPLUSjump, NULL } 
 ,  { &&movnPLUSjump, NULL }  ,  { &&movnPLUSjump, NULL }  ,  { &&movnPLUSjump, NULL }  ,  { &&movnPLUSjump, NULL }  ,  { &&movnPLUSjump, NULL }  ,  { &&movnPLUSjump, NULL }  ,  { &&movnPLUSjump, NULL }  ,  { &&movnPLUSjump, NULL }  ,  { &&movnPLUSjump, NULL }  ,  { &&movnPLUSjump, NULL } 
 ,  { &&movnPLUSjump, NULL }  ,  { &&movnPLUSjump, NULL }  ,  { &&movnPLUSjump, NULL }  ,  { &&movnPLUSjump, NULL }  ,  { &&movnPLUSjump, NULL }  ,  { &&movnPLUSjump, NULL }  ,  { &&movnPLUSjump, NULL }  ,  { &&movnPLUSjump, NULL }  ,  { &&movnPLUSjump, NULL }  ,  { &&movnPLUSjump, NULL } 
 ,  { &&movnPLUSjump, NULL }  ,  { &&movnPLUSjump, NULL }  ,  { &&movnPLUSjump, NULL }  ,  { &&movnPLUSjumpPLUSaddu, NULL }  ,  { &&movnPLUSjump, NULL }  ,  { &&movnPLUSjump, NULL }  ,  { &&movnPLUSjump, NULL }  ,  { &&movnPLUSjump, NULL }  ,  { &&movnPLUSjump, NULL }  ,  { &&movnPLUSjump, NULL } 
 ,  { &&movnPLUSjump, NULL }  ,  { &&movnPLUSjump, NULL }  ,  { &&movnPLUSjump, NULL }  ,  { &&movnPLUSjump, NULL }  ,  { &&movnPLUSjump, NULL }  ,  { &&movnPLUSjump, NULL }  ,  { &&movnPLUSjump, NULL }  ,  { &&movnPLUSjump, NULL }  ,  { &&movnPLUSjump, NULL }  ,  { &&movnPLUSjump, NULL } 
 ,  { &&movnPLUSjump, NULL }  ,  { &&movnPLUSjump, NULL }  ,  { &&movnPLUSjump, NULL }  ,  { &&movnPLUSjump, NULL }  ,  { &&movnPLUSjump, NULL }  ,  { &&movnPLUSjump, NULL }  ,  { &&movnPLUSjump, NULL }  ,  { &&movnPLUSjump, NULL }  ,  { &&movnPLUSjump, NULL }  ,  { &&movnPLUSjump, NULL } 
 ,  { &&movnPLUSjump, NULL }  ,  { &&movnPLUSjump, NULL }  ,  { &&movnPLUSjump, NULL }  ,  { &&movnPLUSjump, NULL }  ,  { &&movnPLUSjump, NULL }  ,  { &&movnPLUSjump, NULL }  ,  { &&movnPLUSjump, NULL }  ,  { &&movnPLUSjump, NULL }  ,  { &&movnPLUSjump, NULL }  ,  { &&movnPLUSjump, NULL } 
 ,  { &&movnPLUSjump, NULL }  ,  { &&movnPLUSjump, NULL }  ,  { &&movnPLUSjump, NULL }  ,  { &&movnPLUSjump, NULL }  ,  { &&movnPLUSjump, NULL }  ,  { &&movnPLUSjump, NULL }  ,  { &&movnPLUSjump, NULL }  ,  { &&movnPLUSjump, NULL }  ,  { &&movnPLUSjump, NULL }  ,  { &&movnPLUSjump, NULL } 
 ,  { &&movnPLUSjump, NULL }  ,  { &&movnPLUSjump, NULL }  ,  { &&movnPLUSjump, NULL }  ,  { &&movnPLUSjump, NULL }  ,  { &&movnPLUSjump, NULL }  ,  { &&movnPLUSjump, NULL }  ,  { &&movnPLUSjump, NULL }  ,  { &&movnPLUSjump, NULL }  ,  { &&movnPLUSjump, NULL }  ,  { &&movnPLUSjump, NULL } 
 ,  { &&movnPLUSjump, NULL }  ,  { &&movnPLUSjump, NULL }  ,  { &&movnPLUSjump, NULL }  ,  { &&movnPLUSjump, NULL }  ,  { &&movnPLUSjump, NULL }  ,  { &&movnPLUSjump, NULL }  ,  { &&movnPLUSjump, NULL }  ,  { &&movnPLUSjump, NULL }  ,  { &&movnPLUSjump, NULL }  ,  { &&movnPLUSjump, NULL } 
 ,  { &&movnPLUSjump, NULL }  ,  { &&movnPLUSjump, NULL }  ,  { &&movnPLUSjump, NULL }  ,  { &&movnPLUSjump, NULL }  ,  { &&movnPLUSjump, NULL }  ,  { &&movnPLUSjump, NULL }  ,  { &&movnPLUSjump, NULL }  ,  { &&movnPLUSjump, NULL }  ,  { &&movnPLUSjump, NULL }  ,  { &&movnPLUSjump, NULL } 
 }; 

struct pointer arrayjalPLUSaddiu[T_SIZE] = {  { &&jalPLUSaddiu, NULL }  ,  { &&jalPLUSaddiu, NULL }  ,  { &&jalPLUSaddiu, NULL }  ,  { &&jalPLUSaddiu, NULL }  ,  { &&jalPLUSaddiu, NULL }  ,  { &&jalPLUSaddiu, NULL }  ,  { &&jalPLUSaddiu, NULL }  ,  { &&jalPLUSaddiu, NULL }  ,  { &&jalPLUSaddiu, NULL }  ,  { &&jalPLUSaddiu, NULL } 
 ,  { &&jalPLUSaddiu, NULL }  ,  { &&jalPLUSaddiu, NULL }  ,  { &&jalPLUSaddiu, NULL }  ,  { &&jalPLUSaddiu, NULL }  ,  { &&jalPLUSaddiu, NULL }  ,  { &&jalPLUSaddiu, NULL }  ,  { &&jalPLUSaddiu, NULL }  ,  { &&jalPLUSaddiu, NULL }  ,  { &&jalPLUSaddiu, NULL }  ,  { &&jalPLUSaddiu, NULL } 
 ,  { &&jalPLUSaddiu, NULL }  ,  { &&jalPLUSaddiu, NULL }  ,  { &&jalPLUSaddiu, NULL }  ,  { &&jalPLUSaddiu, NULL }  ,  { &&jalPLUSaddiu, NULL }  ,  { &&jalPLUSaddiu, NULL }  ,  { &&jalPLUSaddiu, NULL }  ,  { &&jalPLUSaddiu, NULL }  ,  { &&jalPLUSaddiu, NULL }  ,  { &&jalPLUSaddiu, NULL } 
 ,  { &&jalPLUSaddiu, NULL }  ,  { &&jalPLUSaddiu, NULL }  ,  { &&jalPLUSaddiu, NULL }  ,  { &&jalPLUSaddiu, NULL }  ,  { &&jalPLUSaddiu, NULL }  ,  { &&jalPLUSaddiu, NULL }  ,  { &&jalPLUSaddiu, NULL }  ,  { &&jalPLUSaddiu, NULL }  ,  { &&jalPLUSaddiu, NULL }  ,  { &&jalPLUSaddiu, NULL } 
 ,  { &&jalPLUSaddiu, NULL }  ,  { &&jalPLUSaddiu, NULL }  ,  { &&jalPLUSaddiu, NULL }  ,  { &&jalPLUSaddiu, NULL }  ,  { &&jalPLUSaddiu, NULL }  ,  { &&jalPLUSaddiu, NULL }  ,  { &&jalPLUSaddiu, NULL }  ,  { &&jalPLUSaddiu, NULL }  ,  { &&jalPLUSaddiu, NULL }  ,  { &&jalPLUSaddiu, NULL } 
 ,  { &&jalPLUSaddiu, NULL }  ,  { &&jalPLUSaddiu, NULL }  ,  { &&jalPLUSaddiuPLUSaddiu, NULL }  ,  { &&jalPLUSaddiu, NULL }  ,  { &&jalPLUSaddiu, NULL }  ,  { &&jalPLUSaddiu, NULL }  ,  { &&jalPLUSaddiu, NULL }  ,  { &&jalPLUSaddiu, NULL }  ,  { &&jalPLUSaddiu, NULL }  ,  { &&jalPLUSaddiu, NULL } 
 ,  { &&jalPLUSaddiu, NULL }  ,  { &&jalPLUSaddiu, NULL }  ,  { &&jalPLUSaddiu, NULL }  ,  { &&jalPLUSaddiu, NULL }  ,  { &&jalPLUSaddiu, NULL }  ,  { &&jalPLUSaddiu, NULL }  ,  { &&jalPLUSaddiu, NULL }  ,  { &&jalPLUSaddiu, NULL }  ,  { &&jalPLUSaddiu, NULL }  ,  { &&jalPLUSaddiu, NULL } 
 ,  { &&jalPLUSaddiu, NULL }  ,  { &&jalPLUSaddiu, NULL }  ,  { &&jalPLUSaddiu, NULL }  ,  { &&jalPLUSaddiu, NULL }  ,  { &&jalPLUSaddiu, NULL }  ,  { &&jalPLUSaddiu, NULL }  ,  { &&jalPLUSaddiu, NULL }  ,  { &&jalPLUSaddiu, NULL }  ,  { &&jalPLUSaddiuPLUSlw, NULL }  ,  { &&jalPLUSaddiu, NULL } 
 ,  { &&jalPLUSaddiu, NULL }  ,  { &&jalPLUSaddiu, NULL }  ,  { &&jalPLUSaddiu, NULL }  ,  { &&jalPLUSaddiu, NULL }  ,  { &&jalPLUSaddiu, NULL }  ,  { &&jalPLUSaddiu, NULL }  ,  { &&jalPLUSaddiu, NULL }  ,  { &&jalPLUSaddiu, NULL }  ,  { &&jalPLUSaddiu, NULL }  ,  { &&jalPLUSaddiu, NULL } 
 ,  { &&jalPLUSaddiu, NULL }  ,  { &&jalPLUSaddiu, NULL }  ,  { &&jalPLUSaddiu, NULL }  ,  { &&jalPLUSaddiu, NULL }  ,  { &&jalPLUSaddiu, NULL }  ,  { &&jalPLUSaddiu, NULL }  ,  { &&jalPLUSaddiu, NULL }  ,  { &&jalPLUSaddiu, NULL }  ,  { &&jalPLUSaddiu, NULL }  ,  { &&jalPLUSaddiu, NULL } 
 ,  { &&jalPLUSaddiu, NULL }  ,  { &&jalPLUSaddiu, NULL }  ,  { &&jalPLUSaddiu, NULL }  ,  { &&jalPLUSaddiu, NULL }  ,  { &&jalPLUSaddiu, NULL }  ,  { &&jalPLUSaddiu, NULL }  ,  { &&jalPLUSaddiu, NULL }  ,  { &&jalPLUSaddiu, NULL }  ,  { &&jalPLUSaddiu, NULL }  ,  { &&jalPLUSaddiu, NULL } 
 }; 

struct pointer arrayaddiuPLUSsw[T_SIZE] = {  { &&addiuPLUSsw, NULL }  ,  { &&addiuPLUSsw, NULL }  ,  { &&addiuPLUSsw, NULL }  ,  { &&addiuPLUSsw, NULL }  ,  { &&addiuPLUSsw, NULL }  ,  { &&addiuPLUSsw, NULL }  ,  { &&addiuPLUSsw, NULL }  ,  { &&addiuPLUSsw, NULL }  ,  { &&addiuPLUSsw, NULL }  ,  { &&addiuPLUSsw, NULL } 
 ,  { &&addiuPLUSsw, NULL }  ,  { &&addiuPLUSsw, NULL }  ,  { &&addiuPLUSsw, NULL }  ,  { &&addiuPLUSsw, NULL }  ,  { &&addiuPLUSsw, NULL }  ,  { &&addiuPLUSsw, NULL }  ,  { &&addiuPLUSsw, NULL }  ,  { &&addiuPLUSsw, NULL }  ,  { &&addiuPLUSsw, NULL }  ,  { &&addiuPLUSsw, NULL } 
 ,  { &&addiuPLUSsw, NULL }  ,  { &&addiuPLUSsw, NULL }  ,  { &&addiuPLUSsw, NULL }  ,  { &&addiuPLUSsw, NULL }  ,  { &&addiuPLUSsw, NULL }  ,  { &&addiuPLUSsw, NULL }  ,  { &&addiuPLUSsw, NULL }  ,  { &&addiuPLUSsw, NULL }  ,  { &&addiuPLUSsw, NULL }  ,  { &&addiuPLUSsw, NULL } 
 ,  { &&addiuPLUSsw, NULL }  ,  { &&addiuPLUSsw, NULL }  ,  { &&addiuPLUSsw, NULL }  ,  { &&addiuPLUSswPLUSaddu, NULL }  ,  { &&addiuPLUSsw, NULL }  ,  { &&addiuPLUSsw, NULL }  ,  { &&addiuPLUSsw, NULL }  ,  { &&addiuPLUSsw, NULL }  ,  { &&addiuPLUSsw, NULL }  ,  { &&addiuPLUSsw, NULL } 
 ,  { &&addiuPLUSsw, NULL }  ,  { &&addiuPLUSsw, NULL }  ,  { &&addiuPLUSsw, NULL }  ,  { &&addiuPLUSsw, NULL }  ,  { &&addiuPLUSsw, NULL }  ,  { &&addiuPLUSswPLUSjump, NULL }  ,  { &&addiuPLUSsw, NULL }  ,  { &&addiuPLUSsw, NULL }  ,  { &&addiuPLUSsw, NULL }  ,  { &&addiuPLUSsw, NULL } 
 ,  { &&addiuPLUSsw, NULL }  ,  { &&addiuPLUSsw, NULL }  ,  { &&addiuPLUSswPLUSaddiu, NULL }  ,  { &&addiuPLUSsw, NULL }  ,  { &&addiuPLUSsw, NULL }  ,  { &&addiuPLUSsw, NULL }  ,  { &&addiuPLUSsw, NULL }  ,  { &&addiuPLUSsw, NULL }  ,  { &&addiuPLUSsw, NULL }  ,  { &&addiuPLUSsw, NULL } 
 ,  { &&addiuPLUSsw, NULL }  ,  { &&addiuPLUSsw, NULL }  ,  { &&addiuPLUSsw, NULL }  ,  { &&addiuPLUSsw, NULL }  ,  { &&addiuPLUSsw, NULL }  ,  { &&addiuPLUSsw, NULL }  ,  { &&addiuPLUSsw, NULL }  ,  { &&addiuPLUSsw, NULL }  ,  { &&addiuPLUSsw, NULL }  ,  { &&addiuPLUSsw, NULL } 
 ,  { &&addiuPLUSsw, NULL }  ,  { &&addiuPLUSsw, NULL }  ,  { &&addiuPLUSsw, NULL }  ,  { &&addiuPLUSsw, NULL }  ,  { &&addiuPLUSsw, NULL }  ,  { &&addiuPLUSsw, NULL }  ,  { &&addiuPLUSsw, NULL }  ,  { &&addiuPLUSsw, NULL }  ,  { &&addiuPLUSswPLUSlw, NULL }  ,  { &&addiuPLUSsw, NULL } 
 ,  { &&addiuPLUSsw, NULL }  ,  { &&addiuPLUSsw, NULL }  ,  { &&addiuPLUSsw, NULL }  ,  { &&addiuPLUSsw, NULL }  ,  { &&addiuPLUSsw, NULL }  ,  { &&addiuPLUSsw, NULL }  ,  { &&addiuPLUSswPLUSsw, NULL }  ,  { &&addiuPLUSsw, NULL }  ,  { &&addiuPLUSsw, NULL }  ,  { &&addiuPLUSsw, NULL } 
 ,  { &&addiuPLUSsw, NULL }  ,  { &&addiuPLUSsw, NULL }  ,  { &&addiuPLUSsw, NULL }  ,  { &&addiuPLUSsw, NULL }  ,  { &&addiuPLUSsw, NULL }  ,  { &&addiuPLUSsw, NULL }  ,  { &&addiuPLUSsw, NULL }  ,  { &&addiuPLUSsw, NULL }  ,  { &&addiuPLUSsw, NULL }  ,  { &&addiuPLUSsw, NULL } 
 ,  { &&addiuPLUSsw, NULL }  ,  { &&addiuPLUSsw, NULL }  ,  { &&addiuPLUSsw, NULL }  ,  { &&addiuPLUSsw, NULL }  ,  { &&addiuPLUSsw, NULL }  ,  { &&addiuPLUSsw, NULL }  ,  { &&addiuPLUSsw, NULL }  ,  { &&addiuPLUSsw, NULL }  ,  { &&addiuPLUSsw, NULL }  ,  { &&addiuPLUSsw, NULL } 
 }; 

struct pointer arraysltPLUSaddu[T_SIZE] = {  { &&sltPLUSaddu, NULL }  ,  { &&sltPLUSaddu, NULL }  ,  { &&sltPLUSaddu, NULL }  ,  { &&sltPLUSaddu, NULL }  ,  { &&sltPLUSaddu, NULL }  ,  { &&sltPLUSaddu, NULL }  ,  { &&sltPLUSaddu, NULL }  ,  { &&sltPLUSaddu, NULL }  ,  { &&sltPLUSaddu, NULL }  ,  { &&sltPLUSaddu, NULL } 
 ,  { &&sltPLUSaddu, NULL }  ,  { &&sltPLUSaddu, NULL }  ,  { &&sltPLUSaddu, NULL }  ,  { &&sltPLUSaddu, NULL }  ,  { &&sltPLUSaddu, NULL }  ,  { &&sltPLUSaddu, NULL }  ,  { &&sltPLUSaddu, NULL }  ,  { &&sltPLUSaddu, NULL }  ,  { &&sltPLUSaddu, NULL }  ,  { &&sltPLUSaddu, NULL } 
 ,  { &&sltPLUSaddu, NULL }  ,  { &&sltPLUSaddu, NULL }  ,  { &&sltPLUSaddu, NULL }  ,  { &&sltPLUSaddu, NULL }  ,  { &&sltPLUSaddu, NULL }  ,  { &&sltPLUSaddu, NULL }  ,  { &&sltPLUSaddu, NULL }  ,  { &&sltPLUSaddu, NULL }  ,  { &&sltPLUSaddu, NULL }  ,  { &&sltPLUSaddu, NULL } 
 ,  { &&sltPLUSaddu, NULL }  ,  { &&sltPLUSaddu, NULL }  ,  { &&sltPLUSaddu, NULL }  ,  { &&sltPLUSaddu, NULL }  ,  { &&sltPLUSaddu, NULL }  ,  { &&sltPLUSaddu, NULL }  ,  { &&sltPLUSaddu, NULL }  ,  { &&sltPLUSaddu, NULL }  ,  { &&sltPLUSaddu, NULL }  ,  { &&sltPLUSaddu, NULL } 
 ,  { &&sltPLUSaddu, NULL }  ,  { &&sltPLUSaddu, NULL }  ,  { &&sltPLUSaddu, NULL }  ,  { &&sltPLUSaddu, NULL }  ,  { &&sltPLUSaddu, NULL }  ,  { &&sltPLUSaddu, NULL }  ,  { &&sltPLUSaddu, NULL }  ,  { &&sltPLUSaddu, NULL }  ,  { &&sltPLUSadduPLUSbne, NULL }  ,  { &&sltPLUSaddu, NULL } 
 ,  { &&sltPLUSaddu, NULL }  ,  { &&sltPLUSaddu, NULL }  ,  { &&sltPLUSaddu, NULL }  ,  { &&sltPLUSaddu, NULL }  ,  { &&sltPLUSaddu, NULL }  ,  { &&sltPLUSaddu, NULL }  ,  { &&sltPLUSaddu, NULL }  ,  { &&sltPLUSaddu, NULL }  ,  { &&sltPLUSaddu, NULL }  ,  { &&sltPLUSaddu, NULL } 
 ,  { &&sltPLUSaddu, NULL }  ,  { &&sltPLUSaddu, NULL }  ,  { &&sltPLUSaddu, NULL }  ,  { &&sltPLUSaddu, NULL }  ,  { &&sltPLUSaddu, NULL }  ,  { &&sltPLUSaddu, NULL }  ,  { &&sltPLUSaddu, NULL }  ,  { &&sltPLUSaddu, NULL }  ,  { &&sltPLUSaddu, NULL }  ,  { &&sltPLUSaddu, NULL } 
 ,  { &&sltPLUSaddu, NULL }  ,  { &&sltPLUSaddu, NULL }  ,  { &&sltPLUSaddu, NULL }  ,  { &&sltPLUSaddu, NULL }  ,  { &&sltPLUSaddu, NULL }  ,  { &&sltPLUSaddu, NULL }  ,  { &&sltPLUSaddu, NULL }  ,  { &&sltPLUSaddu, NULL }  ,  { &&sltPLUSaddu, NULL }  ,  { &&sltPLUSaddu, NULL } 
 ,  { &&sltPLUSaddu, NULL }  ,  { &&sltPLUSaddu, NULL }  ,  { &&sltPLUSaddu, NULL }  ,  { &&sltPLUSaddu, NULL }  ,  { &&sltPLUSaddu, NULL }  ,  { &&sltPLUSaddu, NULL }  ,  { &&sltPLUSaddu, NULL }  ,  { &&sltPLUSaddu, NULL }  ,  { &&sltPLUSaddu, NULL }  ,  { &&sltPLUSaddu, NULL } 
 ,  { &&sltPLUSaddu, NULL }  ,  { &&sltPLUSaddu, NULL }  ,  { &&sltPLUSaddu, NULL }  ,  { &&sltPLUSaddu, NULL }  ,  { &&sltPLUSaddu, NULL }  ,  { &&sltPLUSaddu, NULL }  ,  { &&sltPLUSaddu, NULL }  ,  { &&sltPLUSaddu, NULL }  ,  { &&sltPLUSaddu, NULL }  ,  { &&sltPLUSaddu, NULL } 
 ,  { &&sltPLUSaddu, NULL }  ,  { &&sltPLUSaddu, NULL }  ,  { &&sltPLUSaddu, NULL }  ,  { &&sltPLUSaddu, NULL }  ,  { &&sltPLUSaddu, NULL }  ,  { &&sltPLUSaddu, NULL }  ,  { &&sltPLUSaddu, NULL }  ,  { &&sltPLUSaddu, NULL }  ,  { &&sltPLUSaddu, NULL }  ,  { &&sltPLUSaddu, NULL } 
 }; 

struct pointer arraylwPLUSsll[T_SIZE] = {  { &&lwPLUSsll, NULL }  ,  { &&lwPLUSsll, NULL }  ,  { &&lwPLUSsll, NULL }  ,  { &&lwPLUSsll, NULL }  ,  { &&lwPLUSsll, NULL }  ,  { &&lwPLUSsll, NULL }  ,  { &&lwPLUSsll, NULL }  ,  { &&lwPLUSsll, NULL }  ,  { &&lwPLUSsll, NULL }  ,  { &&lwPLUSsll, NULL } 
 ,  { &&lwPLUSsll, NULL }  ,  { &&lwPLUSsll, NULL }  ,  { &&lwPLUSsll, NULL }  ,  { &&lwPLUSsll, NULL }  ,  { &&lwPLUSsll, NULL }  ,  { &&lwPLUSsll, NULL }  ,  { &&lwPLUSsll, NULL }  ,  { &&lwPLUSsll, NULL }  ,  { &&lwPLUSsll, NULL }  ,  { &&lwPLUSsll, NULL } 
 ,  { &&lwPLUSsll, NULL }  ,  { &&lwPLUSsll, NULL }  ,  { &&lwPLUSsll, NULL }  ,  { &&lwPLUSsll, NULL }  ,  { &&lwPLUSsll, NULL }  ,  { &&lwPLUSsll, NULL }  ,  { &&lwPLUSsll, NULL }  ,  { &&lwPLUSsll, NULL }  ,  { &&lwPLUSsll, NULL }  ,  { &&lwPLUSsll, NULL } 
 ,  { &&lwPLUSsll, NULL }  ,  { &&lwPLUSsll, NULL }  ,  { &&lwPLUSsll, NULL }  ,  { &&lwPLUSsllPLUSaddu, NULL }  ,  { &&lwPLUSsll, NULL }  ,  { &&lwPLUSsll, NULL }  ,  { &&lwPLUSsll, NULL }  ,  { &&lwPLUSsll, NULL }  ,  { &&lwPLUSsll, NULL }  ,  { &&lwPLUSsll, NULL } 
 ,  { &&lwPLUSsll, NULL }  ,  { &&lwPLUSsll, NULL }  ,  { &&lwPLUSsll, NULL }  ,  { &&lwPLUSsll, NULL }  ,  { &&lwPLUSsll, NULL }  ,  { &&lwPLUSsll, NULL }  ,  { &&lwPLUSsll, NULL }  ,  { &&lwPLUSsll, NULL }  ,  { &&lwPLUSsll, NULL }  ,  { &&lwPLUSsll, NULL } 
 ,  { &&lwPLUSsll, NULL }  ,  { &&lwPLUSsll, NULL }  ,  { &&lwPLUSsll, NULL }  ,  { &&lwPLUSsll, NULL }  ,  { &&lwPLUSsll, NULL }  ,  { &&lwPLUSsll, NULL }  ,  { &&lwPLUSsll, NULL }  ,  { &&lwPLUSsll, NULL }  ,  { &&lwPLUSsll, NULL }  ,  { &&lwPLUSsll, NULL } 
 ,  { &&lwPLUSsll, NULL }  ,  { &&lwPLUSsll, NULL }  ,  { &&lwPLUSsll, NULL }  ,  { &&lwPLUSsll, NULL }  ,  { &&lwPLUSsll, NULL }  ,  { &&lwPLUSsll, NULL }  ,  { &&lwPLUSsll, NULL }  ,  { &&lwPLUSsll, NULL }  ,  { &&lwPLUSsll, NULL }  ,  { &&lwPLUSsll, NULL } 
 ,  { &&lwPLUSsll, NULL }  ,  { &&lwPLUSsll, NULL }  ,  { &&lwPLUSsll, NULL }  ,  { &&lwPLUSsll, NULL }  ,  { &&lwPLUSsll, NULL }  ,  { &&lwPLUSsll, NULL }  ,  { &&lwPLUSsll, NULL }  ,  { &&lwPLUSsll, NULL }  ,  { &&lwPLUSsll, NULL }  ,  { &&lwPLUSsll, NULL } 
 ,  { &&lwPLUSsll, NULL }  ,  { &&lwPLUSsll, NULL }  ,  { &&lwPLUSsll, NULL }  ,  { &&lwPLUSsll, NULL }  ,  { &&lwPLUSsll, NULL }  ,  { &&lwPLUSsll, NULL }  ,  { &&lwPLUSsll, NULL }  ,  { &&lwPLUSsll, NULL }  ,  { &&lwPLUSsll, NULL }  ,  { &&lwPLUSsll, NULL } 
 ,  { &&lwPLUSsll, NULL }  ,  { &&lwPLUSsll, NULL }  ,  { &&lwPLUSsll, NULL }  ,  { &&lwPLUSsll, NULL }  ,  { &&lwPLUSsll, NULL }  ,  { &&lwPLUSsll, NULL }  ,  { &&lwPLUSsll, NULL }  ,  { &&lwPLUSsll, NULL }  ,  { &&lwPLUSsll, NULL }  ,  { &&lwPLUSsll, NULL } 
 ,  { &&lwPLUSsll, NULL }  ,  { &&lwPLUSsll, NULL }  ,  { &&lwPLUSsll, NULL }  ,  { &&lwPLUSsll, NULL }  ,  { &&lwPLUSsll, NULL }  ,  { &&lwPLUSsll, NULL }  ,  { &&lwPLUSsll, NULL }  ,  { &&lwPLUSsll, NULL }  ,  { &&lwPLUSsll, NULL }  ,  { &&lwPLUSsll, NULL } 
 }; 

struct pointer arraysrlPLUSsll[T_SIZE] = {  { &&srlPLUSsllPLUSsll, NULL }  ,  { &&srlPLUSsll, NULL }  ,  { &&srlPLUSsll, NULL }  ,  { &&srlPLUSsll, NULL }  ,  { &&srlPLUSsll, NULL }  ,  { &&srlPLUSsll, NULL }  ,  { &&srlPLUSsll, NULL }  ,  { &&srlPLUSsll, NULL }  ,  { &&srlPLUSsll, NULL }  ,  { &&srlPLUSsll, NULL } 
 ,  { &&srlPLUSsll, NULL }  ,  { &&srlPLUSsll, NULL }  ,  { &&srlPLUSsll, NULL }  ,  { &&srlPLUSsll, NULL }  ,  { &&srlPLUSsll, NULL }  ,  { &&srlPLUSsll, NULL }  ,  { &&srlPLUSsll, NULL }  ,  { &&srlPLUSsll, NULL }  ,  { &&srlPLUSsll, NULL }  ,  { &&srlPLUSsll, NULL } 
 ,  { &&srlPLUSsll, NULL }  ,  { &&srlPLUSsll, NULL }  ,  { &&srlPLUSsll, NULL }  ,  { &&srlPLUSsll, NULL }  ,  { &&srlPLUSsll, NULL }  ,  { &&srlPLUSsll, NULL }  ,  { &&srlPLUSsll, NULL }  ,  { &&srlPLUSsll, NULL }  ,  { &&srlPLUSsll, NULL }  ,  { &&srlPLUSsll, NULL } 
 ,  { &&srlPLUSsll, NULL }  ,  { &&srlPLUSsll, NULL }  ,  { &&srlPLUSsll, NULL }  ,  { &&srlPLUSsll, NULL }  ,  { &&srlPLUSsll, NULL }  ,  { &&srlPLUSsll, NULL }  ,  { &&srlPLUSsll, NULL }  ,  { &&srlPLUSsll, NULL }  ,  { &&srlPLUSsllPLUSxor, NULL }  ,  { &&srlPLUSsll, NULL } 
 ,  { &&srlPLUSsll, NULL }  ,  { &&srlPLUSsll, NULL }  ,  { &&srlPLUSsll, NULL }  ,  { &&srlPLUSsll, NULL }  ,  { &&srlPLUSsll, NULL }  ,  { &&srlPLUSsll, NULL }  ,  { &&srlPLUSsll, NULL }  ,  { &&srlPLUSsll, NULL }  ,  { &&srlPLUSsll, NULL }  ,  { &&srlPLUSsll, NULL } 
 ,  { &&srlPLUSsll, NULL }  ,  { &&srlPLUSsll, NULL }  ,  { &&srlPLUSsll, NULL }  ,  { &&srlPLUSsll, NULL }  ,  { &&srlPLUSsll, NULL }  ,  { &&srlPLUSsll, NULL }  ,  { &&srlPLUSsll, NULL }  ,  { &&srlPLUSsll, NULL }  ,  { &&srlPLUSsll, NULL }  ,  { &&srlPLUSsll, NULL } 
 ,  { &&srlPLUSsll, NULL }  ,  { &&srlPLUSsll, NULL }  ,  { &&srlPLUSsll, NULL }  ,  { &&srlPLUSsll, NULL }  ,  { &&srlPLUSsll, NULL }  ,  { &&srlPLUSsll, NULL }  ,  { &&srlPLUSsll, NULL }  ,  { &&srlPLUSsll, NULL }  ,  { &&srlPLUSsll, NULL }  ,  { &&srlPLUSsll, NULL } 
 ,  { &&srlPLUSsll, NULL }  ,  { &&srlPLUSsll, NULL }  ,  { &&srlPLUSsll, NULL }  ,  { &&srlPLUSsll, NULL }  ,  { &&srlPLUSsll, NULL }  ,  { &&srlPLUSsll, NULL }  ,  { &&srlPLUSsll, NULL }  ,  { &&srlPLUSsll, NULL }  ,  { &&srlPLUSsll, NULL }  ,  { &&srlPLUSsll, NULL } 
 ,  { &&srlPLUSsll, NULL }  ,  { &&srlPLUSsll, NULL }  ,  { &&srlPLUSsll, NULL }  ,  { &&srlPLUSsll, NULL }  ,  { &&srlPLUSsll, NULL }  ,  { &&srlPLUSsll, NULL }  ,  { &&srlPLUSsll, NULL }  ,  { &&srlPLUSsll, NULL }  ,  { &&srlPLUSsll, NULL }  ,  { &&srlPLUSsll, NULL } 
 ,  { &&srlPLUSsll, NULL }  ,  { &&srlPLUSsll, NULL }  ,  { &&srlPLUSsll, NULL }  ,  { &&srlPLUSsll, NULL }  ,  { &&srlPLUSsll, NULL }  ,  { &&srlPLUSsll, NULL }  ,  { &&srlPLUSsll, NULL }  ,  { &&srlPLUSsll, NULL }  ,  { &&srlPLUSsll, NULL }  ,  { &&srlPLUSsll, NULL } 
 ,  { &&srlPLUSsll, NULL }  ,  { &&srlPLUSsll, NULL }  ,  { &&srlPLUSsll, NULL }  ,  { &&srlPLUSsll, NULL }  ,  { &&srlPLUSsll, NULL }  ,  { &&srlPLUSsll, NULL }  ,  { &&srlPLUSsll, NULL }  ,  { &&srlPLUSsll, NULL }  ,  { &&srlPLUSsll, NULL }  ,  { &&srlPLUSsll, NULL } 
 }; 

struct pointer arraylwPLUSslt[T_SIZE] = {  { &&lwPLUSslt, NULL }  ,  { &&lwPLUSslt, NULL }  ,  { &&lwPLUSslt, NULL }  ,  { &&lwPLUSslt, NULL }  ,  { &&lwPLUSslt, NULL }  ,  { &&lwPLUSslt, NULL }  ,  { &&lwPLUSslt, NULL }  ,  { &&lwPLUSslt, NULL }  ,  { &&lwPLUSslt, NULL }  ,  { &&lwPLUSslt, NULL } 
 ,  { &&lwPLUSslt, NULL }  ,  { &&lwPLUSslt, NULL }  ,  { &&lwPLUSslt, NULL }  ,  { &&lwPLUSslt, NULL }  ,  { &&lwPLUSslt, NULL }  ,  { &&lwPLUSslt, NULL }  ,  { &&lwPLUSslt, NULL }  ,  { &&lwPLUSslt, NULL }  ,  { &&lwPLUSslt, NULL }  ,  { &&lwPLUSslt, NULL } 
 ,  { &&lwPLUSslt, NULL }  ,  { &&lwPLUSslt, NULL }  ,  { &&lwPLUSslt, NULL }  ,  { &&lwPLUSslt, NULL }  ,  { &&lwPLUSslt, NULL }  ,  { &&lwPLUSslt, NULL }  ,  { &&lwPLUSslt, NULL }  ,  { &&lwPLUSslt, NULL }  ,  { &&lwPLUSslt, NULL }  ,  { &&lwPLUSslt, NULL } 
 ,  { &&lwPLUSslt, NULL }  ,  { &&lwPLUSslt, NULL }  ,  { &&lwPLUSslt, NULL }  ,  { &&lwPLUSslt, NULL }  ,  { &&lwPLUSslt, NULL }  ,  { &&lwPLUSslt, NULL }  ,  { &&lwPLUSslt, NULL }  ,  { &&lwPLUSslt, NULL }  ,  { &&lwPLUSslt, NULL }  ,  { &&lwPLUSslt, NULL } 
 ,  { &&lwPLUSslt, NULL }  ,  { &&lwPLUSslt, NULL }  ,  { &&lwPLUSslt, NULL }  ,  { &&lwPLUSslt, NULL }  ,  { &&lwPLUSslt, NULL }  ,  { &&lwPLUSslt, NULL }  ,  { &&lwPLUSslt, NULL }  ,  { &&lwPLUSsltPLUSbeq, NULL }  ,  { &&lwPLUSsltPLUSbne, NULL }  ,  { &&lwPLUSslt, NULL } 
 ,  { &&lwPLUSslt, NULL }  ,  { &&lwPLUSslt, NULL }  ,  { &&lwPLUSslt, NULL }  ,  { &&lwPLUSslt, NULL }  ,  { &&lwPLUSslt, NULL }  ,  { &&lwPLUSslt, NULL }  ,  { &&lwPLUSslt, NULL }  ,  { &&lwPLUSslt, NULL }  ,  { &&lwPLUSslt, NULL }  ,  { &&lwPLUSslt, NULL } 
 ,  { &&lwPLUSslt, NULL }  ,  { &&lwPLUSslt, NULL }  ,  { &&lwPLUSslt, NULL }  ,  { &&lwPLUSslt, NULL }  ,  { &&lwPLUSslt, NULL }  ,  { &&lwPLUSslt, NULL }  ,  { &&lwPLUSslt, NULL }  ,  { &&lwPLUSslt, NULL }  ,  { &&lwPLUSslt, NULL }  ,  { &&lwPLUSslt, NULL } 
 ,  { &&lwPLUSslt, NULL }  ,  { &&lwPLUSslt, NULL }  ,  { &&lwPLUSslt, NULL }  ,  { &&lwPLUSslt, NULL }  ,  { &&lwPLUSslt, NULL }  ,  { &&lwPLUSslt, NULL }  ,  { &&lwPLUSslt, NULL }  ,  { &&lwPLUSslt, NULL }  ,  { &&lwPLUSslt, NULL }  ,  { &&lwPLUSslt, NULL } 
 ,  { &&lwPLUSslt, NULL }  ,  { &&lwPLUSslt, NULL }  ,  { &&lwPLUSslt, NULL }  ,  { &&lwPLUSslt, NULL }  ,  { &&lwPLUSslt, NULL }  ,  { &&lwPLUSslt, NULL }  ,  { &&lwPLUSslt, NULL }  ,  { &&lwPLUSslt, NULL }  ,  { &&lwPLUSslt, NULL }  ,  { &&lwPLUSslt, NULL } 
 ,  { &&lwPLUSslt, NULL }  ,  { &&lwPLUSslt, NULL }  ,  { &&lwPLUSslt, NULL }  ,  { &&lwPLUSslt, NULL }  ,  { &&lwPLUSslt, NULL }  ,  { &&lwPLUSslt, NULL }  ,  { &&lwPLUSslt, NULL }  ,  { &&lwPLUSslt, NULL }  ,  { &&lwPLUSslt, NULL }  ,  { &&lwPLUSslt, NULL } 
 ,  { &&lwPLUSslt, NULL }  ,  { &&lwPLUSslt, NULL }  ,  { &&lwPLUSslt, NULL }  ,  { &&lwPLUSslt, NULL }  ,  { &&lwPLUSslt, NULL }  ,  { &&lwPLUSslt, NULL }  ,  { &&lwPLUSslt, NULL }  ,  { &&lwPLUSslt, NULL }  ,  { &&lwPLUSslt, NULL }  ,  { &&lwPLUSslt, NULL } 
 }; 

struct pointer arrayswPLUSaddu[T_SIZE] = {  { &&swPLUSaddu, NULL }  ,  { &&swPLUSaddu, NULL }  ,  { &&swPLUSaddu, NULL }  ,  { &&swPLUSaddu, NULL }  ,  { &&swPLUSaddu, NULL }  ,  { &&swPLUSaddu, NULL }  ,  { &&swPLUSaddu, NULL }  ,  { &&swPLUSaddu, NULL }  ,  { &&swPLUSaddu, NULL }  ,  { &&swPLUSaddu, NULL } 
 ,  { &&swPLUSaddu, NULL }  ,  { &&swPLUSaddu, NULL }  ,  { &&swPLUSaddu, NULL }  ,  { &&swPLUSaddu, NULL }  ,  { &&swPLUSaddu, NULL }  ,  { &&swPLUSaddu, NULL }  ,  { &&swPLUSaddu, NULL }  ,  { &&swPLUSaddu, NULL }  ,  { &&swPLUSaddu, NULL }  ,  { &&swPLUSaddu, NULL } 
 ,  { &&swPLUSaddu, NULL }  ,  { &&swPLUSaddu, NULL }  ,  { &&swPLUSaddu, NULL }  ,  { &&swPLUSaddu, NULL }  ,  { &&swPLUSaddu, NULL }  ,  { &&swPLUSaddu, NULL }  ,  { &&swPLUSaddu, NULL }  ,  { &&swPLUSaddu, NULL }  ,  { &&swPLUSaddu, NULL }  ,  { &&swPLUSaddu, NULL } 
 ,  { &&swPLUSaddu, NULL }  ,  { &&swPLUSaddu, NULL }  ,  { &&swPLUSaddu, NULL }  ,  { &&swPLUSadduPLUSaddu, NULL }  ,  { &&swPLUSaddu, NULL }  ,  { &&swPLUSaddu, NULL }  ,  { &&swPLUSaddu, NULL }  ,  { &&swPLUSaddu, NULL }  ,  { &&swPLUSaddu, NULL }  ,  { &&swPLUSaddu, NULL } 
 ,  { &&swPLUSaddu, NULL }  ,  { &&swPLUSaddu, NULL }  ,  { &&swPLUSadduPLUSslt, NULL }  ,  { &&swPLUSaddu, NULL }  ,  { &&swPLUSaddu, NULL }  ,  { &&swPLUSaddu, NULL }  ,  { &&swPLUSaddu, NULL }  ,  { &&swPLUSaddu, NULL }  ,  { &&swPLUSaddu, NULL }  ,  { &&swPLUSaddu, NULL } 
 ,  { &&swPLUSaddu, NULL }  ,  { &&swPLUSaddu, NULL }  ,  { &&swPLUSadduPLUSaddiu, NULL }  ,  { &&swPLUSaddu, NULL }  ,  { &&swPLUSaddu, NULL }  ,  { &&swPLUSaddu, NULL }  ,  { &&swPLUSaddu, NULL }  ,  { &&swPLUSaddu, NULL }  ,  { &&swPLUSaddu, NULL }  ,  { &&swPLUSaddu, NULL } 
 ,  { &&swPLUSaddu, NULL }  ,  { &&swPLUSaddu, NULL }  ,  { &&swPLUSaddu, NULL }  ,  { &&swPLUSaddu, NULL }  ,  { &&swPLUSaddu, NULL }  ,  { &&swPLUSaddu, NULL }  ,  { &&swPLUSaddu, NULL }  ,  { &&swPLUSaddu, NULL }  ,  { &&swPLUSaddu, NULL }  ,  { &&swPLUSaddu, NULL } 
 ,  { &&swPLUSaddu, NULL }  ,  { &&swPLUSaddu, NULL }  ,  { &&swPLUSaddu, NULL }  ,  { &&swPLUSaddu, NULL }  ,  { &&swPLUSaddu, NULL }  ,  { &&swPLUSaddu, NULL }  ,  { &&swPLUSaddu, NULL }  ,  { &&swPLUSaddu, NULL }  ,  { &&swPLUSadduPLUSlw, NULL }  ,  { &&swPLUSaddu, NULL } 
 ,  { &&swPLUSaddu, NULL }  ,  { &&swPLUSaddu, NULL }  ,  { &&swPLUSaddu, NULL }  ,  { &&swPLUSaddu, NULL }  ,  { &&swPLUSaddu, NULL }  ,  { &&swPLUSaddu, NULL }  ,  { &&swPLUSadduPLUSsw, NULL }  ,  { &&swPLUSaddu, NULL }  ,  { &&swPLUSaddu, NULL }  ,  { &&swPLUSaddu, NULL } 
 ,  { &&swPLUSaddu, NULL }  ,  { &&swPLUSaddu, NULL }  ,  { &&swPLUSaddu, NULL }  ,  { &&swPLUSaddu, NULL }  ,  { &&swPLUSaddu, NULL }  ,  { &&swPLUSaddu, NULL }  ,  { &&swPLUSaddu, NULL }  ,  { &&swPLUSaddu, NULL }  ,  { &&swPLUSaddu, NULL }  ,  { &&swPLUSaddu, NULL } 
 ,  { &&swPLUSaddu, NULL }  ,  { &&swPLUSaddu, NULL }  ,  { &&swPLUSaddu, NULL }  ,  { &&swPLUSaddu, NULL }  ,  { &&swPLUSaddu, NULL }  ,  { &&swPLUSaddu, NULL }  ,  { &&swPLUSaddu, NULL }  ,  { &&swPLUSaddu, NULL }  ,  { &&swPLUSaddu, NULL }  ,  { &&swPLUSaddu, NULL } 
 }; 

struct pointer arraybnePLUSaddu[T_SIZE] = {  { &&bnePLUSadduPLUSsll, NULL }  ,  { &&bnePLUSadduPLUSerror, NULL }  ,  { &&bnePLUSaddu, NULL }  ,  { &&bnePLUSaddu, NULL }  ,  { &&bnePLUSaddu, NULL }  ,  { &&bnePLUSadduPLUSerror, NULL }  ,  { &&bnePLUSaddu, NULL }  ,  { &&bnePLUSaddu, NULL }  ,  { &&bnePLUSaddu, NULL }  ,  { &&bnePLUSaddu, NULL } 
 ,  { &&bnePLUSaddu, NULL }  ,  { &&bnePLUSaddu, NULL }  ,  { &&bnePLUSaddu, NULL }  ,  { &&bnePLUSadduPLUSerror, NULL }  ,  { &&bnePLUSadduPLUSerror, NULL }  ,  { &&bnePLUSadduPLUSerror, NULL }  ,  { &&bnePLUSaddu, NULL }  ,  { &&bnePLUSaddu, NULL }  ,  { &&bnePLUSaddu, NULL }  ,  { &&bnePLUSaddu, NULL } 
 ,  { &&bnePLUSadduPLUSerror, NULL }  ,  { &&bnePLUSadduPLUSerror, NULL }  ,  { &&bnePLUSadduPLUSerror, NULL }  ,  { &&bnePLUSadduPLUSerror, NULL }  ,  { &&bnePLUSadduPLUSmult, NULL }  ,  { &&bnePLUSaddu, NULL }  ,  { &&bnePLUSaddu, NULL }  ,  { &&bnePLUSaddu, NULL }  ,  { &&bnePLUSadduPLUSerror, NULL }  ,  { &&bnePLUSadduPLUSerror, NULL } 
 ,  { &&bnePLUSadduPLUSerror, NULL }  ,  { &&bnePLUSadduPLUSerror, NULL }  ,  { &&bnePLUSaddu, NULL }  ,  { &&bnePLUSaddu, NULL }  ,  { &&bnePLUSaddu, NULL }  ,  { &&bnePLUSaddu, NULL }  ,  { &&bnePLUSaddu, NULL }  ,  { &&bnePLUSaddu, NULL }  ,  { &&bnePLUSaddu, NULL }  ,  { &&bnePLUSadduPLUSnor, NULL } 
 ,  { &&bnePLUSadduPLUSerror, NULL }  ,  { &&bnePLUSadduPLUSerror, NULL }  ,  { &&bnePLUSadduPLUSslt, NULL }  ,  { &&bnePLUSaddu, NULL }  ,  { &&bnePLUSaddu, NULL }  ,  { &&bnePLUSaddu, NULL }  ,  { &&bnePLUSaddu, NULL }  ,  { &&bnePLUSaddu, NULL }  ,  { &&bnePLUSaddu, NULL }  ,  { &&bnePLUSaddu, NULL } 
 ,  { &&bnePLUSaddu, NULL }  ,  { &&bnePLUSaddu, NULL }  ,  { &&bnePLUSadduPLUSaddiu, NULL }  ,  { &&bnePLUSaddu, NULL }  ,  { &&bnePLUSaddu, NULL }  ,  { &&bnePLUSadduPLUSandi, NULL }  ,  { &&bnePLUSaddu, NULL }  ,  { &&bnePLUSaddu, NULL }  ,  { &&bnePLUSaddu, NULL }  ,  { &&bnePLUSadduPLUSerror, NULL } 
 ,  { &&bnePLUSadduPLUSerror, NULL }  ,  { &&bnePLUSadduPLUSerror, NULL }  ,  { &&bnePLUSadduPLUSerror, NULL }  ,  { &&bnePLUSadduPLUSerror, NULL }  ,  { &&bnePLUSadduPLUSerror, NULL }  ,  { &&bnePLUSadduPLUSerror, NULL }  ,  { &&bnePLUSadduPLUSerror, NULL }  ,  { &&bnePLUSaddu, NULL }  ,  { &&bnePLUSaddu, NULL }  ,  { &&bnePLUSaddu, NULL } 
 ,  { &&bnePLUSadduPLUSerror, NULL }  ,  { &&bnePLUSadduPLUSerror, NULL }  ,  { &&bnePLUSadduPLUSerror, NULL }  ,  { &&bnePLUSadduPLUSerror, NULL }  ,  { &&bnePLUSadduPLUSerror, NULL }  ,  { &&bnePLUSaddu, NULL }  ,  { &&bnePLUSaddu, NULL }  ,  { &&bnePLUSaddu, NULL }  ,  { &&bnePLUSaddu, NULL }  ,  { &&bnePLUSadduPLUSlbu, NULL } 
 ,  { &&bnePLUSaddu, NULL }  ,  { &&bnePLUSaddu, NULL }  ,  { &&bnePLUSadduPLUSerror, NULL }  ,  { &&bnePLUSaddu, NULL }  ,  { &&bnePLUSaddu, NULL }  ,  { &&bnePLUSaddu, NULL }  ,  { &&bnePLUSaddu, NULL }  ,  { &&bnePLUSadduPLUSerror, NULL }  ,  { &&bnePLUSadduPLUSerror, NULL }  ,  { &&bnePLUSaddu, NULL } 
 ,  { &&bnePLUSadduPLUSerror, NULL }  ,  { &&bnePLUSadduPLUSerror, NULL }  ,  { &&bnePLUSadduPLUSerror, NULL }  ,  { &&bnePLUSadduPLUSerror, NULL }  ,  { &&bnePLUSadduPLUSerror, NULL }  ,  { &&bnePLUSadduPLUSerror, NULL }  ,  { &&bnePLUSadduPLUSerror, NULL }  ,  { &&bnePLUSadduPLUSerror, NULL }  ,  { &&bnePLUSadduPLUSerror, NULL }  ,  { &&bnePLUSadduPLUSerror, NULL } 
 ,  { &&bnePLUSadduPLUSerror, NULL }  ,  { &&bnePLUSadduPLUSerror, NULL }  ,  { &&bnePLUSadduPLUSerror, NULL }  ,  { &&bnePLUSadduPLUSerror, NULL }  ,  { &&bnePLUSadduPLUSerror, NULL }  ,  { &&bnePLUSadduPLUSerror, NULL }  ,  { &&bnePLUSadduPLUSerror, NULL }  ,  { &&bnePLUSadduPLUSerror, NULL }  ,  { &&bnePLUSadduPLUSerror, NULL }  ,  { &&bnePLUSadduPLUSerror, NULL } 
 }; 

struct pointer arraylwPLUSbeq[T_SIZE] = {  { &&lwPLUSbeqPLUSsll, NULL }  ,  { &&lwPLUSbeq, NULL }  ,  { &&lwPLUSbeq, NULL }  ,  { &&lwPLUSbeq, NULL }  ,  { &&lwPLUSbeq, NULL }  ,  { &&lwPLUSbeq, NULL }  ,  { &&lwPLUSbeq, NULL }  ,  { &&lwPLUSbeq, NULL }  ,  { &&lwPLUSbeq, NULL }  ,  { &&lwPLUSbeq, NULL } 
 ,  { &&lwPLUSbeq, NULL }  ,  { &&lwPLUSbeq, NULL }  ,  { &&lwPLUSbeq, NULL }  ,  { &&lwPLUSbeq, NULL }  ,  { &&lwPLUSbeq, NULL }  ,  { &&lwPLUSbeq, NULL }  ,  { &&lwPLUSbeq, NULL }  ,  { &&lwPLUSbeq, NULL }  ,  { &&lwPLUSbeq, NULL }  ,  { &&lwPLUSbeq, NULL } 
 ,  { &&lwPLUSbeq, NULL }  ,  { &&lwPLUSbeq, NULL }  ,  { &&lwPLUSbeq, NULL }  ,  { &&lwPLUSbeq, NULL }  ,  { &&lwPLUSbeq, NULL }  ,  { &&lwPLUSbeq, NULL }  ,  { &&lwPLUSbeq, NULL }  ,  { &&lwPLUSbeq, NULL }  ,  { &&lwPLUSbeq, NULL }  ,  { &&lwPLUSbeq, NULL } 
 ,  { &&lwPLUSbeq, NULL }  ,  { &&lwPLUSbeq, NULL }  ,  { &&lwPLUSbeq, NULL }  ,  { &&lwPLUSbeq, NULL }  ,  { &&lwPLUSbeq, NULL }  ,  { &&lwPLUSbeq, NULL }  ,  { &&lwPLUSbeq, NULL }  ,  { &&lwPLUSbeq, NULL }  ,  { &&lwPLUSbeq, NULL }  ,  { &&lwPLUSbeq, NULL } 
 ,  { &&lwPLUSbeq, NULL }  ,  { &&lwPLUSbeq, NULL }  ,  { &&lwPLUSbeq, NULL }  ,  { &&lwPLUSbeq, NULL }  ,  { &&lwPLUSbeq, NULL }  ,  { &&lwPLUSbeq, NULL }  ,  { &&lwPLUSbeq, NULL }  ,  { &&lwPLUSbeq, NULL }  ,  { &&lwPLUSbeq, NULL }  ,  { &&lwPLUSbeq, NULL } 
 ,  { &&lwPLUSbeq, NULL }  ,  { &&lwPLUSbeq, NULL }  ,  { &&lwPLUSbeqPLUSaddiu, NULL }  ,  { &&lwPLUSbeq, NULL }  ,  { &&lwPLUSbeq, NULL }  ,  { &&lwPLUSbeq, NULL }  ,  { &&lwPLUSbeq, NULL }  ,  { &&lwPLUSbeq, NULL }  ,  { &&lwPLUSbeq, NULL }  ,  { &&lwPLUSbeq, NULL } 
 ,  { &&lwPLUSbeq, NULL }  ,  { &&lwPLUSbeq, NULL }  ,  { &&lwPLUSbeq, NULL }  ,  { &&lwPLUSbeq, NULL }  ,  { &&lwPLUSbeq, NULL }  ,  { &&lwPLUSbeq, NULL }  ,  { &&lwPLUSbeq, NULL }  ,  { &&lwPLUSbeq, NULL }  ,  { &&lwPLUSbeq, NULL }  ,  { &&lwPLUSbeq, NULL } 
 ,  { &&lwPLUSbeq, NULL }  ,  { &&lwPLUSbeq, NULL }  ,  { &&lwPLUSbeq, NULL }  ,  { &&lwPLUSbeq, NULL }  ,  { &&lwPLUSbeq, NULL }  ,  { &&lwPLUSbeq, NULL }  ,  { &&lwPLUSbeq, NULL }  ,  { &&lwPLUSbeq, NULL }  ,  { &&lwPLUSbeq, NULL }  ,  { &&lwPLUSbeq, NULL } 
 ,  { &&lwPLUSbeq, NULL }  ,  { &&lwPLUSbeq, NULL }  ,  { &&lwPLUSbeq, NULL }  ,  { &&lwPLUSbeq, NULL }  ,  { &&lwPLUSbeq, NULL }  ,  { &&lwPLUSbeq, NULL }  ,  { &&lwPLUSbeq, NULL }  ,  { &&lwPLUSbeq, NULL }  ,  { &&lwPLUSbeq, NULL }  ,  { &&lwPLUSbeq, NULL } 
 ,  { &&lwPLUSbeq, NULL }  ,  { &&lwPLUSbeq, NULL }  ,  { &&lwPLUSbeq, NULL }  ,  { &&lwPLUSbeq, NULL }  ,  { &&lwPLUSbeq, NULL }  ,  { &&lwPLUSbeq, NULL }  ,  { &&lwPLUSbeq, NULL }  ,  { &&lwPLUSbeq, NULL }  ,  { &&lwPLUSbeq, NULL }  ,  { &&lwPLUSbeq, NULL } 
 ,  { &&lwPLUSbeq, NULL }  ,  { &&lwPLUSbeq, NULL }  ,  { &&lwPLUSbeq, NULL }  ,  { &&lwPLUSbeq, NULL }  ,  { &&lwPLUSbeq, NULL }  ,  { &&lwPLUSbeq, NULL }  ,  { &&lwPLUSbeq, NULL }  ,  { &&lwPLUSbeq, NULL }  ,  { &&lwPLUSbeq, NULL }  ,  { &&lwPLUSbeq, NULL } 
 }; 

struct pointer arraysllPLUSlbu[T_SIZE] = {  { &&sllPLUSlbu, NULL }  ,  { &&sllPLUSlbu, NULL }  ,  { &&sllPLUSlbu, NULL }  ,  { &&sllPLUSlbu, NULL }  ,  { &&sllPLUSlbu, NULL }  ,  { &&sllPLUSlbu, NULL }  ,  { &&sllPLUSlbu, NULL }  ,  { &&sllPLUSlbu, NULL }  ,  { &&sllPLUSlbu, NULL }  ,  { &&sllPLUSlbu, NULL } 
 ,  { &&sllPLUSlbu, NULL }  ,  { &&sllPLUSlbu, NULL }  ,  { &&sllPLUSlbu, NULL }  ,  { &&sllPLUSlbu, NULL }  ,  { &&sllPLUSlbu, NULL }  ,  { &&sllPLUSlbu, NULL }  ,  { &&sllPLUSlbu, NULL }  ,  { &&sllPLUSlbu, NULL }  ,  { &&sllPLUSlbu, NULL }  ,  { &&sllPLUSlbu, NULL } 
 ,  { &&sllPLUSlbu, NULL }  ,  { &&sllPLUSlbu, NULL }  ,  { &&sllPLUSlbu, NULL }  ,  { &&sllPLUSlbu, NULL }  ,  { &&sllPLUSlbu, NULL }  ,  { &&sllPLUSlbu, NULL }  ,  { &&sllPLUSlbu, NULL }  ,  { &&sllPLUSlbu, NULL }  ,  { &&sllPLUSlbu, NULL }  ,  { &&sllPLUSlbu, NULL } 
 ,  { &&sllPLUSlbu, NULL }  ,  { &&sllPLUSlbu, NULL }  ,  { &&sllPLUSlbu, NULL }  ,  { &&sllPLUSlbu, NULL }  ,  { &&sllPLUSlbu, NULL }  ,  { &&sllPLUSlbu, NULL }  ,  { &&sllPLUSlbu, NULL }  ,  { &&sllPLUSlbu, NULL }  ,  { &&sllPLUSlbuPLUSxor, NULL }  ,  { &&sllPLUSlbu, NULL } 
 ,  { &&sllPLUSlbu, NULL }  ,  { &&sllPLUSlbu, NULL }  ,  { &&sllPLUSlbu, NULL }  ,  { &&sllPLUSlbu, NULL }  ,  { &&sllPLUSlbu, NULL }  ,  { &&sllPLUSlbu, NULL }  ,  { &&sllPLUSlbu, NULL }  ,  { &&sllPLUSlbuPLUSbeq, NULL }  ,  { &&sllPLUSlbu, NULL }  ,  { &&sllPLUSlbu, NULL } 
 ,  { &&sllPLUSlbu, NULL }  ,  { &&sllPLUSlbu, NULL }  ,  { &&sllPLUSlbu, NULL }  ,  { &&sllPLUSlbu, NULL }  ,  { &&sllPLUSlbu, NULL }  ,  { &&sllPLUSlbu, NULL }  ,  { &&sllPLUSlbu, NULL }  ,  { &&sllPLUSlbu, NULL }  ,  { &&sllPLUSlbu, NULL }  ,  { &&sllPLUSlbu, NULL } 
 ,  { &&sllPLUSlbu, NULL }  ,  { &&sllPLUSlbu, NULL }  ,  { &&sllPLUSlbu, NULL }  ,  { &&sllPLUSlbu, NULL }  ,  { &&sllPLUSlbu, NULL }  ,  { &&sllPLUSlbu, NULL }  ,  { &&sllPLUSlbu, NULL }  ,  { &&sllPLUSlbu, NULL }  ,  { &&sllPLUSlbu, NULL }  ,  { &&sllPLUSlbu, NULL } 
 ,  { &&sllPLUSlbu, NULL }  ,  { &&sllPLUSlbu, NULL }  ,  { &&sllPLUSlbu, NULL }  ,  { &&sllPLUSlbu, NULL }  ,  { &&sllPLUSlbu, NULL }  ,  { &&sllPLUSlbu, NULL }  ,  { &&sllPLUSlbu, NULL }  ,  { &&sllPLUSlbu, NULL }  ,  { &&sllPLUSlbu, NULL }  ,  { &&sllPLUSlbu, NULL } 
 ,  { &&sllPLUSlbu, NULL }  ,  { &&sllPLUSlbu, NULL }  ,  { &&sllPLUSlbu, NULL }  ,  { &&sllPLUSlbu, NULL }  ,  { &&sllPLUSlbu, NULL }  ,  { &&sllPLUSlbu, NULL }  ,  { &&sllPLUSlbu, NULL }  ,  { &&sllPLUSlbu, NULL }  ,  { &&sllPLUSlbu, NULL }  ,  { &&sllPLUSlbu, NULL } 
 ,  { &&sllPLUSlbu, NULL }  ,  { &&sllPLUSlbu, NULL }  ,  { &&sllPLUSlbu, NULL }  ,  { &&sllPLUSlbu, NULL }  ,  { &&sllPLUSlbu, NULL }  ,  { &&sllPLUSlbu, NULL }  ,  { &&sllPLUSlbu, NULL }  ,  { &&sllPLUSlbu, NULL }  ,  { &&sllPLUSlbu, NULL }  ,  { &&sllPLUSlbu, NULL } 
 ,  { &&sllPLUSlbu, NULL }  ,  { &&sllPLUSlbu, NULL }  ,  { &&sllPLUSlbu, NULL }  ,  { &&sllPLUSlbu, NULL }  ,  { &&sllPLUSlbu, NULL }  ,  { &&sllPLUSlbu, NULL }  ,  { &&sllPLUSlbu, NULL }  ,  { &&sllPLUSlbu, NULL }  ,  { &&sllPLUSlbu, NULL }  ,  { &&sllPLUSlbu, NULL } 
 }; 

struct pointer arrayaddiuPLUSblez[T_SIZE] = {  { &&addiuPLUSblez, NULL }  ,  { &&addiuPLUSblez, NULL }  ,  { &&addiuPLUSblez, NULL }  ,  { &&addiuPLUSblez, NULL }  ,  { &&addiuPLUSblez, NULL }  ,  { &&addiuPLUSblez, NULL }  ,  { &&addiuPLUSblez, NULL }  ,  { &&addiuPLUSblez, NULL }  ,  { &&addiuPLUSblez, NULL }  ,  { &&addiuPLUSblez, NULL } 
 ,  { &&addiuPLUSblez, NULL }  ,  { &&addiuPLUSblez, NULL }  ,  { &&addiuPLUSblez, NULL }  ,  { &&addiuPLUSblez, NULL }  ,  { &&addiuPLUSblez, NULL }  ,  { &&addiuPLUSblez, NULL }  ,  { &&addiuPLUSblez, NULL }  ,  { &&addiuPLUSblez, NULL }  ,  { &&addiuPLUSblez, NULL }  ,  { &&addiuPLUSblez, NULL } 
 ,  { &&addiuPLUSblez, NULL }  ,  { &&addiuPLUSblez, NULL }  ,  { &&addiuPLUSblez, NULL }  ,  { &&addiuPLUSblez, NULL }  ,  { &&addiuPLUSblez, NULL }  ,  { &&addiuPLUSblez, NULL }  ,  { &&addiuPLUSblez, NULL }  ,  { &&addiuPLUSblez, NULL }  ,  { &&addiuPLUSblez, NULL }  ,  { &&addiuPLUSblez, NULL } 
 ,  { &&addiuPLUSblez, NULL }  ,  { &&addiuPLUSblez, NULL }  ,  { &&addiuPLUSblez, NULL }  ,  { &&addiuPLUSblez, NULL }  ,  { &&addiuPLUSblez, NULL }  ,  { &&addiuPLUSblez, NULL }  ,  { &&addiuPLUSblez, NULL }  ,  { &&addiuPLUSblez, NULL }  ,  { &&addiuPLUSblez, NULL }  ,  { &&addiuPLUSblez, NULL } 
 ,  { &&addiuPLUSblez, NULL }  ,  { &&addiuPLUSblez, NULL }  ,  { &&addiuPLUSblez, NULL }  ,  { &&addiuPLUSblez, NULL }  ,  { &&addiuPLUSblez, NULL }  ,  { &&addiuPLUSblez, NULL }  ,  { &&addiuPLUSblez, NULL }  ,  { &&addiuPLUSblez, NULL }  ,  { &&addiuPLUSblez, NULL }  ,  { &&addiuPLUSblez, NULL } 
 ,  { &&addiuPLUSblez, NULL }  ,  { &&addiuPLUSblez, NULL }  ,  { &&addiuPLUSblezPLUSaddiu, NULL }  ,  { &&addiuPLUSblez, NULL }  ,  { &&addiuPLUSblez, NULL }  ,  { &&addiuPLUSblez, NULL }  ,  { &&addiuPLUSblez, NULL }  ,  { &&addiuPLUSblez, NULL }  ,  { &&addiuPLUSblez, NULL }  ,  { &&addiuPLUSblez, NULL } 
 ,  { &&addiuPLUSblez, NULL }  ,  { &&addiuPLUSblez, NULL }  ,  { &&addiuPLUSblez, NULL }  ,  { &&addiuPLUSblez, NULL }  ,  { &&addiuPLUSblez, NULL }  ,  { &&addiuPLUSblez, NULL }  ,  { &&addiuPLUSblez, NULL }  ,  { &&addiuPLUSblez, NULL }  ,  { &&addiuPLUSblez, NULL }  ,  { &&addiuPLUSblez, NULL } 
 ,  { &&addiuPLUSblez, NULL }  ,  { &&addiuPLUSblez, NULL }  ,  { &&addiuPLUSblez, NULL }  ,  { &&addiuPLUSblez, NULL }  ,  { &&addiuPLUSblez, NULL }  ,  { &&addiuPLUSblez, NULL }  ,  { &&addiuPLUSblez, NULL }  ,  { &&addiuPLUSblez, NULL }  ,  { &&addiuPLUSblez, NULL }  ,  { &&addiuPLUSblez, NULL } 
 ,  { &&addiuPLUSblez, NULL }  ,  { &&addiuPLUSblez, NULL }  ,  { &&addiuPLUSblez, NULL }  ,  { &&addiuPLUSblez, NULL }  ,  { &&addiuPLUSblez, NULL }  ,  { &&addiuPLUSblez, NULL }  ,  { &&addiuPLUSblez, NULL }  ,  { &&addiuPLUSblez, NULL }  ,  { &&addiuPLUSblez, NULL }  ,  { &&addiuPLUSblez, NULL } 
 ,  { &&addiuPLUSblez, NULL }  ,  { &&addiuPLUSblez, NULL }  ,  { &&addiuPLUSblez, NULL }  ,  { &&addiuPLUSblez, NULL }  ,  { &&addiuPLUSblez, NULL }  ,  { &&addiuPLUSblez, NULL }  ,  { &&addiuPLUSblez, NULL }  ,  { &&addiuPLUSblez, NULL }  ,  { &&addiuPLUSblez, NULL }  ,  { &&addiuPLUSblez, NULL } 
 ,  { &&addiuPLUSblez, NULL }  ,  { &&addiuPLUSblez, NULL }  ,  { &&addiuPLUSblez, NULL }  ,  { &&addiuPLUSblez, NULL }  ,  { &&addiuPLUSblez, NULL }  ,  { &&addiuPLUSblez, NULL }  ,  { &&addiuPLUSblez, NULL }  ,  { &&addiuPLUSblez, NULL }  ,  { &&addiuPLUSblez, NULL }  ,  { &&addiuPLUSblez, NULL } 
 }; 

struct pointer arraysbPLUSjal[T_SIZE] = {  { &&sbPLUSjal, NULL }  ,  { &&sbPLUSjal, NULL }  ,  { &&sbPLUSjal, NULL }  ,  { &&sbPLUSjal, NULL }  ,  { &&sbPLUSjal, NULL }  ,  { &&sbPLUSjal, NULL }  ,  { &&sbPLUSjal, NULL }  ,  { &&sbPLUSjal, NULL }  ,  { &&sbPLUSjal, NULL }  ,  { &&sbPLUSjal, NULL } 
 ,  { &&sbPLUSjal, NULL }  ,  { &&sbPLUSjal, NULL }  ,  { &&sbPLUSjal, NULL }  ,  { &&sbPLUSjal, NULL }  ,  { &&sbPLUSjal, NULL }  ,  { &&sbPLUSjal, NULL }  ,  { &&sbPLUSjal, NULL }  ,  { &&sbPLUSjal, NULL }  ,  { &&sbPLUSjal, NULL }  ,  { &&sbPLUSjal, NULL } 
 ,  { &&sbPLUSjal, NULL }  ,  { &&sbPLUSjal, NULL }  ,  { &&sbPLUSjal, NULL }  ,  { &&sbPLUSjal, NULL }  ,  { &&sbPLUSjal, NULL }  ,  { &&sbPLUSjal, NULL }  ,  { &&sbPLUSjal, NULL }  ,  { &&sbPLUSjal, NULL }  ,  { &&sbPLUSjal, NULL }  ,  { &&sbPLUSjal, NULL } 
 ,  { &&sbPLUSjal, NULL }  ,  { &&sbPLUSjal, NULL }  ,  { &&sbPLUSjal, NULL }  ,  { &&sbPLUSjalPLUSaddu, NULL }  ,  { &&sbPLUSjal, NULL }  ,  { &&sbPLUSjal, NULL }  ,  { &&sbPLUSjal, NULL }  ,  { &&sbPLUSjal, NULL }  ,  { &&sbPLUSjal, NULL }  ,  { &&sbPLUSjal, NULL } 
 ,  { &&sbPLUSjal, NULL }  ,  { &&sbPLUSjal, NULL }  ,  { &&sbPLUSjal, NULL }  ,  { &&sbPLUSjal, NULL }  ,  { &&sbPLUSjal, NULL }  ,  { &&sbPLUSjal, NULL }  ,  { &&sbPLUSjal, NULL }  ,  { &&sbPLUSjal, NULL }  ,  { &&sbPLUSjal, NULL }  ,  { &&sbPLUSjal, NULL } 
 ,  { &&sbPLUSjal, NULL }  ,  { &&sbPLUSjal, NULL }  ,  { &&sbPLUSjal, NULL }  ,  { &&sbPLUSjal, NULL }  ,  { &&sbPLUSjal, NULL }  ,  { &&sbPLUSjal, NULL }  ,  { &&sbPLUSjal, NULL }  ,  { &&sbPLUSjal, NULL }  ,  { &&sbPLUSjal, NULL }  ,  { &&sbPLUSjal, NULL } 
 ,  { &&sbPLUSjal, NULL }  ,  { &&sbPLUSjal, NULL }  ,  { &&sbPLUSjal, NULL }  ,  { &&sbPLUSjal, NULL }  ,  { &&sbPLUSjal, NULL }  ,  { &&sbPLUSjal, NULL }  ,  { &&sbPLUSjal, NULL }  ,  { &&sbPLUSjal, NULL }  ,  { &&sbPLUSjal, NULL }  ,  { &&sbPLUSjal, NULL } 
 ,  { &&sbPLUSjal, NULL }  ,  { &&sbPLUSjal, NULL }  ,  { &&sbPLUSjal, NULL }  ,  { &&sbPLUSjal, NULL }  ,  { &&sbPLUSjal, NULL }  ,  { &&sbPLUSjal, NULL }  ,  { &&sbPLUSjal, NULL }  ,  { &&sbPLUSjal, NULL }  ,  { &&sbPLUSjal, NULL }  ,  { &&sbPLUSjal, NULL } 
 ,  { &&sbPLUSjal, NULL }  ,  { &&sbPLUSjal, NULL }  ,  { &&sbPLUSjal, NULL }  ,  { &&sbPLUSjal, NULL }  ,  { &&sbPLUSjal, NULL }  ,  { &&sbPLUSjal, NULL }  ,  { &&sbPLUSjal, NULL }  ,  { &&sbPLUSjal, NULL }  ,  { &&sbPLUSjal, NULL }  ,  { &&sbPLUSjal, NULL } 
 ,  { &&sbPLUSjal, NULL }  ,  { &&sbPLUSjal, NULL }  ,  { &&sbPLUSjal, NULL }  ,  { &&sbPLUSjal, NULL }  ,  { &&sbPLUSjal, NULL }  ,  { &&sbPLUSjal, NULL }  ,  { &&sbPLUSjal, NULL }  ,  { &&sbPLUSjal, NULL }  ,  { &&sbPLUSjal, NULL }  ,  { &&sbPLUSjal, NULL } 
 ,  { &&sbPLUSjal, NULL }  ,  { &&sbPLUSjal, NULL }  ,  { &&sbPLUSjal, NULL }  ,  { &&sbPLUSjal, NULL }  ,  { &&sbPLUSjal, NULL }  ,  { &&sbPLUSjal, NULL }  ,  { &&sbPLUSjal, NULL }  ,  { &&sbPLUSjal, NULL }  ,  { &&sbPLUSjal, NULL }  ,  { &&sbPLUSjal, NULL } 
 }; 

struct pointer arraysltiPLUSbne[T_SIZE] = {  { &&sltiPLUSbnePLUSsll, NULL }  ,  { &&sltiPLUSbne, NULL }  ,  { &&sltiPLUSbne, NULL }  ,  { &&sltiPLUSbne, NULL }  ,  { &&sltiPLUSbne, NULL }  ,  { &&sltiPLUSbne, NULL }  ,  { &&sltiPLUSbne, NULL }  ,  { &&sltiPLUSbne, NULL }  ,  { &&sltiPLUSbne, NULL }  ,  { &&sltiPLUSbne, NULL } 
 ,  { &&sltiPLUSbne, NULL }  ,  { &&sltiPLUSbne, NULL }  ,  { &&sltiPLUSbne, NULL }  ,  { &&sltiPLUSbne, NULL }  ,  { &&sltiPLUSbne, NULL }  ,  { &&sltiPLUSbne, NULL }  ,  { &&sltiPLUSbne, NULL }  ,  { &&sltiPLUSbne, NULL }  ,  { &&sltiPLUSbne, NULL }  ,  { &&sltiPLUSbne, NULL } 
 ,  { &&sltiPLUSbne, NULL }  ,  { &&sltiPLUSbne, NULL }  ,  { &&sltiPLUSbne, NULL }  ,  { &&sltiPLUSbne, NULL }  ,  { &&sltiPLUSbne, NULL }  ,  { &&sltiPLUSbne, NULL }  ,  { &&sltiPLUSbne, NULL }  ,  { &&sltiPLUSbne, NULL }  ,  { &&sltiPLUSbne, NULL }  ,  { &&sltiPLUSbne, NULL } 
 ,  { &&sltiPLUSbne, NULL }  ,  { &&sltiPLUSbne, NULL }  ,  { &&sltiPLUSbne, NULL }  ,  { &&sltiPLUSbne, NULL }  ,  { &&sltiPLUSbne, NULL }  ,  { &&sltiPLUSbne, NULL }  ,  { &&sltiPLUSbne, NULL }  ,  { &&sltiPLUSbne, NULL }  ,  { &&sltiPLUSbne, NULL }  ,  { &&sltiPLUSbne, NULL } 
 ,  { &&sltiPLUSbne, NULL }  ,  { &&sltiPLUSbne, NULL }  ,  { &&sltiPLUSbne, NULL }  ,  { &&sltiPLUSbne, NULL }  ,  { &&sltiPLUSbne, NULL }  ,  { &&sltiPLUSbne, NULL }  ,  { &&sltiPLUSbne, NULL }  ,  { &&sltiPLUSbne, NULL }  ,  { &&sltiPLUSbne, NULL }  ,  { &&sltiPLUSbne, NULL } 
 ,  { &&sltiPLUSbne, NULL }  ,  { &&sltiPLUSbne, NULL }  ,  { &&sltiPLUSbnePLUSaddiu, NULL }  ,  { &&sltiPLUSbne, NULL }  ,  { &&sltiPLUSbne, NULL }  ,  { &&sltiPLUSbne, NULL }  ,  { &&sltiPLUSbne, NULL }  ,  { &&sltiPLUSbne, NULL }  ,  { &&sltiPLUSbne, NULL }  ,  { &&sltiPLUSbne, NULL } 
 ,  { &&sltiPLUSbne, NULL }  ,  { &&sltiPLUSbne, NULL }  ,  { &&sltiPLUSbne, NULL }  ,  { &&sltiPLUSbne, NULL }  ,  { &&sltiPLUSbne, NULL }  ,  { &&sltiPLUSbne, NULL }  ,  { &&sltiPLUSbne, NULL }  ,  { &&sltiPLUSbne, NULL }  ,  { &&sltiPLUSbne, NULL }  ,  { &&sltiPLUSbne, NULL } 
 ,  { &&sltiPLUSbne, NULL }  ,  { &&sltiPLUSbne, NULL }  ,  { &&sltiPLUSbne, NULL }  ,  { &&sltiPLUSbne, NULL }  ,  { &&sltiPLUSbne, NULL }  ,  { &&sltiPLUSbne, NULL }  ,  { &&sltiPLUSbne, NULL }  ,  { &&sltiPLUSbne, NULL }  ,  { &&sltiPLUSbne, NULL }  ,  { &&sltiPLUSbne, NULL } 
 ,  { &&sltiPLUSbne, NULL }  ,  { &&sltiPLUSbne, NULL }  ,  { &&sltiPLUSbne, NULL }  ,  { &&sltiPLUSbne, NULL }  ,  { &&sltiPLUSbne, NULL }  ,  { &&sltiPLUSbne, NULL }  ,  { &&sltiPLUSbne, NULL }  ,  { &&sltiPLUSbne, NULL }  ,  { &&sltiPLUSbne, NULL }  ,  { &&sltiPLUSbne, NULL } 
 ,  { &&sltiPLUSbne, NULL }  ,  { &&sltiPLUSbne, NULL }  ,  { &&sltiPLUSbne, NULL }  ,  { &&sltiPLUSbne, NULL }  ,  { &&sltiPLUSbne, NULL }  ,  { &&sltiPLUSbne, NULL }  ,  { &&sltiPLUSbne, NULL }  ,  { &&sltiPLUSbne, NULL }  ,  { &&sltiPLUSbne, NULL }  ,  { &&sltiPLUSbne, NULL } 
 ,  { &&sltiPLUSbne, NULL }  ,  { &&sltiPLUSbne, NULL }  ,  { &&sltiPLUSbne, NULL }  ,  { &&sltiPLUSbne, NULL }  ,  { &&sltiPLUSbne, NULL }  ,  { &&sltiPLUSbne, NULL }  ,  { &&sltiPLUSbne, NULL }  ,  { &&sltiPLUSbne, NULL }  ,  { &&sltiPLUSbne, NULL }  ,  { &&sltiPLUSbne, NULL } 
 }; 

struct pointer arrayluiPLUSori[T_SIZE] = {  { &&luiPLUSoriPLUSsll, NULL }  ,  { &&luiPLUSori, NULL }  ,  { &&luiPLUSori, NULL }  ,  { &&luiPLUSori, NULL }  ,  { &&luiPLUSori, NULL }  ,  { &&luiPLUSori, NULL }  ,  { &&luiPLUSori, NULL }  ,  { &&luiPLUSori, NULL }  ,  { &&luiPLUSori, NULL }  ,  { &&luiPLUSori, NULL } 
 ,  { &&luiPLUSori, NULL }  ,  { &&luiPLUSori, NULL }  ,  { &&luiPLUSori, NULL }  ,  { &&luiPLUSori, NULL }  ,  { &&luiPLUSori, NULL }  ,  { &&luiPLUSori, NULL }  ,  { &&luiPLUSori, NULL }  ,  { &&luiPLUSori, NULL }  ,  { &&luiPLUSori, NULL }  ,  { &&luiPLUSori, NULL } 
 ,  { &&luiPLUSori, NULL }  ,  { &&luiPLUSori, NULL }  ,  { &&luiPLUSori, NULL }  ,  { &&luiPLUSori, NULL }  ,  { &&luiPLUSoriPLUSmult, NULL }  ,  { &&luiPLUSori, NULL }  ,  { &&luiPLUSori, NULL }  ,  { &&luiPLUSori, NULL }  ,  { &&luiPLUSori, NULL }  ,  { &&luiPLUSori, NULL } 
 ,  { &&luiPLUSori, NULL }  ,  { &&luiPLUSori, NULL }  ,  { &&luiPLUSori, NULL }  ,  { &&luiPLUSoriPLUSaddu, NULL }  ,  { &&luiPLUSori, NULL }  ,  { &&luiPLUSori, NULL }  ,  { &&luiPLUSoriPLUSand, NULL }  ,  { &&luiPLUSori, NULL }  ,  { &&luiPLUSori, NULL }  ,  { &&luiPLUSori, NULL } 
 ,  { &&luiPLUSori, NULL }  ,  { &&luiPLUSori, NULL }  ,  { &&luiPLUSori, NULL }  ,  { &&luiPLUSori, NULL }  ,  { &&luiPLUSori, NULL }  ,  { &&luiPLUSori, NULL }  ,  { &&luiPLUSori, NULL }  ,  { &&luiPLUSori, NULL }  ,  { &&luiPLUSori, NULL }  ,  { &&luiPLUSori, NULL } 
 ,  { &&luiPLUSori, NULL }  ,  { &&luiPLUSori, NULL }  ,  { &&luiPLUSoriPLUSaddiu, NULL }  ,  { &&luiPLUSori, NULL }  ,  { &&luiPLUSori, NULL }  ,  { &&luiPLUSoriPLUSandi, NULL }  ,  { &&luiPLUSori, NULL }  ,  { &&luiPLUSori, NULL }  ,  { &&luiPLUSori, NULL }  ,  { &&luiPLUSori, NULL } 
 ,  { &&luiPLUSori, NULL }  ,  { &&luiPLUSori, NULL }  ,  { &&luiPLUSori, NULL }  ,  { &&luiPLUSori, NULL }  ,  { &&luiPLUSori, NULL }  ,  { &&luiPLUSori, NULL }  ,  { &&luiPLUSori, NULL }  ,  { &&luiPLUSori, NULL }  ,  { &&luiPLUSori, NULL }  ,  { &&luiPLUSori, NULL } 
 ,  { &&luiPLUSori, NULL }  ,  { &&luiPLUSori, NULL }  ,  { &&luiPLUSori, NULL }  ,  { &&luiPLUSori, NULL }  ,  { &&luiPLUSori, NULL }  ,  { &&luiPLUSori, NULL }  ,  { &&luiPLUSori, NULL }  ,  { &&luiPLUSori, NULL }  ,  { &&luiPLUSori, NULL }  ,  { &&luiPLUSori, NULL } 
 ,  { &&luiPLUSori, NULL }  ,  { &&luiPLUSori, NULL }  ,  { &&luiPLUSori, NULL }  ,  { &&luiPLUSori, NULL }  ,  { &&luiPLUSori, NULL }  ,  { &&luiPLUSori, NULL }  ,  { &&luiPLUSori, NULL }  ,  { &&luiPLUSori, NULL }  ,  { &&luiPLUSori, NULL }  ,  { &&luiPLUSori, NULL } 
 ,  { &&luiPLUSori, NULL }  ,  { &&luiPLUSori, NULL }  ,  { &&luiPLUSori, NULL }  ,  { &&luiPLUSori, NULL }  ,  { &&luiPLUSori, NULL }  ,  { &&luiPLUSori, NULL }  ,  { &&luiPLUSori, NULL }  ,  { &&luiPLUSori, NULL }  ,  { &&luiPLUSori, NULL }  ,  { &&luiPLUSori, NULL } 
 ,  { &&luiPLUSori, NULL }  ,  { &&luiPLUSori, NULL }  ,  { &&luiPLUSori, NULL }  ,  { &&luiPLUSori, NULL }  ,  { &&luiPLUSori, NULL }  ,  { &&luiPLUSori, NULL }  ,  { &&luiPLUSori, NULL }  ,  { &&luiPLUSori, NULL }  ,  { &&luiPLUSori, NULL }  ,  { &&luiPLUSori, NULL } 
 }; 

struct pointer arraybnePLUSsw[T_SIZE] = {  { &&bnePLUSsw, NULL }  ,  { &&bnePLUSsw, NULL }  ,  { &&bnePLUSsw, NULL }  ,  { &&bnePLUSsw, NULL }  ,  { &&bnePLUSsw, NULL }  ,  { &&bnePLUSsw, NULL }  ,  { &&bnePLUSsw, NULL }  ,  { &&bnePLUSsw, NULL }  ,  { &&bnePLUSsw, NULL }  ,  { &&bnePLUSsw, NULL } 
 ,  { &&bnePLUSsw, NULL }  ,  { &&bnePLUSsw, NULL }  ,  { &&bnePLUSsw, NULL }  ,  { &&bnePLUSsw, NULL }  ,  { &&bnePLUSsw, NULL }  ,  { &&bnePLUSsw, NULL }  ,  { &&bnePLUSsw, NULL }  ,  { &&bnePLUSsw, NULL }  ,  { &&bnePLUSsw, NULL }  ,  { &&bnePLUSsw, NULL } 
 ,  { &&bnePLUSsw, NULL }  ,  { &&bnePLUSsw, NULL }  ,  { &&bnePLUSsw, NULL }  ,  { &&bnePLUSsw, NULL }  ,  { &&bnePLUSsw, NULL }  ,  { &&bnePLUSsw, NULL }  ,  { &&bnePLUSsw, NULL }  ,  { &&bnePLUSsw, NULL }  ,  { &&bnePLUSsw, NULL }  ,  { &&bnePLUSsw, NULL } 
 ,  { &&bnePLUSsw, NULL }  ,  { &&bnePLUSsw, NULL }  ,  { &&bnePLUSsw, NULL }  ,  { &&bnePLUSswPLUSaddu, NULL }  ,  { &&bnePLUSsw, NULL }  ,  { &&bnePLUSsw, NULL }  ,  { &&bnePLUSsw, NULL }  ,  { &&bnePLUSsw, NULL }  ,  { &&bnePLUSsw, NULL }  ,  { &&bnePLUSsw, NULL } 
 ,  { &&bnePLUSsw, NULL }  ,  { &&bnePLUSsw, NULL }  ,  { &&bnePLUSsw, NULL }  ,  { &&bnePLUSsw, NULL }  ,  { &&bnePLUSsw, NULL }  ,  { &&bnePLUSsw, NULL }  ,  { &&bnePLUSsw, NULL }  ,  { &&bnePLUSsw, NULL }  ,  { &&bnePLUSsw, NULL }  ,  { &&bnePLUSsw, NULL } 
 ,  { &&bnePLUSsw, NULL }  ,  { &&bnePLUSsw, NULL }  ,  { &&bnePLUSsw, NULL }  ,  { &&bnePLUSsw, NULL }  ,  { &&bnePLUSsw, NULL }  ,  { &&bnePLUSsw, NULL }  ,  { &&bnePLUSsw, NULL }  ,  { &&bnePLUSsw, NULL }  ,  { &&bnePLUSsw, NULL }  ,  { &&bnePLUSsw, NULL } 
 ,  { &&bnePLUSsw, NULL }  ,  { &&bnePLUSsw, NULL }  ,  { &&bnePLUSsw, NULL }  ,  { &&bnePLUSsw, NULL }  ,  { &&bnePLUSsw, NULL }  ,  { &&bnePLUSsw, NULL }  ,  { &&bnePLUSsw, NULL }  ,  { &&bnePLUSsw, NULL }  ,  { &&bnePLUSsw, NULL }  ,  { &&bnePLUSsw, NULL } 
 ,  { &&bnePLUSsw, NULL }  ,  { &&bnePLUSsw, NULL }  ,  { &&bnePLUSsw, NULL }  ,  { &&bnePLUSsw, NULL }  ,  { &&bnePLUSsw, NULL }  ,  { &&bnePLUSsw, NULL }  ,  { &&bnePLUSsw, NULL }  ,  { &&bnePLUSsw, NULL }  ,  { &&bnePLUSswPLUSlw, NULL }  ,  { &&bnePLUSsw, NULL } 
 ,  { &&bnePLUSsw, NULL }  ,  { &&bnePLUSsw, NULL }  ,  { &&bnePLUSsw, NULL }  ,  { &&bnePLUSsw, NULL }  ,  { &&bnePLUSsw, NULL }  ,  { &&bnePLUSsw, NULL }  ,  { &&bnePLUSsw, NULL }  ,  { &&bnePLUSsw, NULL }  ,  { &&bnePLUSsw, NULL }  ,  { &&bnePLUSsw, NULL } 
 ,  { &&bnePLUSsw, NULL }  ,  { &&bnePLUSsw, NULL }  ,  { &&bnePLUSsw, NULL }  ,  { &&bnePLUSsw, NULL }  ,  { &&bnePLUSsw, NULL }  ,  { &&bnePLUSsw, NULL }  ,  { &&bnePLUSsw, NULL }  ,  { &&bnePLUSsw, NULL }  ,  { &&bnePLUSsw, NULL }  ,  { &&bnePLUSsw, NULL } 
 ,  { &&bnePLUSsw, NULL }  ,  { &&bnePLUSsw, NULL }  ,  { &&bnePLUSsw, NULL }  ,  { &&bnePLUSsw, NULL }  ,  { &&bnePLUSsw, NULL }  ,  { &&bnePLUSsw, NULL }  ,  { &&bnePLUSsw, NULL }  ,  { &&bnePLUSsw, NULL }  ,  { &&bnePLUSsw, NULL }  ,  { &&bnePLUSsw, NULL } 
 }; 

struct pointer arraybeqPLUSsw[T_SIZE] = {  { &&beqPLUSswPLUSsll, NULL }  ,  { &&beqPLUSsw, NULL }  ,  { &&beqPLUSsw, NULL }  ,  { &&beqPLUSsw, NULL }  ,  { &&beqPLUSsw, NULL }  ,  { &&beqPLUSsw, NULL }  ,  { &&beqPLUSsw, NULL }  ,  { &&beqPLUSsw, NULL }  ,  { &&beqPLUSsw, NULL }  ,  { &&beqPLUSsw, NULL } 
 ,  { &&beqPLUSsw, NULL }  ,  { &&beqPLUSsw, NULL }  ,  { &&beqPLUSsw, NULL }  ,  { &&beqPLUSsw, NULL }  ,  { &&beqPLUSsw, NULL }  ,  { &&beqPLUSsw, NULL }  ,  { &&beqPLUSsw, NULL }  ,  { &&beqPLUSsw, NULL }  ,  { &&beqPLUSsw, NULL }  ,  { &&beqPLUSsw, NULL } 
 ,  { &&beqPLUSsw, NULL }  ,  { &&beqPLUSsw, NULL }  ,  { &&beqPLUSsw, NULL }  ,  { &&beqPLUSsw, NULL }  ,  { &&beqPLUSsw, NULL }  ,  { &&beqPLUSsw, NULL }  ,  { &&beqPLUSsw, NULL }  ,  { &&beqPLUSsw, NULL }  ,  { &&beqPLUSsw, NULL }  ,  { &&beqPLUSsw, NULL } 
 ,  { &&beqPLUSsw, NULL }  ,  { &&beqPLUSsw, NULL }  ,  { &&beqPLUSsw, NULL }  ,  { &&beqPLUSswPLUSaddu, NULL }  ,  { &&beqPLUSsw, NULL }  ,  { &&beqPLUSsw, NULL }  ,  { &&beqPLUSsw, NULL }  ,  { &&beqPLUSsw, NULL }  ,  { &&beqPLUSsw, NULL }  ,  { &&beqPLUSsw, NULL } 
 ,  { &&beqPLUSsw, NULL }  ,  { &&beqPLUSsw, NULL }  ,  { &&beqPLUSsw, NULL }  ,  { &&beqPLUSsw, NULL }  ,  { &&beqPLUSsw, NULL }  ,  { &&beqPLUSsw, NULL }  ,  { &&beqPLUSsw, NULL }  ,  { &&beqPLUSsw, NULL }  ,  { &&beqPLUSsw, NULL }  ,  { &&beqPLUSsw, NULL } 
 ,  { &&beqPLUSsw, NULL }  ,  { &&beqPLUSsw, NULL }  ,  { &&beqPLUSswPLUSaddiu, NULL }  ,  { &&beqPLUSsw, NULL }  ,  { &&beqPLUSsw, NULL }  ,  { &&beqPLUSsw, NULL }  ,  { &&beqPLUSsw, NULL }  ,  { &&beqPLUSsw, NULL }  ,  { &&beqPLUSsw, NULL }  ,  { &&beqPLUSsw, NULL } 
 ,  { &&beqPLUSsw, NULL }  ,  { &&beqPLUSsw, NULL }  ,  { &&beqPLUSsw, NULL }  ,  { &&beqPLUSsw, NULL }  ,  { &&beqPLUSsw, NULL }  ,  { &&beqPLUSsw, NULL }  ,  { &&beqPLUSsw, NULL }  ,  { &&beqPLUSsw, NULL }  ,  { &&beqPLUSsw, NULL }  ,  { &&beqPLUSsw, NULL } 
 ,  { &&beqPLUSsw, NULL }  ,  { &&beqPLUSsw, NULL }  ,  { &&beqPLUSsw, NULL }  ,  { &&beqPLUSsw, NULL }  ,  { &&beqPLUSsw, NULL }  ,  { &&beqPLUSsw, NULL }  ,  { &&beqPLUSsw, NULL }  ,  { &&beqPLUSsw, NULL }  ,  { &&beqPLUSsw, NULL }  ,  { &&beqPLUSsw, NULL } 
 ,  { &&beqPLUSsw, NULL }  ,  { &&beqPLUSsw, NULL }  ,  { &&beqPLUSsw, NULL }  ,  { &&beqPLUSsw, NULL }  ,  { &&beqPLUSsw, NULL }  ,  { &&beqPLUSsw, NULL }  ,  { &&beqPLUSswPLUSsw, NULL }  ,  { &&beqPLUSsw, NULL }  ,  { &&beqPLUSsw, NULL }  ,  { &&beqPLUSsw, NULL } 
 ,  { &&beqPLUSsw, NULL }  ,  { &&beqPLUSsw, NULL }  ,  { &&beqPLUSsw, NULL }  ,  { &&beqPLUSsw, NULL }  ,  { &&beqPLUSsw, NULL }  ,  { &&beqPLUSsw, NULL }  ,  { &&beqPLUSsw, NULL }  ,  { &&beqPLUSsw, NULL }  ,  { &&beqPLUSsw, NULL }  ,  { &&beqPLUSsw, NULL } 
 ,  { &&beqPLUSsw, NULL }  ,  { &&beqPLUSsw, NULL }  ,  { &&beqPLUSsw, NULL }  ,  { &&beqPLUSsw, NULL }  ,  { &&beqPLUSsw, NULL }  ,  { &&beqPLUSsw, NULL }  ,  { &&beqPLUSsw, NULL }  ,  { &&beqPLUSsw, NULL }  ,  { &&beqPLUSsw, NULL }  ,  { &&beqPLUSsw, NULL } 
 }; 

struct pointer arrayxorPLUSxor[T_SIZE] = {  { &&xorPLUSxor, NULL }  ,  { &&xorPLUSxor, NULL }  ,  { &&xorPLUSxor, NULL }  ,  { &&xorPLUSxor, NULL }  ,  { &&xorPLUSxor, NULL }  ,  { &&xorPLUSxor, NULL }  ,  { &&xorPLUSxor, NULL }  ,  { &&xorPLUSxor, NULL }  ,  { &&xorPLUSxor, NULL }  ,  { &&xorPLUSxor, NULL } 
 ,  { &&xorPLUSxor, NULL }  ,  { &&xorPLUSxor, NULL }  ,  { &&xorPLUSxor, NULL }  ,  { &&xorPLUSxor, NULL }  ,  { &&xorPLUSxor, NULL }  ,  { &&xorPLUSxor, NULL }  ,  { &&xorPLUSxor, NULL }  ,  { &&xorPLUSxor, NULL }  ,  { &&xorPLUSxor, NULL }  ,  { &&xorPLUSxor, NULL } 
 ,  { &&xorPLUSxor, NULL }  ,  { &&xorPLUSxor, NULL }  ,  { &&xorPLUSxor, NULL }  ,  { &&xorPLUSxor, NULL }  ,  { &&xorPLUSxor, NULL }  ,  { &&xorPLUSxor, NULL }  ,  { &&xorPLUSxor, NULL }  ,  { &&xorPLUSxor, NULL }  ,  { &&xorPLUSxor, NULL }  ,  { &&xorPLUSxor, NULL } 
 ,  { &&xorPLUSxor, NULL }  ,  { &&xorPLUSxor, NULL }  ,  { &&xorPLUSxor, NULL }  ,  { &&xorPLUSxor, NULL }  ,  { &&xorPLUSxor, NULL }  ,  { &&xorPLUSxor, NULL }  ,  { &&xorPLUSxor, NULL }  ,  { &&xorPLUSxor, NULL }  ,  { &&xorPLUSxorPLUSxor, NULL }  ,  { &&xorPLUSxor, NULL } 
 ,  { &&xorPLUSxor, NULL }  ,  { &&xorPLUSxor, NULL }  ,  { &&xorPLUSxor, NULL }  ,  { &&xorPLUSxor, NULL }  ,  { &&xorPLUSxor, NULL }  ,  { &&xorPLUSxor, NULL }  ,  { &&xorPLUSxor, NULL }  ,  { &&xorPLUSxor, NULL }  ,  { &&xorPLUSxor, NULL }  ,  { &&xorPLUSxor, NULL } 
 ,  { &&xorPLUSxor, NULL }  ,  { &&xorPLUSxor, NULL }  ,  { &&xorPLUSxorPLUSaddiu, NULL }  ,  { &&xorPLUSxorPLUSslti, NULL }  ,  { &&xorPLUSxor, NULL }  ,  { &&xorPLUSxorPLUSandi, NULL }  ,  { &&xorPLUSxor, NULL }  ,  { &&xorPLUSxor, NULL }  ,  { &&xorPLUSxor, NULL }  ,  { &&xorPLUSxor, NULL } 
 ,  { &&xorPLUSxor, NULL }  ,  { &&xorPLUSxor, NULL }  ,  { &&xorPLUSxor, NULL }  ,  { &&xorPLUSxor, NULL }  ,  { &&xorPLUSxor, NULL }  ,  { &&xorPLUSxor, NULL }  ,  { &&xorPLUSxor, NULL }  ,  { &&xorPLUSxor, NULL }  ,  { &&xorPLUSxor, NULL }  ,  { &&xorPLUSxor, NULL } 
 ,  { &&xorPLUSxor, NULL }  ,  { &&xorPLUSxor, NULL }  ,  { &&xorPLUSxor, NULL }  ,  { &&xorPLUSxor, NULL }  ,  { &&xorPLUSxor, NULL }  ,  { &&xorPLUSxor, NULL }  ,  { &&xorPLUSxor, NULL }  ,  { &&xorPLUSxor, NULL }  ,  { &&xorPLUSxor, NULL }  ,  { &&xorPLUSxor, NULL } 
 ,  { &&xorPLUSxor, NULL }  ,  { &&xorPLUSxor, NULL }  ,  { &&xorPLUSxor, NULL }  ,  { &&xorPLUSxor, NULL }  ,  { &&xorPLUSxor, NULL }  ,  { &&xorPLUSxor, NULL }  ,  { &&xorPLUSxor, NULL }  ,  { &&xorPLUSxor, NULL }  ,  { &&xorPLUSxor, NULL }  ,  { &&xorPLUSxor, NULL } 
 ,  { &&xorPLUSxor, NULL }  ,  { &&xorPLUSxor, NULL }  ,  { &&xorPLUSxor, NULL }  ,  { &&xorPLUSxor, NULL }  ,  { &&xorPLUSxor, NULL }  ,  { &&xorPLUSxor, NULL }  ,  { &&xorPLUSxor, NULL }  ,  { &&xorPLUSxor, NULL }  ,  { &&xorPLUSxor, NULL }  ,  { &&xorPLUSxor, NULL } 
 ,  { &&xorPLUSxor, NULL }  ,  { &&xorPLUSxor, NULL }  ,  { &&xorPLUSxor, NULL }  ,  { &&xorPLUSxor, NULL }  ,  { &&xorPLUSxor, NULL }  ,  { &&xorPLUSxor, NULL }  ,  { &&xorPLUSxor, NULL }  ,  { &&xorPLUSxor, NULL }  ,  { &&xorPLUSxor, NULL }  ,  { &&xorPLUSxor, NULL } 
 }; 

struct pointer arrayoriPLUSandi[T_SIZE] = {  { &&oriPLUSandi, NULL }  ,  { &&oriPLUSandi, NULL }  ,  { &&oriPLUSandi, NULL }  ,  { &&oriPLUSandi, NULL }  ,  { &&oriPLUSandi, NULL }  ,  { &&oriPLUSandi, NULL }  ,  { &&oriPLUSandi, NULL }  ,  { &&oriPLUSandi, NULL }  ,  { &&oriPLUSandi, NULL }  ,  { &&oriPLUSandi, NULL } 
 ,  { &&oriPLUSandi, NULL }  ,  { &&oriPLUSandi, NULL }  ,  { &&oriPLUSandi, NULL }  ,  { &&oriPLUSandi, NULL }  ,  { &&oriPLUSandi, NULL }  ,  { &&oriPLUSandi, NULL }  ,  { &&oriPLUSandi, NULL }  ,  { &&oriPLUSandi, NULL }  ,  { &&oriPLUSandi, NULL }  ,  { &&oriPLUSandi, NULL } 
 ,  { &&oriPLUSandi, NULL }  ,  { &&oriPLUSandi, NULL }  ,  { &&oriPLUSandi, NULL }  ,  { &&oriPLUSandi, NULL }  ,  { &&oriPLUSandi, NULL }  ,  { &&oriPLUSandi, NULL }  ,  { &&oriPLUSandi, NULL }  ,  { &&oriPLUSandi, NULL }  ,  { &&oriPLUSandi, NULL }  ,  { &&oriPLUSandi, NULL } 
 ,  { &&oriPLUSandi, NULL }  ,  { &&oriPLUSandi, NULL }  ,  { &&oriPLUSandi, NULL }  ,  { &&oriPLUSandi, NULL }  ,  { &&oriPLUSandi, NULL }  ,  { &&oriPLUSandi, NULL }  ,  { &&oriPLUSandi, NULL }  ,  { &&oriPLUSandi, NULL }  ,  { &&oriPLUSandiPLUSxor, NULL }  ,  { &&oriPLUSandi, NULL } 
 ,  { &&oriPLUSandi, NULL }  ,  { &&oriPLUSandi, NULL }  ,  { &&oriPLUSandi, NULL }  ,  { &&oriPLUSandi, NULL }  ,  { &&oriPLUSandi, NULL }  ,  { &&oriPLUSandi, NULL }  ,  { &&oriPLUSandi, NULL }  ,  { &&oriPLUSandi, NULL }  ,  { &&oriPLUSandi, NULL }  ,  { &&oriPLUSandi, NULL } 
 ,  { &&oriPLUSandi, NULL }  ,  { &&oriPLUSandi, NULL }  ,  { &&oriPLUSandi, NULL }  ,  { &&oriPLUSandi, NULL }  ,  { &&oriPLUSandi, NULL }  ,  { &&oriPLUSandi, NULL }  ,  { &&oriPLUSandi, NULL }  ,  { &&oriPLUSandi, NULL }  ,  { &&oriPLUSandi, NULL }  ,  { &&oriPLUSandi, NULL } 
 ,  { &&oriPLUSandi, NULL }  ,  { &&oriPLUSandi, NULL }  ,  { &&oriPLUSandi, NULL }  ,  { &&oriPLUSandi, NULL }  ,  { &&oriPLUSandi, NULL }  ,  { &&oriPLUSandi, NULL }  ,  { &&oriPLUSandi, NULL }  ,  { &&oriPLUSandi, NULL }  ,  { &&oriPLUSandi, NULL }  ,  { &&oriPLUSandi, NULL } 
 ,  { &&oriPLUSandi, NULL }  ,  { &&oriPLUSandi, NULL }  ,  { &&oriPLUSandi, NULL }  ,  { &&oriPLUSandi, NULL }  ,  { &&oriPLUSandi, NULL }  ,  { &&oriPLUSandi, NULL }  ,  { &&oriPLUSandi, NULL }  ,  { &&oriPLUSandi, NULL }  ,  { &&oriPLUSandi, NULL }  ,  { &&oriPLUSandi, NULL } 
 ,  { &&oriPLUSandi, NULL }  ,  { &&oriPLUSandi, NULL }  ,  { &&oriPLUSandi, NULL }  ,  { &&oriPLUSandi, NULL }  ,  { &&oriPLUSandi, NULL }  ,  { &&oriPLUSandi, NULL }  ,  { &&oriPLUSandi, NULL }  ,  { &&oriPLUSandi, NULL }  ,  { &&oriPLUSandi, NULL }  ,  { &&oriPLUSandi, NULL } 
 ,  { &&oriPLUSandi, NULL }  ,  { &&oriPLUSandi, NULL }  ,  { &&oriPLUSandi, NULL }  ,  { &&oriPLUSandi, NULL }  ,  { &&oriPLUSandi, NULL }  ,  { &&oriPLUSandi, NULL }  ,  { &&oriPLUSandi, NULL }  ,  { &&oriPLUSandi, NULL }  ,  { &&oriPLUSandi, NULL }  ,  { &&oriPLUSandi, NULL } 
 ,  { &&oriPLUSandi, NULL }  ,  { &&oriPLUSandi, NULL }  ,  { &&oriPLUSandi, NULL }  ,  { &&oriPLUSandi, NULL }  ,  { &&oriPLUSandi, NULL }  ,  { &&oriPLUSandi, NULL }  ,  { &&oriPLUSandi, NULL }  ,  { &&oriPLUSandi, NULL }  ,  { &&oriPLUSandi, NULL }  ,  { &&oriPLUSandi, NULL } 
 }; 

struct pointer arrayadduPLUSnor[T_SIZE] = {  { &&adduPLUSnor, NULL }  ,  { &&adduPLUSnor, NULL }  ,  { &&adduPLUSnorPLUSsrl, NULL }  ,  { &&adduPLUSnor, NULL }  ,  { &&adduPLUSnor, NULL }  ,  { &&adduPLUSnor, NULL }  ,  { &&adduPLUSnor, NULL }  ,  { &&adduPLUSnor, NULL }  ,  { &&adduPLUSnorPLUSjr, NULL }  ,  { &&adduPLUSnor, NULL } 
 ,  { &&adduPLUSnor, NULL }  ,  { &&adduPLUSnor, NULL }  ,  { &&adduPLUSnor, NULL }  ,  { &&adduPLUSnor, NULL }  ,  { &&adduPLUSnor, NULL }  ,  { &&adduPLUSnor, NULL }  ,  { &&adduPLUSnor, NULL }  ,  { &&adduPLUSnor, NULL }  ,  { &&adduPLUSnor, NULL }  ,  { &&adduPLUSnor, NULL } 
 ,  { &&adduPLUSnor, NULL }  ,  { &&adduPLUSnor, NULL }  ,  { &&adduPLUSnor, NULL }  ,  { &&adduPLUSnor, NULL }  ,  { &&adduPLUSnor, NULL }  ,  { &&adduPLUSnor, NULL }  ,  { &&adduPLUSnor, NULL }  ,  { &&adduPLUSnor, NULL }  ,  { &&adduPLUSnor, NULL }  ,  { &&adduPLUSnor, NULL } 
 ,  { &&adduPLUSnor, NULL }  ,  { &&adduPLUSnor, NULL }  ,  { &&adduPLUSnor, NULL }  ,  { &&adduPLUSnor, NULL }  ,  { &&adduPLUSnor, NULL }  ,  { &&adduPLUSnor, NULL }  ,  { &&adduPLUSnor, NULL }  ,  { &&adduPLUSnor, NULL }  ,  { &&adduPLUSnor, NULL }  ,  { &&adduPLUSnor, NULL } 
 ,  { &&adduPLUSnor, NULL }  ,  { &&adduPLUSnor, NULL }  ,  { &&adduPLUSnor, NULL }  ,  { &&adduPLUSnor, NULL }  ,  { &&adduPLUSnor, NULL }  ,  { &&adduPLUSnor, NULL }  ,  { &&adduPLUSnor, NULL }  ,  { &&adduPLUSnor, NULL }  ,  { &&adduPLUSnor, NULL }  ,  { &&adduPLUSnor, NULL } 
 ,  { &&adduPLUSnor, NULL }  ,  { &&adduPLUSnor, NULL }  ,  { &&adduPLUSnor, NULL }  ,  { &&adduPLUSnor, NULL }  ,  { &&adduPLUSnor, NULL }  ,  { &&adduPLUSnor, NULL }  ,  { &&adduPLUSnor, NULL }  ,  { &&adduPLUSnor, NULL }  ,  { &&adduPLUSnor, NULL }  ,  { &&adduPLUSnor, NULL } 
 ,  { &&adduPLUSnor, NULL }  ,  { &&adduPLUSnor, NULL }  ,  { &&adduPLUSnor, NULL }  ,  { &&adduPLUSnor, NULL }  ,  { &&adduPLUSnor, NULL }  ,  { &&adduPLUSnor, NULL }  ,  { &&adduPLUSnor, NULL }  ,  { &&adduPLUSnor, NULL }  ,  { &&adduPLUSnor, NULL }  ,  { &&adduPLUSnor, NULL } 
 ,  { &&adduPLUSnor, NULL }  ,  { &&adduPLUSnor, NULL }  ,  { &&adduPLUSnor, NULL }  ,  { &&adduPLUSnor, NULL }  ,  { &&adduPLUSnor, NULL }  ,  { &&adduPLUSnor, NULL }  ,  { &&adduPLUSnor, NULL }  ,  { &&adduPLUSnor, NULL }  ,  { &&adduPLUSnor, NULL }  ,  { &&adduPLUSnor, NULL } 
 ,  { &&adduPLUSnor, NULL }  ,  { &&adduPLUSnor, NULL }  ,  { &&adduPLUSnor, NULL }  ,  { &&adduPLUSnor, NULL }  ,  { &&adduPLUSnor, NULL }  ,  { &&adduPLUSnor, NULL }  ,  { &&adduPLUSnor, NULL }  ,  { &&adduPLUSnor, NULL }  ,  { &&adduPLUSnor, NULL }  ,  { &&adduPLUSnor, NULL } 
 ,  { &&adduPLUSnor, NULL }  ,  { &&adduPLUSnor, NULL }  ,  { &&adduPLUSnor, NULL }  ,  { &&adduPLUSnor, NULL }  ,  { &&adduPLUSnor, NULL }  ,  { &&adduPLUSnor, NULL }  ,  { &&adduPLUSnor, NULL }  ,  { &&adduPLUSnor, NULL }  ,  { &&adduPLUSnor, NULL }  ,  { &&adduPLUSnor, NULL } 
 ,  { &&adduPLUSnor, NULL }  ,  { &&adduPLUSnor, NULL }  ,  { &&adduPLUSnor, NULL }  ,  { &&adduPLUSnor, NULL }  ,  { &&adduPLUSnor, NULL }  ,  { &&adduPLUSnor, NULL }  ,  { &&adduPLUSnor, NULL }  ,  { &&adduPLUSnor, NULL }  ,  { &&adduPLUSnor, NULL }  ,  { &&adduPLUSnor, NULL } 
 }; 

struct pointer arraysllPLUSslti[T_SIZE] = {  { &&sllPLUSslti, NULL }  ,  { &&sllPLUSslti, NULL }  ,  { &&sllPLUSslti, NULL }  ,  { &&sllPLUSslti, NULL }  ,  { &&sllPLUSslti, NULL }  ,  { &&sllPLUSslti, NULL }  ,  { &&sllPLUSslti, NULL }  ,  { &&sllPLUSslti, NULL }  ,  { &&sllPLUSslti, NULL }  ,  { &&sllPLUSslti, NULL } 
 ,  { &&sllPLUSslti, NULL }  ,  { &&sllPLUSslti, NULL }  ,  { &&sllPLUSslti, NULL }  ,  { &&sllPLUSslti, NULL }  ,  { &&sllPLUSslti, NULL }  ,  { &&sllPLUSslti, NULL }  ,  { &&sllPLUSslti, NULL }  ,  { &&sllPLUSslti, NULL }  ,  { &&sllPLUSslti, NULL }  ,  { &&sllPLUSslti, NULL } 
 ,  { &&sllPLUSslti, NULL }  ,  { &&sllPLUSslti, NULL }  ,  { &&sllPLUSslti, NULL }  ,  { &&sllPLUSslti, NULL }  ,  { &&sllPLUSslti, NULL }  ,  { &&sllPLUSslti, NULL }  ,  { &&sllPLUSslti, NULL }  ,  { &&sllPLUSslti, NULL }  ,  { &&sllPLUSslti, NULL }  ,  { &&sllPLUSslti, NULL } 
 ,  { &&sllPLUSslti, NULL }  ,  { &&sllPLUSslti, NULL }  ,  { &&sllPLUSslti, NULL }  ,  { &&sllPLUSslti, NULL }  ,  { &&sllPLUSslti, NULL }  ,  { &&sllPLUSslti, NULL }  ,  { &&sllPLUSslti, NULL }  ,  { &&sllPLUSslti, NULL }  ,  { &&sllPLUSslti, NULL }  ,  { &&sllPLUSslti, NULL } 
 ,  { &&sllPLUSslti, NULL }  ,  { &&sllPLUSslti, NULL }  ,  { &&sllPLUSslti, NULL }  ,  { &&sllPLUSslti, NULL }  ,  { &&sllPLUSslti, NULL }  ,  { &&sllPLUSslti, NULL }  ,  { &&sllPLUSslti, NULL }  ,  { &&sllPLUSsltiPLUSbeq, NULL }  ,  { &&sllPLUSsltiPLUSbne, NULL }  ,  { &&sllPLUSslti, NULL } 
 ,  { &&sllPLUSslti, NULL }  ,  { &&sllPLUSslti, NULL }  ,  { &&sllPLUSslti, NULL }  ,  { &&sllPLUSslti, NULL }  ,  { &&sllPLUSslti, NULL }  ,  { &&sllPLUSslti, NULL }  ,  { &&sllPLUSslti, NULL }  ,  { &&sllPLUSslti, NULL }  ,  { &&sllPLUSslti, NULL }  ,  { &&sllPLUSslti, NULL } 
 ,  { &&sllPLUSslti, NULL }  ,  { &&sllPLUSslti, NULL }  ,  { &&sllPLUSslti, NULL }  ,  { &&sllPLUSslti, NULL }  ,  { &&sllPLUSslti, NULL }  ,  { &&sllPLUSslti, NULL }  ,  { &&sllPLUSslti, NULL }  ,  { &&sllPLUSslti, NULL }  ,  { &&sllPLUSslti, NULL }  ,  { &&sllPLUSslti, NULL } 
 ,  { &&sllPLUSslti, NULL }  ,  { &&sllPLUSslti, NULL }  ,  { &&sllPLUSslti, NULL }  ,  { &&sllPLUSslti, NULL }  ,  { &&sllPLUSslti, NULL }  ,  { &&sllPLUSslti, NULL }  ,  { &&sllPLUSslti, NULL }  ,  { &&sllPLUSslti, NULL }  ,  { &&sllPLUSslti, NULL }  ,  { &&sllPLUSslti, NULL } 
 ,  { &&sllPLUSslti, NULL }  ,  { &&sllPLUSslti, NULL }  ,  { &&sllPLUSslti, NULL }  ,  { &&sllPLUSslti, NULL }  ,  { &&sllPLUSslti, NULL }  ,  { &&sllPLUSslti, NULL }  ,  { &&sllPLUSslti, NULL }  ,  { &&sllPLUSslti, NULL }  ,  { &&sllPLUSslti, NULL }  ,  { &&sllPLUSslti, NULL } 
 ,  { &&sllPLUSslti, NULL }  ,  { &&sllPLUSslti, NULL }  ,  { &&sllPLUSslti, NULL }  ,  { &&sllPLUSslti, NULL }  ,  { &&sllPLUSslti, NULL }  ,  { &&sllPLUSslti, NULL }  ,  { &&sllPLUSslti, NULL }  ,  { &&sllPLUSslti, NULL }  ,  { &&sllPLUSslti, NULL }  ,  { &&sllPLUSslti, NULL } 
 ,  { &&sllPLUSslti, NULL }  ,  { &&sllPLUSslti, NULL }  ,  { &&sllPLUSslti, NULL }  ,  { &&sllPLUSslti, NULL }  ,  { &&sllPLUSslti, NULL }  ,  { &&sllPLUSslti, NULL }  ,  { &&sllPLUSslti, NULL }  ,  { &&sllPLUSslti, NULL }  ,  { &&sllPLUSslti, NULL }  ,  { &&sllPLUSslti, NULL } 
 }; 

struct pointer arraylwPLUSbne[T_SIZE] = {  { &&lwPLUSbnePLUSsll, NULL }  ,  { &&lwPLUSbne, NULL }  ,  { &&lwPLUSbne, NULL }  ,  { &&lwPLUSbne, NULL }  ,  { &&lwPLUSbne, NULL }  ,  { &&lwPLUSbne, NULL }  ,  { &&lwPLUSbne, NULL }  ,  { &&lwPLUSbne, NULL }  ,  { &&lwPLUSbne, NULL }  ,  { &&lwPLUSbne, NULL } 
 ,  { &&lwPLUSbne, NULL }  ,  { &&lwPLUSbne, NULL }  ,  { &&lwPLUSbne, NULL }  ,  { &&lwPLUSbne, NULL }  ,  { &&lwPLUSbne, NULL }  ,  { &&lwPLUSbne, NULL }  ,  { &&lwPLUSbne, NULL }  ,  { &&lwPLUSbne, NULL }  ,  { &&lwPLUSbne, NULL }  ,  { &&lwPLUSbne, NULL } 
 ,  { &&lwPLUSbne, NULL }  ,  { &&lwPLUSbne, NULL }  ,  { &&lwPLUSbne, NULL }  ,  { &&lwPLUSbne, NULL }  ,  { &&lwPLUSbne, NULL }  ,  { &&lwPLUSbne, NULL }  ,  { &&lwPLUSbne, NULL }  ,  { &&lwPLUSbne, NULL }  ,  { &&lwPLUSbne, NULL }  ,  { &&lwPLUSbne, NULL } 
 ,  { &&lwPLUSbne, NULL }  ,  { &&lwPLUSbne, NULL }  ,  { &&lwPLUSbne, NULL }  ,  { &&lwPLUSbne, NULL }  ,  { &&lwPLUSbne, NULL }  ,  { &&lwPLUSbne, NULL }  ,  { &&lwPLUSbne, NULL }  ,  { &&lwPLUSbne, NULL }  ,  { &&lwPLUSbne, NULL }  ,  { &&lwPLUSbne, NULL } 
 ,  { &&lwPLUSbne, NULL }  ,  { &&lwPLUSbne, NULL }  ,  { &&lwPLUSbne, NULL }  ,  { &&lwPLUSbne, NULL }  ,  { &&lwPLUSbne, NULL }  ,  { &&lwPLUSbne, NULL }  ,  { &&lwPLUSbne, NULL }  ,  { &&lwPLUSbne, NULL }  ,  { &&lwPLUSbne, NULL }  ,  { &&lwPLUSbne, NULL } 
 ,  { &&lwPLUSbne, NULL }  ,  { &&lwPLUSbne, NULL }  ,  { &&lwPLUSbne, NULL }  ,  { &&lwPLUSbne, NULL }  ,  { &&lwPLUSbne, NULL }  ,  { &&lwPLUSbne, NULL }  ,  { &&lwPLUSbne, NULL }  ,  { &&lwPLUSbne, NULL }  ,  { &&lwPLUSbne, NULL }  ,  { &&lwPLUSbne, NULL } 
 ,  { &&lwPLUSbne, NULL }  ,  { &&lwPLUSbne, NULL }  ,  { &&lwPLUSbne, NULL }  ,  { &&lwPLUSbne, NULL }  ,  { &&lwPLUSbne, NULL }  ,  { &&lwPLUSbne, NULL }  ,  { &&lwPLUSbne, NULL }  ,  { &&lwPLUSbne, NULL }  ,  { &&lwPLUSbne, NULL }  ,  { &&lwPLUSbne, NULL } 
 ,  { &&lwPLUSbne, NULL }  ,  { &&lwPLUSbne, NULL }  ,  { &&lwPLUSbne, NULL }  ,  { &&lwPLUSbne, NULL }  ,  { &&lwPLUSbne, NULL }  ,  { &&lwPLUSbne, NULL }  ,  { &&lwPLUSbne, NULL }  ,  { &&lwPLUSbne, NULL }  ,  { &&lwPLUSbne, NULL }  ,  { &&lwPLUSbne, NULL } 
 ,  { &&lwPLUSbne, NULL }  ,  { &&lwPLUSbne, NULL }  ,  { &&lwPLUSbne, NULL }  ,  { &&lwPLUSbne, NULL }  ,  { &&lwPLUSbne, NULL }  ,  { &&lwPLUSbne, NULL }  ,  { &&lwPLUSbne, NULL }  ,  { &&lwPLUSbne, NULL }  ,  { &&lwPLUSbne, NULL }  ,  { &&lwPLUSbne, NULL } 
 ,  { &&lwPLUSbne, NULL }  ,  { &&lwPLUSbne, NULL }  ,  { &&lwPLUSbne, NULL }  ,  { &&lwPLUSbne, NULL }  ,  { &&lwPLUSbne, NULL }  ,  { &&lwPLUSbne, NULL }  ,  { &&lwPLUSbne, NULL }  ,  { &&lwPLUSbne, NULL }  ,  { &&lwPLUSbne, NULL }  ,  { &&lwPLUSbne, NULL } 
 ,  { &&lwPLUSbne, NULL }  ,  { &&lwPLUSbne, NULL }  ,  { &&lwPLUSbne, NULL }  ,  { &&lwPLUSbne, NULL }  ,  { &&lwPLUSbne, NULL }  ,  { &&lwPLUSbne, NULL }  ,  { &&lwPLUSbne, NULL }  ,  { &&lwPLUSbne, NULL }  ,  { &&lwPLUSbne, NULL }  ,  { &&lwPLUSbne, NULL } 
 }; 

struct pointer arraylwPLUSerror[T_SIZE] = {  { &&lwPLUSerror, NULL }  ,  { &&lwPLUSerrorPLUSerror, NULL }  ,  { &&lwPLUSerror, NULL }  ,  { &&lwPLUSerror, NULL }  ,  { &&lwPLUSerror, NULL }  ,  { &&lwPLUSerrorPLUSerror, NULL }  ,  { &&lwPLUSerror, NULL }  ,  { &&lwPLUSerror, NULL }  ,  { &&lwPLUSerror, NULL }  ,  { &&lwPLUSerror, NULL } 
 ,  { &&lwPLUSerror, NULL }  ,  { &&lwPLUSerror, NULL }  ,  { &&lwPLUSerror, NULL }  ,  { &&lwPLUSerrorPLUSerror, NULL }  ,  { &&lwPLUSerrorPLUSerror, NULL }  ,  { &&lwPLUSerrorPLUSerror, NULL }  ,  { &&lwPLUSerror, NULL }  ,  { &&lwPLUSerror, NULL }  ,  { &&lwPLUSerror, NULL }  ,  { &&lwPLUSerror, NULL } 
 ,  { &&lwPLUSerrorPLUSerror, NULL }  ,  { &&lwPLUSerrorPLUSerror, NULL }  ,  { &&lwPLUSerrorPLUSerror, NULL }  ,  { &&lwPLUSerrorPLUSerror, NULL }  ,  { &&lwPLUSerror, NULL }  ,  { &&lwPLUSerror, NULL }  ,  { &&lwPLUSerror, NULL }  ,  { &&lwPLUSerror, NULL }  ,  { &&lwPLUSerrorPLUSerror, NULL }  ,  { &&lwPLUSerrorPLUSerror, NULL } 
 ,  { &&lwPLUSerrorPLUSerror, NULL }  ,  { &&lwPLUSerrorPLUSerror, NULL }  ,  { &&lwPLUSerror, NULL }  ,  { &&lwPLUSerrorPLUSaddu, NULL }  ,  { &&lwPLUSerror, NULL }  ,  { &&lwPLUSerror, NULL }  ,  { &&lwPLUSerror, NULL }  ,  { &&lwPLUSerror, NULL }  ,  { &&lwPLUSerror, NULL }  ,  { &&lwPLUSerror, NULL } 
 ,  { &&lwPLUSerrorPLUSerror, NULL }  ,  { &&lwPLUSerrorPLUSerror, NULL }  ,  { &&lwPLUSerror, NULL }  ,  { &&lwPLUSerror, NULL }  ,  { &&lwPLUSerror, NULL }  ,  { &&lwPLUSerror, NULL }  ,  { &&lwPLUSerror, NULL }  ,  { &&lwPLUSerror, NULL }  ,  { &&lwPLUSerror, NULL }  ,  { &&lwPLUSerror, NULL } 
 ,  { &&lwPLUSerror, NULL }  ,  { &&lwPLUSerror, NULL }  ,  { &&lwPLUSerrorPLUSaddiu, NULL }  ,  { &&lwPLUSerror, NULL }  ,  { &&lwPLUSerror, NULL }  ,  { &&lwPLUSerror, NULL }  ,  { &&lwPLUSerror, NULL }  ,  { &&lwPLUSerror, NULL }  ,  { &&lwPLUSerror, NULL }  ,  { &&lwPLUSerrorPLUSerror, NULL } 
 ,  { &&lwPLUSerrorPLUSerror, NULL }  ,  { &&lwPLUSerrorPLUSerror, NULL }  ,  { &&lwPLUSerrorPLUSerror, NULL }  ,  { &&lwPLUSerrorPLUSerror, NULL }  ,  { &&lwPLUSerrorPLUSerror, NULL }  ,  { &&lwPLUSerrorPLUSerror, NULL }  ,  { &&lwPLUSerrorPLUSerror, NULL }  ,  { &&lwPLUSerror, NULL }  ,  { &&lwPLUSerror, NULL }  ,  { &&lwPLUSerror, NULL } 
 ,  { &&lwPLUSerrorPLUSerror, NULL }  ,  { &&lwPLUSerrorPLUSerror, NULL }  ,  { &&lwPLUSerrorPLUSerror, NULL }  ,  { &&lwPLUSerrorPLUSerror, NULL }  ,  { &&lwPLUSerrorPLUSerror, NULL }  ,  { &&lwPLUSerror, NULL }  ,  { &&lwPLUSerror, NULL }  ,  { &&lwPLUSerror, NULL }  ,  { &&lwPLUSerrorPLUSlw, NULL }  ,  { &&lwPLUSerror, NULL } 
 ,  { &&lwPLUSerror, NULL }  ,  { &&lwPLUSerror, NULL }  ,  { &&lwPLUSerrorPLUSerror, NULL }  ,  { &&lwPLUSerror, NULL }  ,  { &&lwPLUSerror, NULL }  ,  { &&lwPLUSerror, NULL }  ,  { &&lwPLUSerror, NULL }  ,  { &&lwPLUSerrorPLUSerror, NULL }  ,  { &&lwPLUSerrorPLUSerror, NULL }  ,  { &&lwPLUSerror, NULL } 
 ,  { &&lwPLUSerrorPLUSerror, NULL }  ,  { &&lwPLUSerrorPLUSerror, NULL }  ,  { &&lwPLUSerrorPLUSerror, NULL }  ,  { &&lwPLUSerrorPLUSerror, NULL }  ,  { &&lwPLUSerrorPLUSerror, NULL }  ,  { &&lwPLUSerrorPLUSerror, NULL }  ,  { &&lwPLUSerrorPLUSerror, NULL }  ,  { &&lwPLUSerrorPLUSerror, NULL }  ,  { &&lwPLUSerrorPLUSerror, NULL }  ,  { &&lwPLUSerrorPLUSerror, NULL } 
 ,  { &&lwPLUSerrorPLUSerror, NULL }  ,  { &&lwPLUSerrorPLUSerror, NULL }  ,  { &&lwPLUSerrorPLUSerror, NULL }  ,  { &&lwPLUSerrorPLUSerror, NULL }  ,  { &&lwPLUSerrorPLUSerror, NULL }  ,  { &&lwPLUSerrorPLUSerror, NULL }  ,  { &&lwPLUSerrorPLUSerror, NULL }  ,  { &&lwPLUSerrorPLUSerror, NULL }  ,  { &&lwPLUSerrorPLUSerror, NULL }  ,  { &&lwPLUSerrorPLUSerror, NULL } 
 }; 

struct pointer arraylbuPLUSbeq[T_SIZE] = {  { &&lbuPLUSbeq, NULL }  ,  { &&lbuPLUSbeq, NULL }  ,  { &&lbuPLUSbeq, NULL }  ,  { &&lbuPLUSbeq, NULL }  ,  { &&lbuPLUSbeq, NULL }  ,  { &&lbuPLUSbeq, NULL }  ,  { &&lbuPLUSbeq, NULL }  ,  { &&lbuPLUSbeq, NULL }  ,  { &&lbuPLUSbeq, NULL }  ,  { &&lbuPLUSbeq, NULL } 
 ,  { &&lbuPLUSbeq, NULL }  ,  { &&lbuPLUSbeq, NULL }  ,  { &&lbuPLUSbeq, NULL }  ,  { &&lbuPLUSbeq, NULL }  ,  { &&lbuPLUSbeq, NULL }  ,  { &&lbuPLUSbeq, NULL }  ,  { &&lbuPLUSbeq, NULL }  ,  { &&lbuPLUSbeq, NULL }  ,  { &&lbuPLUSbeq, NULL }  ,  { &&lbuPLUSbeq, NULL } 
 ,  { &&lbuPLUSbeq, NULL }  ,  { &&lbuPLUSbeq, NULL }  ,  { &&lbuPLUSbeq, NULL }  ,  { &&lbuPLUSbeq, NULL }  ,  { &&lbuPLUSbeq, NULL }  ,  { &&lbuPLUSbeq, NULL }  ,  { &&lbuPLUSbeq, NULL }  ,  { &&lbuPLUSbeq, NULL }  ,  { &&lbuPLUSbeq, NULL }  ,  { &&lbuPLUSbeq, NULL } 
 ,  { &&lbuPLUSbeq, NULL }  ,  { &&lbuPLUSbeq, NULL }  ,  { &&lbuPLUSbeq, NULL }  ,  { &&lbuPLUSbeq, NULL }  ,  { &&lbuPLUSbeq, NULL }  ,  { &&lbuPLUSbeq, NULL }  ,  { &&lbuPLUSbeq, NULL }  ,  { &&lbuPLUSbeq, NULL }  ,  { &&lbuPLUSbeq, NULL }  ,  { &&lbuPLUSbeq, NULL } 
 ,  { &&lbuPLUSbeq, NULL }  ,  { &&lbuPLUSbeq, NULL }  ,  { &&lbuPLUSbeq, NULL }  ,  { &&lbuPLUSbeq, NULL }  ,  { &&lbuPLUSbeq, NULL }  ,  { &&lbuPLUSbeq, NULL }  ,  { &&lbuPLUSbeq, NULL }  ,  { &&lbuPLUSbeq, NULL }  ,  { &&lbuPLUSbeq, NULL }  ,  { &&lbuPLUSbeq, NULL } 
 ,  { &&lbuPLUSbeq, NULL }  ,  { &&lbuPLUSbeq, NULL }  ,  { &&lbuPLUSbeqPLUSaddiu, NULL }  ,  { &&lbuPLUSbeq, NULL }  ,  { &&lbuPLUSbeq, NULL }  ,  { &&lbuPLUSbeq, NULL }  ,  { &&lbuPLUSbeq, NULL }  ,  { &&lbuPLUSbeq, NULL }  ,  { &&lbuPLUSbeq, NULL }  ,  { &&lbuPLUSbeq, NULL } 
 ,  { &&lbuPLUSbeq, NULL }  ,  { &&lbuPLUSbeq, NULL }  ,  { &&lbuPLUSbeq, NULL }  ,  { &&lbuPLUSbeq, NULL }  ,  { &&lbuPLUSbeq, NULL }  ,  { &&lbuPLUSbeq, NULL }  ,  { &&lbuPLUSbeq, NULL }  ,  { &&lbuPLUSbeq, NULL }  ,  { &&lbuPLUSbeq, NULL }  ,  { &&lbuPLUSbeq, NULL } 
 ,  { &&lbuPLUSbeq, NULL }  ,  { &&lbuPLUSbeq, NULL }  ,  { &&lbuPLUSbeq, NULL }  ,  { &&lbuPLUSbeq, NULL }  ,  { &&lbuPLUSbeq, NULL }  ,  { &&lbuPLUSbeq, NULL }  ,  { &&lbuPLUSbeq, NULL }  ,  { &&lbuPLUSbeq, NULL }  ,  { &&lbuPLUSbeq, NULL }  ,  { &&lbuPLUSbeq, NULL } 
 ,  { &&lbuPLUSbeq, NULL }  ,  { &&lbuPLUSbeq, NULL }  ,  { &&lbuPLUSbeq, NULL }  ,  { &&lbuPLUSbeq, NULL }  ,  { &&lbuPLUSbeq, NULL }  ,  { &&lbuPLUSbeq, NULL }  ,  { &&lbuPLUSbeq, NULL }  ,  { &&lbuPLUSbeq, NULL }  ,  { &&lbuPLUSbeq, NULL }  ,  { &&lbuPLUSbeq, NULL } 
 ,  { &&lbuPLUSbeq, NULL }  ,  { &&lbuPLUSbeq, NULL }  ,  { &&lbuPLUSbeq, NULL }  ,  { &&lbuPLUSbeq, NULL }  ,  { &&lbuPLUSbeq, NULL }  ,  { &&lbuPLUSbeq, NULL }  ,  { &&lbuPLUSbeq, NULL }  ,  { &&lbuPLUSbeq, NULL }  ,  { &&lbuPLUSbeq, NULL }  ,  { &&lbuPLUSbeq, NULL } 
 ,  { &&lbuPLUSbeq, NULL }  ,  { &&lbuPLUSbeq, NULL }  ,  { &&lbuPLUSbeq, NULL }  ,  { &&lbuPLUSbeq, NULL }  ,  { &&lbuPLUSbeq, NULL }  ,  { &&lbuPLUSbeq, NULL }  ,  { &&lbuPLUSbeq, NULL }  ,  { &&lbuPLUSbeq, NULL }  ,  { &&lbuPLUSbeq, NULL }  ,  { &&lbuPLUSbeq, NULL } 
 }; 

struct pointer arraymovnPLUSaddiu[T_SIZE] = {  { &&movnPLUSaddiuPLUSsll, NULL }  ,  { &&movnPLUSaddiu, NULL }  ,  { &&movnPLUSaddiu, NULL }  ,  { &&movnPLUSaddiu, NULL }  ,  { &&movnPLUSaddiu, NULL }  ,  { &&movnPLUSaddiu, NULL }  ,  { &&movnPLUSaddiu, NULL }  ,  { &&movnPLUSaddiu, NULL }  ,  { &&movnPLUSaddiu, NULL }  ,  { &&movnPLUSaddiu, NULL } 
 ,  { &&movnPLUSaddiu, NULL }  ,  { &&movnPLUSaddiu, NULL }  ,  { &&movnPLUSaddiu, NULL }  ,  { &&movnPLUSaddiu, NULL }  ,  { &&movnPLUSaddiu, NULL }  ,  { &&movnPLUSaddiu, NULL }  ,  { &&movnPLUSaddiu, NULL }  ,  { &&movnPLUSaddiu, NULL }  ,  { &&movnPLUSaddiu, NULL }  ,  { &&movnPLUSaddiu, NULL } 
 ,  { &&movnPLUSaddiu, NULL }  ,  { &&movnPLUSaddiu, NULL }  ,  { &&movnPLUSaddiu, NULL }  ,  { &&movnPLUSaddiu, NULL }  ,  { &&movnPLUSaddiu, NULL }  ,  { &&movnPLUSaddiu, NULL }  ,  { &&movnPLUSaddiu, NULL }  ,  { &&movnPLUSaddiu, NULL }  ,  { &&movnPLUSaddiu, NULL }  ,  { &&movnPLUSaddiu, NULL } 
 ,  { &&movnPLUSaddiu, NULL }  ,  { &&movnPLUSaddiu, NULL }  ,  { &&movnPLUSaddiu, NULL }  ,  { &&movnPLUSaddiu, NULL }  ,  { &&movnPLUSaddiu, NULL }  ,  { &&movnPLUSaddiu, NULL }  ,  { &&movnPLUSaddiu, NULL }  ,  { &&movnPLUSaddiu, NULL }  ,  { &&movnPLUSaddiu, NULL }  ,  { &&movnPLUSaddiu, NULL } 
 ,  { &&movnPLUSaddiu, NULL }  ,  { &&movnPLUSaddiu, NULL }  ,  { &&movnPLUSaddiu, NULL }  ,  { &&movnPLUSaddiu, NULL }  ,  { &&movnPLUSaddiu, NULL }  ,  { &&movnPLUSaddiu, NULL }  ,  { &&movnPLUSaddiu, NULL }  ,  { &&movnPLUSaddiu, NULL }  ,  { &&movnPLUSaddiu, NULL }  ,  { &&movnPLUSaddiu, NULL } 
 ,  { &&movnPLUSaddiu, NULL }  ,  { &&movnPLUSaddiu, NULL }  ,  { &&movnPLUSaddiu, NULL }  ,  { &&movnPLUSaddiu, NULL }  ,  { &&movnPLUSaddiu, NULL }  ,  { &&movnPLUSaddiu, NULL }  ,  { &&movnPLUSaddiu, NULL }  ,  { &&movnPLUSaddiu, NULL }  ,  { &&movnPLUSaddiu, NULL }  ,  { &&movnPLUSaddiu, NULL } 
 ,  { &&movnPLUSaddiu, NULL }  ,  { &&movnPLUSaddiu, NULL }  ,  { &&movnPLUSaddiu, NULL }  ,  { &&movnPLUSaddiu, NULL }  ,  { &&movnPLUSaddiu, NULL }  ,  { &&movnPLUSaddiu, NULL }  ,  { &&movnPLUSaddiu, NULL }  ,  { &&movnPLUSaddiu, NULL }  ,  { &&movnPLUSaddiu, NULL }  ,  { &&movnPLUSaddiu, NULL } 
 ,  { &&movnPLUSaddiu, NULL }  ,  { &&movnPLUSaddiu, NULL }  ,  { &&movnPLUSaddiu, NULL }  ,  { &&movnPLUSaddiu, NULL }  ,  { &&movnPLUSaddiu, NULL }  ,  { &&movnPLUSaddiu, NULL }  ,  { &&movnPLUSaddiu, NULL }  ,  { &&movnPLUSaddiu, NULL }  ,  { &&movnPLUSaddiu, NULL }  ,  { &&movnPLUSaddiu, NULL } 
 ,  { &&movnPLUSaddiu, NULL }  ,  { &&movnPLUSaddiu, NULL }  ,  { &&movnPLUSaddiu, NULL }  ,  { &&movnPLUSaddiu, NULL }  ,  { &&movnPLUSaddiu, NULL }  ,  { &&movnPLUSaddiu, NULL }  ,  { &&movnPLUSaddiu, NULL }  ,  { &&movnPLUSaddiu, NULL }  ,  { &&movnPLUSaddiu, NULL }  ,  { &&movnPLUSaddiu, NULL } 
 ,  { &&movnPLUSaddiu, NULL }  ,  { &&movnPLUSaddiu, NULL }  ,  { &&movnPLUSaddiu, NULL }  ,  { &&movnPLUSaddiu, NULL }  ,  { &&movnPLUSaddiu, NULL }  ,  { &&movnPLUSaddiu, NULL }  ,  { &&movnPLUSaddiu, NULL }  ,  { &&movnPLUSaddiu, NULL }  ,  { &&movnPLUSaddiu, NULL }  ,  { &&movnPLUSaddiu, NULL } 
 ,  { &&movnPLUSaddiu, NULL }  ,  { &&movnPLUSaddiu, NULL }  ,  { &&movnPLUSaddiu, NULL }  ,  { &&movnPLUSaddiu, NULL }  ,  { &&movnPLUSaddiu, NULL }  ,  { &&movnPLUSaddiu, NULL }  ,  { &&movnPLUSaddiu, NULL }  ,  { &&movnPLUSaddiu, NULL }  ,  { &&movnPLUSaddiu, NULL }  ,  { &&movnPLUSaddiu, NULL } 
 }; 

struct pointer arrayorPLUSsrl[T_SIZE] = {  { &&orPLUSsrlPLUSsll, NULL }  ,  { &&orPLUSsrl, NULL }  ,  { &&orPLUSsrl, NULL }  ,  { &&orPLUSsrl, NULL }  ,  { &&orPLUSsrl, NULL }  ,  { &&orPLUSsrl, NULL }  ,  { &&orPLUSsrl, NULL }  ,  { &&orPLUSsrl, NULL }  ,  { &&orPLUSsrl, NULL }  ,  { &&orPLUSsrl, NULL } 
 ,  { &&orPLUSsrl, NULL }  ,  { &&orPLUSsrl, NULL }  ,  { &&orPLUSsrl, NULL }  ,  { &&orPLUSsrl, NULL }  ,  { &&orPLUSsrl, NULL }  ,  { &&orPLUSsrl, NULL }  ,  { &&orPLUSsrl, NULL }  ,  { &&orPLUSsrl, NULL }  ,  { &&orPLUSsrl, NULL }  ,  { &&orPLUSsrl, NULL } 
 ,  { &&orPLUSsrl, NULL }  ,  { &&orPLUSsrl, NULL }  ,  { &&orPLUSsrl, NULL }  ,  { &&orPLUSsrl, NULL }  ,  { &&orPLUSsrl, NULL }  ,  { &&orPLUSsrl, NULL }  ,  { &&orPLUSsrl, NULL }  ,  { &&orPLUSsrl, NULL }  ,  { &&orPLUSsrl, NULL }  ,  { &&orPLUSsrl, NULL } 
 ,  { &&orPLUSsrl, NULL }  ,  { &&orPLUSsrl, NULL }  ,  { &&orPLUSsrl, NULL }  ,  { &&orPLUSsrl, NULL }  ,  { &&orPLUSsrl, NULL }  ,  { &&orPLUSsrl, NULL }  ,  { &&orPLUSsrl, NULL }  ,  { &&orPLUSsrl, NULL }  ,  { &&orPLUSsrl, NULL }  ,  { &&orPLUSsrl, NULL } 
 ,  { &&orPLUSsrl, NULL }  ,  { &&orPLUSsrl, NULL }  ,  { &&orPLUSsrl, NULL }  ,  { &&orPLUSsrl, NULL }  ,  { &&orPLUSsrl, NULL }  ,  { &&orPLUSsrl, NULL }  ,  { &&orPLUSsrl, NULL }  ,  { &&orPLUSsrl, NULL }  ,  { &&orPLUSsrl, NULL }  ,  { &&orPLUSsrl, NULL } 
 ,  { &&orPLUSsrl, NULL }  ,  { &&orPLUSsrl, NULL }  ,  { &&orPLUSsrl, NULL }  ,  { &&orPLUSsrl, NULL }  ,  { &&orPLUSsrl, NULL }  ,  { &&orPLUSsrlPLUSandi, NULL }  ,  { &&orPLUSsrl, NULL }  ,  { &&orPLUSsrl, NULL }  ,  { &&orPLUSsrlPLUSlui, NULL }  ,  { &&orPLUSsrl, NULL } 
 ,  { &&orPLUSsrl, NULL }  ,  { &&orPLUSsrl, NULL }  ,  { &&orPLUSsrl, NULL }  ,  { &&orPLUSsrl, NULL }  ,  { &&orPLUSsrl, NULL }  ,  { &&orPLUSsrl, NULL }  ,  { &&orPLUSsrl, NULL }  ,  { &&orPLUSsrl, NULL }  ,  { &&orPLUSsrl, NULL }  ,  { &&orPLUSsrl, NULL } 
 ,  { &&orPLUSsrl, NULL }  ,  { &&orPLUSsrl, NULL }  ,  { &&orPLUSsrl, NULL }  ,  { &&orPLUSsrl, NULL }  ,  { &&orPLUSsrl, NULL }  ,  { &&orPLUSsrl, NULL }  ,  { &&orPLUSsrl, NULL }  ,  { &&orPLUSsrl, NULL }  ,  { &&orPLUSsrl, NULL }  ,  { &&orPLUSsrl, NULL } 
 ,  { &&orPLUSsrl, NULL }  ,  { &&orPLUSsrl, NULL }  ,  { &&orPLUSsrl, NULL }  ,  { &&orPLUSsrl, NULL }  ,  { &&orPLUSsrl, NULL }  ,  { &&orPLUSsrl, NULL }  ,  { &&orPLUSsrl, NULL }  ,  { &&orPLUSsrl, NULL }  ,  { &&orPLUSsrl, NULL }  ,  { &&orPLUSsrl, NULL } 
 ,  { &&orPLUSsrl, NULL }  ,  { &&orPLUSsrl, NULL }  ,  { &&orPLUSsrl, NULL }  ,  { &&orPLUSsrl, NULL }  ,  { &&orPLUSsrl, NULL }  ,  { &&orPLUSsrl, NULL }  ,  { &&orPLUSsrl, NULL }  ,  { &&orPLUSsrl, NULL }  ,  { &&orPLUSsrl, NULL }  ,  { &&orPLUSsrl, NULL } 
 ,  { &&orPLUSsrl, NULL }  ,  { &&orPLUSsrl, NULL }  ,  { &&orPLUSsrl, NULL }  ,  { &&orPLUSsrl, NULL }  ,  { &&orPLUSsrl, NULL }  ,  { &&orPLUSsrl, NULL }  ,  { &&orPLUSsrl, NULL }  ,  { &&orPLUSsrl, NULL }  ,  { &&orPLUSsrl, NULL }  ,  { &&orPLUSsrl, NULL } 
 }; 

struct pointer arrayerrorPLUSaddiu[T_SIZE] = {  { &&errorPLUSaddiu, NULL }  ,  { &&errorPLUSaddiu, NULL }  ,  { &&errorPLUSaddiu, NULL }  ,  { &&errorPLUSaddiu, NULL }  ,  { &&errorPLUSaddiu, NULL }  ,  { &&errorPLUSaddiu, NULL }  ,  { &&errorPLUSaddiu, NULL }  ,  { &&errorPLUSaddiu, NULL }  ,  { &&errorPLUSaddiu, NULL }  ,  { &&errorPLUSaddiu, NULL } 
 ,  { &&errorPLUSaddiu, NULL }  ,  { &&errorPLUSaddiu, NULL }  ,  { &&errorPLUSaddiu, NULL }  ,  { &&errorPLUSaddiu, NULL }  ,  { &&errorPLUSaddiu, NULL }  ,  { &&errorPLUSaddiu, NULL }  ,  { &&errorPLUSaddiu, NULL }  ,  { &&errorPLUSaddiu, NULL }  ,  { &&errorPLUSaddiu, NULL }  ,  { &&errorPLUSaddiu, NULL } 
 ,  { &&errorPLUSaddiu, NULL }  ,  { &&errorPLUSaddiu, NULL }  ,  { &&errorPLUSaddiu, NULL }  ,  { &&errorPLUSaddiu, NULL }  ,  { &&errorPLUSaddiu, NULL }  ,  { &&errorPLUSaddiu, NULL }  ,  { &&errorPLUSaddiu, NULL }  ,  { &&errorPLUSaddiu, NULL }  ,  { &&errorPLUSaddiu, NULL }  ,  { &&errorPLUSaddiu, NULL } 
 ,  { &&errorPLUSaddiu, NULL }  ,  { &&errorPLUSaddiu, NULL }  ,  { &&errorPLUSaddiu, NULL }  ,  { &&errorPLUSaddiuPLUSaddu, NULL }  ,  { &&errorPLUSaddiu, NULL }  ,  { &&errorPLUSaddiu, NULL }  ,  { &&errorPLUSaddiu, NULL }  ,  { &&errorPLUSaddiu, NULL }  ,  { &&errorPLUSaddiu, NULL }  ,  { &&errorPLUSaddiu, NULL } 
 ,  { &&errorPLUSaddiu, NULL }  ,  { &&errorPLUSaddiu, NULL }  ,  { &&errorPLUSaddiu, NULL }  ,  { &&errorPLUSaddiu, NULL }  ,  { &&errorPLUSaddiu, NULL }  ,  { &&errorPLUSaddiu, NULL }  ,  { &&errorPLUSaddiu, NULL }  ,  { &&errorPLUSaddiu, NULL }  ,  { &&errorPLUSaddiu, NULL }  ,  { &&errorPLUSaddiu, NULL } 
 ,  { &&errorPLUSaddiu, NULL }  ,  { &&errorPLUSaddiu, NULL }  ,  { &&errorPLUSaddiuPLUSaddiu, NULL }  ,  { &&errorPLUSaddiu, NULL }  ,  { &&errorPLUSaddiu, NULL }  ,  { &&errorPLUSaddiu, NULL }  ,  { &&errorPLUSaddiu, NULL }  ,  { &&errorPLUSaddiu, NULL }  ,  { &&errorPLUSaddiu, NULL }  ,  { &&errorPLUSaddiu, NULL } 
 ,  { &&errorPLUSaddiu, NULL }  ,  { &&errorPLUSaddiu, NULL }  ,  { &&errorPLUSaddiu, NULL }  ,  { &&errorPLUSaddiu, NULL }  ,  { &&errorPLUSaddiu, NULL }  ,  { &&errorPLUSaddiu, NULL }  ,  { &&errorPLUSaddiu, NULL }  ,  { &&errorPLUSaddiu, NULL }  ,  { &&errorPLUSaddiu, NULL }  ,  { &&errorPLUSaddiu, NULL } 
 ,  { &&errorPLUSaddiu, NULL }  ,  { &&errorPLUSaddiu, NULL }  ,  { &&errorPLUSaddiu, NULL }  ,  { &&errorPLUSaddiu, NULL }  ,  { &&errorPLUSaddiu, NULL }  ,  { &&errorPLUSaddiu, NULL }  ,  { &&errorPLUSaddiu, NULL }  ,  { &&errorPLUSaddiu, NULL }  ,  { &&errorPLUSaddiu, NULL }  ,  { &&errorPLUSaddiuPLUSlbu, NULL } 
 ,  { &&errorPLUSaddiu, NULL }  ,  { &&errorPLUSaddiu, NULL }  ,  { &&errorPLUSaddiu, NULL }  ,  { &&errorPLUSaddiu, NULL }  ,  { &&errorPLUSaddiu, NULL }  ,  { &&errorPLUSaddiu, NULL }  ,  { &&errorPLUSaddiu, NULL }  ,  { &&errorPLUSaddiu, NULL }  ,  { &&errorPLUSaddiu, NULL }  ,  { &&errorPLUSaddiu, NULL } 
 ,  { &&errorPLUSaddiu, NULL }  ,  { &&errorPLUSaddiu, NULL }  ,  { &&errorPLUSaddiu, NULL }  ,  { &&errorPLUSaddiu, NULL }  ,  { &&errorPLUSaddiu, NULL }  ,  { &&errorPLUSaddiu, NULL }  ,  { &&errorPLUSaddiu, NULL }  ,  { &&errorPLUSaddiu, NULL }  ,  { &&errorPLUSaddiu, NULL }  ,  { &&errorPLUSaddiu, NULL } 
 ,  { &&errorPLUSaddiu, NULL }  ,  { &&errorPLUSaddiu, NULL }  ,  { &&errorPLUSaddiu, NULL }  ,  { &&errorPLUSaddiu, NULL }  ,  { &&errorPLUSaddiu, NULL }  ,  { &&errorPLUSaddiu, NULL }  ,  { &&errorPLUSaddiu, NULL }  ,  { &&errorPLUSaddiu, NULL }  ,  { &&errorPLUSaddiu, NULL }  ,  { &&errorPLUSaddiu, NULL } 
 }; 

struct pointer arrayluiPLUSlw[T_SIZE] = {  { &&luiPLUSlw, NULL }  ,  { &&luiPLUSlw, NULL }  ,  { &&luiPLUSlw, NULL }  ,  { &&luiPLUSlw, NULL }  ,  { &&luiPLUSlw, NULL }  ,  { &&luiPLUSlw, NULL }  ,  { &&luiPLUSlw, NULL }  ,  { &&luiPLUSlw, NULL }  ,  { &&luiPLUSlw, NULL }  ,  { &&luiPLUSlw, NULL } 
 ,  { &&luiPLUSlw, NULL }  ,  { &&luiPLUSlw, NULL }  ,  { &&luiPLUSlw, NULL }  ,  { &&luiPLUSlw, NULL }  ,  { &&luiPLUSlw, NULL }  ,  { &&luiPLUSlw, NULL }  ,  { &&luiPLUSlw, NULL }  ,  { &&luiPLUSlw, NULL }  ,  { &&luiPLUSlw, NULL }  ,  { &&luiPLUSlw, NULL } 
 ,  { &&luiPLUSlw, NULL }  ,  { &&luiPLUSlw, NULL }  ,  { &&luiPLUSlw, NULL }  ,  { &&luiPLUSlw, NULL }  ,  { &&luiPLUSlw, NULL }  ,  { &&luiPLUSlw, NULL }  ,  { &&luiPLUSlw, NULL }  ,  { &&luiPLUSlw, NULL }  ,  { &&luiPLUSlw, NULL }  ,  { &&luiPLUSlw, NULL } 
 ,  { &&luiPLUSlw, NULL }  ,  { &&luiPLUSlw, NULL }  ,  { &&luiPLUSlw, NULL }  ,  { &&luiPLUSlw, NULL }  ,  { &&luiPLUSlw, NULL }  ,  { &&luiPLUSlw, NULL }  ,  { &&luiPLUSlw, NULL }  ,  { &&luiPLUSlw, NULL }  ,  { &&luiPLUSlw, NULL }  ,  { &&luiPLUSlw, NULL } 
 ,  { &&luiPLUSlw, NULL }  ,  { &&luiPLUSlw, NULL }  ,  { &&luiPLUSlw, NULL }  ,  { &&luiPLUSlw, NULL }  ,  { &&luiPLUSlw, NULL }  ,  { &&luiPLUSlw, NULL }  ,  { &&luiPLUSlw, NULL }  ,  { &&luiPLUSlw, NULL }  ,  { &&luiPLUSlw, NULL }  ,  { &&luiPLUSlw, NULL } 
 ,  { &&luiPLUSlw, NULL }  ,  { &&luiPLUSlw, NULL }  ,  { &&luiPLUSlwPLUSaddiu, NULL }  ,  { &&luiPLUSlw, NULL }  ,  { &&luiPLUSlw, NULL }  ,  { &&luiPLUSlw, NULL }  ,  { &&luiPLUSlw, NULL }  ,  { &&luiPLUSlw, NULL }  ,  { &&luiPLUSlw, NULL }  ,  { &&luiPLUSlw, NULL } 
 ,  { &&luiPLUSlw, NULL }  ,  { &&luiPLUSlw, NULL }  ,  { &&luiPLUSlw, NULL }  ,  { &&luiPLUSlw, NULL }  ,  { &&luiPLUSlw, NULL }  ,  { &&luiPLUSlw, NULL }  ,  { &&luiPLUSlw, NULL }  ,  { &&luiPLUSlw, NULL }  ,  { &&luiPLUSlw, NULL }  ,  { &&luiPLUSlw, NULL } 
 ,  { &&luiPLUSlw, NULL }  ,  { &&luiPLUSlw, NULL }  ,  { &&luiPLUSlw, NULL }  ,  { &&luiPLUSlw, NULL }  ,  { &&luiPLUSlw, NULL }  ,  { &&luiPLUSlw, NULL }  ,  { &&luiPLUSlw, NULL }  ,  { &&luiPLUSlw, NULL }  ,  { &&luiPLUSlw, NULL }  ,  { &&luiPLUSlw, NULL } 
 ,  { &&luiPLUSlw, NULL }  ,  { &&luiPLUSlw, NULL }  ,  { &&luiPLUSlw, NULL }  ,  { &&luiPLUSlw, NULL }  ,  { &&luiPLUSlw, NULL }  ,  { &&luiPLUSlw, NULL }  ,  { &&luiPLUSlw, NULL }  ,  { &&luiPLUSlw, NULL }  ,  { &&luiPLUSlw, NULL }  ,  { &&luiPLUSlw, NULL } 
 ,  { &&luiPLUSlw, NULL }  ,  { &&luiPLUSlw, NULL }  ,  { &&luiPLUSlw, NULL }  ,  { &&luiPLUSlw, NULL }  ,  { &&luiPLUSlw, NULL }  ,  { &&luiPLUSlw, NULL }  ,  { &&luiPLUSlw, NULL }  ,  { &&luiPLUSlw, NULL }  ,  { &&luiPLUSlw, NULL }  ,  { &&luiPLUSlw, NULL } 
 ,  { &&luiPLUSlw, NULL }  ,  { &&luiPLUSlw, NULL }  ,  { &&luiPLUSlw, NULL }  ,  { &&luiPLUSlw, NULL }  ,  { &&luiPLUSlw, NULL }  ,  { &&luiPLUSlw, NULL }  ,  { &&luiPLUSlw, NULL }  ,  { &&luiPLUSlw, NULL }  ,  { &&luiPLUSlw, NULL }  ,  { &&luiPLUSlw, NULL } 
 }; 

struct pointer arrayswPLUSsw[T_SIZE] = {  { &&swPLUSsw, NULL }  ,  { &&swPLUSsw, NULL }  ,  { &&swPLUSsw, NULL }  ,  { &&swPLUSsw, NULL }  ,  { &&swPLUSsw, NULL }  ,  { &&swPLUSsw, NULL }  ,  { &&swPLUSsw, NULL }  ,  { &&swPLUSsw, NULL }  ,  { &&swPLUSsw, NULL }  ,  { &&swPLUSsw, NULL } 
 ,  { &&swPLUSsw, NULL }  ,  { &&swPLUSsw, NULL }  ,  { &&swPLUSsw, NULL }  ,  { &&swPLUSsw, NULL }  ,  { &&swPLUSsw, NULL }  ,  { &&swPLUSsw, NULL }  ,  { &&swPLUSsw, NULL }  ,  { &&swPLUSsw, NULL }  ,  { &&swPLUSsw, NULL }  ,  { &&swPLUSsw, NULL } 
 ,  { &&swPLUSsw, NULL }  ,  { &&swPLUSsw, NULL }  ,  { &&swPLUSsw, NULL }  ,  { &&swPLUSsw, NULL }  ,  { &&swPLUSsw, NULL }  ,  { &&swPLUSsw, NULL }  ,  { &&swPLUSsw, NULL }  ,  { &&swPLUSsw, NULL }  ,  { &&swPLUSsw, NULL }  ,  { &&swPLUSsw, NULL } 
 ,  { &&swPLUSsw, NULL }  ,  { &&swPLUSsw, NULL }  ,  { &&swPLUSsw, NULL }  ,  { &&swPLUSswPLUSaddu, NULL }  ,  { &&swPLUSsw, NULL }  ,  { &&swPLUSsw, NULL }  ,  { &&swPLUSsw, NULL }  ,  { &&swPLUSsw, NULL }  ,  { &&swPLUSsw, NULL }  ,  { &&swPLUSsw, NULL } 
 ,  { &&swPLUSsw, NULL }  ,  { &&swPLUSsw, NULL }  ,  { &&swPLUSsw, NULL }  ,  { &&swPLUSsw, NULL }  ,  { &&swPLUSsw, NULL }  ,  { &&swPLUSsw, NULL }  ,  { &&swPLUSswPLUSjal, NULL }  ,  { &&swPLUSsw, NULL }  ,  { &&swPLUSsw, NULL }  ,  { &&swPLUSsw, NULL } 
 ,  { &&swPLUSsw, NULL }  ,  { &&swPLUSsw, NULL }  ,  { &&swPLUSswPLUSaddiu, NULL }  ,  { &&swPLUSsw, NULL }  ,  { &&swPLUSsw, NULL }  ,  { &&swPLUSsw, NULL }  ,  { &&swPLUSsw, NULL }  ,  { &&swPLUSsw, NULL }  ,  { &&swPLUSswPLUSlui, NULL }  ,  { &&swPLUSsw, NULL } 
 ,  { &&swPLUSsw, NULL }  ,  { &&swPLUSsw, NULL }  ,  { &&swPLUSsw, NULL }  ,  { &&swPLUSsw, NULL }  ,  { &&swPLUSsw, NULL }  ,  { &&swPLUSsw, NULL }  ,  { &&swPLUSsw, NULL }  ,  { &&swPLUSsw, NULL }  ,  { &&swPLUSsw, NULL }  ,  { &&swPLUSsw, NULL } 
 ,  { &&swPLUSsw, NULL }  ,  { &&swPLUSsw, NULL }  ,  { &&swPLUSsw, NULL }  ,  { &&swPLUSsw, NULL }  ,  { &&swPLUSsw, NULL }  ,  { &&swPLUSsw, NULL }  ,  { &&swPLUSsw, NULL }  ,  { &&swPLUSsw, NULL }  ,  { &&swPLUSswPLUSlw, NULL }  ,  { &&swPLUSsw, NULL } 
 ,  { &&swPLUSsw, NULL }  ,  { &&swPLUSsw, NULL }  ,  { &&swPLUSsw, NULL }  ,  { &&swPLUSswPLUSsb, NULL }  ,  { &&swPLUSsw, NULL }  ,  { &&swPLUSsw, NULL }  ,  { &&swPLUSswPLUSsw, NULL }  ,  { &&swPLUSsw, NULL }  ,  { &&swPLUSsw, NULL }  ,  { &&swPLUSsw, NULL } 
 ,  { &&swPLUSsw, NULL }  ,  { &&swPLUSsw, NULL }  ,  { &&swPLUSsw, NULL }  ,  { &&swPLUSsw, NULL }  ,  { &&swPLUSsw, NULL }  ,  { &&swPLUSsw, NULL }  ,  { &&swPLUSsw, NULL }  ,  { &&swPLUSsw, NULL }  ,  { &&swPLUSsw, NULL }  ,  { &&swPLUSsw, NULL } 
 ,  { &&swPLUSsw, NULL }  ,  { &&swPLUSsw, NULL }  ,  { &&swPLUSsw, NULL }  ,  { &&swPLUSsw, NULL }  ,  { &&swPLUSsw, NULL }  ,  { &&swPLUSsw, NULL }  ,  { &&swPLUSsw, NULL }  ,  { &&swPLUSsw, NULL }  ,  { &&swPLUSsw, NULL }  ,  { &&swPLUSsw, NULL } 
 }; 

struct pointer arrayadduPLUSaddiu[T_SIZE] = {  { &&adduPLUSaddiuPLUSsll, NULL }  ,  { &&adduPLUSaddiu, NULL }  ,  { &&adduPLUSaddiu, NULL }  ,  { &&adduPLUSaddiu, NULL }  ,  { &&adduPLUSaddiu, NULL }  ,  { &&adduPLUSaddiu, NULL }  ,  { &&adduPLUSaddiu, NULL }  ,  { &&adduPLUSaddiu, NULL }  ,  { &&adduPLUSaddiu, NULL }  ,  { &&adduPLUSaddiu, NULL } 
 ,  { &&adduPLUSaddiu, NULL }  ,  { &&adduPLUSaddiu, NULL }  ,  { &&adduPLUSaddiu, NULL }  ,  { &&adduPLUSaddiu, NULL }  ,  { &&adduPLUSaddiu, NULL }  ,  { &&adduPLUSaddiu, NULL }  ,  { &&adduPLUSaddiu, NULL }  ,  { &&adduPLUSaddiu, NULL }  ,  { &&adduPLUSaddiu, NULL }  ,  { &&adduPLUSaddiu, NULL } 
 ,  { &&adduPLUSaddiu, NULL }  ,  { &&adduPLUSaddiu, NULL }  ,  { &&adduPLUSaddiu, NULL }  ,  { &&adduPLUSaddiu, NULL }  ,  { &&adduPLUSaddiu, NULL }  ,  { &&adduPLUSaddiu, NULL }  ,  { &&adduPLUSaddiu, NULL }  ,  { &&adduPLUSaddiu, NULL }  ,  { &&adduPLUSaddiu, NULL }  ,  { &&adduPLUSaddiu, NULL } 
 ,  { &&adduPLUSaddiu, NULL }  ,  { &&adduPLUSaddiu, NULL }  ,  { &&adduPLUSaddiu, NULL }  ,  { &&adduPLUSaddiu, NULL }  ,  { &&adduPLUSaddiu, NULL }  ,  { &&adduPLUSaddiu, NULL }  ,  { &&adduPLUSaddiu, NULL }  ,  { &&adduPLUSaddiu, NULL }  ,  { &&adduPLUSaddiu, NULL }  ,  { &&adduPLUSaddiu, NULL } 
 ,  { &&adduPLUSaddiu, NULL }  ,  { &&adduPLUSaddiu, NULL }  ,  { &&adduPLUSaddiu, NULL }  ,  { &&adduPLUSaddiu, NULL }  ,  { &&adduPLUSaddiu, NULL }  ,  { &&adduPLUSaddiu, NULL }  ,  { &&adduPLUSaddiu, NULL }  ,  { &&adduPLUSaddiu, NULL }  ,  { &&adduPLUSaddiu, NULL }  ,  { &&adduPLUSaddiu, NULL } 
 ,  { &&adduPLUSaddiu, NULL }  ,  { &&adduPLUSaddiu, NULL }  ,  { &&adduPLUSaddiuPLUSaddiu, NULL }  ,  { &&adduPLUSaddiu, NULL }  ,  { &&adduPLUSaddiu, NULL }  ,  { &&adduPLUSaddiu, NULL }  ,  { &&adduPLUSaddiu, NULL }  ,  { &&adduPLUSaddiu, NULL }  ,  { &&adduPLUSaddiuPLUSlui, NULL }  ,  { &&adduPLUSaddiu, NULL } 
 ,  { &&adduPLUSaddiu, NULL }  ,  { &&adduPLUSaddiu, NULL }  ,  { &&adduPLUSaddiu, NULL }  ,  { &&adduPLUSaddiu, NULL }  ,  { &&adduPLUSaddiu, NULL }  ,  { &&adduPLUSaddiu, NULL }  ,  { &&adduPLUSaddiu, NULL }  ,  { &&adduPLUSaddiu, NULL }  ,  { &&adduPLUSaddiu, NULL }  ,  { &&adduPLUSaddiu, NULL } 
 ,  { &&adduPLUSaddiu, NULL }  ,  { &&adduPLUSaddiu, NULL }  ,  { &&adduPLUSaddiu, NULL }  ,  { &&adduPLUSaddiu, NULL }  ,  { &&adduPLUSaddiu, NULL }  ,  { &&adduPLUSaddiu, NULL }  ,  { &&adduPLUSaddiu, NULL }  ,  { &&adduPLUSaddiu, NULL }  ,  { &&adduPLUSaddiuPLUSlw, NULL }  ,  { &&adduPLUSaddiu, NULL } 
 ,  { &&adduPLUSaddiu, NULL }  ,  { &&adduPLUSaddiu, NULL }  ,  { &&adduPLUSaddiu, NULL }  ,  { &&adduPLUSaddiu, NULL }  ,  { &&adduPLUSaddiu, NULL }  ,  { &&adduPLUSaddiu, NULL }  ,  { &&adduPLUSaddiuPLUSsw, NULL }  ,  { &&adduPLUSaddiu, NULL }  ,  { &&adduPLUSaddiu, NULL }  ,  { &&adduPLUSaddiu, NULL } 
 ,  { &&adduPLUSaddiu, NULL }  ,  { &&adduPLUSaddiu, NULL }  ,  { &&adduPLUSaddiu, NULL }  ,  { &&adduPLUSaddiu, NULL }  ,  { &&adduPLUSaddiu, NULL }  ,  { &&adduPLUSaddiu, NULL }  ,  { &&adduPLUSaddiu, NULL }  ,  { &&adduPLUSaddiu, NULL }  ,  { &&adduPLUSaddiu, NULL }  ,  { &&adduPLUSaddiu, NULL } 
 ,  { &&adduPLUSaddiu, NULL }  ,  { &&adduPLUSaddiu, NULL }  ,  { &&adduPLUSaddiu, NULL }  ,  { &&adduPLUSaddiu, NULL }  ,  { &&adduPLUSaddiu, NULL }  ,  { &&adduPLUSaddiu, NULL }  ,  { &&adduPLUSaddiu, NULL }  ,  { &&adduPLUSaddiu, NULL }  ,  { &&adduPLUSaddiu, NULL }  ,  { &&adduPLUSaddiu, NULL } 
 }; 

struct pointer arrayaddiuPLUSjump[T_SIZE] = {  { &&addiuPLUSjumpPLUSsll, NULL }  ,  { &&addiuPLUSjump, NULL }  ,  { &&addiuPLUSjump, NULL }  ,  { &&addiuPLUSjump, NULL }  ,  { &&addiuPLUSjump, NULL }  ,  { &&addiuPLUSjump, NULL }  ,  { &&addiuPLUSjump, NULL }  ,  { &&addiuPLUSjump, NULL }  ,  { &&addiuPLUSjump, NULL }  ,  { &&addiuPLUSjump, NULL } 
 ,  { &&addiuPLUSjump, NULL }  ,  { &&addiuPLUSjump, NULL }  ,  { &&addiuPLUSjump, NULL }  ,  { &&addiuPLUSjump, NULL }  ,  { &&addiuPLUSjump, NULL }  ,  { &&addiuPLUSjump, NULL }  ,  { &&addiuPLUSjump, NULL }  ,  { &&addiuPLUSjump, NULL }  ,  { &&addiuPLUSjump, NULL }  ,  { &&addiuPLUSjump, NULL } 
 ,  { &&addiuPLUSjump, NULL }  ,  { &&addiuPLUSjump, NULL }  ,  { &&addiuPLUSjump, NULL }  ,  { &&addiuPLUSjump, NULL }  ,  { &&addiuPLUSjump, NULL }  ,  { &&addiuPLUSjump, NULL }  ,  { &&addiuPLUSjump, NULL }  ,  { &&addiuPLUSjump, NULL }  ,  { &&addiuPLUSjump, NULL }  ,  { &&addiuPLUSjump, NULL } 
 ,  { &&addiuPLUSjump, NULL }  ,  { &&addiuPLUSjump, NULL }  ,  { &&addiuPLUSjump, NULL }  ,  { &&addiuPLUSjumpPLUSaddu, NULL }  ,  { &&addiuPLUSjump, NULL }  ,  { &&addiuPLUSjump, NULL }  ,  { &&addiuPLUSjump, NULL }  ,  { &&addiuPLUSjump, NULL }  ,  { &&addiuPLUSjump, NULL }  ,  { &&addiuPLUSjump, NULL } 
 ,  { &&addiuPLUSjump, NULL }  ,  { &&addiuPLUSjump, NULL }  ,  { &&addiuPLUSjump, NULL }  ,  { &&addiuPLUSjump, NULL }  ,  { &&addiuPLUSjump, NULL }  ,  { &&addiuPLUSjump, NULL }  ,  { &&addiuPLUSjump, NULL }  ,  { &&addiuPLUSjump, NULL }  ,  { &&addiuPLUSjump, NULL }  ,  { &&addiuPLUSjump, NULL } 
 ,  { &&addiuPLUSjump, NULL }  ,  { &&addiuPLUSjump, NULL }  ,  { &&addiuPLUSjumpPLUSaddiu, NULL }  ,  { &&addiuPLUSjump, NULL }  ,  { &&addiuPLUSjump, NULL }  ,  { &&addiuPLUSjump, NULL }  ,  { &&addiuPLUSjump, NULL }  ,  { &&addiuPLUSjump, NULL }  ,  { &&addiuPLUSjump, NULL }  ,  { &&addiuPLUSjump, NULL } 
 ,  { &&addiuPLUSjump, NULL }  ,  { &&addiuPLUSjump, NULL }  ,  { &&addiuPLUSjump, NULL }  ,  { &&addiuPLUSjump, NULL }  ,  { &&addiuPLUSjump, NULL }  ,  { &&addiuPLUSjump, NULL }  ,  { &&addiuPLUSjump, NULL }  ,  { &&addiuPLUSjump, NULL }  ,  { &&addiuPLUSjump, NULL }  ,  { &&addiuPLUSjump, NULL } 
 ,  { &&addiuPLUSjump, NULL }  ,  { &&addiuPLUSjump, NULL }  ,  { &&addiuPLUSjump, NULL }  ,  { &&addiuPLUSjump, NULL }  ,  { &&addiuPLUSjump, NULL }  ,  { &&addiuPLUSjump, NULL }  ,  { &&addiuPLUSjump, NULL }  ,  { &&addiuPLUSjump, NULL }  ,  { &&addiuPLUSjump, NULL }  ,  { &&addiuPLUSjump, NULL } 
 ,  { &&addiuPLUSjump, NULL }  ,  { &&addiuPLUSjump, NULL }  ,  { &&addiuPLUSjump, NULL }  ,  { &&addiuPLUSjump, NULL }  ,  { &&addiuPLUSjump, NULL }  ,  { &&addiuPLUSjump, NULL }  ,  { &&addiuPLUSjump, NULL }  ,  { &&addiuPLUSjump, NULL }  ,  { &&addiuPLUSjump, NULL }  ,  { &&addiuPLUSjump, NULL } 
 ,  { &&addiuPLUSjump, NULL }  ,  { &&addiuPLUSjump, NULL }  ,  { &&addiuPLUSjump, NULL }  ,  { &&addiuPLUSjump, NULL }  ,  { &&addiuPLUSjump, NULL }  ,  { &&addiuPLUSjump, NULL }  ,  { &&addiuPLUSjump, NULL }  ,  { &&addiuPLUSjump, NULL }  ,  { &&addiuPLUSjump, NULL }  ,  { &&addiuPLUSjump, NULL } 
 ,  { &&addiuPLUSjump, NULL }  ,  { &&addiuPLUSjump, NULL }  ,  { &&addiuPLUSjump, NULL }  ,  { &&addiuPLUSjump, NULL }  ,  { &&addiuPLUSjump, NULL }  ,  { &&addiuPLUSjump, NULL }  ,  { &&addiuPLUSjump, NULL }  ,  { &&addiuPLUSjump, NULL }  ,  { &&addiuPLUSjump, NULL }  ,  { &&addiuPLUSjump, NULL } 
 }; 

struct pointer arrayxorPLUSandi[T_SIZE] = {  { &&xorPLUSandiPLUSsll, NULL }  ,  { &&xorPLUSandi, NULL }  ,  { &&xorPLUSandi, NULL }  ,  { &&xorPLUSandi, NULL }  ,  { &&xorPLUSandi, NULL }  ,  { &&xorPLUSandi, NULL }  ,  { &&xorPLUSandi, NULL }  ,  { &&xorPLUSandi, NULL }  ,  { &&xorPLUSandi, NULL }  ,  { &&xorPLUSandi, NULL } 
 ,  { &&xorPLUSandi, NULL }  ,  { &&xorPLUSandi, NULL }  ,  { &&xorPLUSandi, NULL }  ,  { &&xorPLUSandi, NULL }  ,  { &&xorPLUSandi, NULL }  ,  { &&xorPLUSandi, NULL }  ,  { &&xorPLUSandi, NULL }  ,  { &&xorPLUSandi, NULL }  ,  { &&xorPLUSandi, NULL }  ,  { &&xorPLUSandi, NULL } 
 ,  { &&xorPLUSandi, NULL }  ,  { &&xorPLUSandi, NULL }  ,  { &&xorPLUSandi, NULL }  ,  { &&xorPLUSandi, NULL }  ,  { &&xorPLUSandi, NULL }  ,  { &&xorPLUSandi, NULL }  ,  { &&xorPLUSandi, NULL }  ,  { &&xorPLUSandi, NULL }  ,  { &&xorPLUSandi, NULL }  ,  { &&xorPLUSandi, NULL } 
 ,  { &&xorPLUSandi, NULL }  ,  { &&xorPLUSandi, NULL }  ,  { &&xorPLUSandi, NULL }  ,  { &&xorPLUSandi, NULL }  ,  { &&xorPLUSandi, NULL }  ,  { &&xorPLUSandiPLUSsubu, NULL }  ,  { &&xorPLUSandi, NULL }  ,  { &&xorPLUSandi, NULL }  ,  { &&xorPLUSandi, NULL }  ,  { &&xorPLUSandi, NULL } 
 ,  { &&xorPLUSandi, NULL }  ,  { &&xorPLUSandi, NULL }  ,  { &&xorPLUSandi, NULL }  ,  { &&xorPLUSandi, NULL }  ,  { &&xorPLUSandi, NULL }  ,  { &&xorPLUSandi, NULL }  ,  { &&xorPLUSandi, NULL }  ,  { &&xorPLUSandi, NULL }  ,  { &&xorPLUSandi, NULL }  ,  { &&xorPLUSandi, NULL } 
 ,  { &&xorPLUSandi, NULL }  ,  { &&xorPLUSandi, NULL }  ,  { &&xorPLUSandi, NULL }  ,  { &&xorPLUSandi, NULL }  ,  { &&xorPLUSandi, NULL }  ,  { &&xorPLUSandi, NULL }  ,  { &&xorPLUSandi, NULL }  ,  { &&xorPLUSandi, NULL }  ,  { &&xorPLUSandi, NULL }  ,  { &&xorPLUSandi, NULL } 
 ,  { &&xorPLUSandi, NULL }  ,  { &&xorPLUSandi, NULL }  ,  { &&xorPLUSandi, NULL }  ,  { &&xorPLUSandi, NULL }  ,  { &&xorPLUSandi, NULL }  ,  { &&xorPLUSandi, NULL }  ,  { &&xorPLUSandi, NULL }  ,  { &&xorPLUSandi, NULL }  ,  { &&xorPLUSandi, NULL }  ,  { &&xorPLUSandi, NULL } 
 ,  { &&xorPLUSandi, NULL }  ,  { &&xorPLUSandi, NULL }  ,  { &&xorPLUSandi, NULL }  ,  { &&xorPLUSandi, NULL }  ,  { &&xorPLUSandi, NULL }  ,  { &&xorPLUSandi, NULL }  ,  { &&xorPLUSandi, NULL }  ,  { &&xorPLUSandi, NULL }  ,  { &&xorPLUSandi, NULL }  ,  { &&xorPLUSandi, NULL } 
 ,  { &&xorPLUSandi, NULL }  ,  { &&xorPLUSandi, NULL }  ,  { &&xorPLUSandi, NULL }  ,  { &&xorPLUSandi, NULL }  ,  { &&xorPLUSandi, NULL }  ,  { &&xorPLUSandi, NULL }  ,  { &&xorPLUSandi, NULL }  ,  { &&xorPLUSandi, NULL }  ,  { &&xorPLUSandi, NULL }  ,  { &&xorPLUSandi, NULL } 
 ,  { &&xorPLUSandi, NULL }  ,  { &&xorPLUSandi, NULL }  ,  { &&xorPLUSandi, NULL }  ,  { &&xorPLUSandi, NULL }  ,  { &&xorPLUSandi, NULL }  ,  { &&xorPLUSandi, NULL }  ,  { &&xorPLUSandi, NULL }  ,  { &&xorPLUSandi, NULL }  ,  { &&xorPLUSandi, NULL }  ,  { &&xorPLUSandi, NULL } 
 ,  { &&xorPLUSandi, NULL }  ,  { &&xorPLUSandi, NULL }  ,  { &&xorPLUSandi, NULL }  ,  { &&xorPLUSandi, NULL }  ,  { &&xorPLUSandi, NULL }  ,  { &&xorPLUSandi, NULL }  ,  { &&xorPLUSandi, NULL }  ,  { &&xorPLUSandi, NULL }  ,  { &&xorPLUSandi, NULL }  ,  { &&xorPLUSandi, NULL } 
 }; 

struct pointer arrayadduPLUSbne[T_SIZE] = {  { &&adduPLUSbne, NULL }  ,  { &&adduPLUSbne, NULL }  ,  { &&adduPLUSbne, NULL }  ,  { &&adduPLUSbne, NULL }  ,  { &&adduPLUSbne, NULL }  ,  { &&adduPLUSbne, NULL }  ,  { &&adduPLUSbne, NULL }  ,  { &&adduPLUSbne, NULL }  ,  { &&adduPLUSbne, NULL }  ,  { &&adduPLUSbne, NULL } 
 ,  { &&adduPLUSbne, NULL }  ,  { &&adduPLUSbne, NULL }  ,  { &&adduPLUSbne, NULL }  ,  { &&adduPLUSbne, NULL }  ,  { &&adduPLUSbne, NULL }  ,  { &&adduPLUSbne, NULL }  ,  { &&adduPLUSbne, NULL }  ,  { &&adduPLUSbne, NULL }  ,  { &&adduPLUSbne, NULL }  ,  { &&adduPLUSbne, NULL } 
 ,  { &&adduPLUSbne, NULL }  ,  { &&adduPLUSbne, NULL }  ,  { &&adduPLUSbne, NULL }  ,  { &&adduPLUSbne, NULL }  ,  { &&adduPLUSbne, NULL }  ,  { &&adduPLUSbne, NULL }  ,  { &&adduPLUSbne, NULL }  ,  { &&adduPLUSbne, NULL }  ,  { &&adduPLUSbne, NULL }  ,  { &&adduPLUSbne, NULL } 
 ,  { &&adduPLUSbne, NULL }  ,  { &&adduPLUSbne, NULL }  ,  { &&adduPLUSbne, NULL }  ,  { &&adduPLUSbnePLUSaddu, NULL }  ,  { &&adduPLUSbne, NULL }  ,  { &&adduPLUSbne, NULL }  ,  { &&adduPLUSbne, NULL }  ,  { &&adduPLUSbne, NULL }  ,  { &&adduPLUSbne, NULL }  ,  { &&adduPLUSbne, NULL } 
 ,  { &&adduPLUSbne, NULL }  ,  { &&adduPLUSbne, NULL }  ,  { &&adduPLUSbne, NULL }  ,  { &&adduPLUSbne, NULL }  ,  { &&adduPLUSbne, NULL }  ,  { &&adduPLUSbne, NULL }  ,  { &&adduPLUSbne, NULL }  ,  { &&adduPLUSbne, NULL }  ,  { &&adduPLUSbne, NULL }  ,  { &&adduPLUSbne, NULL } 
 ,  { &&adduPLUSbne, NULL }  ,  { &&adduPLUSbne, NULL }  ,  { &&adduPLUSbne, NULL }  ,  { &&adduPLUSbne, NULL }  ,  { &&adduPLUSbne, NULL }  ,  { &&adduPLUSbne, NULL }  ,  { &&adduPLUSbne, NULL }  ,  { &&adduPLUSbne, NULL }  ,  { &&adduPLUSbne, NULL }  ,  { &&adduPLUSbne, NULL } 
 ,  { &&adduPLUSbne, NULL }  ,  { &&adduPLUSbne, NULL }  ,  { &&adduPLUSbne, NULL }  ,  { &&adduPLUSbne, NULL }  ,  { &&adduPLUSbne, NULL }  ,  { &&adduPLUSbne, NULL }  ,  { &&adduPLUSbne, NULL }  ,  { &&adduPLUSbne, NULL }  ,  { &&adduPLUSbne, NULL }  ,  { &&adduPLUSbne, NULL } 
 ,  { &&adduPLUSbne, NULL }  ,  { &&adduPLUSbne, NULL }  ,  { &&adduPLUSbne, NULL }  ,  { &&adduPLUSbne, NULL }  ,  { &&adduPLUSbne, NULL }  ,  { &&adduPLUSbne, NULL }  ,  { &&adduPLUSbne, NULL }  ,  { &&adduPLUSbne, NULL }  ,  { &&adduPLUSbne, NULL }  ,  { &&adduPLUSbne, NULL } 
 ,  { &&adduPLUSbne, NULL }  ,  { &&adduPLUSbne, NULL }  ,  { &&adduPLUSbne, NULL }  ,  { &&adduPLUSbne, NULL }  ,  { &&adduPLUSbne, NULL }  ,  { &&adduPLUSbne, NULL }  ,  { &&adduPLUSbnePLUSsw, NULL }  ,  { &&adduPLUSbne, NULL }  ,  { &&adduPLUSbne, NULL }  ,  { &&adduPLUSbne, NULL } 
 ,  { &&adduPLUSbne, NULL }  ,  { &&adduPLUSbne, NULL }  ,  { &&adduPLUSbne, NULL }  ,  { &&adduPLUSbne, NULL }  ,  { &&adduPLUSbne, NULL }  ,  { &&adduPLUSbne, NULL }  ,  { &&adduPLUSbne, NULL }  ,  { &&adduPLUSbne, NULL }  ,  { &&adduPLUSbne, NULL }  ,  { &&adduPLUSbne, NULL } 
 ,  { &&adduPLUSbne, NULL }  ,  { &&adduPLUSbne, NULL }  ,  { &&adduPLUSbne, NULL }  ,  { &&adduPLUSbne, NULL }  ,  { &&adduPLUSbne, NULL }  ,  { &&adduPLUSbne, NULL }  ,  { &&adduPLUSbne, NULL }  ,  { &&adduPLUSbne, NULL }  ,  { &&adduPLUSbne, NULL }  ,  { &&adduPLUSbne, NULL } 
 }; 

struct pointer arrayoriPLUSaddiu[T_SIZE] = {  { &&oriPLUSaddiu, NULL }  ,  { &&oriPLUSaddiuPLUSerror, NULL }  ,  { &&oriPLUSaddiu, NULL }  ,  { &&oriPLUSaddiu, NULL }  ,  { &&oriPLUSaddiu, NULL }  ,  { &&oriPLUSaddiuPLUSerror, NULL }  ,  { &&oriPLUSaddiu, NULL }  ,  { &&oriPLUSaddiu, NULL }  ,  { &&oriPLUSaddiu, NULL }  ,  { &&oriPLUSaddiu, NULL } 
 ,  { &&oriPLUSaddiu, NULL }  ,  { &&oriPLUSaddiu, NULL }  ,  { &&oriPLUSaddiu, NULL }  ,  { &&oriPLUSaddiuPLUSerror, NULL }  ,  { &&oriPLUSaddiuPLUSerror, NULL }  ,  { &&oriPLUSaddiuPLUSerror, NULL }  ,  { &&oriPLUSaddiu, NULL }  ,  { &&oriPLUSaddiu, NULL }  ,  { &&oriPLUSaddiu, NULL }  ,  { &&oriPLUSaddiu, NULL } 
 ,  { &&oriPLUSaddiuPLUSerror, NULL }  ,  { &&oriPLUSaddiuPLUSerror, NULL }  ,  { &&oriPLUSaddiuPLUSerror, NULL }  ,  { &&oriPLUSaddiuPLUSerror, NULL }  ,  { &&oriPLUSaddiuPLUSmult, NULL }  ,  { &&oriPLUSaddiu, NULL }  ,  { &&oriPLUSaddiu, NULL }  ,  { &&oriPLUSaddiu, NULL }  ,  { &&oriPLUSaddiuPLUSerror, NULL }  ,  { &&oriPLUSaddiuPLUSerror, NULL } 
 ,  { &&oriPLUSaddiuPLUSerror, NULL }  ,  { &&oriPLUSaddiuPLUSerror, NULL }  ,  { &&oriPLUSaddiu, NULL }  ,  { &&oriPLUSaddiu, NULL }  ,  { &&oriPLUSaddiu, NULL }  ,  { &&oriPLUSaddiu, NULL }  ,  { &&oriPLUSaddiu, NULL }  ,  { &&oriPLUSaddiu, NULL }  ,  { &&oriPLUSaddiu, NULL }  ,  { &&oriPLUSaddiu, NULL } 
 ,  { &&oriPLUSaddiuPLUSerror, NULL }  ,  { &&oriPLUSaddiuPLUSerror, NULL }  ,  { &&oriPLUSaddiu, NULL }  ,  { &&oriPLUSaddiu, NULL }  ,  { &&oriPLUSaddiu, NULL }  ,  { &&oriPLUSaddiu, NULL }  ,  { &&oriPLUSaddiu, NULL }  ,  { &&oriPLUSaddiu, NULL }  ,  { &&oriPLUSaddiu, NULL }  ,  { &&oriPLUSaddiu, NULL } 
 ,  { &&oriPLUSaddiu, NULL }  ,  { &&oriPLUSaddiu, NULL }  ,  { &&oriPLUSaddiu, NULL }  ,  { &&oriPLUSaddiu, NULL }  ,  { &&oriPLUSaddiu, NULL }  ,  { &&oriPLUSaddiu, NULL }  ,  { &&oriPLUSaddiu, NULL }  ,  { &&oriPLUSaddiu, NULL }  ,  { &&oriPLUSaddiu, NULL }  ,  { &&oriPLUSaddiuPLUSerror, NULL } 
 ,  { &&oriPLUSaddiuPLUSerror, NULL }  ,  { &&oriPLUSaddiuPLUSerror, NULL }  ,  { &&oriPLUSaddiuPLUSerror, NULL }  ,  { &&oriPLUSaddiuPLUSerror, NULL }  ,  { &&oriPLUSaddiuPLUSerror, NULL }  ,  { &&oriPLUSaddiuPLUSerror, NULL }  ,  { &&oriPLUSaddiuPLUSerror, NULL }  ,  { &&oriPLUSaddiu, NULL }  ,  { &&oriPLUSaddiu, NULL }  ,  { &&oriPLUSaddiu, NULL } 
 ,  { &&oriPLUSaddiuPLUSerror, NULL }  ,  { &&oriPLUSaddiuPLUSerror, NULL }  ,  { &&oriPLUSaddiuPLUSerror, NULL }  ,  { &&oriPLUSaddiuPLUSerror, NULL }  ,  { &&oriPLUSaddiuPLUSerror, NULL }  ,  { &&oriPLUSaddiu, NULL }  ,  { &&oriPLUSaddiu, NULL }  ,  { &&oriPLUSaddiu, NULL }  ,  { &&oriPLUSaddiu, NULL }  ,  { &&oriPLUSaddiu, NULL } 
 ,  { &&oriPLUSaddiu, NULL }  ,  { &&oriPLUSaddiu, NULL }  ,  { &&oriPLUSaddiuPLUSerror, NULL }  ,  { &&oriPLUSaddiu, NULL }  ,  { &&oriPLUSaddiu, NULL }  ,  { &&oriPLUSaddiu, NULL }  ,  { &&oriPLUSaddiu, NULL }  ,  { &&oriPLUSaddiuPLUSerror, NULL }  ,  { &&oriPLUSaddiuPLUSerror, NULL }  ,  { &&oriPLUSaddiu, NULL } 
 ,  { &&oriPLUSaddiuPLUSerror, NULL }  ,  { &&oriPLUSaddiuPLUSerror, NULL }  ,  { &&oriPLUSaddiuPLUSerror, NULL }  ,  { &&oriPLUSaddiuPLUSerror, NULL }  ,  { &&oriPLUSaddiuPLUSerror, NULL }  ,  { &&oriPLUSaddiuPLUSerror, NULL }  ,  { &&oriPLUSaddiuPLUSerror, NULL }  ,  { &&oriPLUSaddiuPLUSerror, NULL }  ,  { &&oriPLUSaddiuPLUSerror, NULL }  ,  { &&oriPLUSaddiuPLUSerror, NULL } 
 ,  { &&oriPLUSaddiuPLUSerror, NULL }  ,  { &&oriPLUSaddiuPLUSerror, NULL }  ,  { &&oriPLUSaddiuPLUSerror, NULL }  ,  { &&oriPLUSaddiuPLUSerror, NULL }  ,  { &&oriPLUSaddiuPLUSerror, NULL }  ,  { &&oriPLUSaddiuPLUSerror, NULL }  ,  { &&oriPLUSaddiuPLUSerror, NULL }  ,  { &&oriPLUSaddiuPLUSerror, NULL }  ,  { &&oriPLUSaddiuPLUSerror, NULL }  ,  { &&oriPLUSaddiuPLUSerror, NULL } 
 }; 

struct pointer arrayswPLUSsb[T_SIZE] = {  { &&swPLUSsb, NULL }  ,  { &&swPLUSsb, NULL }  ,  { &&swPLUSsb, NULL }  ,  { &&swPLUSsb, NULL }  ,  { &&swPLUSsb, NULL }  ,  { &&swPLUSsb, NULL }  ,  { &&swPLUSsb, NULL }  ,  { &&swPLUSsb, NULL }  ,  { &&swPLUSsb, NULL }  ,  { &&swPLUSsb, NULL } 
 ,  { &&swPLUSsb, NULL }  ,  { &&swPLUSsb, NULL }  ,  { &&swPLUSsb, NULL }  ,  { &&swPLUSsb, NULL }  ,  { &&swPLUSsb, NULL }  ,  { &&swPLUSsb, NULL }  ,  { &&swPLUSsb, NULL }  ,  { &&swPLUSsb, NULL }  ,  { &&swPLUSsb, NULL }  ,  { &&swPLUSsb, NULL } 
 ,  { &&swPLUSsb, NULL }  ,  { &&swPLUSsb, NULL }  ,  { &&swPLUSsb, NULL }  ,  { &&swPLUSsb, NULL }  ,  { &&swPLUSsb, NULL }  ,  { &&swPLUSsb, NULL }  ,  { &&swPLUSsb, NULL }  ,  { &&swPLUSsb, NULL }  ,  { &&swPLUSsb, NULL }  ,  { &&swPLUSsb, NULL } 
 ,  { &&swPLUSsb, NULL }  ,  { &&swPLUSsb, NULL }  ,  { &&swPLUSsb, NULL }  ,  { &&swPLUSsb, NULL }  ,  { &&swPLUSsb, NULL }  ,  { &&swPLUSsb, NULL }  ,  { &&swPLUSsb, NULL }  ,  { &&swPLUSsb, NULL }  ,  { &&swPLUSsb, NULL }  ,  { &&swPLUSsb, NULL } 
 ,  { &&swPLUSsb, NULL }  ,  { &&swPLUSsb, NULL }  ,  { &&swPLUSsb, NULL }  ,  { &&swPLUSsb, NULL }  ,  { &&swPLUSsb, NULL }  ,  { &&swPLUSsb, NULL }  ,  { &&swPLUSsbPLUSjal, NULL }  ,  { &&swPLUSsb, NULL }  ,  { &&swPLUSsb, NULL }  ,  { &&swPLUSsb, NULL } 
 ,  { &&swPLUSsb, NULL }  ,  { &&swPLUSsb, NULL }  ,  { &&swPLUSsb, NULL }  ,  { &&swPLUSsb, NULL }  ,  { &&swPLUSsb, NULL }  ,  { &&swPLUSsb, NULL }  ,  { &&swPLUSsb, NULL }  ,  { &&swPLUSsb, NULL }  ,  { &&swPLUSsb, NULL }  ,  { &&swPLUSsb, NULL } 
 ,  { &&swPLUSsb, NULL }  ,  { &&swPLUSsb, NULL }  ,  { &&swPLUSsb, NULL }  ,  { &&swPLUSsb, NULL }  ,  { &&swPLUSsb, NULL }  ,  { &&swPLUSsb, NULL }  ,  { &&swPLUSsb, NULL }  ,  { &&swPLUSsb, NULL }  ,  { &&swPLUSsb, NULL }  ,  { &&swPLUSsb, NULL } 
 ,  { &&swPLUSsb, NULL }  ,  { &&swPLUSsb, NULL }  ,  { &&swPLUSsb, NULL }  ,  { &&swPLUSsb, NULL }  ,  { &&swPLUSsb, NULL }  ,  { &&swPLUSsb, NULL }  ,  { &&swPLUSsb, NULL }  ,  { &&swPLUSsb, NULL }  ,  { &&swPLUSsb, NULL }  ,  { &&swPLUSsb, NULL } 
 ,  { &&swPLUSsb, NULL }  ,  { &&swPLUSsb, NULL }  ,  { &&swPLUSsb, NULL }  ,  { &&swPLUSsb, NULL }  ,  { &&swPLUSsb, NULL }  ,  { &&swPLUSsb, NULL }  ,  { &&swPLUSsb, NULL }  ,  { &&swPLUSsb, NULL }  ,  { &&swPLUSsb, NULL }  ,  { &&swPLUSsb, NULL } 
 ,  { &&swPLUSsb, NULL }  ,  { &&swPLUSsb, NULL }  ,  { &&swPLUSsb, NULL }  ,  { &&swPLUSsb, NULL }  ,  { &&swPLUSsb, NULL }  ,  { &&swPLUSsb, NULL }  ,  { &&swPLUSsb, NULL }  ,  { &&swPLUSsb, NULL }  ,  { &&swPLUSsb, NULL }  ,  { &&swPLUSsb, NULL } 
 ,  { &&swPLUSsb, NULL }  ,  { &&swPLUSsb, NULL }  ,  { &&swPLUSsb, NULL }  ,  { &&swPLUSsb, NULL }  ,  { &&swPLUSsb, NULL }  ,  { &&swPLUSsb, NULL }  ,  { &&swPLUSsb, NULL }  ,  { &&swPLUSsb, NULL }  ,  { &&swPLUSsb, NULL }  ,  { &&swPLUSsb, NULL } 
 }; 

struct pointer arrayswPLUSslti[T_SIZE] = {  { &&swPLUSslti, NULL }  ,  { &&swPLUSslti, NULL }  ,  { &&swPLUSslti, NULL }  ,  { &&swPLUSslti, NULL }  ,  { &&swPLUSslti, NULL }  ,  { &&swPLUSslti, NULL }  ,  { &&swPLUSslti, NULL }  ,  { &&swPLUSslti, NULL }  ,  { &&swPLUSslti, NULL }  ,  { &&swPLUSslti, NULL } 
 ,  { &&swPLUSslti, NULL }  ,  { &&swPLUSslti, NULL }  ,  { &&swPLUSslti, NULL }  ,  { &&swPLUSslti, NULL }  ,  { &&swPLUSslti, NULL }  ,  { &&swPLUSslti, NULL }  ,  { &&swPLUSslti, NULL }  ,  { &&swPLUSslti, NULL }  ,  { &&swPLUSslti, NULL }  ,  { &&swPLUSslti, NULL } 
 ,  { &&swPLUSslti, NULL }  ,  { &&swPLUSslti, NULL }  ,  { &&swPLUSslti, NULL }  ,  { &&swPLUSslti, NULL }  ,  { &&swPLUSslti, NULL }  ,  { &&swPLUSslti, NULL }  ,  { &&swPLUSslti, NULL }  ,  { &&swPLUSslti, NULL }  ,  { &&swPLUSslti, NULL }  ,  { &&swPLUSslti, NULL } 
 ,  { &&swPLUSslti, NULL }  ,  { &&swPLUSslti, NULL }  ,  { &&swPLUSslti, NULL }  ,  { &&swPLUSslti, NULL }  ,  { &&swPLUSslti, NULL }  ,  { &&swPLUSslti, NULL }  ,  { &&swPLUSslti, NULL }  ,  { &&swPLUSslti, NULL }  ,  { &&swPLUSslti, NULL }  ,  { &&swPLUSslti, NULL } 
 ,  { &&swPLUSslti, NULL }  ,  { &&swPLUSslti, NULL }  ,  { &&swPLUSslti, NULL }  ,  { &&swPLUSslti, NULL }  ,  { &&swPLUSslti, NULL }  ,  { &&swPLUSslti, NULL }  ,  { &&swPLUSslti, NULL }  ,  { &&swPLUSslti, NULL }  ,  { &&swPLUSsltiPLUSbne, NULL }  ,  { &&swPLUSslti, NULL } 
 ,  { &&swPLUSslti, NULL }  ,  { &&swPLUSslti, NULL }  ,  { &&swPLUSslti, NULL }  ,  { &&swPLUSslti, NULL }  ,  { &&swPLUSslti, NULL }  ,  { &&swPLUSslti, NULL }  ,  { &&swPLUSslti, NULL }  ,  { &&swPLUSslti, NULL }  ,  { &&swPLUSslti, NULL }  ,  { &&swPLUSslti, NULL } 
 ,  { &&swPLUSslti, NULL }  ,  { &&swPLUSslti, NULL }  ,  { &&swPLUSslti, NULL }  ,  { &&swPLUSslti, NULL }  ,  { &&swPLUSslti, NULL }  ,  { &&swPLUSslti, NULL }  ,  { &&swPLUSslti, NULL }  ,  { &&swPLUSslti, NULL }  ,  { &&swPLUSslti, NULL }  ,  { &&swPLUSslti, NULL } 
 ,  { &&swPLUSslti, NULL }  ,  { &&swPLUSslti, NULL }  ,  { &&swPLUSslti, NULL }  ,  { &&swPLUSslti, NULL }  ,  { &&swPLUSslti, NULL }  ,  { &&swPLUSslti, NULL }  ,  { &&swPLUSslti, NULL }  ,  { &&swPLUSslti, NULL }  ,  { &&swPLUSslti, NULL }  ,  { &&swPLUSslti, NULL } 
 ,  { &&swPLUSslti, NULL }  ,  { &&swPLUSslti, NULL }  ,  { &&swPLUSslti, NULL }  ,  { &&swPLUSslti, NULL }  ,  { &&swPLUSslti, NULL }  ,  { &&swPLUSslti, NULL }  ,  { &&swPLUSsltiPLUSsw, NULL }  ,  { &&swPLUSslti, NULL }  ,  { &&swPLUSslti, NULL }  ,  { &&swPLUSslti, NULL } 
 ,  { &&swPLUSslti, NULL }  ,  { &&swPLUSslti, NULL }  ,  { &&swPLUSslti, NULL }  ,  { &&swPLUSslti, NULL }  ,  { &&swPLUSslti, NULL }  ,  { &&swPLUSslti, NULL }  ,  { &&swPLUSslti, NULL }  ,  { &&swPLUSslti, NULL }  ,  { &&swPLUSslti, NULL }  ,  { &&swPLUSslti, NULL } 
 ,  { &&swPLUSslti, NULL }  ,  { &&swPLUSslti, NULL }  ,  { &&swPLUSslti, NULL }  ,  { &&swPLUSslti, NULL }  ,  { &&swPLUSslti, NULL }  ,  { &&swPLUSslti, NULL }  ,  { &&swPLUSslti, NULL }  ,  { &&swPLUSslti, NULL }  ,  { &&swPLUSslti, NULL }  ,  { &&swPLUSslti, NULL } 
 }; 

struct pointer arraysllPLUSaddu[T_SIZE] = {  { &&sllPLUSadduPLUSsll, NULL }  ,  { &&sllPLUSaddu, NULL }  ,  { &&sllPLUSadduPLUSsrl, NULL }  ,  { &&sllPLUSaddu, NULL }  ,  { &&sllPLUSaddu, NULL }  ,  { &&sllPLUSaddu, NULL }  ,  { &&sllPLUSaddu, NULL }  ,  { &&sllPLUSaddu, NULL }  ,  { &&sllPLUSaddu, NULL }  ,  { &&sllPLUSaddu, NULL } 
 ,  { &&sllPLUSaddu, NULL }  ,  { &&sllPLUSaddu, NULL }  ,  { &&sllPLUSaddu, NULL }  ,  { &&sllPLUSaddu, NULL }  ,  { &&sllPLUSaddu, NULL }  ,  { &&sllPLUSaddu, NULL }  ,  { &&sllPLUSaddu, NULL }  ,  { &&sllPLUSaddu, NULL }  ,  { &&sllPLUSaddu, NULL }  ,  { &&sllPLUSaddu, NULL } 
 ,  { &&sllPLUSaddu, NULL }  ,  { &&sllPLUSaddu, NULL }  ,  { &&sllPLUSaddu, NULL }  ,  { &&sllPLUSaddu, NULL }  ,  { &&sllPLUSaddu, NULL }  ,  { &&sllPLUSaddu, NULL }  ,  { &&sllPLUSaddu, NULL }  ,  { &&sllPLUSaddu, NULL }  ,  { &&sllPLUSaddu, NULL }  ,  { &&sllPLUSaddu, NULL } 
 ,  { &&sllPLUSaddu, NULL }  ,  { &&sllPLUSaddu, NULL }  ,  { &&sllPLUSaddu, NULL }  ,  { &&sllPLUSadduPLUSaddu, NULL }  ,  { &&sllPLUSaddu, NULL }  ,  { &&sllPLUSadduPLUSsubu, NULL }  ,  { &&sllPLUSaddu, NULL }  ,  { &&sllPLUSaddu, NULL }  ,  { &&sllPLUSaddu, NULL }  ,  { &&sllPLUSaddu, NULL } 
 ,  { &&sllPLUSaddu, NULL }  ,  { &&sllPLUSaddu, NULL }  ,  { &&sllPLUSadduPLUSslt, NULL }  ,  { &&sllPLUSaddu, NULL }  ,  { &&sllPLUSaddu, NULL }  ,  { &&sllPLUSaddu, NULL }  ,  { &&sllPLUSadduPLUSjal, NULL }  ,  { &&sllPLUSaddu, NULL }  ,  { &&sllPLUSaddu, NULL }  ,  { &&sllPLUSaddu, NULL } 
 ,  { &&sllPLUSaddu, NULL }  ,  { &&sllPLUSaddu, NULL }  ,  { &&sllPLUSadduPLUSaddiu, NULL }  ,  { &&sllPLUSadduPLUSslti, NULL }  ,  { &&sllPLUSaddu, NULL }  ,  { &&sllPLUSaddu, NULL }  ,  { &&sllPLUSaddu, NULL }  ,  { &&sllPLUSaddu, NULL }  ,  { &&sllPLUSaddu, NULL }  ,  { &&sllPLUSaddu, NULL } 
 ,  { &&sllPLUSaddu, NULL }  ,  { &&sllPLUSaddu, NULL }  ,  { &&sllPLUSaddu, NULL }  ,  { &&sllPLUSaddu, NULL }  ,  { &&sllPLUSaddu, NULL }  ,  { &&sllPLUSaddu, NULL }  ,  { &&sllPLUSaddu, NULL }  ,  { &&sllPLUSaddu, NULL }  ,  { &&sllPLUSaddu, NULL }  ,  { &&sllPLUSaddu, NULL } 
 ,  { &&sllPLUSaddu, NULL }  ,  { &&sllPLUSaddu, NULL }  ,  { &&sllPLUSaddu, NULL }  ,  { &&sllPLUSaddu, NULL }  ,  { &&sllPLUSaddu, NULL }  ,  { &&sllPLUSaddu, NULL }  ,  { &&sllPLUSaddu, NULL }  ,  { &&sllPLUSaddu, NULL }  ,  { &&sllPLUSadduPLUSlw, NULL }  ,  { &&sllPLUSaddu, NULL } 
 ,  { &&sllPLUSaddu, NULL }  ,  { &&sllPLUSaddu, NULL }  ,  { &&sllPLUSaddu, NULL }  ,  { &&sllPLUSaddu, NULL }  ,  { &&sllPLUSaddu, NULL }  ,  { &&sllPLUSaddu, NULL }  ,  { &&sllPLUSadduPLUSsw, NULL }  ,  { &&sllPLUSaddu, NULL }  ,  { &&sllPLUSaddu, NULL }  ,  { &&sllPLUSaddu, NULL } 
 ,  { &&sllPLUSaddu, NULL }  ,  { &&sllPLUSaddu, NULL }  ,  { &&sllPLUSaddu, NULL }  ,  { &&sllPLUSaddu, NULL }  ,  { &&sllPLUSaddu, NULL }  ,  { &&sllPLUSaddu, NULL }  ,  { &&sllPLUSaddu, NULL }  ,  { &&sllPLUSaddu, NULL }  ,  { &&sllPLUSaddu, NULL }  ,  { &&sllPLUSaddu, NULL } 
 ,  { &&sllPLUSaddu, NULL }  ,  { &&sllPLUSaddu, NULL }  ,  { &&sllPLUSaddu, NULL }  ,  { &&sllPLUSaddu, NULL }  ,  { &&sllPLUSaddu, NULL }  ,  { &&sllPLUSaddu, NULL }  ,  { &&sllPLUSaddu, NULL }  ,  { &&sllPLUSaddu, NULL }  ,  { &&sllPLUSaddu, NULL }  ,  { &&sllPLUSaddu, NULL } 
 }; 

struct pointer arrayandPLUSxor[T_SIZE] = {  { &&andPLUSxor, NULL }  ,  { &&andPLUSxor, NULL }  ,  { &&andPLUSxorPLUSsrl, NULL }  ,  { &&andPLUSxor, NULL }  ,  { &&andPLUSxor, NULL }  ,  { &&andPLUSxor, NULL }  ,  { &&andPLUSxor, NULL }  ,  { &&andPLUSxor, NULL }  ,  { &&andPLUSxor, NULL }  ,  { &&andPLUSxor, NULL } 
 ,  { &&andPLUSxor, NULL }  ,  { &&andPLUSxor, NULL }  ,  { &&andPLUSxor, NULL }  ,  { &&andPLUSxor, NULL }  ,  { &&andPLUSxor, NULL }  ,  { &&andPLUSxor, NULL }  ,  { &&andPLUSxor, NULL }  ,  { &&andPLUSxor, NULL }  ,  { &&andPLUSxor, NULL }  ,  { &&andPLUSxor, NULL } 
 ,  { &&andPLUSxor, NULL }  ,  { &&andPLUSxor, NULL }  ,  { &&andPLUSxor, NULL }  ,  { &&andPLUSxor, NULL }  ,  { &&andPLUSxor, NULL }  ,  { &&andPLUSxor, NULL }  ,  { &&andPLUSxor, NULL }  ,  { &&andPLUSxor, NULL }  ,  { &&andPLUSxor, NULL }  ,  { &&andPLUSxor, NULL } 
 ,  { &&andPLUSxor, NULL }  ,  { &&andPLUSxor, NULL }  ,  { &&andPLUSxor, NULL }  ,  { &&andPLUSxor, NULL }  ,  { &&andPLUSxor, NULL }  ,  { &&andPLUSxor, NULL }  ,  { &&andPLUSxor, NULL }  ,  { &&andPLUSxor, NULL }  ,  { &&andPLUSxor, NULL }  ,  { &&andPLUSxor, NULL } 
 ,  { &&andPLUSxor, NULL }  ,  { &&andPLUSxor, NULL }  ,  { &&andPLUSxor, NULL }  ,  { &&andPLUSxor, NULL }  ,  { &&andPLUSxor, NULL }  ,  { &&andPLUSxor, NULL }  ,  { &&andPLUSxor, NULL }  ,  { &&andPLUSxor, NULL }  ,  { &&andPLUSxorPLUSbne, NULL }  ,  { &&andPLUSxor, NULL } 
 ,  { &&andPLUSxor, NULL }  ,  { &&andPLUSxor, NULL }  ,  { &&andPLUSxor, NULL }  ,  { &&andPLUSxor, NULL }  ,  { &&andPLUSxor, NULL }  ,  { &&andPLUSxor, NULL }  ,  { &&andPLUSxor, NULL }  ,  { &&andPLUSxor, NULL }  ,  { &&andPLUSxor, NULL }  ,  { &&andPLUSxor, NULL } 
 ,  { &&andPLUSxor, NULL }  ,  { &&andPLUSxor, NULL }  ,  { &&andPLUSxor, NULL }  ,  { &&andPLUSxor, NULL }  ,  { &&andPLUSxor, NULL }  ,  { &&andPLUSxor, NULL }  ,  { &&andPLUSxor, NULL }  ,  { &&andPLUSxor, NULL }  ,  { &&andPLUSxor, NULL }  ,  { &&andPLUSxor, NULL } 
 ,  { &&andPLUSxor, NULL }  ,  { &&andPLUSxor, NULL }  ,  { &&andPLUSxor, NULL }  ,  { &&andPLUSxor, NULL }  ,  { &&andPLUSxor, NULL }  ,  { &&andPLUSxor, NULL }  ,  { &&andPLUSxor, NULL }  ,  { &&andPLUSxor, NULL }  ,  { &&andPLUSxor, NULL }  ,  { &&andPLUSxor, NULL } 
 ,  { &&andPLUSxor, NULL }  ,  { &&andPLUSxor, NULL }  ,  { &&andPLUSxor, NULL }  ,  { &&andPLUSxor, NULL }  ,  { &&andPLUSxor, NULL }  ,  { &&andPLUSxor, NULL }  ,  { &&andPLUSxor, NULL }  ,  { &&andPLUSxor, NULL }  ,  { &&andPLUSxor, NULL }  ,  { &&andPLUSxor, NULL } 
 ,  { &&andPLUSxor, NULL }  ,  { &&andPLUSxor, NULL }  ,  { &&andPLUSxor, NULL }  ,  { &&andPLUSxor, NULL }  ,  { &&andPLUSxor, NULL }  ,  { &&andPLUSxor, NULL }  ,  { &&andPLUSxor, NULL }  ,  { &&andPLUSxor, NULL }  ,  { &&andPLUSxor, NULL }  ,  { &&andPLUSxor, NULL } 
 ,  { &&andPLUSxor, NULL }  ,  { &&andPLUSxor, NULL }  ,  { &&andPLUSxor, NULL }  ,  { &&andPLUSxor, NULL }  ,  { &&andPLUSxor, NULL }  ,  { &&andPLUSxor, NULL }  ,  { &&andPLUSxor, NULL }  ,  { &&andPLUSxor, NULL }  ,  { &&andPLUSxor, NULL }  ,  { &&andPLUSxor, NULL } 
 }; 

struct pointer arrayjrPLUSaddiu[T_SIZE] = {  { &&jrPLUSaddiu, NULL }  ,  { &&jrPLUSaddiu, NULL }  ,  { &&jrPLUSaddiu, NULL }  ,  { &&jrPLUSaddiu, NULL }  ,  { &&jrPLUSaddiu, NULL }  ,  { &&jrPLUSaddiu, NULL }  ,  { &&jrPLUSaddiu, NULL }  ,  { &&jrPLUSaddiu, NULL }  ,  { &&jrPLUSaddiu, NULL }  ,  { &&jrPLUSaddiu, NULL } 
 ,  { &&jrPLUSaddiu, NULL }  ,  { &&jrPLUSaddiu, NULL }  ,  { &&jrPLUSaddiu, NULL }  ,  { &&jrPLUSaddiu, NULL }  ,  { &&jrPLUSaddiu, NULL }  ,  { &&jrPLUSaddiu, NULL }  ,  { &&jrPLUSaddiu, NULL }  ,  { &&jrPLUSaddiu, NULL }  ,  { &&jrPLUSaddiu, NULL }  ,  { &&jrPLUSaddiu, NULL } 
 ,  { &&jrPLUSaddiu, NULL }  ,  { &&jrPLUSaddiu, NULL }  ,  { &&jrPLUSaddiu, NULL }  ,  { &&jrPLUSaddiu, NULL }  ,  { &&jrPLUSaddiu, NULL }  ,  { &&jrPLUSaddiu, NULL }  ,  { &&jrPLUSaddiu, NULL }  ,  { &&jrPLUSaddiu, NULL }  ,  { &&jrPLUSaddiu, NULL }  ,  { &&jrPLUSaddiu, NULL } 
 ,  { &&jrPLUSaddiu, NULL }  ,  { &&jrPLUSaddiu, NULL }  ,  { &&jrPLUSaddiu, NULL }  ,  { &&jrPLUSaddiu, NULL }  ,  { &&jrPLUSaddiu, NULL }  ,  { &&jrPLUSaddiu, NULL }  ,  { &&jrPLUSaddiu, NULL }  ,  { &&jrPLUSaddiu, NULL }  ,  { &&jrPLUSaddiu, NULL }  ,  { &&jrPLUSaddiu, NULL } 
 ,  { &&jrPLUSaddiu, NULL }  ,  { &&jrPLUSaddiu, NULL }  ,  { &&jrPLUSaddiu, NULL }  ,  { &&jrPLUSaddiu, NULL }  ,  { &&jrPLUSaddiu, NULL }  ,  { &&jrPLUSaddiu, NULL }  ,  { &&jrPLUSaddiu, NULL }  ,  { &&jrPLUSaddiu, NULL }  ,  { &&jrPLUSaddiuPLUSbne, NULL }  ,  { &&jrPLUSaddiu, NULL } 
 ,  { &&jrPLUSaddiu, NULL }  ,  { &&jrPLUSaddiu, NULL }  ,  { &&jrPLUSaddiuPLUSaddiu, NULL }  ,  { &&jrPLUSaddiu, NULL }  ,  { &&jrPLUSaddiu, NULL }  ,  { &&jrPLUSaddiu, NULL }  ,  { &&jrPLUSaddiu, NULL }  ,  { &&jrPLUSaddiu, NULL }  ,  { &&jrPLUSaddiu, NULL }  ,  { &&jrPLUSaddiu, NULL } 
 ,  { &&jrPLUSaddiu, NULL }  ,  { &&jrPLUSaddiu, NULL }  ,  { &&jrPLUSaddiu, NULL }  ,  { &&jrPLUSaddiu, NULL }  ,  { &&jrPLUSaddiu, NULL }  ,  { &&jrPLUSaddiu, NULL }  ,  { &&jrPLUSaddiu, NULL }  ,  { &&jrPLUSaddiu, NULL }  ,  { &&jrPLUSaddiu, NULL }  ,  { &&jrPLUSaddiu, NULL } 
 ,  { &&jrPLUSaddiu, NULL }  ,  { &&jrPLUSaddiu, NULL }  ,  { &&jrPLUSaddiu, NULL }  ,  { &&jrPLUSaddiu, NULL }  ,  { &&jrPLUSaddiu, NULL }  ,  { &&jrPLUSaddiu, NULL }  ,  { &&jrPLUSaddiu, NULL }  ,  { &&jrPLUSaddiu, NULL }  ,  { &&jrPLUSaddiuPLUSlw, NULL }  ,  { &&jrPLUSaddiu, NULL } 
 ,  { &&jrPLUSaddiu, NULL }  ,  { &&jrPLUSaddiu, NULL }  ,  { &&jrPLUSaddiu, NULL }  ,  { &&jrPLUSaddiu, NULL }  ,  { &&jrPLUSaddiu, NULL }  ,  { &&jrPLUSaddiu, NULL }  ,  { &&jrPLUSaddiu, NULL }  ,  { &&jrPLUSaddiu, NULL }  ,  { &&jrPLUSaddiu, NULL }  ,  { &&jrPLUSaddiu, NULL } 
 ,  { &&jrPLUSaddiu, NULL }  ,  { &&jrPLUSaddiu, NULL }  ,  { &&jrPLUSaddiu, NULL }  ,  { &&jrPLUSaddiu, NULL }  ,  { &&jrPLUSaddiu, NULL }  ,  { &&jrPLUSaddiu, NULL }  ,  { &&jrPLUSaddiu, NULL }  ,  { &&jrPLUSaddiu, NULL }  ,  { &&jrPLUSaddiu, NULL }  ,  { &&jrPLUSaddiu, NULL } 
 ,  { &&jrPLUSaddiu, NULL }  ,  { &&jrPLUSaddiu, NULL }  ,  { &&jrPLUSaddiu, NULL }  ,  { &&jrPLUSaddiu, NULL }  ,  { &&jrPLUSaddiu, NULL }  ,  { &&jrPLUSaddiu, NULL }  ,  { &&jrPLUSaddiu, NULL }  ,  { &&jrPLUSaddiu, NULL }  ,  { &&jrPLUSaddiu, NULL }  ,  { &&jrPLUSaddiu, NULL } 
 }; 

struct pointer arrayxorPLUSerror[T_SIZE] = {  { &&xorPLUSerror, NULL }  ,  { &&xorPLUSerror, NULL }  ,  { &&xorPLUSerror, NULL }  ,  { &&xorPLUSerror, NULL }  ,  { &&xorPLUSerror, NULL }  ,  { &&xorPLUSerror, NULL }  ,  { &&xorPLUSerror, NULL }  ,  { &&xorPLUSerror, NULL }  ,  { &&xorPLUSerror, NULL }  ,  { &&xorPLUSerror, NULL } 
 ,  { &&xorPLUSerror, NULL }  ,  { &&xorPLUSerror, NULL }  ,  { &&xorPLUSerror, NULL }  ,  { &&xorPLUSerror, NULL }  ,  { &&xorPLUSerror, NULL }  ,  { &&xorPLUSerror, NULL }  ,  { &&xorPLUSerror, NULL }  ,  { &&xorPLUSerror, NULL }  ,  { &&xorPLUSerror, NULL }  ,  { &&xorPLUSerror, NULL } 
 ,  { &&xorPLUSerror, NULL }  ,  { &&xorPLUSerror, NULL }  ,  { &&xorPLUSerror, NULL }  ,  { &&xorPLUSerror, NULL }  ,  { &&xorPLUSerror, NULL }  ,  { &&xorPLUSerror, NULL }  ,  { &&xorPLUSerror, NULL }  ,  { &&xorPLUSerror, NULL }  ,  { &&xorPLUSerror, NULL }  ,  { &&xorPLUSerror, NULL } 
 ,  { &&xorPLUSerror, NULL }  ,  { &&xorPLUSerror, NULL }  ,  { &&xorPLUSerror, NULL }  ,  { &&xorPLUSerror, NULL }  ,  { &&xorPLUSerror, NULL }  ,  { &&xorPLUSerrorPLUSsubu, NULL }  ,  { &&xorPLUSerror, NULL }  ,  { &&xorPLUSerror, NULL }  ,  { &&xorPLUSerror, NULL }  ,  { &&xorPLUSerror, NULL } 
 ,  { &&xorPLUSerror, NULL }  ,  { &&xorPLUSerror, NULL }  ,  { &&xorPLUSerror, NULL }  ,  { &&xorPLUSerror, NULL }  ,  { &&xorPLUSerror, NULL }  ,  { &&xorPLUSerror, NULL }  ,  { &&xorPLUSerror, NULL }  ,  { &&xorPLUSerror, NULL }  ,  { &&xorPLUSerror, NULL }  ,  { &&xorPLUSerror, NULL } 
 ,  { &&xorPLUSerror, NULL }  ,  { &&xorPLUSerror, NULL }  ,  { &&xorPLUSerrorPLUSaddiu, NULL }  ,  { &&xorPLUSerror, NULL }  ,  { &&xorPLUSerror, NULL }  ,  { &&xorPLUSerror, NULL }  ,  { &&xorPLUSerror, NULL }  ,  { &&xorPLUSerror, NULL }  ,  { &&xorPLUSerror, NULL }  ,  { &&xorPLUSerror, NULL } 
 ,  { &&xorPLUSerror, NULL }  ,  { &&xorPLUSerror, NULL }  ,  { &&xorPLUSerror, NULL }  ,  { &&xorPLUSerror, NULL }  ,  { &&xorPLUSerror, NULL }  ,  { &&xorPLUSerror, NULL }  ,  { &&xorPLUSerror, NULL }  ,  { &&xorPLUSerror, NULL }  ,  { &&xorPLUSerror, NULL }  ,  { &&xorPLUSerror, NULL } 
 ,  { &&xorPLUSerror, NULL }  ,  { &&xorPLUSerror, NULL }  ,  { &&xorPLUSerror, NULL }  ,  { &&xorPLUSerror, NULL }  ,  { &&xorPLUSerror, NULL }  ,  { &&xorPLUSerror, NULL }  ,  { &&xorPLUSerror, NULL }  ,  { &&xorPLUSerror, NULL }  ,  { &&xorPLUSerror, NULL }  ,  { &&xorPLUSerror, NULL } 
 ,  { &&xorPLUSerror, NULL }  ,  { &&xorPLUSerror, NULL }  ,  { &&xorPLUSerror, NULL }  ,  { &&xorPLUSerror, NULL }  ,  { &&xorPLUSerror, NULL }  ,  { &&xorPLUSerror, NULL }  ,  { &&xorPLUSerror, NULL }  ,  { &&xorPLUSerror, NULL }  ,  { &&xorPLUSerror, NULL }  ,  { &&xorPLUSerror, NULL } 
 ,  { &&xorPLUSerror, NULL }  ,  { &&xorPLUSerror, NULL }  ,  { &&xorPLUSerror, NULL }  ,  { &&xorPLUSerror, NULL }  ,  { &&xorPLUSerror, NULL }  ,  { &&xorPLUSerror, NULL }  ,  { &&xorPLUSerror, NULL }  ,  { &&xorPLUSerror, NULL }  ,  { &&xorPLUSerror, NULL }  ,  { &&xorPLUSerror, NULL } 
 ,  { &&xorPLUSerror, NULL }  ,  { &&xorPLUSerror, NULL }  ,  { &&xorPLUSerror, NULL }  ,  { &&xorPLUSerror, NULL }  ,  { &&xorPLUSerror, NULL }  ,  { &&xorPLUSerror, NULL }  ,  { &&xorPLUSerror, NULL }  ,  { &&xorPLUSerror, NULL }  ,  { &&xorPLUSerror, NULL }  ,  { &&xorPLUSerror, NULL } 
 }; 

struct pointer arraymfhiPLUSsll[T_SIZE] = {  { &&mfhiPLUSsllPLUSsll, NULL }  ,  { &&mfhiPLUSsll, NULL }  ,  { &&mfhiPLUSsll, NULL }  ,  { &&mfhiPLUSsll, NULL }  ,  { &&mfhiPLUSsll, NULL }  ,  { &&mfhiPLUSsll, NULL }  ,  { &&mfhiPLUSsll, NULL }  ,  { &&mfhiPLUSsll, NULL }  ,  { &&mfhiPLUSsll, NULL }  ,  { &&mfhiPLUSsll, NULL } 
 ,  { &&mfhiPLUSsll, NULL }  ,  { &&mfhiPLUSsll, NULL }  ,  { &&mfhiPLUSsll, NULL }  ,  { &&mfhiPLUSsll, NULL }  ,  { &&mfhiPLUSsll, NULL }  ,  { &&mfhiPLUSsll, NULL }  ,  { &&mfhiPLUSsll, NULL }  ,  { &&mfhiPLUSsll, NULL }  ,  { &&mfhiPLUSsll, NULL }  ,  { &&mfhiPLUSsll, NULL } 
 ,  { &&mfhiPLUSsll, NULL }  ,  { &&mfhiPLUSsll, NULL }  ,  { &&mfhiPLUSsll, NULL }  ,  { &&mfhiPLUSsll, NULL }  ,  { &&mfhiPLUSsll, NULL }  ,  { &&mfhiPLUSsll, NULL }  ,  { &&mfhiPLUSsll, NULL }  ,  { &&mfhiPLUSsll, NULL }  ,  { &&mfhiPLUSsll, NULL }  ,  { &&mfhiPLUSsll, NULL } 
 ,  { &&mfhiPLUSsll, NULL }  ,  { &&mfhiPLUSsll, NULL }  ,  { &&mfhiPLUSsll, NULL }  ,  { &&mfhiPLUSsll, NULL }  ,  { &&mfhiPLUSsll, NULL }  ,  { &&mfhiPLUSsll, NULL }  ,  { &&mfhiPLUSsll, NULL }  ,  { &&mfhiPLUSsll, NULL }  ,  { &&mfhiPLUSsll, NULL }  ,  { &&mfhiPLUSsll, NULL } 
 ,  { &&mfhiPLUSsll, NULL }  ,  { &&mfhiPLUSsll, NULL }  ,  { &&mfhiPLUSsll, NULL }  ,  { &&mfhiPLUSsll, NULL }  ,  { &&mfhiPLUSsll, NULL }  ,  { &&mfhiPLUSsll, NULL }  ,  { &&mfhiPLUSsll, NULL }  ,  { &&mfhiPLUSsll, NULL }  ,  { &&mfhiPLUSsll, NULL }  ,  { &&mfhiPLUSsll, NULL } 
 ,  { &&mfhiPLUSsll, NULL }  ,  { &&mfhiPLUSsll, NULL }  ,  { &&mfhiPLUSsll, NULL }  ,  { &&mfhiPLUSsll, NULL }  ,  { &&mfhiPLUSsll, NULL }  ,  { &&mfhiPLUSsll, NULL }  ,  { &&mfhiPLUSsll, NULL }  ,  { &&mfhiPLUSsll, NULL }  ,  { &&mfhiPLUSsll, NULL }  ,  { &&mfhiPLUSsll, NULL } 
 ,  { &&mfhiPLUSsll, NULL }  ,  { &&mfhiPLUSsll, NULL }  ,  { &&mfhiPLUSsll, NULL }  ,  { &&mfhiPLUSsll, NULL }  ,  { &&mfhiPLUSsll, NULL }  ,  { &&mfhiPLUSsll, NULL }  ,  { &&mfhiPLUSsll, NULL }  ,  { &&mfhiPLUSsll, NULL }  ,  { &&mfhiPLUSsll, NULL }  ,  { &&mfhiPLUSsll, NULL } 
 ,  { &&mfhiPLUSsll, NULL }  ,  { &&mfhiPLUSsll, NULL }  ,  { &&mfhiPLUSsll, NULL }  ,  { &&mfhiPLUSsll, NULL }  ,  { &&mfhiPLUSsll, NULL }  ,  { &&mfhiPLUSsll, NULL }  ,  { &&mfhiPLUSsll, NULL }  ,  { &&mfhiPLUSsll, NULL }  ,  { &&mfhiPLUSsll, NULL }  ,  { &&mfhiPLUSsll, NULL } 
 ,  { &&mfhiPLUSsll, NULL }  ,  { &&mfhiPLUSsll, NULL }  ,  { &&mfhiPLUSsll, NULL }  ,  { &&mfhiPLUSsll, NULL }  ,  { &&mfhiPLUSsll, NULL }  ,  { &&mfhiPLUSsll, NULL }  ,  { &&mfhiPLUSsll, NULL }  ,  { &&mfhiPLUSsll, NULL }  ,  { &&mfhiPLUSsll, NULL }  ,  { &&mfhiPLUSsll, NULL } 
 ,  { &&mfhiPLUSsll, NULL }  ,  { &&mfhiPLUSsll, NULL }  ,  { &&mfhiPLUSsll, NULL }  ,  { &&mfhiPLUSsll, NULL }  ,  { &&mfhiPLUSsll, NULL }  ,  { &&mfhiPLUSsll, NULL }  ,  { &&mfhiPLUSsll, NULL }  ,  { &&mfhiPLUSsll, NULL }  ,  { &&mfhiPLUSsll, NULL }  ,  { &&mfhiPLUSsll, NULL } 
 ,  { &&mfhiPLUSsll, NULL }  ,  { &&mfhiPLUSsll, NULL }  ,  { &&mfhiPLUSsll, NULL }  ,  { &&mfhiPLUSsll, NULL }  ,  { &&mfhiPLUSsll, NULL }  ,  { &&mfhiPLUSsll, NULL }  ,  { &&mfhiPLUSsll, NULL }  ,  { &&mfhiPLUSsll, NULL }  ,  { &&mfhiPLUSsll, NULL }  ,  { &&mfhiPLUSsll, NULL } 
 }; 

struct pointer arrayjrPLUSor[T_SIZE] = {  { &&jrPLUSor, NULL }  ,  { &&jrPLUSor, NULL }  ,  { &&jrPLUSor, NULL }  ,  { &&jrPLUSor, NULL }  ,  { &&jrPLUSor, NULL }  ,  { &&jrPLUSor, NULL }  ,  { &&jrPLUSor, NULL }  ,  { &&jrPLUSor, NULL }  ,  { &&jrPLUSor, NULL }  ,  { &&jrPLUSor, NULL } 
 ,  { &&jrPLUSor, NULL }  ,  { &&jrPLUSor, NULL }  ,  { &&jrPLUSor, NULL }  ,  { &&jrPLUSor, NULL }  ,  { &&jrPLUSor, NULL }  ,  { &&jrPLUSor, NULL }  ,  { &&jrPLUSor, NULL }  ,  { &&jrPLUSor, NULL }  ,  { &&jrPLUSor, NULL }  ,  { &&jrPLUSor, NULL } 
 ,  { &&jrPLUSor, NULL }  ,  { &&jrPLUSor, NULL }  ,  { &&jrPLUSor, NULL }  ,  { &&jrPLUSor, NULL }  ,  { &&jrPLUSor, NULL }  ,  { &&jrPLUSor, NULL }  ,  { &&jrPLUSor, NULL }  ,  { &&jrPLUSor, NULL }  ,  { &&jrPLUSor, NULL }  ,  { &&jrPLUSor, NULL } 
 ,  { &&jrPLUSor, NULL }  ,  { &&jrPLUSor, NULL }  ,  { &&jrPLUSor, NULL }  ,  { &&jrPLUSorPLUSaddu, NULL }  ,  { &&jrPLUSor, NULL }  ,  { &&jrPLUSor, NULL }  ,  { &&jrPLUSor, NULL }  ,  { &&jrPLUSor, NULL }  ,  { &&jrPLUSor, NULL }  ,  { &&jrPLUSor, NULL } 
 ,  { &&jrPLUSor, NULL }  ,  { &&jrPLUSor, NULL }  ,  { &&jrPLUSor, NULL }  ,  { &&jrPLUSor, NULL }  ,  { &&jrPLUSor, NULL }  ,  { &&jrPLUSor, NULL }  ,  { &&jrPLUSor, NULL }  ,  { &&jrPLUSor, NULL }  ,  { &&jrPLUSor, NULL }  ,  { &&jrPLUSor, NULL } 
 ,  { &&jrPLUSor, NULL }  ,  { &&jrPLUSor, NULL }  ,  { &&jrPLUSor, NULL }  ,  { &&jrPLUSor, NULL }  ,  { &&jrPLUSor, NULL }  ,  { &&jrPLUSor, NULL }  ,  { &&jrPLUSor, NULL }  ,  { &&jrPLUSor, NULL }  ,  { &&jrPLUSor, NULL }  ,  { &&jrPLUSor, NULL } 
 ,  { &&jrPLUSor, NULL }  ,  { &&jrPLUSor, NULL }  ,  { &&jrPLUSor, NULL }  ,  { &&jrPLUSor, NULL }  ,  { &&jrPLUSor, NULL }  ,  { &&jrPLUSor, NULL }  ,  { &&jrPLUSor, NULL }  ,  { &&jrPLUSor, NULL }  ,  { &&jrPLUSor, NULL }  ,  { &&jrPLUSor, NULL } 
 ,  { &&jrPLUSor, NULL }  ,  { &&jrPLUSor, NULL }  ,  { &&jrPLUSor, NULL }  ,  { &&jrPLUSor, NULL }  ,  { &&jrPLUSor, NULL }  ,  { &&jrPLUSor, NULL }  ,  { &&jrPLUSor, NULL }  ,  { &&jrPLUSor, NULL }  ,  { &&jrPLUSor, NULL }  ,  { &&jrPLUSor, NULL } 
 ,  { &&jrPLUSor, NULL }  ,  { &&jrPLUSor, NULL }  ,  { &&jrPLUSor, NULL }  ,  { &&jrPLUSor, NULL }  ,  { &&jrPLUSor, NULL }  ,  { &&jrPLUSor, NULL }  ,  { &&jrPLUSor, NULL }  ,  { &&jrPLUSor, NULL }  ,  { &&jrPLUSor, NULL }  ,  { &&jrPLUSor, NULL } 
 ,  { &&jrPLUSor, NULL }  ,  { &&jrPLUSor, NULL }  ,  { &&jrPLUSor, NULL }  ,  { &&jrPLUSor, NULL }  ,  { &&jrPLUSor, NULL }  ,  { &&jrPLUSor, NULL }  ,  { &&jrPLUSor, NULL }  ,  { &&jrPLUSor, NULL }  ,  { &&jrPLUSor, NULL }  ,  { &&jrPLUSor, NULL } 
 ,  { &&jrPLUSor, NULL }  ,  { &&jrPLUSor, NULL }  ,  { &&jrPLUSor, NULL }  ,  { &&jrPLUSor, NULL }  ,  { &&jrPLUSor, NULL }  ,  { &&jrPLUSor, NULL }  ,  { &&jrPLUSor, NULL }  ,  { &&jrPLUSor, NULL }  ,  { &&jrPLUSor, NULL }  ,  { &&jrPLUSor, NULL } 
 }; 

struct pointer arrayaddiuPLUSjr[T_SIZE] = {  { &&addiuPLUSjrPLUSsll, NULL }  ,  { &&addiuPLUSjr, NULL }  ,  { &&addiuPLUSjr, NULL }  ,  { &&addiuPLUSjr, NULL }  ,  { &&addiuPLUSjr, NULL }  ,  { &&addiuPLUSjr, NULL }  ,  { &&addiuPLUSjr, NULL }  ,  { &&addiuPLUSjr, NULL }  ,  { &&addiuPLUSjr, NULL }  ,  { &&addiuPLUSjr, NULL } 
 ,  { &&addiuPLUSjr, NULL }  ,  { &&addiuPLUSjr, NULL }  ,  { &&addiuPLUSjr, NULL }  ,  { &&addiuPLUSjr, NULL }  ,  { &&addiuPLUSjr, NULL }  ,  { &&addiuPLUSjr, NULL }  ,  { &&addiuPLUSjr, NULL }  ,  { &&addiuPLUSjr, NULL }  ,  { &&addiuPLUSjr, NULL }  ,  { &&addiuPLUSjr, NULL } 
 ,  { &&addiuPLUSjr, NULL }  ,  { &&addiuPLUSjr, NULL }  ,  { &&addiuPLUSjr, NULL }  ,  { &&addiuPLUSjr, NULL }  ,  { &&addiuPLUSjr, NULL }  ,  { &&addiuPLUSjr, NULL }  ,  { &&addiuPLUSjr, NULL }  ,  { &&addiuPLUSjr, NULL }  ,  { &&addiuPLUSjr, NULL }  ,  { &&addiuPLUSjr, NULL } 
 ,  { &&addiuPLUSjr, NULL }  ,  { &&addiuPLUSjr, NULL }  ,  { &&addiuPLUSjr, NULL }  ,  { &&addiuPLUSjr, NULL }  ,  { &&addiuPLUSjr, NULL }  ,  { &&addiuPLUSjr, NULL }  ,  { &&addiuPLUSjr, NULL }  ,  { &&addiuPLUSjr, NULL }  ,  { &&addiuPLUSjr, NULL }  ,  { &&addiuPLUSjr, NULL } 
 ,  { &&addiuPLUSjr, NULL }  ,  { &&addiuPLUSjr, NULL }  ,  { &&addiuPLUSjr, NULL }  ,  { &&addiuPLUSjr, NULL }  ,  { &&addiuPLUSjr, NULL }  ,  { &&addiuPLUSjr, NULL }  ,  { &&addiuPLUSjr, NULL }  ,  { &&addiuPLUSjr, NULL }  ,  { &&addiuPLUSjr, NULL }  ,  { &&addiuPLUSjr, NULL } 
 ,  { &&addiuPLUSjr, NULL }  ,  { &&addiuPLUSjr, NULL }  ,  { &&addiuPLUSjr, NULL }  ,  { &&addiuPLUSjr, NULL }  ,  { &&addiuPLUSjr, NULL }  ,  { &&addiuPLUSjr, NULL }  ,  { &&addiuPLUSjr, NULL }  ,  { &&addiuPLUSjr, NULL }  ,  { &&addiuPLUSjr, NULL }  ,  { &&addiuPLUSjr, NULL } 
 ,  { &&addiuPLUSjr, NULL }  ,  { &&addiuPLUSjr, NULL }  ,  { &&addiuPLUSjr, NULL }  ,  { &&addiuPLUSjr, NULL }  ,  { &&addiuPLUSjr, NULL }  ,  { &&addiuPLUSjr, NULL }  ,  { &&addiuPLUSjr, NULL }  ,  { &&addiuPLUSjr, NULL }  ,  { &&addiuPLUSjr, NULL }  ,  { &&addiuPLUSjr, NULL } 
 ,  { &&addiuPLUSjr, NULL }  ,  { &&addiuPLUSjr, NULL }  ,  { &&addiuPLUSjr, NULL }  ,  { &&addiuPLUSjr, NULL }  ,  { &&addiuPLUSjr, NULL }  ,  { &&addiuPLUSjr, NULL }  ,  { &&addiuPLUSjr, NULL }  ,  { &&addiuPLUSjr, NULL }  ,  { &&addiuPLUSjr, NULL }  ,  { &&addiuPLUSjr, NULL } 
 ,  { &&addiuPLUSjr, NULL }  ,  { &&addiuPLUSjr, NULL }  ,  { &&addiuPLUSjr, NULL }  ,  { &&addiuPLUSjr, NULL }  ,  { &&addiuPLUSjr, NULL }  ,  { &&addiuPLUSjr, NULL }  ,  { &&addiuPLUSjr, NULL }  ,  { &&addiuPLUSjr, NULL }  ,  { &&addiuPLUSjr, NULL }  ,  { &&addiuPLUSjr, NULL } 
 ,  { &&addiuPLUSjr, NULL }  ,  { &&addiuPLUSjr, NULL }  ,  { &&addiuPLUSjr, NULL }  ,  { &&addiuPLUSjr, NULL }  ,  { &&addiuPLUSjr, NULL }  ,  { &&addiuPLUSjr, NULL }  ,  { &&addiuPLUSjr, NULL }  ,  { &&addiuPLUSjr, NULL }  ,  { &&addiuPLUSjr, NULL }  ,  { &&addiuPLUSjr, NULL } 
 ,  { &&addiuPLUSjr, NULL }  ,  { &&addiuPLUSjr, NULL }  ,  { &&addiuPLUSjr, NULL }  ,  { &&addiuPLUSjr, NULL }  ,  { &&addiuPLUSjr, NULL }  ,  { &&addiuPLUSjr, NULL }  ,  { &&addiuPLUSjr, NULL }  ,  { &&addiuPLUSjr, NULL }  ,  { &&addiuPLUSjr, NULL }  ,  { &&addiuPLUSjr, NULL } 
 }; 

struct pointer arraylwPLUSjr[T_SIZE] = {  { &&lwPLUSjr, NULL }  ,  { &&lwPLUSjr, NULL }  ,  { &&lwPLUSjr, NULL }  ,  { &&lwPLUSjr, NULL }  ,  { &&lwPLUSjr, NULL }  ,  { &&lwPLUSjr, NULL }  ,  { &&lwPLUSjr, NULL }  ,  { &&lwPLUSjr, NULL }  ,  { &&lwPLUSjr, NULL }  ,  { &&lwPLUSjr, NULL } 
 ,  { &&lwPLUSjr, NULL }  ,  { &&lwPLUSjr, NULL }  ,  { &&lwPLUSjr, NULL }  ,  { &&lwPLUSjr, NULL }  ,  { &&lwPLUSjr, NULL }  ,  { &&lwPLUSjr, NULL }  ,  { &&lwPLUSjr, NULL }  ,  { &&lwPLUSjr, NULL }  ,  { &&lwPLUSjr, NULL }  ,  { &&lwPLUSjr, NULL } 
 ,  { &&lwPLUSjr, NULL }  ,  { &&lwPLUSjr, NULL }  ,  { &&lwPLUSjr, NULL }  ,  { &&lwPLUSjr, NULL }  ,  { &&lwPLUSjr, NULL }  ,  { &&lwPLUSjr, NULL }  ,  { &&lwPLUSjr, NULL }  ,  { &&lwPLUSjr, NULL }  ,  { &&lwPLUSjr, NULL }  ,  { &&lwPLUSjr, NULL } 
 ,  { &&lwPLUSjr, NULL }  ,  { &&lwPLUSjr, NULL }  ,  { &&lwPLUSjr, NULL }  ,  { &&lwPLUSjr, NULL }  ,  { &&lwPLUSjr, NULL }  ,  { &&lwPLUSjr, NULL }  ,  { &&lwPLUSjr, NULL }  ,  { &&lwPLUSjr, NULL }  ,  { &&lwPLUSjr, NULL }  ,  { &&lwPLUSjr, NULL } 
 ,  { &&lwPLUSjr, NULL }  ,  { &&lwPLUSjr, NULL }  ,  { &&lwPLUSjr, NULL }  ,  { &&lwPLUSjr, NULL }  ,  { &&lwPLUSjr, NULL }  ,  { &&lwPLUSjr, NULL }  ,  { &&lwPLUSjr, NULL }  ,  { &&lwPLUSjr, NULL }  ,  { &&lwPLUSjr, NULL }  ,  { &&lwPLUSjr, NULL } 
 ,  { &&lwPLUSjr, NULL }  ,  { &&lwPLUSjr, NULL }  ,  { &&lwPLUSjrPLUSaddiu, NULL }  ,  { &&lwPLUSjr, NULL }  ,  { &&lwPLUSjr, NULL }  ,  { &&lwPLUSjr, NULL }  ,  { &&lwPLUSjr, NULL }  ,  { &&lwPLUSjr, NULL }  ,  { &&lwPLUSjr, NULL }  ,  { &&lwPLUSjr, NULL } 
 ,  { &&lwPLUSjr, NULL }  ,  { &&lwPLUSjr, NULL }  ,  { &&lwPLUSjr, NULL }  ,  { &&lwPLUSjr, NULL }  ,  { &&lwPLUSjr, NULL }  ,  { &&lwPLUSjr, NULL }  ,  { &&lwPLUSjr, NULL }  ,  { &&lwPLUSjr, NULL }  ,  { &&lwPLUSjr, NULL }  ,  { &&lwPLUSjr, NULL } 
 ,  { &&lwPLUSjr, NULL }  ,  { &&lwPLUSjr, NULL }  ,  { &&lwPLUSjr, NULL }  ,  { &&lwPLUSjr, NULL }  ,  { &&lwPLUSjr, NULL }  ,  { &&lwPLUSjr, NULL }  ,  { &&lwPLUSjr, NULL }  ,  { &&lwPLUSjr, NULL }  ,  { &&lwPLUSjr, NULL }  ,  { &&lwPLUSjr, NULL } 
 ,  { &&lwPLUSjr, NULL }  ,  { &&lwPLUSjr, NULL }  ,  { &&lwPLUSjr, NULL }  ,  { &&lwPLUSjr, NULL }  ,  { &&lwPLUSjr, NULL }  ,  { &&lwPLUSjr, NULL }  ,  { &&lwPLUSjr, NULL }  ,  { &&lwPLUSjr, NULL }  ,  { &&lwPLUSjr, NULL }  ,  { &&lwPLUSjr, NULL } 
 ,  { &&lwPLUSjr, NULL }  ,  { &&lwPLUSjr, NULL }  ,  { &&lwPLUSjr, NULL }  ,  { &&lwPLUSjr, NULL }  ,  { &&lwPLUSjr, NULL }  ,  { &&lwPLUSjr, NULL }  ,  { &&lwPLUSjr, NULL }  ,  { &&lwPLUSjr, NULL }  ,  { &&lwPLUSjr, NULL }  ,  { &&lwPLUSjr, NULL } 
 ,  { &&lwPLUSjr, NULL }  ,  { &&lwPLUSjr, NULL }  ,  { &&lwPLUSjr, NULL }  ,  { &&lwPLUSjr, NULL }  ,  { &&lwPLUSjr, NULL }  ,  { &&lwPLUSjr, NULL }  ,  { &&lwPLUSjr, NULL }  ,  { &&lwPLUSjr, NULL }  ,  { &&lwPLUSjr, NULL }  ,  { &&lwPLUSjr, NULL } 
 }; 

struct pointer arrayluiPLUSsw[T_SIZE] = {  { &&luiPLUSsw, NULL }  ,  { &&luiPLUSsw, NULL }  ,  { &&luiPLUSsw, NULL }  ,  { &&luiPLUSsw, NULL }  ,  { &&luiPLUSsw, NULL }  ,  { &&luiPLUSsw, NULL }  ,  { &&luiPLUSsw, NULL }  ,  { &&luiPLUSsw, NULL }  ,  { &&luiPLUSsw, NULL }  ,  { &&luiPLUSsw, NULL } 
 ,  { &&luiPLUSsw, NULL }  ,  { &&luiPLUSsw, NULL }  ,  { &&luiPLUSsw, NULL }  ,  { &&luiPLUSsw, NULL }  ,  { &&luiPLUSsw, NULL }  ,  { &&luiPLUSsw, NULL }  ,  { &&luiPLUSsw, NULL }  ,  { &&luiPLUSsw, NULL }  ,  { &&luiPLUSsw, NULL }  ,  { &&luiPLUSsw, NULL } 
 ,  { &&luiPLUSsw, NULL }  ,  { &&luiPLUSsw, NULL }  ,  { &&luiPLUSsw, NULL }  ,  { &&luiPLUSsw, NULL }  ,  { &&luiPLUSsw, NULL }  ,  { &&luiPLUSsw, NULL }  ,  { &&luiPLUSsw, NULL }  ,  { &&luiPLUSsw, NULL }  ,  { &&luiPLUSsw, NULL }  ,  { &&luiPLUSsw, NULL } 
 ,  { &&luiPLUSsw, NULL }  ,  { &&luiPLUSsw, NULL }  ,  { &&luiPLUSsw, NULL }  ,  { &&luiPLUSswPLUSaddu, NULL }  ,  { &&luiPLUSsw, NULL }  ,  { &&luiPLUSsw, NULL }  ,  { &&luiPLUSsw, NULL }  ,  { &&luiPLUSsw, NULL }  ,  { &&luiPLUSsw, NULL }  ,  { &&luiPLUSsw, NULL } 
 ,  { &&luiPLUSsw, NULL }  ,  { &&luiPLUSsw, NULL }  ,  { &&luiPLUSsw, NULL }  ,  { &&luiPLUSsw, NULL }  ,  { &&luiPLUSsw, NULL }  ,  { &&luiPLUSsw, NULL }  ,  { &&luiPLUSsw, NULL }  ,  { &&luiPLUSsw, NULL }  ,  { &&luiPLUSsw, NULL }  ,  { &&luiPLUSsw, NULL } 
 ,  { &&luiPLUSsw, NULL }  ,  { &&luiPLUSsw, NULL }  ,  { &&luiPLUSswPLUSaddiu, NULL }  ,  { &&luiPLUSsw, NULL }  ,  { &&luiPLUSsw, NULL }  ,  { &&luiPLUSsw, NULL }  ,  { &&luiPLUSsw, NULL }  ,  { &&luiPLUSsw, NULL }  ,  { &&luiPLUSswPLUSlui, NULL }  ,  { &&luiPLUSsw, NULL } 
 ,  { &&luiPLUSsw, NULL }  ,  { &&luiPLUSsw, NULL }  ,  { &&luiPLUSsw, NULL }  ,  { &&luiPLUSsw, NULL }  ,  { &&luiPLUSsw, NULL }  ,  { &&luiPLUSsw, NULL }  ,  { &&luiPLUSsw, NULL }  ,  { &&luiPLUSsw, NULL }  ,  { &&luiPLUSsw, NULL }  ,  { &&luiPLUSsw, NULL } 
 ,  { &&luiPLUSsw, NULL }  ,  { &&luiPLUSsw, NULL }  ,  { &&luiPLUSsw, NULL }  ,  { &&luiPLUSsw, NULL }  ,  { &&luiPLUSsw, NULL }  ,  { &&luiPLUSsw, NULL }  ,  { &&luiPLUSsw, NULL }  ,  { &&luiPLUSsw, NULL }  ,  { &&luiPLUSswPLUSlw, NULL }  ,  { &&luiPLUSsw, NULL } 
 ,  { &&luiPLUSsw, NULL }  ,  { &&luiPLUSsw, NULL }  ,  { &&luiPLUSsw, NULL }  ,  { &&luiPLUSsw, NULL }  ,  { &&luiPLUSsw, NULL }  ,  { &&luiPLUSsw, NULL }  ,  { &&luiPLUSsw, NULL }  ,  { &&luiPLUSsw, NULL }  ,  { &&luiPLUSsw, NULL }  ,  { &&luiPLUSsw, NULL } 
 ,  { &&luiPLUSsw, NULL }  ,  { &&luiPLUSsw, NULL }  ,  { &&luiPLUSsw, NULL }  ,  { &&luiPLUSsw, NULL }  ,  { &&luiPLUSsw, NULL }  ,  { &&luiPLUSsw, NULL }  ,  { &&luiPLUSsw, NULL }  ,  { &&luiPLUSsw, NULL }  ,  { &&luiPLUSsw, NULL }  ,  { &&luiPLUSsw, NULL } 
 ,  { &&luiPLUSsw, NULL }  ,  { &&luiPLUSsw, NULL }  ,  { &&luiPLUSsw, NULL }  ,  { &&luiPLUSsw, NULL }  ,  { &&luiPLUSsw, NULL }  ,  { &&luiPLUSsw, NULL }  ,  { &&luiPLUSsw, NULL }  ,  { &&luiPLUSsw, NULL }  ,  { &&luiPLUSsw, NULL }  ,  { &&luiPLUSsw, NULL } 
 }; 

struct pointer arrayerrorPLUSerror[T_SIZE] = {  { &&errorPLUSerror, NULL }  ,  { &&errorPLUSerror, NULL }  ,  { &&errorPLUSerror, NULL }  ,  { &&errorPLUSerror, NULL }  ,  { &&errorPLUSerror, NULL }  ,  { &&errorPLUSerror, NULL }  ,  { &&errorPLUSerror, NULL }  ,  { &&errorPLUSerror, NULL }  ,  { &&errorPLUSerror, NULL }  ,  { &&errorPLUSerror, NULL } 
 ,  { &&errorPLUSerror, NULL }  ,  { &&errorPLUSerror, NULL }  ,  { &&errorPLUSerror, NULL }  ,  { &&errorPLUSerror, NULL }  ,  { &&errorPLUSerror, NULL }  ,  { &&errorPLUSerror, NULL }  ,  { &&errorPLUSerror, NULL }  ,  { &&errorPLUSerror, NULL }  ,  { &&errorPLUSerror, NULL }  ,  { &&errorPLUSerror, NULL } 
 ,  { &&errorPLUSerror, NULL }  ,  { &&errorPLUSerror, NULL }  ,  { &&errorPLUSerror, NULL }  ,  { &&errorPLUSerror, NULL }  ,  { &&errorPLUSerror, NULL }  ,  { &&errorPLUSerror, NULL }  ,  { &&errorPLUSerror, NULL }  ,  { &&errorPLUSerror, NULL }  ,  { &&errorPLUSerror, NULL }  ,  { &&errorPLUSerror, NULL } 
 ,  { &&errorPLUSerror, NULL }  ,  { &&errorPLUSerror, NULL }  ,  { &&errorPLUSerror, NULL }  ,  { &&errorPLUSerror, NULL }  ,  { &&errorPLUSerror, NULL }  ,  { &&errorPLUSerror, NULL }  ,  { &&errorPLUSerror, NULL }  ,  { &&errorPLUSerror, NULL }  ,  { &&errorPLUSerror, NULL }  ,  { &&errorPLUSerror, NULL } 
 ,  { &&errorPLUSerror, NULL }  ,  { &&errorPLUSerror, NULL }  ,  { &&errorPLUSerror, NULL }  ,  { &&errorPLUSerror, NULL }  ,  { &&errorPLUSerror, NULL }  ,  { &&errorPLUSerror, NULL }  ,  { &&errorPLUSerror, NULL }  ,  { &&errorPLUSerror, NULL }  ,  { &&errorPLUSerror, NULL }  ,  { &&errorPLUSerror, NULL } 
 ,  { &&errorPLUSerror, NULL }  ,  { &&errorPLUSerror, NULL }  ,  { &&errorPLUSerror, NULL }  ,  { &&errorPLUSerror, NULL }  ,  { &&errorPLUSerror, NULL }  ,  { &&errorPLUSerror, NULL }  ,  { &&errorPLUSerror, NULL }  ,  { &&errorPLUSerror, NULL }  ,  { &&errorPLUSerror, NULL }  ,  { &&errorPLUSerror, NULL } 
 ,  { &&errorPLUSerror, NULL }  ,  { &&errorPLUSerror, NULL }  ,  { &&errorPLUSerror, NULL }  ,  { &&errorPLUSerror, NULL }  ,  { &&errorPLUSerror, NULL }  ,  { &&errorPLUSerror, NULL }  ,  { &&errorPLUSerror, NULL }  ,  { &&errorPLUSerror, NULL }  ,  { &&errorPLUSerror, NULL }  ,  { &&errorPLUSerror, NULL } 
 ,  { &&errorPLUSerror, NULL }  ,  { &&errorPLUSerror, NULL }  ,  { &&errorPLUSerror, NULL }  ,  { &&errorPLUSerror, NULL }  ,  { &&errorPLUSerror, NULL }  ,  { &&errorPLUSerror, NULL }  ,  { &&errorPLUSerror, NULL }  ,  { &&errorPLUSerror, NULL }  ,  { &&errorPLUSerrorPLUSlw, NULL }  ,  { &&errorPLUSerror, NULL } 
 ,  { &&errorPLUSerror, NULL }  ,  { &&errorPLUSerror, NULL }  ,  { &&errorPLUSerror, NULL }  ,  { &&errorPLUSerror, NULL }  ,  { &&errorPLUSerror, NULL }  ,  { &&errorPLUSerror, NULL }  ,  { &&errorPLUSerror, NULL }  ,  { &&errorPLUSerror, NULL }  ,  { &&errorPLUSerror, NULL }  ,  { &&errorPLUSerror, NULL } 
 ,  { &&errorPLUSerror, NULL }  ,  { &&errorPLUSerror, NULL }  ,  { &&errorPLUSerror, NULL }  ,  { &&errorPLUSerror, NULL }  ,  { &&errorPLUSerror, NULL }  ,  { &&errorPLUSerror, NULL }  ,  { &&errorPLUSerror, NULL }  ,  { &&errorPLUSerror, NULL }  ,  { &&errorPLUSerror, NULL }  ,  { &&errorPLUSerror, NULL } 
 ,  { &&errorPLUSerror, NULL }  ,  { &&errorPLUSerror, NULL }  ,  { &&errorPLUSerror, NULL }  ,  { &&errorPLUSerror, NULL }  ,  { &&errorPLUSerror, NULL }  ,  { &&errorPLUSerror, NULL }  ,  { &&errorPLUSerror, NULL }  ,  { &&errorPLUSerror, NULL }  ,  { &&errorPLUSerror, NULL }  ,  { &&errorPLUSerror, NULL } 
 }; 

struct pointer arraysubuPLUSand[T_SIZE] = {  { &&subuPLUSand, NULL }  ,  { &&subuPLUSand, NULL }  ,  { &&subuPLUSandPLUSsrl, NULL }  ,  { &&subuPLUSand, NULL }  ,  { &&subuPLUSand, NULL }  ,  { &&subuPLUSand, NULL }  ,  { &&subuPLUSand, NULL }  ,  { &&subuPLUSand, NULL }  ,  { &&subuPLUSand, NULL }  ,  { &&subuPLUSand, NULL } 
 ,  { &&subuPLUSand, NULL }  ,  { &&subuPLUSand, NULL }  ,  { &&subuPLUSand, NULL }  ,  { &&subuPLUSand, NULL }  ,  { &&subuPLUSand, NULL }  ,  { &&subuPLUSand, NULL }  ,  { &&subuPLUSand, NULL }  ,  { &&subuPLUSand, NULL }  ,  { &&subuPLUSand, NULL }  ,  { &&subuPLUSand, NULL } 
 ,  { &&subuPLUSand, NULL }  ,  { &&subuPLUSand, NULL }  ,  { &&subuPLUSand, NULL }  ,  { &&subuPLUSand, NULL }  ,  { &&subuPLUSand, NULL }  ,  { &&subuPLUSand, NULL }  ,  { &&subuPLUSand, NULL }  ,  { &&subuPLUSand, NULL }  ,  { &&subuPLUSand, NULL }  ,  { &&subuPLUSand, NULL } 
 ,  { &&subuPLUSand, NULL }  ,  { &&subuPLUSand, NULL }  ,  { &&subuPLUSand, NULL }  ,  { &&subuPLUSand, NULL }  ,  { &&subuPLUSand, NULL }  ,  { &&subuPLUSand, NULL }  ,  { &&subuPLUSand, NULL }  ,  { &&subuPLUSand, NULL }  ,  { &&subuPLUSandPLUSxor, NULL }  ,  { &&subuPLUSand, NULL } 
 ,  { &&subuPLUSand, NULL }  ,  { &&subuPLUSand, NULL }  ,  { &&subuPLUSand, NULL }  ,  { &&subuPLUSand, NULL }  ,  { &&subuPLUSand, NULL }  ,  { &&subuPLUSand, NULL }  ,  { &&subuPLUSand, NULL }  ,  { &&subuPLUSand, NULL }  ,  { &&subuPLUSand, NULL }  ,  { &&subuPLUSand, NULL } 
 ,  { &&subuPLUSand, NULL }  ,  { &&subuPLUSand, NULL }  ,  { &&subuPLUSand, NULL }  ,  { &&subuPLUSand, NULL }  ,  { &&subuPLUSand, NULL }  ,  { &&subuPLUSandPLUSandi, NULL }  ,  { &&subuPLUSand, NULL }  ,  { &&subuPLUSand, NULL }  ,  { &&subuPLUSand, NULL }  ,  { &&subuPLUSand, NULL } 
 ,  { &&subuPLUSand, NULL }  ,  { &&subuPLUSand, NULL }  ,  { &&subuPLUSand, NULL }  ,  { &&subuPLUSand, NULL }  ,  { &&subuPLUSand, NULL }  ,  { &&subuPLUSand, NULL }  ,  { &&subuPLUSand, NULL }  ,  { &&subuPLUSand, NULL }  ,  { &&subuPLUSand, NULL }  ,  { &&subuPLUSand, NULL } 
 ,  { &&subuPLUSand, NULL }  ,  { &&subuPLUSand, NULL }  ,  { &&subuPLUSand, NULL }  ,  { &&subuPLUSand, NULL }  ,  { &&subuPLUSand, NULL }  ,  { &&subuPLUSand, NULL }  ,  { &&subuPLUSand, NULL }  ,  { &&subuPLUSand, NULL }  ,  { &&subuPLUSand, NULL }  ,  { &&subuPLUSand, NULL } 
 ,  { &&subuPLUSand, NULL }  ,  { &&subuPLUSand, NULL }  ,  { &&subuPLUSand, NULL }  ,  { &&subuPLUSand, NULL }  ,  { &&subuPLUSand, NULL }  ,  { &&subuPLUSand, NULL }  ,  { &&subuPLUSand, NULL }  ,  { &&subuPLUSand, NULL }  ,  { &&subuPLUSand, NULL }  ,  { &&subuPLUSand, NULL } 
 ,  { &&subuPLUSand, NULL }  ,  { &&subuPLUSand, NULL }  ,  { &&subuPLUSand, NULL }  ,  { &&subuPLUSand, NULL }  ,  { &&subuPLUSand, NULL }  ,  { &&subuPLUSand, NULL }  ,  { &&subuPLUSand, NULL }  ,  { &&subuPLUSand, NULL }  ,  { &&subuPLUSand, NULL }  ,  { &&subuPLUSand, NULL } 
 ,  { &&subuPLUSand, NULL }  ,  { &&subuPLUSand, NULL }  ,  { &&subuPLUSand, NULL }  ,  { &&subuPLUSand, NULL }  ,  { &&subuPLUSand, NULL }  ,  { &&subuPLUSand, NULL }  ,  { &&subuPLUSand, NULL }  ,  { &&subuPLUSand, NULL }  ,  { &&subuPLUSand, NULL }  ,  { &&subuPLUSand, NULL } 
 }; 

struct pointer arrayshPLUSor[T_SIZE] = {  { &&shPLUSorPLUSsll, NULL }  ,  { &&shPLUSor, NULL }  ,  { &&shPLUSor, NULL }  ,  { &&shPLUSor, NULL }  ,  { &&shPLUSor, NULL }  ,  { &&shPLUSor, NULL }  ,  { &&shPLUSor, NULL }  ,  { &&shPLUSor, NULL }  ,  { &&shPLUSor, NULL }  ,  { &&shPLUSor, NULL } 
 ,  { &&shPLUSor, NULL }  ,  { &&shPLUSor, NULL }  ,  { &&shPLUSor, NULL }  ,  { &&shPLUSor, NULL }  ,  { &&shPLUSor, NULL }  ,  { &&shPLUSor, NULL }  ,  { &&shPLUSor, NULL }  ,  { &&shPLUSor, NULL }  ,  { &&shPLUSor, NULL }  ,  { &&shPLUSor, NULL } 
 ,  { &&shPLUSor, NULL }  ,  { &&shPLUSor, NULL }  ,  { &&shPLUSor, NULL }  ,  { &&shPLUSor, NULL }  ,  { &&shPLUSor, NULL }  ,  { &&shPLUSor, NULL }  ,  { &&shPLUSor, NULL }  ,  { &&shPLUSor, NULL }  ,  { &&shPLUSor, NULL }  ,  { &&shPLUSor, NULL } 
 ,  { &&shPLUSor, NULL }  ,  { &&shPLUSor, NULL }  ,  { &&shPLUSor, NULL }  ,  { &&shPLUSor, NULL }  ,  { &&shPLUSor, NULL }  ,  { &&shPLUSor, NULL }  ,  { &&shPLUSor, NULL }  ,  { &&shPLUSor, NULL }  ,  { &&shPLUSor, NULL }  ,  { &&shPLUSor, NULL } 
 ,  { &&shPLUSor, NULL }  ,  { &&shPLUSor, NULL }  ,  { &&shPLUSor, NULL }  ,  { &&shPLUSor, NULL }  ,  { &&shPLUSor, NULL }  ,  { &&shPLUSor, NULL }  ,  { &&shPLUSor, NULL }  ,  { &&shPLUSor, NULL }  ,  { &&shPLUSor, NULL }  ,  { &&shPLUSor, NULL } 
 ,  { &&shPLUSor, NULL }  ,  { &&shPLUSor, NULL }  ,  { &&shPLUSor, NULL }  ,  { &&shPLUSor, NULL }  ,  { &&shPLUSor, NULL }  ,  { &&shPLUSor, NULL }  ,  { &&shPLUSor, NULL }  ,  { &&shPLUSor, NULL }  ,  { &&shPLUSor, NULL }  ,  { &&shPLUSor, NULL } 
 ,  { &&shPLUSor, NULL }  ,  { &&shPLUSor, NULL }  ,  { &&shPLUSor, NULL }  ,  { &&shPLUSor, NULL }  ,  { &&shPLUSor, NULL }  ,  { &&shPLUSor, NULL }  ,  { &&shPLUSor, NULL }  ,  { &&shPLUSor, NULL }  ,  { &&shPLUSor, NULL }  ,  { &&shPLUSor, NULL } 
 ,  { &&shPLUSor, NULL }  ,  { &&shPLUSor, NULL }  ,  { &&shPLUSor, NULL }  ,  { &&shPLUSor, NULL }  ,  { &&shPLUSor, NULL }  ,  { &&shPLUSor, NULL }  ,  { &&shPLUSor, NULL }  ,  { &&shPLUSor, NULL }  ,  { &&shPLUSor, NULL }  ,  { &&shPLUSor, NULL } 
 ,  { &&shPLUSor, NULL }  ,  { &&shPLUSor, NULL }  ,  { &&shPLUSor, NULL }  ,  { &&shPLUSor, NULL }  ,  { &&shPLUSor, NULL }  ,  { &&shPLUSor, NULL }  ,  { &&shPLUSor, NULL }  ,  { &&shPLUSor, NULL }  ,  { &&shPLUSor, NULL }  ,  { &&shPLUSor, NULL } 
 ,  { &&shPLUSor, NULL }  ,  { &&shPLUSor, NULL }  ,  { &&shPLUSor, NULL }  ,  { &&shPLUSor, NULL }  ,  { &&shPLUSor, NULL }  ,  { &&shPLUSor, NULL }  ,  { &&shPLUSor, NULL }  ,  { &&shPLUSor, NULL }  ,  { &&shPLUSor, NULL }  ,  { &&shPLUSor, NULL } 
 ,  { &&shPLUSor, NULL }  ,  { &&shPLUSor, NULL }  ,  { &&shPLUSor, NULL }  ,  { &&shPLUSor, NULL }  ,  { &&shPLUSor, NULL }  ,  { &&shPLUSor, NULL }  ,  { &&shPLUSor, NULL }  ,  { &&shPLUSor, NULL }  ,  { &&shPLUSor, NULL }  ,  { &&shPLUSor, NULL } 
 }; 

struct pointer arrayadduPLUSlui[T_SIZE] = {  { &&adduPLUSlui, NULL }  ,  { &&adduPLUSlui, NULL }  ,  { &&adduPLUSlui, NULL }  ,  { &&adduPLUSlui, NULL }  ,  { &&adduPLUSlui, NULL }  ,  { &&adduPLUSlui, NULL }  ,  { &&adduPLUSlui, NULL }  ,  { &&adduPLUSlui, NULL }  ,  { &&adduPLUSlui, NULL }  ,  { &&adduPLUSlui, NULL } 
 ,  { &&adduPLUSlui, NULL }  ,  { &&adduPLUSlui, NULL }  ,  { &&adduPLUSlui, NULL }  ,  { &&adduPLUSlui, NULL }  ,  { &&adduPLUSlui, NULL }  ,  { &&adduPLUSlui, NULL }  ,  { &&adduPLUSlui, NULL }  ,  { &&adduPLUSlui, NULL }  ,  { &&adduPLUSlui, NULL }  ,  { &&adduPLUSlui, NULL } 
 ,  { &&adduPLUSlui, NULL }  ,  { &&adduPLUSlui, NULL }  ,  { &&adduPLUSlui, NULL }  ,  { &&adduPLUSlui, NULL }  ,  { &&adduPLUSlui, NULL }  ,  { &&adduPLUSlui, NULL }  ,  { &&adduPLUSlui, NULL }  ,  { &&adduPLUSlui, NULL }  ,  { &&adduPLUSlui, NULL }  ,  { &&adduPLUSlui, NULL } 
 ,  { &&adduPLUSlui, NULL }  ,  { &&adduPLUSlui, NULL }  ,  { &&adduPLUSlui, NULL }  ,  { &&adduPLUSlui, NULL }  ,  { &&adduPLUSlui, NULL }  ,  { &&adduPLUSlui, NULL }  ,  { &&adduPLUSlui, NULL }  ,  { &&adduPLUSlui, NULL }  ,  { &&adduPLUSlui, NULL }  ,  { &&adduPLUSlui, NULL } 
 ,  { &&adduPLUSlui, NULL }  ,  { &&adduPLUSlui, NULL }  ,  { &&adduPLUSlui, NULL }  ,  { &&adduPLUSlui, NULL }  ,  { &&adduPLUSlui, NULL }  ,  { &&adduPLUSlui, NULL }  ,  { &&adduPLUSlui, NULL }  ,  { &&adduPLUSlui, NULL }  ,  { &&adduPLUSlui, NULL }  ,  { &&adduPLUSlui, NULL } 
 ,  { &&adduPLUSlui, NULL }  ,  { &&adduPLUSlui, NULL }  ,  { &&adduPLUSluiPLUSaddiu, NULL }  ,  { &&adduPLUSlui, NULL }  ,  { &&adduPLUSlui, NULL }  ,  { &&adduPLUSlui, NULL }  ,  { &&adduPLUSlui, NULL }  ,  { &&adduPLUSlui, NULL }  ,  { &&adduPLUSlui, NULL }  ,  { &&adduPLUSlui, NULL } 
 ,  { &&adduPLUSlui, NULL }  ,  { &&adduPLUSlui, NULL }  ,  { &&adduPLUSlui, NULL }  ,  { &&adduPLUSlui, NULL }  ,  { &&adduPLUSlui, NULL }  ,  { &&adduPLUSlui, NULL }  ,  { &&adduPLUSlui, NULL }  ,  { &&adduPLUSlui, NULL }  ,  { &&adduPLUSlui, NULL }  ,  { &&adduPLUSlui, NULL } 
 ,  { &&adduPLUSlui, NULL }  ,  { &&adduPLUSlui, NULL }  ,  { &&adduPLUSlui, NULL }  ,  { &&adduPLUSlui, NULL }  ,  { &&adduPLUSlui, NULL }  ,  { &&adduPLUSlui, NULL }  ,  { &&adduPLUSlui, NULL }  ,  { &&adduPLUSlui, NULL }  ,  { &&adduPLUSlui, NULL }  ,  { &&adduPLUSlui, NULL } 
 ,  { &&adduPLUSlui, NULL }  ,  { &&adduPLUSlui, NULL }  ,  { &&adduPLUSlui, NULL }  ,  { &&adduPLUSlui, NULL }  ,  { &&adduPLUSlui, NULL }  ,  { &&adduPLUSlui, NULL }  ,  { &&adduPLUSluiPLUSsw, NULL }  ,  { &&adduPLUSlui, NULL }  ,  { &&adduPLUSlui, NULL }  ,  { &&adduPLUSlui, NULL } 
 ,  { &&adduPLUSlui, NULL }  ,  { &&adduPLUSlui, NULL }  ,  { &&adduPLUSlui, NULL }  ,  { &&adduPLUSlui, NULL }  ,  { &&adduPLUSlui, NULL }  ,  { &&adduPLUSlui, NULL }  ,  { &&adduPLUSlui, NULL }  ,  { &&adduPLUSlui, NULL }  ,  { &&adduPLUSlui, NULL }  ,  { &&adduPLUSlui, NULL } 
 ,  { &&adduPLUSlui, NULL }  ,  { &&adduPLUSlui, NULL }  ,  { &&adduPLUSlui, NULL }  ,  { &&adduPLUSlui, NULL }  ,  { &&adduPLUSlui, NULL }  ,  { &&adduPLUSlui, NULL }  ,  { &&adduPLUSlui, NULL }  ,  { &&adduPLUSlui, NULL }  ,  { &&adduPLUSlui, NULL }  ,  { &&adduPLUSlui, NULL } 
 }; 

struct pointer arraymultPLUSmfhi[T_SIZE] = {  { &&multPLUSmfhiPLUSsll, NULL }  ,  { &&multPLUSmfhi, NULL }  ,  { &&multPLUSmfhiPLUSsrl, NULL }  ,  { &&multPLUSmfhi, NULL }  ,  { &&multPLUSmfhi, NULL }  ,  { &&multPLUSmfhi, NULL }  ,  { &&multPLUSmfhi, NULL }  ,  { &&multPLUSmfhi, NULL }  ,  { &&multPLUSmfhi, NULL }  ,  { &&multPLUSmfhi, NULL } 
 ,  { &&multPLUSmfhi, NULL }  ,  { &&multPLUSmfhi, NULL }  ,  { &&multPLUSmfhi, NULL }  ,  { &&multPLUSmfhi, NULL }  ,  { &&multPLUSmfhi, NULL }  ,  { &&multPLUSmfhi, NULL }  ,  { &&multPLUSmfhi, NULL }  ,  { &&multPLUSmfhi, NULL }  ,  { &&multPLUSmfhi, NULL }  ,  { &&multPLUSmfhi, NULL } 
 ,  { &&multPLUSmfhi, NULL }  ,  { &&multPLUSmfhi, NULL }  ,  { &&multPLUSmfhi, NULL }  ,  { &&multPLUSmfhi, NULL }  ,  { &&multPLUSmfhiPLUSmult, NULL }  ,  { &&multPLUSmfhi, NULL }  ,  { &&multPLUSmfhi, NULL }  ,  { &&multPLUSmfhi, NULL }  ,  { &&multPLUSmfhi, NULL }  ,  { &&multPLUSmfhi, NULL } 
 ,  { &&multPLUSmfhi, NULL }  ,  { &&multPLUSmfhi, NULL }  ,  { &&multPLUSmfhi, NULL }  ,  { &&multPLUSmfhi, NULL }  ,  { &&multPLUSmfhi, NULL }  ,  { &&multPLUSmfhi, NULL }  ,  { &&multPLUSmfhi, NULL }  ,  { &&multPLUSmfhi, NULL }  ,  { &&multPLUSmfhi, NULL }  ,  { &&multPLUSmfhi, NULL } 
 ,  { &&multPLUSmfhi, NULL }  ,  { &&multPLUSmfhi, NULL }  ,  { &&multPLUSmfhi, NULL }  ,  { &&multPLUSmfhi, NULL }  ,  { &&multPLUSmfhi, NULL }  ,  { &&multPLUSmfhi, NULL }  ,  { &&multPLUSmfhi, NULL }  ,  { &&multPLUSmfhi, NULL }  ,  { &&multPLUSmfhi, NULL }  ,  { &&multPLUSmfhi, NULL } 
 ,  { &&multPLUSmfhi, NULL }  ,  { &&multPLUSmfhi, NULL }  ,  { &&multPLUSmfhiPLUSaddiu, NULL }  ,  { &&multPLUSmfhi, NULL }  ,  { &&multPLUSmfhi, NULL }  ,  { &&multPLUSmfhi, NULL }  ,  { &&multPLUSmfhi, NULL }  ,  { &&multPLUSmfhi, NULL }  ,  { &&multPLUSmfhi, NULL }  ,  { &&multPLUSmfhi, NULL } 
 ,  { &&multPLUSmfhi, NULL }  ,  { &&multPLUSmfhi, NULL }  ,  { &&multPLUSmfhi, NULL }  ,  { &&multPLUSmfhi, NULL }  ,  { &&multPLUSmfhi, NULL }  ,  { &&multPLUSmfhi, NULL }  ,  { &&multPLUSmfhi, NULL }  ,  { &&multPLUSmfhi, NULL }  ,  { &&multPLUSmfhi, NULL }  ,  { &&multPLUSmfhi, NULL } 
 ,  { &&multPLUSmfhi, NULL }  ,  { &&multPLUSmfhi, NULL }  ,  { &&multPLUSmfhi, NULL }  ,  { &&multPLUSmfhi, NULL }  ,  { &&multPLUSmfhi, NULL }  ,  { &&multPLUSmfhi, NULL }  ,  { &&multPLUSmfhi, NULL }  ,  { &&multPLUSmfhi, NULL }  ,  { &&multPLUSmfhi, NULL }  ,  { &&multPLUSmfhi, NULL } 
 ,  { &&multPLUSmfhi, NULL }  ,  { &&multPLUSmfhi, NULL }  ,  { &&multPLUSmfhi, NULL }  ,  { &&multPLUSmfhi, NULL }  ,  { &&multPLUSmfhi, NULL }  ,  { &&multPLUSmfhi, NULL }  ,  { &&multPLUSmfhi, NULL }  ,  { &&multPLUSmfhi, NULL }  ,  { &&multPLUSmfhi, NULL }  ,  { &&multPLUSmfhi, NULL } 
 ,  { &&multPLUSmfhi, NULL }  ,  { &&multPLUSmfhi, NULL }  ,  { &&multPLUSmfhi, NULL }  ,  { &&multPLUSmfhi, NULL }  ,  { &&multPLUSmfhi, NULL }  ,  { &&multPLUSmfhi, NULL }  ,  { &&multPLUSmfhi, NULL }  ,  { &&multPLUSmfhi, NULL }  ,  { &&multPLUSmfhi, NULL }  ,  { &&multPLUSmfhi, NULL } 
 ,  { &&multPLUSmfhi, NULL }  ,  { &&multPLUSmfhi, NULL }  ,  { &&multPLUSmfhi, NULL }  ,  { &&multPLUSmfhi, NULL }  ,  { &&multPLUSmfhi, NULL }  ,  { &&multPLUSmfhi, NULL }  ,  { &&multPLUSmfhi, NULL }  ,  { &&multPLUSmfhi, NULL }  ,  { &&multPLUSmfhi, NULL }  ,  { &&multPLUSmfhi, NULL } 
 }; 

struct pointer arrayswPLUSbne[T_SIZE] = {  { &&swPLUSbne, NULL }  ,  { &&swPLUSbne, NULL }  ,  { &&swPLUSbne, NULL }  ,  { &&swPLUSbne, NULL }  ,  { &&swPLUSbne, NULL }  ,  { &&swPLUSbne, NULL }  ,  { &&swPLUSbne, NULL }  ,  { &&swPLUSbne, NULL }  ,  { &&swPLUSbne, NULL }  ,  { &&swPLUSbne, NULL } 
 ,  { &&swPLUSbne, NULL }  ,  { &&swPLUSbne, NULL }  ,  { &&swPLUSbne, NULL }  ,  { &&swPLUSbne, NULL }  ,  { &&swPLUSbne, NULL }  ,  { &&swPLUSbne, NULL }  ,  { &&swPLUSbne, NULL }  ,  { &&swPLUSbne, NULL }  ,  { &&swPLUSbne, NULL }  ,  { &&swPLUSbne, NULL } 
 ,  { &&swPLUSbne, NULL }  ,  { &&swPLUSbne, NULL }  ,  { &&swPLUSbne, NULL }  ,  { &&swPLUSbne, NULL }  ,  { &&swPLUSbne, NULL }  ,  { &&swPLUSbne, NULL }  ,  { &&swPLUSbne, NULL }  ,  { &&swPLUSbne, NULL }  ,  { &&swPLUSbne, NULL }  ,  { &&swPLUSbne, NULL } 
 ,  { &&swPLUSbne, NULL }  ,  { &&swPLUSbne, NULL }  ,  { &&swPLUSbne, NULL }  ,  { &&swPLUSbnePLUSaddu, NULL }  ,  { &&swPLUSbne, NULL }  ,  { &&swPLUSbne, NULL }  ,  { &&swPLUSbne, NULL }  ,  { &&swPLUSbne, NULL }  ,  { &&swPLUSbne, NULL }  ,  { &&swPLUSbne, NULL } 
 ,  { &&swPLUSbne, NULL }  ,  { &&swPLUSbne, NULL }  ,  { &&swPLUSbne, NULL }  ,  { &&swPLUSbne, NULL }  ,  { &&swPLUSbne, NULL }  ,  { &&swPLUSbne, NULL }  ,  { &&swPLUSbne, NULL }  ,  { &&swPLUSbne, NULL }  ,  { &&swPLUSbne, NULL }  ,  { &&swPLUSbne, NULL } 
 ,  { &&swPLUSbne, NULL }  ,  { &&swPLUSbne, NULL }  ,  { &&swPLUSbne, NULL }  ,  { &&swPLUSbne, NULL }  ,  { &&swPLUSbne, NULL }  ,  { &&swPLUSbne, NULL }  ,  { &&swPLUSbne, NULL }  ,  { &&swPLUSbne, NULL }  ,  { &&swPLUSbne, NULL }  ,  { &&swPLUSbne, NULL } 
 ,  { &&swPLUSbne, NULL }  ,  { &&swPLUSbne, NULL }  ,  { &&swPLUSbne, NULL }  ,  { &&swPLUSbne, NULL }  ,  { &&swPLUSbne, NULL }  ,  { &&swPLUSbne, NULL }  ,  { &&swPLUSbne, NULL }  ,  { &&swPLUSbne, NULL }  ,  { &&swPLUSbne, NULL }  ,  { &&swPLUSbne, NULL } 
 ,  { &&swPLUSbne, NULL }  ,  { &&swPLUSbne, NULL }  ,  { &&swPLUSbne, NULL }  ,  { &&swPLUSbne, NULL }  ,  { &&swPLUSbne, NULL }  ,  { &&swPLUSbne, NULL }  ,  { &&swPLUSbne, NULL }  ,  { &&swPLUSbne, NULL }  ,  { &&swPLUSbne, NULL }  ,  { &&swPLUSbne, NULL } 
 ,  { &&swPLUSbne, NULL }  ,  { &&swPLUSbne, NULL }  ,  { &&swPLUSbne, NULL }  ,  { &&swPLUSbne, NULL }  ,  { &&swPLUSbne, NULL }  ,  { &&swPLUSbne, NULL }  ,  { &&swPLUSbne, NULL }  ,  { &&swPLUSbne, NULL }  ,  { &&swPLUSbne, NULL }  ,  { &&swPLUSbne, NULL } 
 ,  { &&swPLUSbne, NULL }  ,  { &&swPLUSbne, NULL }  ,  { &&swPLUSbne, NULL }  ,  { &&swPLUSbne, NULL }  ,  { &&swPLUSbne, NULL }  ,  { &&swPLUSbne, NULL }  ,  { &&swPLUSbne, NULL }  ,  { &&swPLUSbne, NULL }  ,  { &&swPLUSbne, NULL }  ,  { &&swPLUSbne, NULL } 
 ,  { &&swPLUSbne, NULL }  ,  { &&swPLUSbne, NULL }  ,  { &&swPLUSbne, NULL }  ,  { &&swPLUSbne, NULL }  ,  { &&swPLUSbne, NULL }  ,  { &&swPLUSbne, NULL }  ,  { &&swPLUSbne, NULL }  ,  { &&swPLUSbne, NULL }  ,  { &&swPLUSbne, NULL }  ,  { &&swPLUSbne, NULL } 
 }; 

struct pointer arraysllPLUSjump[T_SIZE] = {  { &&sllPLUSjumpPLUSsll, NULL }  ,  { &&sllPLUSjump, NULL }  ,  { &&sllPLUSjump, NULL }  ,  { &&sllPLUSjump, NULL }  ,  { &&sllPLUSjump, NULL }  ,  { &&sllPLUSjump, NULL }  ,  { &&sllPLUSjump, NULL }  ,  { &&sllPLUSjump, NULL }  ,  { &&sllPLUSjump, NULL }  ,  { &&sllPLUSjump, NULL } 
 ,  { &&sllPLUSjump, NULL }  ,  { &&sllPLUSjump, NULL }  ,  { &&sllPLUSjump, NULL }  ,  { &&sllPLUSjump, NULL }  ,  { &&sllPLUSjump, NULL }  ,  { &&sllPLUSjump, NULL }  ,  { &&sllPLUSjump, NULL }  ,  { &&sllPLUSjump, NULL }  ,  { &&sllPLUSjump, NULL }  ,  { &&sllPLUSjump, NULL } 
 ,  { &&sllPLUSjump, NULL }  ,  { &&sllPLUSjump, NULL }  ,  { &&sllPLUSjump, NULL }  ,  { &&sllPLUSjump, NULL }  ,  { &&sllPLUSjump, NULL }  ,  { &&sllPLUSjump, NULL }  ,  { &&sllPLUSjump, NULL }  ,  { &&sllPLUSjump, NULL }  ,  { &&sllPLUSjump, NULL }  ,  { &&sllPLUSjump, NULL } 
 ,  { &&sllPLUSjump, NULL }  ,  { &&sllPLUSjump, NULL }  ,  { &&sllPLUSjump, NULL }  ,  { &&sllPLUSjumpPLUSaddu, NULL }  ,  { &&sllPLUSjump, NULL }  ,  { &&sllPLUSjump, NULL }  ,  { &&sllPLUSjump, NULL }  ,  { &&sllPLUSjump, NULL }  ,  { &&sllPLUSjump, NULL }  ,  { &&sllPLUSjump, NULL } 
 ,  { &&sllPLUSjump, NULL }  ,  { &&sllPLUSjump, NULL }  ,  { &&sllPLUSjump, NULL }  ,  { &&sllPLUSjump, NULL }  ,  { &&sllPLUSjump, NULL }  ,  { &&sllPLUSjump, NULL }  ,  { &&sllPLUSjump, NULL }  ,  { &&sllPLUSjump, NULL }  ,  { &&sllPLUSjump, NULL }  ,  { &&sllPLUSjump, NULL } 
 ,  { &&sllPLUSjump, NULL }  ,  { &&sllPLUSjump, NULL }  ,  { &&sllPLUSjumpPLUSaddiu, NULL }  ,  { &&sllPLUSjump, NULL }  ,  { &&sllPLUSjump, NULL }  ,  { &&sllPLUSjump, NULL }  ,  { &&sllPLUSjump, NULL }  ,  { &&sllPLUSjump, NULL }  ,  { &&sllPLUSjump, NULL }  ,  { &&sllPLUSjump, NULL } 
 ,  { &&sllPLUSjump, NULL }  ,  { &&sllPLUSjump, NULL }  ,  { &&sllPLUSjump, NULL }  ,  { &&sllPLUSjump, NULL }  ,  { &&sllPLUSjump, NULL }  ,  { &&sllPLUSjump, NULL }  ,  { &&sllPLUSjump, NULL }  ,  { &&sllPLUSjump, NULL }  ,  { &&sllPLUSjump, NULL }  ,  { &&sllPLUSjump, NULL } 
 ,  { &&sllPLUSjump, NULL }  ,  { &&sllPLUSjump, NULL }  ,  { &&sllPLUSjump, NULL }  ,  { &&sllPLUSjump, NULL }  ,  { &&sllPLUSjump, NULL }  ,  { &&sllPLUSjump, NULL }  ,  { &&sllPLUSjump, NULL }  ,  { &&sllPLUSjump, NULL }  ,  { &&sllPLUSjump, NULL }  ,  { &&sllPLUSjump, NULL } 
 ,  { &&sllPLUSjump, NULL }  ,  { &&sllPLUSjump, NULL }  ,  { &&sllPLUSjump, NULL }  ,  { &&sllPLUSjump, NULL }  ,  { &&sllPLUSjump, NULL }  ,  { &&sllPLUSjump, NULL }  ,  { &&sllPLUSjumpPLUSsw, NULL }  ,  { &&sllPLUSjump, NULL }  ,  { &&sllPLUSjump, NULL }  ,  { &&sllPLUSjump, NULL } 
 ,  { &&sllPLUSjump, NULL }  ,  { &&sllPLUSjump, NULL }  ,  { &&sllPLUSjump, NULL }  ,  { &&sllPLUSjump, NULL }  ,  { &&sllPLUSjump, NULL }  ,  { &&sllPLUSjump, NULL }  ,  { &&sllPLUSjump, NULL }  ,  { &&sllPLUSjump, NULL }  ,  { &&sllPLUSjump, NULL }  ,  { &&sllPLUSjump, NULL } 
 ,  { &&sllPLUSjump, NULL }  ,  { &&sllPLUSjump, NULL }  ,  { &&sllPLUSjump, NULL }  ,  { &&sllPLUSjump, NULL }  ,  { &&sllPLUSjump, NULL }  ,  { &&sllPLUSjump, NULL }  ,  { &&sllPLUSjump, NULL }  ,  { &&sllPLUSjump, NULL }  ,  { &&sllPLUSjump, NULL }  ,  { &&sllPLUSjump, NULL } 
 }; 

struct pointer arrayaddiuPLUSandi[T_SIZE] = {  { &&addiuPLUSandiPLUSsll, NULL }  ,  { &&addiuPLUSandi, NULL }  ,  { &&addiuPLUSandi, NULL }  ,  { &&addiuPLUSandi, NULL }  ,  { &&addiuPLUSandi, NULL }  ,  { &&addiuPLUSandi, NULL }  ,  { &&addiuPLUSandi, NULL }  ,  { &&addiuPLUSandi, NULL }  ,  { &&addiuPLUSandi, NULL }  ,  { &&addiuPLUSandi, NULL } 
 ,  { &&addiuPLUSandi, NULL }  ,  { &&addiuPLUSandi, NULL }  ,  { &&addiuPLUSandi, NULL }  ,  { &&addiuPLUSandi, NULL }  ,  { &&addiuPLUSandi, NULL }  ,  { &&addiuPLUSandi, NULL }  ,  { &&addiuPLUSandi, NULL }  ,  { &&addiuPLUSandi, NULL }  ,  { &&addiuPLUSandi, NULL }  ,  { &&addiuPLUSandi, NULL } 
 ,  { &&addiuPLUSandi, NULL }  ,  { &&addiuPLUSandi, NULL }  ,  { &&addiuPLUSandi, NULL }  ,  { &&addiuPLUSandi, NULL }  ,  { &&addiuPLUSandi, NULL }  ,  { &&addiuPLUSandi, NULL }  ,  { &&addiuPLUSandi, NULL }  ,  { &&addiuPLUSandi, NULL }  ,  { &&addiuPLUSandi, NULL }  ,  { &&addiuPLUSandi, NULL } 
 ,  { &&addiuPLUSandi, NULL }  ,  { &&addiuPLUSandi, NULL }  ,  { &&addiuPLUSandi, NULL }  ,  { &&addiuPLUSandi, NULL }  ,  { &&addiuPLUSandi, NULL }  ,  { &&addiuPLUSandi, NULL }  ,  { &&addiuPLUSandi, NULL }  ,  { &&addiuPLUSandi, NULL }  ,  { &&addiuPLUSandi, NULL }  ,  { &&addiuPLUSandi, NULL } 
 ,  { &&addiuPLUSandi, NULL }  ,  { &&addiuPLUSandi, NULL }  ,  { &&addiuPLUSandi, NULL }  ,  { &&addiuPLUSandi, NULL }  ,  { &&addiuPLUSandi, NULL }  ,  { &&addiuPLUSandi, NULL }  ,  { &&addiuPLUSandi, NULL }  ,  { &&addiuPLUSandi, NULL }  ,  { &&addiuPLUSandi, NULL }  ,  { &&addiuPLUSandi, NULL } 
 ,  { &&addiuPLUSandi, NULL }  ,  { &&addiuPLUSandi, NULL }  ,  { &&addiuPLUSandi, NULL }  ,  { &&addiuPLUSandi, NULL }  ,  { &&addiuPLUSandi, NULL }  ,  { &&addiuPLUSandi, NULL }  ,  { &&addiuPLUSandi, NULL }  ,  { &&addiuPLUSandi, NULL }  ,  { &&addiuPLUSandi, NULL }  ,  { &&addiuPLUSandi, NULL } 
 ,  { &&addiuPLUSandi, NULL }  ,  { &&addiuPLUSandi, NULL }  ,  { &&addiuPLUSandi, NULL }  ,  { &&addiuPLUSandi, NULL }  ,  { &&addiuPLUSandi, NULL }  ,  { &&addiuPLUSandi, NULL }  ,  { &&addiuPLUSandi, NULL }  ,  { &&addiuPLUSandi, NULL }  ,  { &&addiuPLUSandi, NULL }  ,  { &&addiuPLUSandi, NULL } 
 ,  { &&addiuPLUSandi, NULL }  ,  { &&addiuPLUSandi, NULL }  ,  { &&addiuPLUSandi, NULL }  ,  { &&addiuPLUSandi, NULL }  ,  { &&addiuPLUSandi, NULL }  ,  { &&addiuPLUSandi, NULL }  ,  { &&addiuPLUSandi, NULL }  ,  { &&addiuPLUSandi, NULL }  ,  { &&addiuPLUSandi, NULL }  ,  { &&addiuPLUSandi, NULL } 
 ,  { &&addiuPLUSandi, NULL }  ,  { &&addiuPLUSandi, NULL }  ,  { &&addiuPLUSandi, NULL }  ,  { &&addiuPLUSandi, NULL }  ,  { &&addiuPLUSandi, NULL }  ,  { &&addiuPLUSandi, NULL }  ,  { &&addiuPLUSandi, NULL }  ,  { &&addiuPLUSandi, NULL }  ,  { &&addiuPLUSandi, NULL }  ,  { &&addiuPLUSandi, NULL } 
 ,  { &&addiuPLUSandi, NULL }  ,  { &&addiuPLUSandi, NULL }  ,  { &&addiuPLUSandi, NULL }  ,  { &&addiuPLUSandi, NULL }  ,  { &&addiuPLUSandi, NULL }  ,  { &&addiuPLUSandi, NULL }  ,  { &&addiuPLUSandi, NULL }  ,  { &&addiuPLUSandi, NULL }  ,  { &&addiuPLUSandi, NULL }  ,  { &&addiuPLUSandi, NULL } 
 ,  { &&addiuPLUSandi, NULL }  ,  { &&addiuPLUSandi, NULL }  ,  { &&addiuPLUSandi, NULL }  ,  { &&addiuPLUSandi, NULL }  ,  { &&addiuPLUSandi, NULL }  ,  { &&addiuPLUSandi, NULL }  ,  { &&addiuPLUSandi, NULL }  ,  { &&addiuPLUSandi, NULL }  ,  { &&addiuPLUSandi, NULL }  ,  { &&addiuPLUSandi, NULL } 
 }; 

struct pointer arraysltiPLUSbeq[T_SIZE] = {  { &&sltiPLUSbeqPLUSsll, NULL }  ,  { &&sltiPLUSbeq, NULL }  ,  { &&sltiPLUSbeq, NULL }  ,  { &&sltiPLUSbeq, NULL }  ,  { &&sltiPLUSbeq, NULL }  ,  { &&sltiPLUSbeq, NULL }  ,  { &&sltiPLUSbeq, NULL }  ,  { &&sltiPLUSbeq, NULL }  ,  { &&sltiPLUSbeq, NULL }  ,  { &&sltiPLUSbeq, NULL } 
 ,  { &&sltiPLUSbeq, NULL }  ,  { &&sltiPLUSbeq, NULL }  ,  { &&sltiPLUSbeq, NULL }  ,  { &&sltiPLUSbeq, NULL }  ,  { &&sltiPLUSbeq, NULL }  ,  { &&sltiPLUSbeq, NULL }  ,  { &&sltiPLUSbeq, NULL }  ,  { &&sltiPLUSbeq, NULL }  ,  { &&sltiPLUSbeq, NULL }  ,  { &&sltiPLUSbeq, NULL } 
 ,  { &&sltiPLUSbeq, NULL }  ,  { &&sltiPLUSbeq, NULL }  ,  { &&sltiPLUSbeq, NULL }  ,  { &&sltiPLUSbeq, NULL }  ,  { &&sltiPLUSbeq, NULL }  ,  { &&sltiPLUSbeq, NULL }  ,  { &&sltiPLUSbeq, NULL }  ,  { &&sltiPLUSbeq, NULL }  ,  { &&sltiPLUSbeq, NULL }  ,  { &&sltiPLUSbeq, NULL } 
 ,  { &&sltiPLUSbeq, NULL }  ,  { &&sltiPLUSbeq, NULL }  ,  { &&sltiPLUSbeq, NULL }  ,  { &&sltiPLUSbeqPLUSaddu, NULL }  ,  { &&sltiPLUSbeq, NULL }  ,  { &&sltiPLUSbeq, NULL }  ,  { &&sltiPLUSbeq, NULL }  ,  { &&sltiPLUSbeq, NULL }  ,  { &&sltiPLUSbeq, NULL }  ,  { &&sltiPLUSbeq, NULL } 
 ,  { &&sltiPLUSbeq, NULL }  ,  { &&sltiPLUSbeq, NULL }  ,  { &&sltiPLUSbeq, NULL }  ,  { &&sltiPLUSbeq, NULL }  ,  { &&sltiPLUSbeq, NULL }  ,  { &&sltiPLUSbeq, NULL }  ,  { &&sltiPLUSbeq, NULL }  ,  { &&sltiPLUSbeq, NULL }  ,  { &&sltiPLUSbeq, NULL }  ,  { &&sltiPLUSbeq, NULL } 
 ,  { &&sltiPLUSbeq, NULL }  ,  { &&sltiPLUSbeq, NULL }  ,  { &&sltiPLUSbeq, NULL }  ,  { &&sltiPLUSbeq, NULL }  ,  { &&sltiPLUSbeq, NULL }  ,  { &&sltiPLUSbeq, NULL }  ,  { &&sltiPLUSbeq, NULL }  ,  { &&sltiPLUSbeq, NULL }  ,  { &&sltiPLUSbeq, NULL }  ,  { &&sltiPLUSbeq, NULL } 
 ,  { &&sltiPLUSbeq, NULL }  ,  { &&sltiPLUSbeq, NULL }  ,  { &&sltiPLUSbeq, NULL }  ,  { &&sltiPLUSbeq, NULL }  ,  { &&sltiPLUSbeq, NULL }  ,  { &&sltiPLUSbeq, NULL }  ,  { &&sltiPLUSbeq, NULL }  ,  { &&sltiPLUSbeq, NULL }  ,  { &&sltiPLUSbeq, NULL }  ,  { &&sltiPLUSbeq, NULL } 
 ,  { &&sltiPLUSbeq, NULL }  ,  { &&sltiPLUSbeq, NULL }  ,  { &&sltiPLUSbeq, NULL }  ,  { &&sltiPLUSbeq, NULL }  ,  { &&sltiPLUSbeq, NULL }  ,  { &&sltiPLUSbeq, NULL }  ,  { &&sltiPLUSbeq, NULL }  ,  { &&sltiPLUSbeq, NULL }  ,  { &&sltiPLUSbeq, NULL }  ,  { &&sltiPLUSbeq, NULL } 
 ,  { &&sltiPLUSbeq, NULL }  ,  { &&sltiPLUSbeq, NULL }  ,  { &&sltiPLUSbeq, NULL }  ,  { &&sltiPLUSbeq, NULL }  ,  { &&sltiPLUSbeq, NULL }  ,  { &&sltiPLUSbeq, NULL }  ,  { &&sltiPLUSbeqPLUSsw, NULL }  ,  { &&sltiPLUSbeq, NULL }  ,  { &&sltiPLUSbeq, NULL }  ,  { &&sltiPLUSbeq, NULL } 
 ,  { &&sltiPLUSbeq, NULL }  ,  { &&sltiPLUSbeq, NULL }  ,  { &&sltiPLUSbeq, NULL }  ,  { &&sltiPLUSbeq, NULL }  ,  { &&sltiPLUSbeq, NULL }  ,  { &&sltiPLUSbeq, NULL }  ,  { &&sltiPLUSbeq, NULL }  ,  { &&sltiPLUSbeq, NULL }  ,  { &&sltiPLUSbeq, NULL }  ,  { &&sltiPLUSbeq, NULL } 
 ,  { &&sltiPLUSbeq, NULL }  ,  { &&sltiPLUSbeq, NULL }  ,  { &&sltiPLUSbeq, NULL }  ,  { &&sltiPLUSbeq, NULL }  ,  { &&sltiPLUSbeq, NULL }  ,  { &&sltiPLUSbeq, NULL }  ,  { &&sltiPLUSbeq, NULL }  ,  { &&sltiPLUSbeq, NULL }  ,  { &&sltiPLUSbeq, NULL }  ,  { &&sltiPLUSbeq, NULL } 
 }; 

struct pointer arraysrlPLUSaddu[T_SIZE] = {  { &&srlPLUSadduPLUSsll, NULL }  ,  { &&srlPLUSaddu, NULL }  ,  { &&srlPLUSaddu, NULL }  ,  { &&srlPLUSaddu, NULL }  ,  { &&srlPLUSaddu, NULL }  ,  { &&srlPLUSaddu, NULL }  ,  { &&srlPLUSaddu, NULL }  ,  { &&srlPLUSaddu, NULL }  ,  { &&srlPLUSaddu, NULL }  ,  { &&srlPLUSaddu, NULL } 
 ,  { &&srlPLUSaddu, NULL }  ,  { &&srlPLUSaddu, NULL }  ,  { &&srlPLUSaddu, NULL }  ,  { &&srlPLUSaddu, NULL }  ,  { &&srlPLUSaddu, NULL }  ,  { &&srlPLUSaddu, NULL }  ,  { &&srlPLUSaddu, NULL }  ,  { &&srlPLUSaddu, NULL }  ,  { &&srlPLUSaddu, NULL }  ,  { &&srlPLUSaddu, NULL } 
 ,  { &&srlPLUSaddu, NULL }  ,  { &&srlPLUSaddu, NULL }  ,  { &&srlPLUSaddu, NULL }  ,  { &&srlPLUSaddu, NULL }  ,  { &&srlPLUSaddu, NULL }  ,  { &&srlPLUSaddu, NULL }  ,  { &&srlPLUSaddu, NULL }  ,  { &&srlPLUSaddu, NULL }  ,  { &&srlPLUSaddu, NULL }  ,  { &&srlPLUSaddu, NULL } 
 ,  { &&srlPLUSaddu, NULL }  ,  { &&srlPLUSaddu, NULL }  ,  { &&srlPLUSaddu, NULL }  ,  { &&srlPLUSaddu, NULL }  ,  { &&srlPLUSaddu, NULL }  ,  { &&srlPLUSaddu, NULL }  ,  { &&srlPLUSaddu, NULL }  ,  { &&srlPLUSaddu, NULL }  ,  { &&srlPLUSaddu, NULL }  ,  { &&srlPLUSaddu, NULL } 
 ,  { &&srlPLUSaddu, NULL }  ,  { &&srlPLUSaddu, NULL }  ,  { &&srlPLUSaddu, NULL }  ,  { &&srlPLUSaddu, NULL }  ,  { &&srlPLUSaddu, NULL }  ,  { &&srlPLUSaddu, NULL }  ,  { &&srlPLUSaddu, NULL }  ,  { &&srlPLUSaddu, NULL }  ,  { &&srlPLUSaddu, NULL }  ,  { &&srlPLUSaddu, NULL } 
 ,  { &&srlPLUSaddu, NULL }  ,  { &&srlPLUSaddu, NULL }  ,  { &&srlPLUSaddu, NULL }  ,  { &&srlPLUSaddu, NULL }  ,  { &&srlPLUSaddu, NULL }  ,  { &&srlPLUSaddu, NULL }  ,  { &&srlPLUSaddu, NULL }  ,  { &&srlPLUSaddu, NULL }  ,  { &&srlPLUSaddu, NULL }  ,  { &&srlPLUSaddu, NULL } 
 ,  { &&srlPLUSaddu, NULL }  ,  { &&srlPLUSaddu, NULL }  ,  { &&srlPLUSaddu, NULL }  ,  { &&srlPLUSaddu, NULL }  ,  { &&srlPLUSaddu, NULL }  ,  { &&srlPLUSaddu, NULL }  ,  { &&srlPLUSaddu, NULL }  ,  { &&srlPLUSaddu, NULL }  ,  { &&srlPLUSaddu, NULL }  ,  { &&srlPLUSaddu, NULL } 
 ,  { &&srlPLUSaddu, NULL }  ,  { &&srlPLUSaddu, NULL }  ,  { &&srlPLUSaddu, NULL }  ,  { &&srlPLUSaddu, NULL }  ,  { &&srlPLUSaddu, NULL }  ,  { &&srlPLUSaddu, NULL }  ,  { &&srlPLUSaddu, NULL }  ,  { &&srlPLUSaddu, NULL }  ,  { &&srlPLUSaddu, NULL }  ,  { &&srlPLUSaddu, NULL } 
 ,  { &&srlPLUSaddu, NULL }  ,  { &&srlPLUSaddu, NULL }  ,  { &&srlPLUSaddu, NULL }  ,  { &&srlPLUSaddu, NULL }  ,  { &&srlPLUSaddu, NULL }  ,  { &&srlPLUSaddu, NULL }  ,  { &&srlPLUSaddu, NULL }  ,  { &&srlPLUSaddu, NULL }  ,  { &&srlPLUSaddu, NULL }  ,  { &&srlPLUSaddu, NULL } 
 ,  { &&srlPLUSaddu, NULL }  ,  { &&srlPLUSaddu, NULL }  ,  { &&srlPLUSaddu, NULL }  ,  { &&srlPLUSaddu, NULL }  ,  { &&srlPLUSaddu, NULL }  ,  { &&srlPLUSaddu, NULL }  ,  { &&srlPLUSaddu, NULL }  ,  { &&srlPLUSaddu, NULL }  ,  { &&srlPLUSaddu, NULL }  ,  { &&srlPLUSaddu, NULL } 
 ,  { &&srlPLUSaddu, NULL }  ,  { &&srlPLUSaddu, NULL }  ,  { &&srlPLUSaddu, NULL }  ,  { &&srlPLUSaddu, NULL }  ,  { &&srlPLUSaddu, NULL }  ,  { &&srlPLUSaddu, NULL }  ,  { &&srlPLUSaddu, NULL }  ,  { &&srlPLUSaddu, NULL }  ,  { &&srlPLUSaddu, NULL }  ,  { &&srlPLUSaddu, NULL } 
 }; 

struct pointer arrayaddiuPLUSaddu[T_SIZE] = {  { &&addiuPLUSadduPLUSsll, NULL }  ,  { &&addiuPLUSaddu, NULL }  ,  { &&addiuPLUSaddu, NULL }  ,  { &&addiuPLUSaddu, NULL }  ,  { &&addiuPLUSaddu, NULL }  ,  { &&addiuPLUSaddu, NULL }  ,  { &&addiuPLUSaddu, NULL }  ,  { &&addiuPLUSaddu, NULL }  ,  { &&addiuPLUSaddu, NULL }  ,  { &&addiuPLUSaddu, NULL } 
 ,  { &&addiuPLUSaddu, NULL }  ,  { &&addiuPLUSaddu, NULL }  ,  { &&addiuPLUSaddu, NULL }  ,  { &&addiuPLUSaddu, NULL }  ,  { &&addiuPLUSaddu, NULL }  ,  { &&addiuPLUSaddu, NULL }  ,  { &&addiuPLUSaddu, NULL }  ,  { &&addiuPLUSaddu, NULL }  ,  { &&addiuPLUSaddu, NULL }  ,  { &&addiuPLUSaddu, NULL } 
 ,  { &&addiuPLUSaddu, NULL }  ,  { &&addiuPLUSaddu, NULL }  ,  { &&addiuPLUSaddu, NULL }  ,  { &&addiuPLUSaddu, NULL }  ,  { &&addiuPLUSaddu, NULL }  ,  { &&addiuPLUSaddu, NULL }  ,  { &&addiuPLUSaddu, NULL }  ,  { &&addiuPLUSaddu, NULL }  ,  { &&addiuPLUSaddu, NULL }  ,  { &&addiuPLUSaddu, NULL } 
 ,  { &&addiuPLUSaddu, NULL }  ,  { &&addiuPLUSaddu, NULL }  ,  { &&addiuPLUSaddu, NULL }  ,  { &&addiuPLUSadduPLUSaddu, NULL }  ,  { &&addiuPLUSaddu, NULL }  ,  { &&addiuPLUSaddu, NULL }  ,  { &&addiuPLUSaddu, NULL }  ,  { &&addiuPLUSaddu, NULL }  ,  { &&addiuPLUSaddu, NULL }  ,  { &&addiuPLUSaddu, NULL } 
 ,  { &&addiuPLUSaddu, NULL }  ,  { &&addiuPLUSaddu, NULL }  ,  { &&addiuPLUSadduPLUSslt, NULL }  ,  { &&addiuPLUSaddu, NULL }  ,  { &&addiuPLUSaddu, NULL }  ,  { &&addiuPLUSaddu, NULL }  ,  { &&addiuPLUSaddu, NULL }  ,  { &&addiuPLUSaddu, NULL }  ,  { &&addiuPLUSaddu, NULL }  ,  { &&addiuPLUSaddu, NULL } 
 ,  { &&addiuPLUSaddu, NULL }  ,  { &&addiuPLUSaddu, NULL }  ,  { &&addiuPLUSadduPLUSaddiu, NULL }  ,  { &&addiuPLUSaddu, NULL }  ,  { &&addiuPLUSaddu, NULL }  ,  { &&addiuPLUSaddu, NULL }  ,  { &&addiuPLUSaddu, NULL }  ,  { &&addiuPLUSaddu, NULL }  ,  { &&addiuPLUSaddu, NULL }  ,  { &&addiuPLUSaddu, NULL } 
 ,  { &&addiuPLUSaddu, NULL }  ,  { &&addiuPLUSaddu, NULL }  ,  { &&addiuPLUSaddu, NULL }  ,  { &&addiuPLUSaddu, NULL }  ,  { &&addiuPLUSaddu, NULL }  ,  { &&addiuPLUSaddu, NULL }  ,  { &&addiuPLUSaddu, NULL }  ,  { &&addiuPLUSaddu, NULL }  ,  { &&addiuPLUSaddu, NULL }  ,  { &&addiuPLUSaddu, NULL } 
 ,  { &&addiuPLUSaddu, NULL }  ,  { &&addiuPLUSaddu, NULL }  ,  { &&addiuPLUSaddu, NULL }  ,  { &&addiuPLUSaddu, NULL }  ,  { &&addiuPLUSaddu, NULL }  ,  { &&addiuPLUSaddu, NULL }  ,  { &&addiuPLUSaddu, NULL }  ,  { &&addiuPLUSaddu, NULL }  ,  { &&addiuPLUSadduPLUSlw, NULL }  ,  { &&addiuPLUSaddu, NULL } 
 ,  { &&addiuPLUSaddu, NULL }  ,  { &&addiuPLUSaddu, NULL }  ,  { &&addiuPLUSaddu, NULL }  ,  { &&addiuPLUSaddu, NULL }  ,  { &&addiuPLUSaddu, NULL }  ,  { &&addiuPLUSaddu, NULL }  ,  { &&addiuPLUSadduPLUSsw, NULL }  ,  { &&addiuPLUSaddu, NULL }  ,  { &&addiuPLUSaddu, NULL }  ,  { &&addiuPLUSaddu, NULL } 
 ,  { &&addiuPLUSaddu, NULL }  ,  { &&addiuPLUSaddu, NULL }  ,  { &&addiuPLUSaddu, NULL }  ,  { &&addiuPLUSaddu, NULL }  ,  { &&addiuPLUSaddu, NULL }  ,  { &&addiuPLUSaddu, NULL }  ,  { &&addiuPLUSaddu, NULL }  ,  { &&addiuPLUSaddu, NULL }  ,  { &&addiuPLUSaddu, NULL }  ,  { &&addiuPLUSaddu, NULL } 
 ,  { &&addiuPLUSaddu, NULL }  ,  { &&addiuPLUSaddu, NULL }  ,  { &&addiuPLUSaddu, NULL }  ,  { &&addiuPLUSaddu, NULL }  ,  { &&addiuPLUSaddu, NULL }  ,  { &&addiuPLUSaddu, NULL }  ,  { &&addiuPLUSaddu, NULL }  ,  { &&addiuPLUSaddu, NULL }  ,  { &&addiuPLUSaddu, NULL }  ,  { &&addiuPLUSaddu, NULL } 
 }; 

struct pointer arrayswPLUSlw[T_SIZE] = {  { &&swPLUSlw, NULL }  ,  { &&swPLUSlw, NULL }  ,  { &&swPLUSlw, NULL }  ,  { &&swPLUSlw, NULL }  ,  { &&swPLUSlw, NULL }  ,  { &&swPLUSlw, NULL }  ,  { &&swPLUSlw, NULL }  ,  { &&swPLUSlw, NULL }  ,  { &&swPLUSlw, NULL }  ,  { &&swPLUSlw, NULL } 
 ,  { &&swPLUSlw, NULL }  ,  { &&swPLUSlw, NULL }  ,  { &&swPLUSlw, NULL }  ,  { &&swPLUSlw, NULL }  ,  { &&swPLUSlw, NULL }  ,  { &&swPLUSlw, NULL }  ,  { &&swPLUSlw, NULL }  ,  { &&swPLUSlw, NULL }  ,  { &&swPLUSlw, NULL }  ,  { &&swPLUSlw, NULL } 
 ,  { &&swPLUSlw, NULL }  ,  { &&swPLUSlw, NULL }  ,  { &&swPLUSlw, NULL }  ,  { &&swPLUSlw, NULL }  ,  { &&swPLUSlw, NULL }  ,  { &&swPLUSlw, NULL }  ,  { &&swPLUSlw, NULL }  ,  { &&swPLUSlw, NULL }  ,  { &&swPLUSlw, NULL }  ,  { &&swPLUSlw, NULL } 
 ,  { &&swPLUSlw, NULL }  ,  { &&swPLUSlw, NULL }  ,  { &&swPLUSlw, NULL }  ,  { &&swPLUSlw, NULL }  ,  { &&swPLUSlw, NULL }  ,  { &&swPLUSlw, NULL }  ,  { &&swPLUSlw, NULL }  ,  { &&swPLUSlw, NULL }  ,  { &&swPLUSlw, NULL }  ,  { &&swPLUSlw, NULL } 
 ,  { &&swPLUSlw, NULL }  ,  { &&swPLUSlw, NULL }  ,  { &&swPLUSlw, NULL }  ,  { &&swPLUSlw, NULL }  ,  { &&swPLUSlw, NULL }  ,  { &&swPLUSlw, NULL }  ,  { &&swPLUSlwPLUSjal, NULL }  ,  { &&swPLUSlwPLUSbeq, NULL }  ,  { &&swPLUSlw, NULL }  ,  { &&swPLUSlw, NULL } 
 ,  { &&swPLUSlw, NULL }  ,  { &&swPLUSlw, NULL }  ,  { &&swPLUSlwPLUSaddiu, NULL }  ,  { &&swPLUSlwPLUSslti, NULL }  ,  { &&swPLUSlw, NULL }  ,  { &&swPLUSlw, NULL }  ,  { &&swPLUSlw, NULL }  ,  { &&swPLUSlw, NULL }  ,  { &&swPLUSlw, NULL }  ,  { &&swPLUSlw, NULL } 
 ,  { &&swPLUSlw, NULL }  ,  { &&swPLUSlw, NULL }  ,  { &&swPLUSlw, NULL }  ,  { &&swPLUSlw, NULL }  ,  { &&swPLUSlw, NULL }  ,  { &&swPLUSlw, NULL }  ,  { &&swPLUSlw, NULL }  ,  { &&swPLUSlw, NULL }  ,  { &&swPLUSlw, NULL }  ,  { &&swPLUSlw, NULL } 
 ,  { &&swPLUSlw, NULL }  ,  { &&swPLUSlw, NULL }  ,  { &&swPLUSlw, NULL }  ,  { &&swPLUSlw, NULL }  ,  { &&swPLUSlw, NULL }  ,  { &&swPLUSlw, NULL }  ,  { &&swPLUSlw, NULL }  ,  { &&swPLUSlw, NULL }  ,  { &&swPLUSlwPLUSlw, NULL }  ,  { &&swPLUSlw, NULL } 
 ,  { &&swPLUSlw, NULL }  ,  { &&swPLUSlw, NULL }  ,  { &&swPLUSlw, NULL }  ,  { &&swPLUSlw, NULL }  ,  { &&swPLUSlw, NULL }  ,  { &&swPLUSlw, NULL }  ,  { &&swPLUSlwPLUSsw, NULL }  ,  { &&swPLUSlw, NULL }  ,  { &&swPLUSlw, NULL }  ,  { &&swPLUSlw, NULL } 
 ,  { &&swPLUSlw, NULL }  ,  { &&swPLUSlw, NULL }  ,  { &&swPLUSlw, NULL }  ,  { &&swPLUSlw, NULL }  ,  { &&swPLUSlw, NULL }  ,  { &&swPLUSlw, NULL }  ,  { &&swPLUSlw, NULL }  ,  { &&swPLUSlw, NULL }  ,  { &&swPLUSlw, NULL }  ,  { &&swPLUSlw, NULL } 
 ,  { &&swPLUSlw, NULL }  ,  { &&swPLUSlw, NULL }  ,  { &&swPLUSlw, NULL }  ,  { &&swPLUSlw, NULL }  ,  { &&swPLUSlw, NULL }  ,  { &&swPLUSlw, NULL }  ,  { &&swPLUSlw, NULL }  ,  { &&swPLUSlw, NULL }  ,  { &&swPLUSlw, NULL }  ,  { &&swPLUSlw, NULL } 
 }; 

struct pointer arrayluiPLUSlui[T_SIZE] = {  { &&luiPLUSlui, NULL }  ,  { &&luiPLUSlui, NULL }  ,  { &&luiPLUSluiPLUSsrl, NULL }  ,  { &&luiPLUSlui, NULL }  ,  { &&luiPLUSlui, NULL }  ,  { &&luiPLUSlui, NULL }  ,  { &&luiPLUSlui, NULL }  ,  { &&luiPLUSlui, NULL }  ,  { &&luiPLUSlui, NULL }  ,  { &&luiPLUSlui, NULL } 
 ,  { &&luiPLUSlui, NULL }  ,  { &&luiPLUSlui, NULL }  ,  { &&luiPLUSlui, NULL }  ,  { &&luiPLUSlui, NULL }  ,  { &&luiPLUSlui, NULL }  ,  { &&luiPLUSlui, NULL }  ,  { &&luiPLUSlui, NULL }  ,  { &&luiPLUSlui, NULL }  ,  { &&luiPLUSlui, NULL }  ,  { &&luiPLUSlui, NULL } 
 ,  { &&luiPLUSlui, NULL }  ,  { &&luiPLUSlui, NULL }  ,  { &&luiPLUSlui, NULL }  ,  { &&luiPLUSlui, NULL }  ,  { &&luiPLUSlui, NULL }  ,  { &&luiPLUSlui, NULL }  ,  { &&luiPLUSlui, NULL }  ,  { &&luiPLUSlui, NULL }  ,  { &&luiPLUSlui, NULL }  ,  { &&luiPLUSlui, NULL } 
 ,  { &&luiPLUSlui, NULL }  ,  { &&luiPLUSlui, NULL }  ,  { &&luiPLUSlui, NULL }  ,  { &&luiPLUSlui, NULL }  ,  { &&luiPLUSlui, NULL }  ,  { &&luiPLUSlui, NULL }  ,  { &&luiPLUSlui, NULL }  ,  { &&luiPLUSlui, NULL }  ,  { &&luiPLUSlui, NULL }  ,  { &&luiPLUSlui, NULL } 
 ,  { &&luiPLUSlui, NULL }  ,  { &&luiPLUSlui, NULL }  ,  { &&luiPLUSlui, NULL }  ,  { &&luiPLUSlui, NULL }  ,  { &&luiPLUSlui, NULL }  ,  { &&luiPLUSlui, NULL }  ,  { &&luiPLUSlui, NULL }  ,  { &&luiPLUSlui, NULL }  ,  { &&luiPLUSlui, NULL }  ,  { &&luiPLUSlui, NULL } 
 ,  { &&luiPLUSlui, NULL }  ,  { &&luiPLUSlui, NULL }  ,  { &&luiPLUSlui, NULL }  ,  { &&luiPLUSlui, NULL }  ,  { &&luiPLUSlui, NULL }  ,  { &&luiPLUSlui, NULL }  ,  { &&luiPLUSlui, NULL }  ,  { &&luiPLUSlui, NULL }  ,  { &&luiPLUSluiPLUSlui, NULL }  ,  { &&luiPLUSlui, NULL } 
 ,  { &&luiPLUSlui, NULL }  ,  { &&luiPLUSlui, NULL }  ,  { &&luiPLUSlui, NULL }  ,  { &&luiPLUSlui, NULL }  ,  { &&luiPLUSlui, NULL }  ,  { &&luiPLUSlui, NULL }  ,  { &&luiPLUSlui, NULL }  ,  { &&luiPLUSlui, NULL }  ,  { &&luiPLUSlui, NULL }  ,  { &&luiPLUSlui, NULL } 
 ,  { &&luiPLUSlui, NULL }  ,  { &&luiPLUSlui, NULL }  ,  { &&luiPLUSlui, NULL }  ,  { &&luiPLUSlui, NULL }  ,  { &&luiPLUSlui, NULL }  ,  { &&luiPLUSlui, NULL }  ,  { &&luiPLUSlui, NULL }  ,  { &&luiPLUSlui, NULL }  ,  { &&luiPLUSlui, NULL }  ,  { &&luiPLUSlui, NULL } 
 ,  { &&luiPLUSlui, NULL }  ,  { &&luiPLUSlui, NULL }  ,  { &&luiPLUSlui, NULL }  ,  { &&luiPLUSlui, NULL }  ,  { &&luiPLUSlui, NULL }  ,  { &&luiPLUSlui, NULL }  ,  { &&luiPLUSlui, NULL }  ,  { &&luiPLUSlui, NULL }  ,  { &&luiPLUSlui, NULL }  ,  { &&luiPLUSlui, NULL } 
 ,  { &&luiPLUSlui, NULL }  ,  { &&luiPLUSlui, NULL }  ,  { &&luiPLUSlui, NULL }  ,  { &&luiPLUSlui, NULL }  ,  { &&luiPLUSlui, NULL }  ,  { &&luiPLUSlui, NULL }  ,  { &&luiPLUSlui, NULL }  ,  { &&luiPLUSlui, NULL }  ,  { &&luiPLUSlui, NULL }  ,  { &&luiPLUSlui, NULL } 
 ,  { &&luiPLUSlui, NULL }  ,  { &&luiPLUSlui, NULL }  ,  { &&luiPLUSlui, NULL }  ,  { &&luiPLUSlui, NULL }  ,  { &&luiPLUSlui, NULL }  ,  { &&luiPLUSlui, NULL }  ,  { &&luiPLUSlui, NULL }  ,  { &&luiPLUSlui, NULL }  ,  { &&luiPLUSlui, NULL }  ,  { &&luiPLUSlui, NULL } 
 }; 

struct pointer arraysrlPLUSbne[T_SIZE] = {  { &&srlPLUSbne, NULL }  ,  { &&srlPLUSbne, NULL }  ,  { &&srlPLUSbne, NULL }  ,  { &&srlPLUSbne, NULL }  ,  { &&srlPLUSbne, NULL }  ,  { &&srlPLUSbne, NULL }  ,  { &&srlPLUSbne, NULL }  ,  { &&srlPLUSbne, NULL }  ,  { &&srlPLUSbne, NULL }  ,  { &&srlPLUSbne, NULL } 
 ,  { &&srlPLUSbne, NULL }  ,  { &&srlPLUSbne, NULL }  ,  { &&srlPLUSbne, NULL }  ,  { &&srlPLUSbne, NULL }  ,  { &&srlPLUSbne, NULL }  ,  { &&srlPLUSbne, NULL }  ,  { &&srlPLUSbne, NULL }  ,  { &&srlPLUSbne, NULL }  ,  { &&srlPLUSbne, NULL }  ,  { &&srlPLUSbne, NULL } 
 ,  { &&srlPLUSbne, NULL }  ,  { &&srlPLUSbne, NULL }  ,  { &&srlPLUSbne, NULL }  ,  { &&srlPLUSbne, NULL }  ,  { &&srlPLUSbne, NULL }  ,  { &&srlPLUSbne, NULL }  ,  { &&srlPLUSbne, NULL }  ,  { &&srlPLUSbne, NULL }  ,  { &&srlPLUSbne, NULL }  ,  { &&srlPLUSbne, NULL } 
 ,  { &&srlPLUSbne, NULL }  ,  { &&srlPLUSbne, NULL }  ,  { &&srlPLUSbne, NULL }  ,  { &&srlPLUSbne, NULL }  ,  { &&srlPLUSbne, NULL }  ,  { &&srlPLUSbne, NULL }  ,  { &&srlPLUSbne, NULL }  ,  { &&srlPLUSbne, NULL }  ,  { &&srlPLUSbnePLUSxor, NULL }  ,  { &&srlPLUSbne, NULL } 
 ,  { &&srlPLUSbne, NULL }  ,  { &&srlPLUSbne, NULL }  ,  { &&srlPLUSbne, NULL }  ,  { &&srlPLUSbne, NULL }  ,  { &&srlPLUSbne, NULL }  ,  { &&srlPLUSbne, NULL }  ,  { &&srlPLUSbne, NULL }  ,  { &&srlPLUSbne, NULL }  ,  { &&srlPLUSbne, NULL }  ,  { &&srlPLUSbne, NULL } 
 ,  { &&srlPLUSbne, NULL }  ,  { &&srlPLUSbne, NULL }  ,  { &&srlPLUSbne, NULL }  ,  { &&srlPLUSbne, NULL }  ,  { &&srlPLUSbne, NULL }  ,  { &&srlPLUSbne, NULL }  ,  { &&srlPLUSbne, NULL }  ,  { &&srlPLUSbne, NULL }  ,  { &&srlPLUSbne, NULL }  ,  { &&srlPLUSbne, NULL } 
 ,  { &&srlPLUSbne, NULL }  ,  { &&srlPLUSbne, NULL }  ,  { &&srlPLUSbne, NULL }  ,  { &&srlPLUSbne, NULL }  ,  { &&srlPLUSbne, NULL }  ,  { &&srlPLUSbne, NULL }  ,  { &&srlPLUSbne, NULL }  ,  { &&srlPLUSbne, NULL }  ,  { &&srlPLUSbne, NULL }  ,  { &&srlPLUSbne, NULL } 
 ,  { &&srlPLUSbne, NULL }  ,  { &&srlPLUSbne, NULL }  ,  { &&srlPLUSbne, NULL }  ,  { &&srlPLUSbne, NULL }  ,  { &&srlPLUSbne, NULL }  ,  { &&srlPLUSbne, NULL }  ,  { &&srlPLUSbne, NULL }  ,  { &&srlPLUSbne, NULL }  ,  { &&srlPLUSbne, NULL }  ,  { &&srlPLUSbne, NULL } 
 ,  { &&srlPLUSbne, NULL }  ,  { &&srlPLUSbne, NULL }  ,  { &&srlPLUSbne, NULL }  ,  { &&srlPLUSbne, NULL }  ,  { &&srlPLUSbne, NULL }  ,  { &&srlPLUSbne, NULL }  ,  { &&srlPLUSbne, NULL }  ,  { &&srlPLUSbne, NULL }  ,  { &&srlPLUSbne, NULL }  ,  { &&srlPLUSbne, NULL } 
 ,  { &&srlPLUSbne, NULL }  ,  { &&srlPLUSbne, NULL }  ,  { &&srlPLUSbne, NULL }  ,  { &&srlPLUSbne, NULL }  ,  { &&srlPLUSbne, NULL }  ,  { &&srlPLUSbne, NULL }  ,  { &&srlPLUSbne, NULL }  ,  { &&srlPLUSbne, NULL }  ,  { &&srlPLUSbne, NULL }  ,  { &&srlPLUSbne, NULL } 
 ,  { &&srlPLUSbne, NULL }  ,  { &&srlPLUSbne, NULL }  ,  { &&srlPLUSbne, NULL }  ,  { &&srlPLUSbne, NULL }  ,  { &&srlPLUSbne, NULL }  ,  { &&srlPLUSbne, NULL }  ,  { &&srlPLUSbne, NULL }  ,  { &&srlPLUSbne, NULL }  ,  { &&srlPLUSbne, NULL }  ,  { &&srlPLUSbne, NULL } 
 }; 

struct pointer arraybnePLUSaddiu[T_SIZE] = {  { &&bnePLUSaddiuPLUSsll, NULL }  ,  { &&bnePLUSaddiu, NULL }  ,  { &&bnePLUSaddiu, NULL }  ,  { &&bnePLUSaddiu, NULL }  ,  { &&bnePLUSaddiu, NULL }  ,  { &&bnePLUSaddiu, NULL }  ,  { &&bnePLUSaddiu, NULL }  ,  { &&bnePLUSaddiu, NULL }  ,  { &&bnePLUSaddiu, NULL }  ,  { &&bnePLUSaddiu, NULL } 
 ,  { &&bnePLUSaddiu, NULL }  ,  { &&bnePLUSaddiu, NULL }  ,  { &&bnePLUSaddiu, NULL }  ,  { &&bnePLUSaddiu, NULL }  ,  { &&bnePLUSaddiu, NULL }  ,  { &&bnePLUSaddiu, NULL }  ,  { &&bnePLUSaddiu, NULL }  ,  { &&bnePLUSaddiu, NULL }  ,  { &&bnePLUSaddiu, NULL }  ,  { &&bnePLUSaddiu, NULL } 
 ,  { &&bnePLUSaddiu, NULL }  ,  { &&bnePLUSaddiu, NULL }  ,  { &&bnePLUSaddiu, NULL }  ,  { &&bnePLUSaddiu, NULL }  ,  { &&bnePLUSaddiu, NULL }  ,  { &&bnePLUSaddiu, NULL }  ,  { &&bnePLUSaddiu, NULL }  ,  { &&bnePLUSaddiu, NULL }  ,  { &&bnePLUSaddiu, NULL }  ,  { &&bnePLUSaddiu, NULL } 
 ,  { &&bnePLUSaddiu, NULL }  ,  { &&bnePLUSaddiu, NULL }  ,  { &&bnePLUSaddiu, NULL }  ,  { &&bnePLUSaddiuPLUSaddu, NULL }  ,  { &&bnePLUSaddiu, NULL }  ,  { &&bnePLUSaddiuPLUSsubu, NULL }  ,  { &&bnePLUSaddiu, NULL }  ,  { &&bnePLUSaddiu, NULL }  ,  { &&bnePLUSaddiu, NULL }  ,  { &&bnePLUSaddiu, NULL } 
 ,  { &&bnePLUSaddiu, NULL }  ,  { &&bnePLUSaddiu, NULL }  ,  { &&bnePLUSaddiuPLUSslt, NULL }  ,  { &&bnePLUSaddiu, NULL }  ,  { &&bnePLUSaddiu, NULL }  ,  { &&bnePLUSaddiuPLUSjump, NULL }  ,  { &&bnePLUSaddiu, NULL }  ,  { &&bnePLUSaddiu, NULL }  ,  { &&bnePLUSaddiu, NULL }  ,  { &&bnePLUSaddiu, NULL } 
 ,  { &&bnePLUSaddiu, NULL }  ,  { &&bnePLUSaddiu, NULL }  ,  { &&bnePLUSaddiuPLUSaddiu, NULL }  ,  { &&bnePLUSaddiuPLUSslti, NULL }  ,  { &&bnePLUSaddiu, NULL }  ,  { &&bnePLUSaddiu, NULL }  ,  { &&bnePLUSaddiu, NULL }  ,  { &&bnePLUSaddiu, NULL }  ,  { &&bnePLUSaddiu, NULL }  ,  { &&bnePLUSaddiu, NULL } 
 ,  { &&bnePLUSaddiu, NULL }  ,  { &&bnePLUSaddiu, NULL }  ,  { &&bnePLUSaddiu, NULL }  ,  { &&bnePLUSaddiu, NULL }  ,  { &&bnePLUSaddiu, NULL }  ,  { &&bnePLUSaddiu, NULL }  ,  { &&bnePLUSaddiu, NULL }  ,  { &&bnePLUSaddiu, NULL }  ,  { &&bnePLUSaddiu, NULL }  ,  { &&bnePLUSaddiu, NULL } 
 ,  { &&bnePLUSaddiu, NULL }  ,  { &&bnePLUSaddiu, NULL }  ,  { &&bnePLUSaddiu, NULL }  ,  { &&bnePLUSaddiu, NULL }  ,  { &&bnePLUSaddiu, NULL }  ,  { &&bnePLUSaddiu, NULL }  ,  { &&bnePLUSaddiu, NULL }  ,  { &&bnePLUSaddiu, NULL }  ,  { &&bnePLUSaddiuPLUSlw, NULL }  ,  { &&bnePLUSaddiu, NULL } 
 ,  { &&bnePLUSaddiu, NULL }  ,  { &&bnePLUSaddiu, NULL }  ,  { &&bnePLUSaddiu, NULL }  ,  { &&bnePLUSaddiu, NULL }  ,  { &&bnePLUSaddiu, NULL }  ,  { &&bnePLUSaddiu, NULL }  ,  { &&bnePLUSaddiuPLUSsw, NULL }  ,  { &&bnePLUSaddiu, NULL }  ,  { &&bnePLUSaddiu, NULL }  ,  { &&bnePLUSaddiu, NULL } 
 ,  { &&bnePLUSaddiu, NULL }  ,  { &&bnePLUSaddiu, NULL }  ,  { &&bnePLUSaddiu, NULL }  ,  { &&bnePLUSaddiu, NULL }  ,  { &&bnePLUSaddiu, NULL }  ,  { &&bnePLUSaddiu, NULL }  ,  { &&bnePLUSaddiu, NULL }  ,  { &&bnePLUSaddiu, NULL }  ,  { &&bnePLUSaddiu, NULL }  ,  { &&bnePLUSaddiu, NULL } 
 ,  { &&bnePLUSaddiu, NULL }  ,  { &&bnePLUSaddiu, NULL }  ,  { &&bnePLUSaddiu, NULL }  ,  { &&bnePLUSaddiu, NULL }  ,  { &&bnePLUSaddiu, NULL }  ,  { &&bnePLUSaddiu, NULL }  ,  { &&bnePLUSaddiu, NULL }  ,  { &&bnePLUSaddiu, NULL }  ,  { &&bnePLUSaddiu, NULL }  ,  { &&bnePLUSaddiu, NULL } 
 }; 

struct pointer arraybgtzPLUSsll[T_SIZE] = {  { &&bgtzPLUSsllPLUSsll, NULL }  ,  { &&bgtzPLUSsll, NULL }  ,  { &&bgtzPLUSsll, NULL }  ,  { &&bgtzPLUSsll, NULL }  ,  { &&bgtzPLUSsll, NULL }  ,  { &&bgtzPLUSsll, NULL }  ,  { &&bgtzPLUSsll, NULL }  ,  { &&bgtzPLUSsll, NULL }  ,  { &&bgtzPLUSsll, NULL }  ,  { &&bgtzPLUSsll, NULL } 
 ,  { &&bgtzPLUSsll, NULL }  ,  { &&bgtzPLUSsll, NULL }  ,  { &&bgtzPLUSsll, NULL }  ,  { &&bgtzPLUSsll, NULL }  ,  { &&bgtzPLUSsll, NULL }  ,  { &&bgtzPLUSsll, NULL }  ,  { &&bgtzPLUSsll, NULL }  ,  { &&bgtzPLUSsll, NULL }  ,  { &&bgtzPLUSsll, NULL }  ,  { &&bgtzPLUSsll, NULL } 
 ,  { &&bgtzPLUSsll, NULL }  ,  { &&bgtzPLUSsll, NULL }  ,  { &&bgtzPLUSsll, NULL }  ,  { &&bgtzPLUSsll, NULL }  ,  { &&bgtzPLUSsll, NULL }  ,  { &&bgtzPLUSsll, NULL }  ,  { &&bgtzPLUSsll, NULL }  ,  { &&bgtzPLUSsll, NULL }  ,  { &&bgtzPLUSsll, NULL }  ,  { &&bgtzPLUSsll, NULL } 
 ,  { &&bgtzPLUSsll, NULL }  ,  { &&bgtzPLUSsll, NULL }  ,  { &&bgtzPLUSsll, NULL }  ,  { &&bgtzPLUSsll, NULL }  ,  { &&bgtzPLUSsll, NULL }  ,  { &&bgtzPLUSsll, NULL }  ,  { &&bgtzPLUSsll, NULL }  ,  { &&bgtzPLUSsll, NULL }  ,  { &&bgtzPLUSsll, NULL }  ,  { &&bgtzPLUSsll, NULL } 
 ,  { &&bgtzPLUSsll, NULL }  ,  { &&bgtzPLUSsll, NULL }  ,  { &&bgtzPLUSsllPLUSslt, NULL }  ,  { &&bgtzPLUSsll, NULL }  ,  { &&bgtzPLUSsll, NULL }  ,  { &&bgtzPLUSsll, NULL }  ,  { &&bgtzPLUSsll, NULL }  ,  { &&bgtzPLUSsll, NULL }  ,  { &&bgtzPLUSsllPLUSbne, NULL }  ,  { &&bgtzPLUSsll, NULL } 
 ,  { &&bgtzPLUSsll, NULL }  ,  { &&bgtzPLUSsll, NULL }  ,  { &&bgtzPLUSsll, NULL }  ,  { &&bgtzPLUSsll, NULL }  ,  { &&bgtzPLUSsll, NULL }  ,  { &&bgtzPLUSsll, NULL }  ,  { &&bgtzPLUSsll, NULL }  ,  { &&bgtzPLUSsll, NULL }  ,  { &&bgtzPLUSsll, NULL }  ,  { &&bgtzPLUSsll, NULL } 
 ,  { &&bgtzPLUSsll, NULL }  ,  { &&bgtzPLUSsll, NULL }  ,  { &&bgtzPLUSsll, NULL }  ,  { &&bgtzPLUSsll, NULL }  ,  { &&bgtzPLUSsll, NULL }  ,  { &&bgtzPLUSsll, NULL }  ,  { &&bgtzPLUSsll, NULL }  ,  { &&bgtzPLUSsll, NULL }  ,  { &&bgtzPLUSsll, NULL }  ,  { &&bgtzPLUSsll, NULL } 
 ,  { &&bgtzPLUSsll, NULL }  ,  { &&bgtzPLUSsll, NULL }  ,  { &&bgtzPLUSsll, NULL }  ,  { &&bgtzPLUSsll, NULL }  ,  { &&bgtzPLUSsll, NULL }  ,  { &&bgtzPLUSsll, NULL }  ,  { &&bgtzPLUSsll, NULL }  ,  { &&bgtzPLUSsll, NULL }  ,  { &&bgtzPLUSsll, NULL }  ,  { &&bgtzPLUSsll, NULL } 
 ,  { &&bgtzPLUSsll, NULL }  ,  { &&bgtzPLUSsll, NULL }  ,  { &&bgtzPLUSsll, NULL }  ,  { &&bgtzPLUSsll, NULL }  ,  { &&bgtzPLUSsll, NULL }  ,  { &&bgtzPLUSsll, NULL }  ,  { &&bgtzPLUSsll, NULL }  ,  { &&bgtzPLUSsll, NULL }  ,  { &&bgtzPLUSsll, NULL }  ,  { &&bgtzPLUSsll, NULL } 
 ,  { &&bgtzPLUSsll, NULL }  ,  { &&bgtzPLUSsll, NULL }  ,  { &&bgtzPLUSsll, NULL }  ,  { &&bgtzPLUSsll, NULL }  ,  { &&bgtzPLUSsll, NULL }  ,  { &&bgtzPLUSsll, NULL }  ,  { &&bgtzPLUSsll, NULL }  ,  { &&bgtzPLUSsll, NULL }  ,  { &&bgtzPLUSsll, NULL }  ,  { &&bgtzPLUSsll, NULL } 
 ,  { &&bgtzPLUSsll, NULL }  ,  { &&bgtzPLUSsll, NULL }  ,  { &&bgtzPLUSsll, NULL }  ,  { &&bgtzPLUSsll, NULL }  ,  { &&bgtzPLUSsll, NULL }  ,  { &&bgtzPLUSsll, NULL }  ,  { &&bgtzPLUSsll, NULL }  ,  { &&bgtzPLUSsll, NULL }  ,  { &&bgtzPLUSsll, NULL }  ,  { &&bgtzPLUSsll, NULL } 
 }; 

struct pointer arrayluiPLUSjal[T_SIZE] = {  { &&luiPLUSjal, NULL }  ,  { &&luiPLUSjal, NULL }  ,  { &&luiPLUSjal, NULL }  ,  { &&luiPLUSjal, NULL }  ,  { &&luiPLUSjal, NULL }  ,  { &&luiPLUSjal, NULL }  ,  { &&luiPLUSjal, NULL }  ,  { &&luiPLUSjal, NULL }  ,  { &&luiPLUSjal, NULL }  ,  { &&luiPLUSjal, NULL } 
 ,  { &&luiPLUSjal, NULL }  ,  { &&luiPLUSjal, NULL }  ,  { &&luiPLUSjal, NULL }  ,  { &&luiPLUSjal, NULL }  ,  { &&luiPLUSjal, NULL }  ,  { &&luiPLUSjal, NULL }  ,  { &&luiPLUSjal, NULL }  ,  { &&luiPLUSjal, NULL }  ,  { &&luiPLUSjal, NULL }  ,  { &&luiPLUSjal, NULL } 
 ,  { &&luiPLUSjal, NULL }  ,  { &&luiPLUSjal, NULL }  ,  { &&luiPLUSjal, NULL }  ,  { &&luiPLUSjal, NULL }  ,  { &&luiPLUSjal, NULL }  ,  { &&luiPLUSjal, NULL }  ,  { &&luiPLUSjal, NULL }  ,  { &&luiPLUSjal, NULL }  ,  { &&luiPLUSjal, NULL }  ,  { &&luiPLUSjal, NULL } 
 ,  { &&luiPLUSjal, NULL }  ,  { &&luiPLUSjal, NULL }  ,  { &&luiPLUSjal, NULL }  ,  { &&luiPLUSjal, NULL }  ,  { &&luiPLUSjal, NULL }  ,  { &&luiPLUSjal, NULL }  ,  { &&luiPLUSjal, NULL }  ,  { &&luiPLUSjal, NULL }  ,  { &&luiPLUSjal, NULL }  ,  { &&luiPLUSjal, NULL } 
 ,  { &&luiPLUSjal, NULL }  ,  { &&luiPLUSjal, NULL }  ,  { &&luiPLUSjal, NULL }  ,  { &&luiPLUSjal, NULL }  ,  { &&luiPLUSjal, NULL }  ,  { &&luiPLUSjal, NULL }  ,  { &&luiPLUSjal, NULL }  ,  { &&luiPLUSjal, NULL }  ,  { &&luiPLUSjal, NULL }  ,  { &&luiPLUSjal, NULL } 
 ,  { &&luiPLUSjal, NULL }  ,  { &&luiPLUSjal, NULL }  ,  { &&luiPLUSjalPLUSaddiu, NULL }  ,  { &&luiPLUSjal, NULL }  ,  { &&luiPLUSjal, NULL }  ,  { &&luiPLUSjal, NULL }  ,  { &&luiPLUSjal, NULL }  ,  { &&luiPLUSjal, NULL }  ,  { &&luiPLUSjal, NULL }  ,  { &&luiPLUSjal, NULL } 
 ,  { &&luiPLUSjal, NULL }  ,  { &&luiPLUSjal, NULL }  ,  { &&luiPLUSjal, NULL }  ,  { &&luiPLUSjal, NULL }  ,  { &&luiPLUSjal, NULL }  ,  { &&luiPLUSjal, NULL }  ,  { &&luiPLUSjal, NULL }  ,  { &&luiPLUSjal, NULL }  ,  { &&luiPLUSjal, NULL }  ,  { &&luiPLUSjal, NULL } 
 ,  { &&luiPLUSjal, NULL }  ,  { &&luiPLUSjal, NULL }  ,  { &&luiPLUSjal, NULL }  ,  { &&luiPLUSjal, NULL }  ,  { &&luiPLUSjal, NULL }  ,  { &&luiPLUSjal, NULL }  ,  { &&luiPLUSjal, NULL }  ,  { &&luiPLUSjal, NULL }  ,  { &&luiPLUSjal, NULL }  ,  { &&luiPLUSjal, NULL } 
 ,  { &&luiPLUSjal, NULL }  ,  { &&luiPLUSjal, NULL }  ,  { &&luiPLUSjal, NULL }  ,  { &&luiPLUSjal, NULL }  ,  { &&luiPLUSjal, NULL }  ,  { &&luiPLUSjal, NULL }  ,  { &&luiPLUSjal, NULL }  ,  { &&luiPLUSjal, NULL }  ,  { &&luiPLUSjal, NULL }  ,  { &&luiPLUSjal, NULL } 
 ,  { &&luiPLUSjal, NULL }  ,  { &&luiPLUSjal, NULL }  ,  { &&luiPLUSjal, NULL }  ,  { &&luiPLUSjal, NULL }  ,  { &&luiPLUSjal, NULL }  ,  { &&luiPLUSjal, NULL }  ,  { &&luiPLUSjal, NULL }  ,  { &&luiPLUSjal, NULL }  ,  { &&luiPLUSjal, NULL }  ,  { &&luiPLUSjal, NULL } 
 ,  { &&luiPLUSjal, NULL }  ,  { &&luiPLUSjal, NULL }  ,  { &&luiPLUSjal, NULL }  ,  { &&luiPLUSjal, NULL }  ,  { &&luiPLUSjal, NULL }  ,  { &&luiPLUSjal, NULL }  ,  { &&luiPLUSjal, NULL }  ,  { &&luiPLUSjal, NULL }  ,  { &&luiPLUSjal, NULL }  ,  { &&luiPLUSjal, NULL } 
 }; 

struct pointer arraysraPLUSaddu[T_SIZE] = {  { &&sraPLUSadduPLUSsll, NULL }  ,  { &&sraPLUSaddu, NULL }  ,  { &&sraPLUSaddu, NULL }  ,  { &&sraPLUSaddu, NULL }  ,  { &&sraPLUSaddu, NULL }  ,  { &&sraPLUSaddu, NULL }  ,  { &&sraPLUSaddu, NULL }  ,  { &&sraPLUSaddu, NULL }  ,  { &&sraPLUSaddu, NULL }  ,  { &&sraPLUSaddu, NULL } 
 ,  { &&sraPLUSaddu, NULL }  ,  { &&sraPLUSaddu, NULL }  ,  { &&sraPLUSaddu, NULL }  ,  { &&sraPLUSaddu, NULL }  ,  { &&sraPLUSaddu, NULL }  ,  { &&sraPLUSaddu, NULL }  ,  { &&sraPLUSaddu, NULL }  ,  { &&sraPLUSaddu, NULL }  ,  { &&sraPLUSaddu, NULL }  ,  { &&sraPLUSaddu, NULL } 
 ,  { &&sraPLUSaddu, NULL }  ,  { &&sraPLUSaddu, NULL }  ,  { &&sraPLUSaddu, NULL }  ,  { &&sraPLUSaddu, NULL }  ,  { &&sraPLUSaddu, NULL }  ,  { &&sraPLUSaddu, NULL }  ,  { &&sraPLUSaddu, NULL }  ,  { &&sraPLUSaddu, NULL }  ,  { &&sraPLUSaddu, NULL }  ,  { &&sraPLUSaddu, NULL } 
 ,  { &&sraPLUSaddu, NULL }  ,  { &&sraPLUSaddu, NULL }  ,  { &&sraPLUSaddu, NULL }  ,  { &&sraPLUSaddu, NULL }  ,  { &&sraPLUSaddu, NULL }  ,  { &&sraPLUSaddu, NULL }  ,  { &&sraPLUSaddu, NULL }  ,  { &&sraPLUSaddu, NULL }  ,  { &&sraPLUSaddu, NULL }  ,  { &&sraPLUSaddu, NULL } 
 ,  { &&sraPLUSaddu, NULL }  ,  { &&sraPLUSaddu, NULL }  ,  { &&sraPLUSaddu, NULL }  ,  { &&sraPLUSaddu, NULL }  ,  { &&sraPLUSaddu, NULL }  ,  { &&sraPLUSaddu, NULL }  ,  { &&sraPLUSaddu, NULL }  ,  { &&sraPLUSaddu, NULL }  ,  { &&sraPLUSaddu, NULL }  ,  { &&sraPLUSaddu, NULL } 
 ,  { &&sraPLUSaddu, NULL }  ,  { &&sraPLUSaddu, NULL }  ,  { &&sraPLUSaddu, NULL }  ,  { &&sraPLUSaddu, NULL }  ,  { &&sraPLUSaddu, NULL }  ,  { &&sraPLUSaddu, NULL }  ,  { &&sraPLUSaddu, NULL }  ,  { &&sraPLUSaddu, NULL }  ,  { &&sraPLUSaddu, NULL }  ,  { &&sraPLUSaddu, NULL } 
 ,  { &&sraPLUSaddu, NULL }  ,  { &&sraPLUSaddu, NULL }  ,  { &&sraPLUSaddu, NULL }  ,  { &&sraPLUSaddu, NULL }  ,  { &&sraPLUSaddu, NULL }  ,  { &&sraPLUSaddu, NULL }  ,  { &&sraPLUSaddu, NULL }  ,  { &&sraPLUSaddu, NULL }  ,  { &&sraPLUSaddu, NULL }  ,  { &&sraPLUSaddu, NULL } 
 ,  { &&sraPLUSaddu, NULL }  ,  { &&sraPLUSaddu, NULL }  ,  { &&sraPLUSaddu, NULL }  ,  { &&sraPLUSaddu, NULL }  ,  { &&sraPLUSaddu, NULL }  ,  { &&sraPLUSaddu, NULL }  ,  { &&sraPLUSaddu, NULL }  ,  { &&sraPLUSaddu, NULL }  ,  { &&sraPLUSaddu, NULL }  ,  { &&sraPLUSaddu, NULL } 
 ,  { &&sraPLUSaddu, NULL }  ,  { &&sraPLUSaddu, NULL }  ,  { &&sraPLUSaddu, NULL }  ,  { &&sraPLUSaddu, NULL }  ,  { &&sraPLUSaddu, NULL }  ,  { &&sraPLUSaddu, NULL }  ,  { &&sraPLUSaddu, NULL }  ,  { &&sraPLUSaddu, NULL }  ,  { &&sraPLUSaddu, NULL }  ,  { &&sraPLUSaddu, NULL } 
 ,  { &&sraPLUSaddu, NULL }  ,  { &&sraPLUSaddu, NULL }  ,  { &&sraPLUSaddu, NULL }  ,  { &&sraPLUSaddu, NULL }  ,  { &&sraPLUSaddu, NULL }  ,  { &&sraPLUSaddu, NULL }  ,  { &&sraPLUSaddu, NULL }  ,  { &&sraPLUSaddu, NULL }  ,  { &&sraPLUSaddu, NULL }  ,  { &&sraPLUSaddu, NULL } 
 ,  { &&sraPLUSaddu, NULL }  ,  { &&sraPLUSaddu, NULL }  ,  { &&sraPLUSaddu, NULL }  ,  { &&sraPLUSaddu, NULL }  ,  { &&sraPLUSaddu, NULL }  ,  { &&sraPLUSaddu, NULL }  ,  { &&sraPLUSaddu, NULL }  ,  { &&sraPLUSaddu, NULL }  ,  { &&sraPLUSaddu, NULL }  ,  { &&sraPLUSaddu, NULL } 
 }; 

struct pointer arrayadduPLUSerror[T_SIZE] = {  { &&adduPLUSerror, NULL }  ,  { &&adduPLUSerror, NULL }  ,  { &&adduPLUSerror, NULL }  ,  { &&adduPLUSerror, NULL }  ,  { &&adduPLUSerror, NULL }  ,  { &&adduPLUSerror, NULL }  ,  { &&adduPLUSerror, NULL }  ,  { &&adduPLUSerror, NULL }  ,  { &&adduPLUSerror, NULL }  ,  { &&adduPLUSerror, NULL } 
 ,  { &&adduPLUSerror, NULL }  ,  { &&adduPLUSerror, NULL }  ,  { &&adduPLUSerror, NULL }  ,  { &&adduPLUSerror, NULL }  ,  { &&adduPLUSerror, NULL }  ,  { &&adduPLUSerror, NULL }  ,  { &&adduPLUSerror, NULL }  ,  { &&adduPLUSerror, NULL }  ,  { &&adduPLUSerror, NULL }  ,  { &&adduPLUSerror, NULL } 
 ,  { &&adduPLUSerror, NULL }  ,  { &&adduPLUSerror, NULL }  ,  { &&adduPLUSerror, NULL }  ,  { &&adduPLUSerror, NULL }  ,  { &&adduPLUSerror, NULL }  ,  { &&adduPLUSerror, NULL }  ,  { &&adduPLUSerror, NULL }  ,  { &&adduPLUSerror, NULL }  ,  { &&adduPLUSerror, NULL }  ,  { &&adduPLUSerror, NULL } 
 ,  { &&adduPLUSerror, NULL }  ,  { &&adduPLUSerror, NULL }  ,  { &&adduPLUSerror, NULL }  ,  { &&adduPLUSerror, NULL }  ,  { &&adduPLUSerror, NULL }  ,  { &&adduPLUSerrorPLUSsubu, NULL }  ,  { &&adduPLUSerror, NULL }  ,  { &&adduPLUSerror, NULL }  ,  { &&adduPLUSerror, NULL }  ,  { &&adduPLUSerror, NULL } 
 ,  { &&adduPLUSerror, NULL }  ,  { &&adduPLUSerror, NULL }  ,  { &&adduPLUSerror, NULL }  ,  { &&adduPLUSerror, NULL }  ,  { &&adduPLUSerror, NULL }  ,  { &&adduPLUSerror, NULL }  ,  { &&adduPLUSerror, NULL }  ,  { &&adduPLUSerror, NULL }  ,  { &&adduPLUSerror, NULL }  ,  { &&adduPLUSerror, NULL } 
 ,  { &&adduPLUSerror, NULL }  ,  { &&adduPLUSerror, NULL }  ,  { &&adduPLUSerror, NULL }  ,  { &&adduPLUSerror, NULL }  ,  { &&adduPLUSerror, NULL }  ,  { &&adduPLUSerror, NULL }  ,  { &&adduPLUSerror, NULL }  ,  { &&adduPLUSerror, NULL }  ,  { &&adduPLUSerror, NULL }  ,  { &&adduPLUSerror, NULL } 
 ,  { &&adduPLUSerror, NULL }  ,  { &&adduPLUSerror, NULL }  ,  { &&adduPLUSerror, NULL }  ,  { &&adduPLUSerror, NULL }  ,  { &&adduPLUSerror, NULL }  ,  { &&adduPLUSerror, NULL }  ,  { &&adduPLUSerror, NULL }  ,  { &&adduPLUSerror, NULL }  ,  { &&adduPLUSerror, NULL }  ,  { &&adduPLUSerror, NULL } 
 ,  { &&adduPLUSerror, NULL }  ,  { &&adduPLUSerror, NULL }  ,  { &&adduPLUSerror, NULL }  ,  { &&adduPLUSerror, NULL }  ,  { &&adduPLUSerror, NULL }  ,  { &&adduPLUSerror, NULL }  ,  { &&adduPLUSerror, NULL }  ,  { &&adduPLUSerror, NULL }  ,  { &&adduPLUSerror, NULL }  ,  { &&adduPLUSerror, NULL } 
 ,  { &&adduPLUSerror, NULL }  ,  { &&adduPLUSerror, NULL }  ,  { &&adduPLUSerror, NULL }  ,  { &&adduPLUSerror, NULL }  ,  { &&adduPLUSerror, NULL }  ,  { &&adduPLUSerror, NULL }  ,  { &&adduPLUSerror, NULL }  ,  { &&adduPLUSerror, NULL }  ,  { &&adduPLUSerror, NULL }  ,  { &&adduPLUSerror, NULL } 
 ,  { &&adduPLUSerror, NULL }  ,  { &&adduPLUSerror, NULL }  ,  { &&adduPLUSerror, NULL }  ,  { &&adduPLUSerror, NULL }  ,  { &&adduPLUSerror, NULL }  ,  { &&adduPLUSerror, NULL }  ,  { &&adduPLUSerror, NULL }  ,  { &&adduPLUSerror, NULL }  ,  { &&adduPLUSerror, NULL }  ,  { &&adduPLUSerror, NULL } 
 ,  { &&adduPLUSerror, NULL }  ,  { &&adduPLUSerror, NULL }  ,  { &&adduPLUSerror, NULL }  ,  { &&adduPLUSerror, NULL }  ,  { &&adduPLUSerror, NULL }  ,  { &&adduPLUSerror, NULL }  ,  { &&adduPLUSerror, NULL }  ,  { &&adduPLUSerror, NULL }  ,  { &&adduPLUSerror, NULL }  ,  { &&adduPLUSerror, NULL } 
 }; 

struct pointer arraysrlPLUSandi[T_SIZE] = {  { &&srlPLUSandi, NULL }  ,  { &&srlPLUSandi, NULL }  ,  { &&srlPLUSandi, NULL }  ,  { &&srlPLUSandi, NULL }  ,  { &&srlPLUSandi, NULL }  ,  { &&srlPLUSandi, NULL }  ,  { &&srlPLUSandi, NULL }  ,  { &&srlPLUSandi, NULL }  ,  { &&srlPLUSandiPLUSjr, NULL }  ,  { &&srlPLUSandi, NULL } 
 ,  { &&srlPLUSandi, NULL }  ,  { &&srlPLUSandi, NULL }  ,  { &&srlPLUSandi, NULL }  ,  { &&srlPLUSandi, NULL }  ,  { &&srlPLUSandi, NULL }  ,  { &&srlPLUSandi, NULL }  ,  { &&srlPLUSandi, NULL }  ,  { &&srlPLUSandi, NULL }  ,  { &&srlPLUSandi, NULL }  ,  { &&srlPLUSandi, NULL } 
 ,  { &&srlPLUSandi, NULL }  ,  { &&srlPLUSandi, NULL }  ,  { &&srlPLUSandi, NULL }  ,  { &&srlPLUSandi, NULL }  ,  { &&srlPLUSandi, NULL }  ,  { &&srlPLUSandi, NULL }  ,  { &&srlPLUSandi, NULL }  ,  { &&srlPLUSandi, NULL }  ,  { &&srlPLUSandi, NULL }  ,  { &&srlPLUSandi, NULL } 
 ,  { &&srlPLUSandi, NULL }  ,  { &&srlPLUSandi, NULL }  ,  { &&srlPLUSandi, NULL }  ,  { &&srlPLUSandi, NULL }  ,  { &&srlPLUSandi, NULL }  ,  { &&srlPLUSandi, NULL }  ,  { &&srlPLUSandi, NULL }  ,  { &&srlPLUSandi, NULL }  ,  { &&srlPLUSandi, NULL }  ,  { &&srlPLUSandi, NULL } 
 ,  { &&srlPLUSandi, NULL }  ,  { &&srlPLUSandi, NULL }  ,  { &&srlPLUSandi, NULL }  ,  { &&srlPLUSandi, NULL }  ,  { &&srlPLUSandi, NULL }  ,  { &&srlPLUSandi, NULL }  ,  { &&srlPLUSandi, NULL }  ,  { &&srlPLUSandi, NULL }  ,  { &&srlPLUSandi, NULL }  ,  { &&srlPLUSandi, NULL } 
 ,  { &&srlPLUSandi, NULL }  ,  { &&srlPLUSandi, NULL }  ,  { &&srlPLUSandi, NULL }  ,  { &&srlPLUSandi, NULL }  ,  { &&srlPLUSandi, NULL }  ,  { &&srlPLUSandi, NULL }  ,  { &&srlPLUSandi, NULL }  ,  { &&srlPLUSandi, NULL }  ,  { &&srlPLUSandi, NULL }  ,  { &&srlPLUSandi, NULL } 
 ,  { &&srlPLUSandi, NULL }  ,  { &&srlPLUSandi, NULL }  ,  { &&srlPLUSandi, NULL }  ,  { &&srlPLUSandi, NULL }  ,  { &&srlPLUSandi, NULL }  ,  { &&srlPLUSandi, NULL }  ,  { &&srlPLUSandi, NULL }  ,  { &&srlPLUSandi, NULL }  ,  { &&srlPLUSandi, NULL }  ,  { &&srlPLUSandi, NULL } 
 ,  { &&srlPLUSandi, NULL }  ,  { &&srlPLUSandi, NULL }  ,  { &&srlPLUSandi, NULL }  ,  { &&srlPLUSandi, NULL }  ,  { &&srlPLUSandi, NULL }  ,  { &&srlPLUSandi, NULL }  ,  { &&srlPLUSandi, NULL }  ,  { &&srlPLUSandi, NULL }  ,  { &&srlPLUSandi, NULL }  ,  { &&srlPLUSandi, NULL } 
 ,  { &&srlPLUSandi, NULL }  ,  { &&srlPLUSandi, NULL }  ,  { &&srlPLUSandi, NULL }  ,  { &&srlPLUSandi, NULL }  ,  { &&srlPLUSandi, NULL }  ,  { &&srlPLUSandi, NULL }  ,  { &&srlPLUSandi, NULL }  ,  { &&srlPLUSandi, NULL }  ,  { &&srlPLUSandi, NULL }  ,  { &&srlPLUSandi, NULL } 
 ,  { &&srlPLUSandi, NULL }  ,  { &&srlPLUSandi, NULL }  ,  { &&srlPLUSandi, NULL }  ,  { &&srlPLUSandi, NULL }  ,  { &&srlPLUSandi, NULL }  ,  { &&srlPLUSandi, NULL }  ,  { &&srlPLUSandi, NULL }  ,  { &&srlPLUSandi, NULL }  ,  { &&srlPLUSandi, NULL }  ,  { &&srlPLUSandi, NULL } 
 ,  { &&srlPLUSandi, NULL }  ,  { &&srlPLUSandi, NULL }  ,  { &&srlPLUSandi, NULL }  ,  { &&srlPLUSandi, NULL }  ,  { &&srlPLUSandi, NULL }  ,  { &&srlPLUSandi, NULL }  ,  { &&srlPLUSandi, NULL }  ,  { &&srlPLUSandi, NULL }  ,  { &&srlPLUSandi, NULL }  ,  { &&srlPLUSandi, NULL } 
 }; 

struct pointer arrayerrorPLUSsubu[T_SIZE] = {  { &&errorPLUSsubu, NULL }  ,  { &&errorPLUSsubu, NULL }  ,  { &&errorPLUSsubu, NULL }  ,  { &&errorPLUSsubu, NULL }  ,  { &&errorPLUSsubu, NULL }  ,  { &&errorPLUSsubu, NULL }  ,  { &&errorPLUSsubu, NULL }  ,  { &&errorPLUSsubu, NULL }  ,  { &&errorPLUSsubu, NULL }  ,  { &&errorPLUSsubu, NULL } 
 ,  { &&errorPLUSsubu, NULL }  ,  { &&errorPLUSsubu, NULL }  ,  { &&errorPLUSsubu, NULL }  ,  { &&errorPLUSsubu, NULL }  ,  { &&errorPLUSsubu, NULL }  ,  { &&errorPLUSsubu, NULL }  ,  { &&errorPLUSsubu, NULL }  ,  { &&errorPLUSsubu, NULL }  ,  { &&errorPLUSsubu, NULL }  ,  { &&errorPLUSsubu, NULL } 
 ,  { &&errorPLUSsubu, NULL }  ,  { &&errorPLUSsubu, NULL }  ,  { &&errorPLUSsubu, NULL }  ,  { &&errorPLUSsubu, NULL }  ,  { &&errorPLUSsubu, NULL }  ,  { &&errorPLUSsubu, NULL }  ,  { &&errorPLUSsubu, NULL }  ,  { &&errorPLUSsubu, NULL }  ,  { &&errorPLUSsubu, NULL }  ,  { &&errorPLUSsubu, NULL } 
 ,  { &&errorPLUSsubu, NULL }  ,  { &&errorPLUSsubu, NULL }  ,  { &&errorPLUSsubu, NULL }  ,  { &&errorPLUSsubu, NULL }  ,  { &&errorPLUSsubu, NULL }  ,  { &&errorPLUSsubu, NULL }  ,  { &&errorPLUSsubuPLUSand, NULL }  ,  { &&errorPLUSsubu, NULL }  ,  { &&errorPLUSsubu, NULL }  ,  { &&errorPLUSsubu, NULL } 
 ,  { &&errorPLUSsubu, NULL }  ,  { &&errorPLUSsubu, NULL }  ,  { &&errorPLUSsubu, NULL }  ,  { &&errorPLUSsubu, NULL }  ,  { &&errorPLUSsubu, NULL }  ,  { &&errorPLUSsubu, NULL }  ,  { &&errorPLUSsubu, NULL }  ,  { &&errorPLUSsubu, NULL }  ,  { &&errorPLUSsubu, NULL }  ,  { &&errorPLUSsubu, NULL } 
 ,  { &&errorPLUSsubu, NULL }  ,  { &&errorPLUSsubu, NULL }  ,  { &&errorPLUSsubu, NULL }  ,  { &&errorPLUSsubu, NULL }  ,  { &&errorPLUSsubu, NULL }  ,  { &&errorPLUSsubu, NULL }  ,  { &&errorPLUSsubu, NULL }  ,  { &&errorPLUSsubu, NULL }  ,  { &&errorPLUSsubu, NULL }  ,  { &&errorPLUSsubu, NULL } 
 ,  { &&errorPLUSsubu, NULL }  ,  { &&errorPLUSsubu, NULL }  ,  { &&errorPLUSsubu, NULL }  ,  { &&errorPLUSsubu, NULL }  ,  { &&errorPLUSsubu, NULL }  ,  { &&errorPLUSsubu, NULL }  ,  { &&errorPLUSsubu, NULL }  ,  { &&errorPLUSsubu, NULL }  ,  { &&errorPLUSsubu, NULL }  ,  { &&errorPLUSsubu, NULL } 
 ,  { &&errorPLUSsubu, NULL }  ,  { &&errorPLUSsubu, NULL }  ,  { &&errorPLUSsubu, NULL }  ,  { &&errorPLUSsubu, NULL }  ,  { &&errorPLUSsubu, NULL }  ,  { &&errorPLUSsubu, NULL }  ,  { &&errorPLUSsubu, NULL }  ,  { &&errorPLUSsubu, NULL }  ,  { &&errorPLUSsubu, NULL }  ,  { &&errorPLUSsubu, NULL } 
 ,  { &&errorPLUSsubu, NULL }  ,  { &&errorPLUSsubu, NULL }  ,  { &&errorPLUSsubu, NULL }  ,  { &&errorPLUSsubu, NULL }  ,  { &&errorPLUSsubu, NULL }  ,  { &&errorPLUSsubu, NULL }  ,  { &&errorPLUSsubu, NULL }  ,  { &&errorPLUSsubu, NULL }  ,  { &&errorPLUSsubu, NULL }  ,  { &&errorPLUSsubu, NULL } 
 ,  { &&errorPLUSsubu, NULL }  ,  { &&errorPLUSsubu, NULL }  ,  { &&errorPLUSsubu, NULL }  ,  { &&errorPLUSsubu, NULL }  ,  { &&errorPLUSsubu, NULL }  ,  { &&errorPLUSsubu, NULL }  ,  { &&errorPLUSsubu, NULL }  ,  { &&errorPLUSsubu, NULL }  ,  { &&errorPLUSsubu, NULL }  ,  { &&errorPLUSsubu, NULL } 
 ,  { &&errorPLUSsubu, NULL }  ,  { &&errorPLUSsubu, NULL }  ,  { &&errorPLUSsubu, NULL }  ,  { &&errorPLUSsubu, NULL }  ,  { &&errorPLUSsubu, NULL }  ,  { &&errorPLUSsubu, NULL }  ,  { &&errorPLUSsubu, NULL }  ,  { &&errorPLUSsubu, NULL }  ,  { &&errorPLUSsubu, NULL }  ,  { &&errorPLUSsubu, NULL } 
 }; 

struct pointer arraymovnPLUSsll[T_SIZE] = {  { &&movnPLUSsll, NULL }  ,  { &&movnPLUSsll, NULL }  ,  { &&movnPLUSsll, NULL }  ,  { &&movnPLUSsll, NULL }  ,  { &&movnPLUSsll, NULL }  ,  { &&movnPLUSsll, NULL }  ,  { &&movnPLUSsll, NULL }  ,  { &&movnPLUSsll, NULL }  ,  { &&movnPLUSsll, NULL }  ,  { &&movnPLUSsll, NULL } 
 ,  { &&movnPLUSsll, NULL }  ,  { &&movnPLUSsll, NULL }  ,  { &&movnPLUSsll, NULL }  ,  { &&movnPLUSsll, NULL }  ,  { &&movnPLUSsll, NULL }  ,  { &&movnPLUSsll, NULL }  ,  { &&movnPLUSsll, NULL }  ,  { &&movnPLUSsll, NULL }  ,  { &&movnPLUSsll, NULL }  ,  { &&movnPLUSsll, NULL } 
 ,  { &&movnPLUSsll, NULL }  ,  { &&movnPLUSsll, NULL }  ,  { &&movnPLUSsll, NULL }  ,  { &&movnPLUSsll, NULL }  ,  { &&movnPLUSsll, NULL }  ,  { &&movnPLUSsll, NULL }  ,  { &&movnPLUSsll, NULL }  ,  { &&movnPLUSsll, NULL }  ,  { &&movnPLUSsll, NULL }  ,  { &&movnPLUSsll, NULL } 
 ,  { &&movnPLUSsll, NULL }  ,  { &&movnPLUSsll, NULL }  ,  { &&movnPLUSsll, NULL }  ,  { &&movnPLUSsll, NULL }  ,  { &&movnPLUSsll, NULL }  ,  { &&movnPLUSsll, NULL }  ,  { &&movnPLUSsll, NULL }  ,  { &&movnPLUSsll, NULL }  ,  { &&movnPLUSsllPLUSxor, NULL }  ,  { &&movnPLUSsll, NULL } 
 ,  { &&movnPLUSsll, NULL }  ,  { &&movnPLUSsll, NULL }  ,  { &&movnPLUSsll, NULL }  ,  { &&movnPLUSsll, NULL }  ,  { &&movnPLUSsll, NULL }  ,  { &&movnPLUSsll, NULL }  ,  { &&movnPLUSsll, NULL }  ,  { &&movnPLUSsll, NULL }  ,  { &&movnPLUSsll, NULL }  ,  { &&movnPLUSsll, NULL } 
 ,  { &&movnPLUSsll, NULL }  ,  { &&movnPLUSsll, NULL }  ,  { &&movnPLUSsll, NULL }  ,  { &&movnPLUSsll, NULL }  ,  { &&movnPLUSsll, NULL }  ,  { &&movnPLUSsll, NULL }  ,  { &&movnPLUSsll, NULL }  ,  { &&movnPLUSsll, NULL }  ,  { &&movnPLUSsll, NULL }  ,  { &&movnPLUSsll, NULL } 
 ,  { &&movnPLUSsll, NULL }  ,  { &&movnPLUSsll, NULL }  ,  { &&movnPLUSsll, NULL }  ,  { &&movnPLUSsll, NULL }  ,  { &&movnPLUSsll, NULL }  ,  { &&movnPLUSsll, NULL }  ,  { &&movnPLUSsll, NULL }  ,  { &&movnPLUSsll, NULL }  ,  { &&movnPLUSsll, NULL }  ,  { &&movnPLUSsll, NULL } 
 ,  { &&movnPLUSsll, NULL }  ,  { &&movnPLUSsll, NULL }  ,  { &&movnPLUSsll, NULL }  ,  { &&movnPLUSsll, NULL }  ,  { &&movnPLUSsll, NULL }  ,  { &&movnPLUSsll, NULL }  ,  { &&movnPLUSsll, NULL }  ,  { &&movnPLUSsll, NULL }  ,  { &&movnPLUSsll, NULL }  ,  { &&movnPLUSsll, NULL } 
 ,  { &&movnPLUSsll, NULL }  ,  { &&movnPLUSsll, NULL }  ,  { &&movnPLUSsll, NULL }  ,  { &&movnPLUSsll, NULL }  ,  { &&movnPLUSsll, NULL }  ,  { &&movnPLUSsll, NULL }  ,  { &&movnPLUSsll, NULL }  ,  { &&movnPLUSsll, NULL }  ,  { &&movnPLUSsll, NULL }  ,  { &&movnPLUSsll, NULL } 
 ,  { &&movnPLUSsll, NULL }  ,  { &&movnPLUSsll, NULL }  ,  { &&movnPLUSsll, NULL }  ,  { &&movnPLUSsll, NULL }  ,  { &&movnPLUSsll, NULL }  ,  { &&movnPLUSsll, NULL }  ,  { &&movnPLUSsll, NULL }  ,  { &&movnPLUSsll, NULL }  ,  { &&movnPLUSsll, NULL }  ,  { &&movnPLUSsll, NULL } 
 ,  { &&movnPLUSsll, NULL }  ,  { &&movnPLUSsll, NULL }  ,  { &&movnPLUSsll, NULL }  ,  { &&movnPLUSsll, NULL }  ,  { &&movnPLUSsll, NULL }  ,  { &&movnPLUSsll, NULL }  ,  { &&movnPLUSsll, NULL }  ,  { &&movnPLUSsll, NULL }  ,  { &&movnPLUSsll, NULL }  ,  { &&movnPLUSsll, NULL } 
 }; 

struct pointer arraylwPLUSlbu[T_SIZE] = {  { &&lwPLUSlbu, NULL }  ,  { &&lwPLUSlbu, NULL }  ,  { &&lwPLUSlbu, NULL }  ,  { &&lwPLUSlbu, NULL }  ,  { &&lwPLUSlbu, NULL }  ,  { &&lwPLUSlbu, NULL }  ,  { &&lwPLUSlbu, NULL }  ,  { &&lwPLUSlbu, NULL }  ,  { &&lwPLUSlbu, NULL }  ,  { &&lwPLUSlbu, NULL } 
 ,  { &&lwPLUSlbu, NULL }  ,  { &&lwPLUSlbu, NULL }  ,  { &&lwPLUSlbu, NULL }  ,  { &&lwPLUSlbu, NULL }  ,  { &&lwPLUSlbu, NULL }  ,  { &&lwPLUSlbu, NULL }  ,  { &&lwPLUSlbu, NULL }  ,  { &&lwPLUSlbu, NULL }  ,  { &&lwPLUSlbu, NULL }  ,  { &&lwPLUSlbu, NULL } 
 ,  { &&lwPLUSlbu, NULL }  ,  { &&lwPLUSlbu, NULL }  ,  { &&lwPLUSlbu, NULL }  ,  { &&lwPLUSlbu, NULL }  ,  { &&lwPLUSlbu, NULL }  ,  { &&lwPLUSlbu, NULL }  ,  { &&lwPLUSlbu, NULL }  ,  { &&lwPLUSlbu, NULL }  ,  { &&lwPLUSlbu, NULL }  ,  { &&lwPLUSlbu, NULL } 
 ,  { &&lwPLUSlbu, NULL }  ,  { &&lwPLUSlbu, NULL }  ,  { &&lwPLUSlbu, NULL }  ,  { &&lwPLUSlbu, NULL }  ,  { &&lwPLUSlbu, NULL }  ,  { &&lwPLUSlbu, NULL }  ,  { &&lwPLUSlbu, NULL }  ,  { &&lwPLUSlbu, NULL }  ,  { &&lwPLUSlbu, NULL }  ,  { &&lwPLUSlbu, NULL } 
 ,  { &&lwPLUSlbu, NULL }  ,  { &&lwPLUSlbu, NULL }  ,  { &&lwPLUSlbu, NULL }  ,  { &&lwPLUSlbu, NULL }  ,  { &&lwPLUSlbu, NULL }  ,  { &&lwPLUSlbu, NULL }  ,  { &&lwPLUSlbu, NULL }  ,  { &&lwPLUSlbu, NULL }  ,  { &&lwPLUSlbu, NULL }  ,  { &&lwPLUSlbu, NULL } 
 ,  { &&lwPLUSlbu, NULL }  ,  { &&lwPLUSlbu, NULL }  ,  { &&lwPLUSlbuPLUSaddiu, NULL }  ,  { &&lwPLUSlbu, NULL }  ,  { &&lwPLUSlbu, NULL }  ,  { &&lwPLUSlbu, NULL }  ,  { &&lwPLUSlbu, NULL }  ,  { &&lwPLUSlbu, NULL }  ,  { &&lwPLUSlbu, NULL }  ,  { &&lwPLUSlbu, NULL } 
 ,  { &&lwPLUSlbu, NULL }  ,  { &&lwPLUSlbu, NULL }  ,  { &&lwPLUSlbu, NULL }  ,  { &&lwPLUSlbu, NULL }  ,  { &&lwPLUSlbu, NULL }  ,  { &&lwPLUSlbu, NULL }  ,  { &&lwPLUSlbu, NULL }  ,  { &&lwPLUSlbu, NULL }  ,  { &&lwPLUSlbu, NULL }  ,  { &&lwPLUSlbu, NULL } 
 ,  { &&lwPLUSlbu, NULL }  ,  { &&lwPLUSlbu, NULL }  ,  { &&lwPLUSlbu, NULL }  ,  { &&lwPLUSlbu, NULL }  ,  { &&lwPLUSlbu, NULL }  ,  { &&lwPLUSlbu, NULL }  ,  { &&lwPLUSlbu, NULL }  ,  { &&lwPLUSlbu, NULL }  ,  { &&lwPLUSlbu, NULL }  ,  { &&lwPLUSlbu, NULL } 
 ,  { &&lwPLUSlbu, NULL }  ,  { &&lwPLUSlbu, NULL }  ,  { &&lwPLUSlbu, NULL }  ,  { &&lwPLUSlbu, NULL }  ,  { &&lwPLUSlbu, NULL }  ,  { &&lwPLUSlbu, NULL }  ,  { &&lwPLUSlbu, NULL }  ,  { &&lwPLUSlbu, NULL }  ,  { &&lwPLUSlbu, NULL }  ,  { &&lwPLUSlbu, NULL } 
 ,  { &&lwPLUSlbu, NULL }  ,  { &&lwPLUSlbu, NULL }  ,  { &&lwPLUSlbu, NULL }  ,  { &&lwPLUSlbu, NULL }  ,  { &&lwPLUSlbu, NULL }  ,  { &&lwPLUSlbu, NULL }  ,  { &&lwPLUSlbu, NULL }  ,  { &&lwPLUSlbu, NULL }  ,  { &&lwPLUSlbu, NULL }  ,  { &&lwPLUSlbu, NULL } 
 ,  { &&lwPLUSlbu, NULL }  ,  { &&lwPLUSlbu, NULL }  ,  { &&lwPLUSlbu, NULL }  ,  { &&lwPLUSlbu, NULL }  ,  { &&lwPLUSlbu, NULL }  ,  { &&lwPLUSlbu, NULL }  ,  { &&lwPLUSlbu, NULL }  ,  { &&lwPLUSlbu, NULL }  ,  { &&lwPLUSlbu, NULL }  ,  { &&lwPLUSlbu, NULL } 
 }; 

struct pointer arrayaddiuPLUSlui[T_SIZE] = {  { &&addiuPLUSlui, NULL }  ,  { &&addiuPLUSlui, NULL }  ,  { &&addiuPLUSlui, NULL }  ,  { &&addiuPLUSlui, NULL }  ,  { &&addiuPLUSlui, NULL }  ,  { &&addiuPLUSlui, NULL }  ,  { &&addiuPLUSlui, NULL }  ,  { &&addiuPLUSlui, NULL }  ,  { &&addiuPLUSlui, NULL }  ,  { &&addiuPLUSlui, NULL } 
 ,  { &&addiuPLUSlui, NULL }  ,  { &&addiuPLUSlui, NULL }  ,  { &&addiuPLUSlui, NULL }  ,  { &&addiuPLUSlui, NULL }  ,  { &&addiuPLUSlui, NULL }  ,  { &&addiuPLUSlui, NULL }  ,  { &&addiuPLUSlui, NULL }  ,  { &&addiuPLUSlui, NULL }  ,  { &&addiuPLUSlui, NULL }  ,  { &&addiuPLUSlui, NULL } 
 ,  { &&addiuPLUSlui, NULL }  ,  { &&addiuPLUSlui, NULL }  ,  { &&addiuPLUSlui, NULL }  ,  { &&addiuPLUSlui, NULL }  ,  { &&addiuPLUSlui, NULL }  ,  { &&addiuPLUSlui, NULL }  ,  { &&addiuPLUSlui, NULL }  ,  { &&addiuPLUSlui, NULL }  ,  { &&addiuPLUSlui, NULL }  ,  { &&addiuPLUSlui, NULL } 
 ,  { &&addiuPLUSlui, NULL }  ,  { &&addiuPLUSlui, NULL }  ,  { &&addiuPLUSlui, NULL }  ,  { &&addiuPLUSlui, NULL }  ,  { &&addiuPLUSlui, NULL }  ,  { &&addiuPLUSlui, NULL }  ,  { &&addiuPLUSlui, NULL }  ,  { &&addiuPLUSlui, NULL }  ,  { &&addiuPLUSlui, NULL }  ,  { &&addiuPLUSlui, NULL } 
 ,  { &&addiuPLUSlui, NULL }  ,  { &&addiuPLUSlui, NULL }  ,  { &&addiuPLUSlui, NULL }  ,  { &&addiuPLUSlui, NULL }  ,  { &&addiuPLUSlui, NULL }  ,  { &&addiuPLUSlui, NULL }  ,  { &&addiuPLUSlui, NULL }  ,  { &&addiuPLUSlui, NULL }  ,  { &&addiuPLUSlui, NULL }  ,  { &&addiuPLUSlui, NULL } 
 ,  { &&addiuPLUSlui, NULL }  ,  { &&addiuPLUSlui, NULL }  ,  { &&addiuPLUSluiPLUSaddiu, NULL }  ,  { &&addiuPLUSlui, NULL }  ,  { &&addiuPLUSlui, NULL }  ,  { &&addiuPLUSlui, NULL }  ,  { &&addiuPLUSluiPLUSori, NULL }  ,  { &&addiuPLUSlui, NULL }  ,  { &&addiuPLUSlui, NULL }  ,  { &&addiuPLUSlui, NULL } 
 ,  { &&addiuPLUSlui, NULL }  ,  { &&addiuPLUSlui, NULL }  ,  { &&addiuPLUSlui, NULL }  ,  { &&addiuPLUSlui, NULL }  ,  { &&addiuPLUSlui, NULL }  ,  { &&addiuPLUSlui, NULL }  ,  { &&addiuPLUSlui, NULL }  ,  { &&addiuPLUSlui, NULL }  ,  { &&addiuPLUSlui, NULL }  ,  { &&addiuPLUSlui, NULL } 
 ,  { &&addiuPLUSlui, NULL }  ,  { &&addiuPLUSlui, NULL }  ,  { &&addiuPLUSlui, NULL }  ,  { &&addiuPLUSlui, NULL }  ,  { &&addiuPLUSlui, NULL }  ,  { &&addiuPLUSlui, NULL }  ,  { &&addiuPLUSlui, NULL }  ,  { &&addiuPLUSlui, NULL }  ,  { &&addiuPLUSlui, NULL }  ,  { &&addiuPLUSlui, NULL } 
 ,  { &&addiuPLUSlui, NULL }  ,  { &&addiuPLUSlui, NULL }  ,  { &&addiuPLUSlui, NULL }  ,  { &&addiuPLUSlui, NULL }  ,  { &&addiuPLUSlui, NULL }  ,  { &&addiuPLUSlui, NULL }  ,  { &&addiuPLUSluiPLUSsw, NULL }  ,  { &&addiuPLUSlui, NULL }  ,  { &&addiuPLUSlui, NULL }  ,  { &&addiuPLUSlui, NULL } 
 ,  { &&addiuPLUSlui, NULL }  ,  { &&addiuPLUSlui, NULL }  ,  { &&addiuPLUSlui, NULL }  ,  { &&addiuPLUSlui, NULL }  ,  { &&addiuPLUSlui, NULL }  ,  { &&addiuPLUSlui, NULL }  ,  { &&addiuPLUSlui, NULL }  ,  { &&addiuPLUSlui, NULL }  ,  { &&addiuPLUSlui, NULL }  ,  { &&addiuPLUSlui, NULL } 
 ,  { &&addiuPLUSlui, NULL }  ,  { &&addiuPLUSlui, NULL }  ,  { &&addiuPLUSlui, NULL }  ,  { &&addiuPLUSlui, NULL }  ,  { &&addiuPLUSlui, NULL }  ,  { &&addiuPLUSlui, NULL }  ,  { &&addiuPLUSlui, NULL }  ,  { &&addiuPLUSlui, NULL }  ,  { &&addiuPLUSlui, NULL }  ,  { &&addiuPLUSlui, NULL } 
 }; 

struct pointer arrayandPLUSsrl[T_SIZE] = {  { &&andPLUSsrl, NULL }  ,  { &&andPLUSsrlPLUSerror, NULL }  ,  { &&andPLUSsrl, NULL }  ,  { &&andPLUSsrl, NULL }  ,  { &&andPLUSsrl, NULL }  ,  { &&andPLUSsrlPLUSerror, NULL }  ,  { &&andPLUSsrl, NULL }  ,  { &&andPLUSsrl, NULL }  ,  { &&andPLUSsrl, NULL }  ,  { &&andPLUSsrl, NULL } 
 ,  { &&andPLUSsrl, NULL }  ,  { &&andPLUSsrl, NULL }  ,  { &&andPLUSsrl, NULL }  ,  { &&andPLUSsrlPLUSerror, NULL }  ,  { &&andPLUSsrlPLUSerror, NULL }  ,  { &&andPLUSsrlPLUSerror, NULL }  ,  { &&andPLUSsrl, NULL }  ,  { &&andPLUSsrl, NULL }  ,  { &&andPLUSsrl, NULL }  ,  { &&andPLUSsrl, NULL } 
 ,  { &&andPLUSsrlPLUSerror, NULL }  ,  { &&andPLUSsrlPLUSerror, NULL }  ,  { &&andPLUSsrlPLUSerror, NULL }  ,  { &&andPLUSsrlPLUSerror, NULL }  ,  { &&andPLUSsrl, NULL }  ,  { &&andPLUSsrl, NULL }  ,  { &&andPLUSsrl, NULL }  ,  { &&andPLUSsrl, NULL }  ,  { &&andPLUSsrlPLUSerror, NULL }  ,  { &&andPLUSsrlPLUSerror, NULL } 
 ,  { &&andPLUSsrlPLUSerror, NULL }  ,  { &&andPLUSsrlPLUSerror, NULL }  ,  { &&andPLUSsrl, NULL }  ,  { &&andPLUSsrl, NULL }  ,  { &&andPLUSsrl, NULL }  ,  { &&andPLUSsrl, NULL }  ,  { &&andPLUSsrl, NULL }  ,  { &&andPLUSsrl, NULL }  ,  { &&andPLUSsrlPLUSxor, NULL }  ,  { &&andPLUSsrl, NULL } 
 ,  { &&andPLUSsrlPLUSerror, NULL }  ,  { &&andPLUSsrlPLUSerror, NULL }  ,  { &&andPLUSsrl, NULL }  ,  { &&andPLUSsrl, NULL }  ,  { &&andPLUSsrl, NULL }  ,  { &&andPLUSsrl, NULL }  ,  { &&andPLUSsrl, NULL }  ,  { &&andPLUSsrl, NULL }  ,  { &&andPLUSsrl, NULL }  ,  { &&andPLUSsrl, NULL } 
 ,  { &&andPLUSsrl, NULL }  ,  { &&andPLUSsrl, NULL }  ,  { &&andPLUSsrl, NULL }  ,  { &&andPLUSsrl, NULL }  ,  { &&andPLUSsrl, NULL }  ,  { &&andPLUSsrl, NULL }  ,  { &&andPLUSsrl, NULL }  ,  { &&andPLUSsrl, NULL }  ,  { &&andPLUSsrl, NULL }  ,  { &&andPLUSsrlPLUSerror, NULL } 
 ,  { &&andPLUSsrlPLUSerror, NULL }  ,  { &&andPLUSsrlPLUSerror, NULL }  ,  { &&andPLUSsrlPLUSerror, NULL }  ,  { &&andPLUSsrlPLUSerror, NULL }  ,  { &&andPLUSsrlPLUSerror, NULL }  ,  { &&andPLUSsrlPLUSerror, NULL }  ,  { &&andPLUSsrlPLUSerror, NULL }  ,  { &&andPLUSsrl, NULL }  ,  { &&andPLUSsrl, NULL }  ,  { &&andPLUSsrl, NULL } 
 ,  { &&andPLUSsrlPLUSerror, NULL }  ,  { &&andPLUSsrlPLUSerror, NULL }  ,  { &&andPLUSsrlPLUSerror, NULL }  ,  { &&andPLUSsrlPLUSerror, NULL }  ,  { &&andPLUSsrlPLUSerror, NULL }  ,  { &&andPLUSsrl, NULL }  ,  { &&andPLUSsrl, NULL }  ,  { &&andPLUSsrl, NULL }  ,  { &&andPLUSsrl, NULL }  ,  { &&andPLUSsrl, NULL } 
 ,  { &&andPLUSsrl, NULL }  ,  { &&andPLUSsrl, NULL }  ,  { &&andPLUSsrlPLUSerror, NULL }  ,  { &&andPLUSsrl, NULL }  ,  { &&andPLUSsrl, NULL }  ,  { &&andPLUSsrl, NULL }  ,  { &&andPLUSsrl, NULL }  ,  { &&andPLUSsrlPLUSerror, NULL }  ,  { &&andPLUSsrlPLUSerror, NULL }  ,  { &&andPLUSsrl, NULL } 
 ,  { &&andPLUSsrlPLUSerror, NULL }  ,  { &&andPLUSsrlPLUSerror, NULL }  ,  { &&andPLUSsrlPLUSerror, NULL }  ,  { &&andPLUSsrlPLUSerror, NULL }  ,  { &&andPLUSsrlPLUSerror, NULL }  ,  { &&andPLUSsrlPLUSerror, NULL }  ,  { &&andPLUSsrlPLUSerror, NULL }  ,  { &&andPLUSsrlPLUSerror, NULL }  ,  { &&andPLUSsrlPLUSerror, NULL }  ,  { &&andPLUSsrlPLUSerror, NULL } 
 ,  { &&andPLUSsrlPLUSerror, NULL }  ,  { &&andPLUSsrlPLUSerror, NULL }  ,  { &&andPLUSsrlPLUSerror, NULL }  ,  { &&andPLUSsrlPLUSerror, NULL }  ,  { &&andPLUSsrlPLUSerror, NULL }  ,  { &&andPLUSsrlPLUSerror, NULL }  ,  { &&andPLUSsrlPLUSerror, NULL }  ,  { &&andPLUSsrlPLUSerror, NULL }  ,  { &&andPLUSsrlPLUSerror, NULL }  ,  { &&andPLUSsrlPLUSerror, NULL } 
 }; 

struct pointer arraybeqPLUSaddu[T_SIZE] = {  { &&beqPLUSadduPLUSsll, NULL }  ,  { &&beqPLUSaddu, NULL }  ,  { &&beqPLUSaddu, NULL }  ,  { &&beqPLUSaddu, NULL }  ,  { &&beqPLUSaddu, NULL }  ,  { &&beqPLUSaddu, NULL }  ,  { &&beqPLUSaddu, NULL }  ,  { &&beqPLUSaddu, NULL }  ,  { &&beqPLUSaddu, NULL }  ,  { &&beqPLUSaddu, NULL } 
 ,  { &&beqPLUSaddu, NULL }  ,  { &&beqPLUSaddu, NULL }  ,  { &&beqPLUSaddu, NULL }  ,  { &&beqPLUSaddu, NULL }  ,  { &&beqPLUSaddu, NULL }  ,  { &&beqPLUSaddu, NULL }  ,  { &&beqPLUSaddu, NULL }  ,  { &&beqPLUSaddu, NULL }  ,  { &&beqPLUSaddu, NULL }  ,  { &&beqPLUSaddu, NULL } 
 ,  { &&beqPLUSaddu, NULL }  ,  { &&beqPLUSaddu, NULL }  ,  { &&beqPLUSaddu, NULL }  ,  { &&beqPLUSaddu, NULL }  ,  { &&beqPLUSaddu, NULL }  ,  { &&beqPLUSaddu, NULL }  ,  { &&beqPLUSaddu, NULL }  ,  { &&beqPLUSaddu, NULL }  ,  { &&beqPLUSaddu, NULL }  ,  { &&beqPLUSaddu, NULL } 
 ,  { &&beqPLUSaddu, NULL }  ,  { &&beqPLUSaddu, NULL }  ,  { &&beqPLUSaddu, NULL }  ,  { &&beqPLUSaddu, NULL }  ,  { &&beqPLUSaddu, NULL }  ,  { &&beqPLUSaddu, NULL }  ,  { &&beqPLUSaddu, NULL }  ,  { &&beqPLUSaddu, NULL }  ,  { &&beqPLUSaddu, NULL }  ,  { &&beqPLUSaddu, NULL } 
 ,  { &&beqPLUSaddu, NULL }  ,  { &&beqPLUSaddu, NULL }  ,  { &&beqPLUSadduPLUSslt, NULL }  ,  { &&beqPLUSaddu, NULL }  ,  { &&beqPLUSaddu, NULL }  ,  { &&beqPLUSadduPLUSjump, NULL }  ,  { &&beqPLUSaddu, NULL }  ,  { &&beqPLUSaddu, NULL }  ,  { &&beqPLUSaddu, NULL }  ,  { &&beqPLUSaddu, NULL } 
 ,  { &&beqPLUSaddu, NULL }  ,  { &&beqPLUSaddu, NULL }  ,  { &&beqPLUSaddu, NULL }  ,  { &&beqPLUSaddu, NULL }  ,  { &&beqPLUSaddu, NULL }  ,  { &&beqPLUSaddu, NULL }  ,  { &&beqPLUSaddu, NULL }  ,  { &&beqPLUSaddu, NULL }  ,  { &&beqPLUSadduPLUSlui, NULL }  ,  { &&beqPLUSaddu, NULL } 
 ,  { &&beqPLUSaddu, NULL }  ,  { &&beqPLUSaddu, NULL }  ,  { &&beqPLUSaddu, NULL }  ,  { &&beqPLUSaddu, NULL }  ,  { &&beqPLUSaddu, NULL }  ,  { &&beqPLUSaddu, NULL }  ,  { &&beqPLUSaddu, NULL }  ,  { &&beqPLUSaddu, NULL }  ,  { &&beqPLUSaddu, NULL }  ,  { &&beqPLUSaddu, NULL } 
 ,  { &&beqPLUSaddu, NULL }  ,  { &&beqPLUSaddu, NULL }  ,  { &&beqPLUSaddu, NULL }  ,  { &&beqPLUSaddu, NULL }  ,  { &&beqPLUSaddu, NULL }  ,  { &&beqPLUSaddu, NULL }  ,  { &&beqPLUSaddu, NULL }  ,  { &&beqPLUSaddu, NULL }  ,  { &&beqPLUSadduPLUSlw, NULL }  ,  { &&beqPLUSaddu, NULL } 
 ,  { &&beqPLUSaddu, NULL }  ,  { &&beqPLUSaddu, NULL }  ,  { &&beqPLUSaddu, NULL }  ,  { &&beqPLUSaddu, NULL }  ,  { &&beqPLUSaddu, NULL }  ,  { &&beqPLUSaddu, NULL }  ,  { &&beqPLUSaddu, NULL }  ,  { &&beqPLUSaddu, NULL }  ,  { &&beqPLUSaddu, NULL }  ,  { &&beqPLUSaddu, NULL } 
 ,  { &&beqPLUSaddu, NULL }  ,  { &&beqPLUSaddu, NULL }  ,  { &&beqPLUSaddu, NULL }  ,  { &&beqPLUSaddu, NULL }  ,  { &&beqPLUSaddu, NULL }  ,  { &&beqPLUSaddu, NULL }  ,  { &&beqPLUSaddu, NULL }  ,  { &&beqPLUSaddu, NULL }  ,  { &&beqPLUSaddu, NULL }  ,  { &&beqPLUSaddu, NULL } 
 ,  { &&beqPLUSaddu, NULL }  ,  { &&beqPLUSaddu, NULL }  ,  { &&beqPLUSaddu, NULL }  ,  { &&beqPLUSaddu, NULL }  ,  { &&beqPLUSaddu, NULL }  ,  { &&beqPLUSaddu, NULL }  ,  { &&beqPLUSaddu, NULL }  ,  { &&beqPLUSaddu, NULL }  ,  { &&beqPLUSaddu, NULL }  ,  { &&beqPLUSaddu, NULL } 
 }; 

struct pointer arraylwPLUSsltu[T_SIZE] = {  { &&lwPLUSsltu, NULL }  ,  { &&lwPLUSsltu, NULL }  ,  { &&lwPLUSsltu, NULL }  ,  { &&lwPLUSsltu, NULL }  ,  { &&lwPLUSsltu, NULL }  ,  { &&lwPLUSsltu, NULL }  ,  { &&lwPLUSsltu, NULL }  ,  { &&lwPLUSsltu, NULL }  ,  { &&lwPLUSsltu, NULL }  ,  { &&lwPLUSsltu, NULL } 
 ,  { &&lwPLUSsltu, NULL }  ,  { &&lwPLUSsltuPLUSmovn, NULL }  ,  { &&lwPLUSsltu, NULL }  ,  { &&lwPLUSsltu, NULL }  ,  { &&lwPLUSsltu, NULL }  ,  { &&lwPLUSsltu, NULL }  ,  { &&lwPLUSsltu, NULL }  ,  { &&lwPLUSsltu, NULL }  ,  { &&lwPLUSsltu, NULL }  ,  { &&lwPLUSsltu, NULL } 
 ,  { &&lwPLUSsltu, NULL }  ,  { &&lwPLUSsltu, NULL }  ,  { &&lwPLUSsltu, NULL }  ,  { &&lwPLUSsltu, NULL }  ,  { &&lwPLUSsltu, NULL }  ,  { &&lwPLUSsltu, NULL }  ,  { &&lwPLUSsltu, NULL }  ,  { &&lwPLUSsltu, NULL }  ,  { &&lwPLUSsltu, NULL }  ,  { &&lwPLUSsltu, NULL } 
 ,  { &&lwPLUSsltu, NULL }  ,  { &&lwPLUSsltu, NULL }  ,  { &&lwPLUSsltu, NULL }  ,  { &&lwPLUSsltu, NULL }  ,  { &&lwPLUSsltu, NULL }  ,  { &&lwPLUSsltu, NULL }  ,  { &&lwPLUSsltu, NULL }  ,  { &&lwPLUSsltu, NULL }  ,  { &&lwPLUSsltu, NULL }  ,  { &&lwPLUSsltu, NULL } 
 ,  { &&lwPLUSsltu, NULL }  ,  { &&lwPLUSsltu, NULL }  ,  { &&lwPLUSsltu, NULL }  ,  { &&lwPLUSsltu, NULL }  ,  { &&lwPLUSsltu, NULL }  ,  { &&lwPLUSsltu, NULL }  ,  { &&lwPLUSsltu, NULL }  ,  { &&lwPLUSsltuPLUSbeq, NULL }  ,  { &&lwPLUSsltu, NULL }  ,  { &&lwPLUSsltu, NULL } 
 ,  { &&lwPLUSsltu, NULL }  ,  { &&lwPLUSsltu, NULL }  ,  { &&lwPLUSsltuPLUSaddiu, NULL }  ,  { &&lwPLUSsltu, NULL }  ,  { &&lwPLUSsltu, NULL }  ,  { &&lwPLUSsltu, NULL }  ,  { &&lwPLUSsltu, NULL }  ,  { &&lwPLUSsltu, NULL }  ,  { &&lwPLUSsltu, NULL }  ,  { &&lwPLUSsltu, NULL } 
 ,  { &&lwPLUSsltu, NULL }  ,  { &&lwPLUSsltu, NULL }  ,  { &&lwPLUSsltu, NULL }  ,  { &&lwPLUSsltu, NULL }  ,  { &&lwPLUSsltu, NULL }  ,  { &&lwPLUSsltu, NULL }  ,  { &&lwPLUSsltu, NULL }  ,  { &&lwPLUSsltu, NULL }  ,  { &&lwPLUSsltu, NULL }  ,  { &&lwPLUSsltu, NULL } 
 ,  { &&lwPLUSsltu, NULL }  ,  { &&lwPLUSsltu, NULL }  ,  { &&lwPLUSsltu, NULL }  ,  { &&lwPLUSsltu, NULL }  ,  { &&lwPLUSsltu, NULL }  ,  { &&lwPLUSsltu, NULL }  ,  { &&lwPLUSsltu, NULL }  ,  { &&lwPLUSsltu, NULL }  ,  { &&lwPLUSsltu, NULL }  ,  { &&lwPLUSsltu, NULL } 
 ,  { &&lwPLUSsltu, NULL }  ,  { &&lwPLUSsltu, NULL }  ,  { &&lwPLUSsltu, NULL }  ,  { &&lwPLUSsltu, NULL }  ,  { &&lwPLUSsltu, NULL }  ,  { &&lwPLUSsltu, NULL }  ,  { &&lwPLUSsltu, NULL }  ,  { &&lwPLUSsltu, NULL }  ,  { &&lwPLUSsltu, NULL }  ,  { &&lwPLUSsltu, NULL } 
 ,  { &&lwPLUSsltu, NULL }  ,  { &&lwPLUSsltu, NULL }  ,  { &&lwPLUSsltu, NULL }  ,  { &&lwPLUSsltu, NULL }  ,  { &&lwPLUSsltu, NULL }  ,  { &&lwPLUSsltu, NULL }  ,  { &&lwPLUSsltu, NULL }  ,  { &&lwPLUSsltu, NULL }  ,  { &&lwPLUSsltu, NULL }  ,  { &&lwPLUSsltu, NULL } 
 ,  { &&lwPLUSsltu, NULL }  ,  { &&lwPLUSsltu, NULL }  ,  { &&lwPLUSsltu, NULL }  ,  { &&lwPLUSsltu, NULL }  ,  { &&lwPLUSsltu, NULL }  ,  { &&lwPLUSsltu, NULL }  ,  { &&lwPLUSsltu, NULL }  ,  { &&lwPLUSsltu, NULL }  ,  { &&lwPLUSsltu, NULL }  ,  { &&lwPLUSsltu, NULL } 
 }; 

struct pointer arraysltuPLUSaddiu[T_SIZE] = {  { &&sltuPLUSaddiu, NULL }  ,  { &&sltuPLUSaddiu, NULL }  ,  { &&sltuPLUSaddiu, NULL }  ,  { &&sltuPLUSaddiu, NULL }  ,  { &&sltuPLUSaddiu, NULL }  ,  { &&sltuPLUSaddiu, NULL }  ,  { &&sltuPLUSaddiu, NULL }  ,  { &&sltuPLUSaddiu, NULL }  ,  { &&sltuPLUSaddiu, NULL }  ,  { &&sltuPLUSaddiu, NULL } 
 ,  { &&sltuPLUSaddiu, NULL }  ,  { &&sltuPLUSaddiu, NULL }  ,  { &&sltuPLUSaddiu, NULL }  ,  { &&sltuPLUSaddiu, NULL }  ,  { &&sltuPLUSaddiu, NULL }  ,  { &&sltuPLUSaddiu, NULL }  ,  { &&sltuPLUSaddiu, NULL }  ,  { &&sltuPLUSaddiu, NULL }  ,  { &&sltuPLUSaddiu, NULL }  ,  { &&sltuPLUSaddiu, NULL } 
 ,  { &&sltuPLUSaddiu, NULL }  ,  { &&sltuPLUSaddiu, NULL }  ,  { &&sltuPLUSaddiu, NULL }  ,  { &&sltuPLUSaddiu, NULL }  ,  { &&sltuPLUSaddiu, NULL }  ,  { &&sltuPLUSaddiu, NULL }  ,  { &&sltuPLUSaddiu, NULL }  ,  { &&sltuPLUSaddiu, NULL }  ,  { &&sltuPLUSaddiu, NULL }  ,  { &&sltuPLUSaddiu, NULL } 
 ,  { &&sltuPLUSaddiu, NULL }  ,  { &&sltuPLUSaddiu, NULL }  ,  { &&sltuPLUSaddiu, NULL }  ,  { &&sltuPLUSaddiu, NULL }  ,  { &&sltuPLUSaddiu, NULL }  ,  { &&sltuPLUSaddiu, NULL }  ,  { &&sltuPLUSaddiu, NULL }  ,  { &&sltuPLUSaddiu, NULL }  ,  { &&sltuPLUSaddiu, NULL }  ,  { &&sltuPLUSaddiu, NULL } 
 ,  { &&sltuPLUSaddiu, NULL }  ,  { &&sltuPLUSaddiu, NULL }  ,  { &&sltuPLUSaddiu, NULL }  ,  { &&sltuPLUSaddiu, NULL }  ,  { &&sltuPLUSaddiu, NULL }  ,  { &&sltuPLUSaddiu, NULL }  ,  { &&sltuPLUSaddiu, NULL }  ,  { &&sltuPLUSaddiuPLUSbeq, NULL }  ,  { &&sltuPLUSaddiuPLUSbne, NULL }  ,  { &&sltuPLUSaddiu, NULL } 
 ,  { &&sltuPLUSaddiu, NULL }  ,  { &&sltuPLUSaddiu, NULL }  ,  { &&sltuPLUSaddiu, NULL }  ,  { &&sltuPLUSaddiu, NULL }  ,  { &&sltuPLUSaddiu, NULL }  ,  { &&sltuPLUSaddiu, NULL }  ,  { &&sltuPLUSaddiu, NULL }  ,  { &&sltuPLUSaddiu, NULL }  ,  { &&sltuPLUSaddiu, NULL }  ,  { &&sltuPLUSaddiu, NULL } 
 ,  { &&sltuPLUSaddiu, NULL }  ,  { &&sltuPLUSaddiu, NULL }  ,  { &&sltuPLUSaddiu, NULL }  ,  { &&sltuPLUSaddiu, NULL }  ,  { &&sltuPLUSaddiu, NULL }  ,  { &&sltuPLUSaddiu, NULL }  ,  { &&sltuPLUSaddiu, NULL }  ,  { &&sltuPLUSaddiu, NULL }  ,  { &&sltuPLUSaddiu, NULL }  ,  { &&sltuPLUSaddiu, NULL } 
 ,  { &&sltuPLUSaddiu, NULL }  ,  { &&sltuPLUSaddiu, NULL }  ,  { &&sltuPLUSaddiu, NULL }  ,  { &&sltuPLUSaddiu, NULL }  ,  { &&sltuPLUSaddiu, NULL }  ,  { &&sltuPLUSaddiu, NULL }  ,  { &&sltuPLUSaddiu, NULL }  ,  { &&sltuPLUSaddiu, NULL }  ,  { &&sltuPLUSaddiu, NULL }  ,  { &&sltuPLUSaddiu, NULL } 
 ,  { &&sltuPLUSaddiu, NULL }  ,  { &&sltuPLUSaddiu, NULL }  ,  { &&sltuPLUSaddiu, NULL }  ,  { &&sltuPLUSaddiu, NULL }  ,  { &&sltuPLUSaddiu, NULL }  ,  { &&sltuPLUSaddiu, NULL }  ,  { &&sltuPLUSaddiu, NULL }  ,  { &&sltuPLUSaddiu, NULL }  ,  { &&sltuPLUSaddiu, NULL }  ,  { &&sltuPLUSaddiu, NULL } 
 ,  { &&sltuPLUSaddiu, NULL }  ,  { &&sltuPLUSaddiu, NULL }  ,  { &&sltuPLUSaddiu, NULL }  ,  { &&sltuPLUSaddiu, NULL }  ,  { &&sltuPLUSaddiu, NULL }  ,  { &&sltuPLUSaddiu, NULL }  ,  { &&sltuPLUSaddiu, NULL }  ,  { &&sltuPLUSaddiu, NULL }  ,  { &&sltuPLUSaddiu, NULL }  ,  { &&sltuPLUSaddiu, NULL } 
 ,  { &&sltuPLUSaddiu, NULL }  ,  { &&sltuPLUSaddiu, NULL }  ,  { &&sltuPLUSaddiu, NULL }  ,  { &&sltuPLUSaddiu, NULL }  ,  { &&sltuPLUSaddiu, NULL }  ,  { &&sltuPLUSaddiu, NULL }  ,  { &&sltuPLUSaddiu, NULL }  ,  { &&sltuPLUSaddiu, NULL }  ,  { &&sltuPLUSaddiu, NULL }  ,  { &&sltuPLUSaddiu, NULL } 
 }; 

struct pointer arrayaddiuPLUSsrl[T_SIZE] = {  { &&addiuPLUSsrl, NULL }  ,  { &&addiuPLUSsrl, NULL }  ,  { &&addiuPLUSsrl, NULL }  ,  { &&addiuPLUSsrlPLUSsra, NULL }  ,  { &&addiuPLUSsrl, NULL }  ,  { &&addiuPLUSsrl, NULL }  ,  { &&addiuPLUSsrl, NULL }  ,  { &&addiuPLUSsrl, NULL }  ,  { &&addiuPLUSsrl, NULL }  ,  { &&addiuPLUSsrl, NULL } 
 ,  { &&addiuPLUSsrl, NULL }  ,  { &&addiuPLUSsrl, NULL }  ,  { &&addiuPLUSsrl, NULL }  ,  { &&addiuPLUSsrl, NULL }  ,  { &&addiuPLUSsrl, NULL }  ,  { &&addiuPLUSsrl, NULL }  ,  { &&addiuPLUSsrl, NULL }  ,  { &&addiuPLUSsrl, NULL }  ,  { &&addiuPLUSsrl, NULL }  ,  { &&addiuPLUSsrl, NULL } 
 ,  { &&addiuPLUSsrl, NULL }  ,  { &&addiuPLUSsrl, NULL }  ,  { &&addiuPLUSsrl, NULL }  ,  { &&addiuPLUSsrl, NULL }  ,  { &&addiuPLUSsrl, NULL }  ,  { &&addiuPLUSsrl, NULL }  ,  { &&addiuPLUSsrl, NULL }  ,  { &&addiuPLUSsrl, NULL }  ,  { &&addiuPLUSsrl, NULL }  ,  { &&addiuPLUSsrl, NULL } 
 ,  { &&addiuPLUSsrl, NULL }  ,  { &&addiuPLUSsrl, NULL }  ,  { &&addiuPLUSsrl, NULL }  ,  { &&addiuPLUSsrlPLUSaddu, NULL }  ,  { &&addiuPLUSsrl, NULL }  ,  { &&addiuPLUSsrl, NULL }  ,  { &&addiuPLUSsrl, NULL }  ,  { &&addiuPLUSsrl, NULL }  ,  { &&addiuPLUSsrl, NULL }  ,  { &&addiuPLUSsrl, NULL } 
 ,  { &&addiuPLUSsrl, NULL }  ,  { &&addiuPLUSsrl, NULL }  ,  { &&addiuPLUSsrl, NULL }  ,  { &&addiuPLUSsrl, NULL }  ,  { &&addiuPLUSsrl, NULL }  ,  { &&addiuPLUSsrl, NULL }  ,  { &&addiuPLUSsrl, NULL }  ,  { &&addiuPLUSsrl, NULL }  ,  { &&addiuPLUSsrlPLUSbne, NULL }  ,  { &&addiuPLUSsrl, NULL } 
 ,  { &&addiuPLUSsrl, NULL }  ,  { &&addiuPLUSsrl, NULL }  ,  { &&addiuPLUSsrl, NULL }  ,  { &&addiuPLUSsrl, NULL }  ,  { &&addiuPLUSsrl, NULL }  ,  { &&addiuPLUSsrl, NULL }  ,  { &&addiuPLUSsrl, NULL }  ,  { &&addiuPLUSsrl, NULL }  ,  { &&addiuPLUSsrl, NULL }  ,  { &&addiuPLUSsrl, NULL } 
 ,  { &&addiuPLUSsrl, NULL }  ,  { &&addiuPLUSsrl, NULL }  ,  { &&addiuPLUSsrl, NULL }  ,  { &&addiuPLUSsrl, NULL }  ,  { &&addiuPLUSsrl, NULL }  ,  { &&addiuPLUSsrl, NULL }  ,  { &&addiuPLUSsrl, NULL }  ,  { &&addiuPLUSsrl, NULL }  ,  { &&addiuPLUSsrl, NULL }  ,  { &&addiuPLUSsrl, NULL } 
 ,  { &&addiuPLUSsrl, NULL }  ,  { &&addiuPLUSsrl, NULL }  ,  { &&addiuPLUSsrl, NULL }  ,  { &&addiuPLUSsrl, NULL }  ,  { &&addiuPLUSsrl, NULL }  ,  { &&addiuPLUSsrl, NULL }  ,  { &&addiuPLUSsrl, NULL }  ,  { &&addiuPLUSsrl, NULL }  ,  { &&addiuPLUSsrl, NULL }  ,  { &&addiuPLUSsrl, NULL } 
 ,  { &&addiuPLUSsrl, NULL }  ,  { &&addiuPLUSsrl, NULL }  ,  { &&addiuPLUSsrl, NULL }  ,  { &&addiuPLUSsrl, NULL }  ,  { &&addiuPLUSsrl, NULL }  ,  { &&addiuPLUSsrl, NULL }  ,  { &&addiuPLUSsrl, NULL }  ,  { &&addiuPLUSsrl, NULL }  ,  { &&addiuPLUSsrl, NULL }  ,  { &&addiuPLUSsrl, NULL } 
 ,  { &&addiuPLUSsrl, NULL }  ,  { &&addiuPLUSsrl, NULL }  ,  { &&addiuPLUSsrl, NULL }  ,  { &&addiuPLUSsrl, NULL }  ,  { &&addiuPLUSsrl, NULL }  ,  { &&addiuPLUSsrl, NULL }  ,  { &&addiuPLUSsrl, NULL }  ,  { &&addiuPLUSsrl, NULL }  ,  { &&addiuPLUSsrl, NULL }  ,  { &&addiuPLUSsrl, NULL } 
 ,  { &&addiuPLUSsrl, NULL }  ,  { &&addiuPLUSsrl, NULL }  ,  { &&addiuPLUSsrl, NULL }  ,  { &&addiuPLUSsrl, NULL }  ,  { &&addiuPLUSsrl, NULL }  ,  { &&addiuPLUSsrl, NULL }  ,  { &&addiuPLUSsrl, NULL }  ,  { &&addiuPLUSsrl, NULL }  ,  { &&addiuPLUSsrl, NULL }  ,  { &&addiuPLUSsrl, NULL } 
 }; 

struct pointer arraylwPLUSblez[T_SIZE] = {  { &&lwPLUSblezPLUSsll, NULL }  ,  { &&lwPLUSblez, NULL }  ,  { &&lwPLUSblez, NULL }  ,  { &&lwPLUSblez, NULL }  ,  { &&lwPLUSblez, NULL }  ,  { &&lwPLUSblez, NULL }  ,  { &&lwPLUSblez, NULL }  ,  { &&lwPLUSblez, NULL }  ,  { &&lwPLUSblez, NULL }  ,  { &&lwPLUSblez, NULL } 
 ,  { &&lwPLUSblez, NULL }  ,  { &&lwPLUSblez, NULL }  ,  { &&lwPLUSblez, NULL }  ,  { &&lwPLUSblez, NULL }  ,  { &&lwPLUSblez, NULL }  ,  { &&lwPLUSblez, NULL }  ,  { &&lwPLUSblez, NULL }  ,  { &&lwPLUSblez, NULL }  ,  { &&lwPLUSblez, NULL }  ,  { &&lwPLUSblez, NULL } 
 ,  { &&lwPLUSblez, NULL }  ,  { &&lwPLUSblez, NULL }  ,  { &&lwPLUSblez, NULL }  ,  { &&lwPLUSblez, NULL }  ,  { &&lwPLUSblez, NULL }  ,  { &&lwPLUSblez, NULL }  ,  { &&lwPLUSblez, NULL }  ,  { &&lwPLUSblez, NULL }  ,  { &&lwPLUSblez, NULL }  ,  { &&lwPLUSblez, NULL } 
 ,  { &&lwPLUSblez, NULL }  ,  { &&lwPLUSblez, NULL }  ,  { &&lwPLUSblez, NULL }  ,  { &&lwPLUSblez, NULL }  ,  { &&lwPLUSblez, NULL }  ,  { &&lwPLUSblez, NULL }  ,  { &&lwPLUSblez, NULL }  ,  { &&lwPLUSblez, NULL }  ,  { &&lwPLUSblez, NULL }  ,  { &&lwPLUSblez, NULL } 
 ,  { &&lwPLUSblez, NULL }  ,  { &&lwPLUSblez, NULL }  ,  { &&lwPLUSblez, NULL }  ,  { &&lwPLUSblez, NULL }  ,  { &&lwPLUSblez, NULL }  ,  { &&lwPLUSblez, NULL }  ,  { &&lwPLUSblez, NULL }  ,  { &&lwPLUSblez, NULL }  ,  { &&lwPLUSblez, NULL }  ,  { &&lwPLUSblez, NULL } 
 ,  { &&lwPLUSblez, NULL }  ,  { &&lwPLUSblez, NULL }  ,  { &&lwPLUSblez, NULL }  ,  { &&lwPLUSblez, NULL }  ,  { &&lwPLUSblez, NULL }  ,  { &&lwPLUSblez, NULL }  ,  { &&lwPLUSblez, NULL }  ,  { &&lwPLUSblez, NULL }  ,  { &&lwPLUSblez, NULL }  ,  { &&lwPLUSblez, NULL } 
 ,  { &&lwPLUSblez, NULL }  ,  { &&lwPLUSblez, NULL }  ,  { &&lwPLUSblez, NULL }  ,  { &&lwPLUSblez, NULL }  ,  { &&lwPLUSblez, NULL }  ,  { &&lwPLUSblez, NULL }  ,  { &&lwPLUSblez, NULL }  ,  { &&lwPLUSblez, NULL }  ,  { &&lwPLUSblez, NULL }  ,  { &&lwPLUSblez, NULL } 
 ,  { &&lwPLUSblez, NULL }  ,  { &&lwPLUSblez, NULL }  ,  { &&lwPLUSblez, NULL }  ,  { &&lwPLUSblez, NULL }  ,  { &&lwPLUSblez, NULL }  ,  { &&lwPLUSblez, NULL }  ,  { &&lwPLUSblez, NULL }  ,  { &&lwPLUSblez, NULL }  ,  { &&lwPLUSblez, NULL }  ,  { &&lwPLUSblez, NULL } 
 ,  { &&lwPLUSblez, NULL }  ,  { &&lwPLUSblez, NULL }  ,  { &&lwPLUSblez, NULL }  ,  { &&lwPLUSblez, NULL }  ,  { &&lwPLUSblez, NULL }  ,  { &&lwPLUSblez, NULL }  ,  { &&lwPLUSblez, NULL }  ,  { &&lwPLUSblez, NULL }  ,  { &&lwPLUSblez, NULL }  ,  { &&lwPLUSblez, NULL } 
 ,  { &&lwPLUSblez, NULL }  ,  { &&lwPLUSblez, NULL }  ,  { &&lwPLUSblez, NULL }  ,  { &&lwPLUSblez, NULL }  ,  { &&lwPLUSblez, NULL }  ,  { &&lwPLUSblez, NULL }  ,  { &&lwPLUSblez, NULL }  ,  { &&lwPLUSblez, NULL }  ,  { &&lwPLUSblez, NULL }  ,  { &&lwPLUSblez, NULL } 
 ,  { &&lwPLUSblez, NULL }  ,  { &&lwPLUSblez, NULL }  ,  { &&lwPLUSblez, NULL }  ,  { &&lwPLUSblez, NULL }  ,  { &&lwPLUSblez, NULL }  ,  { &&lwPLUSblez, NULL }  ,  { &&lwPLUSblez, NULL }  ,  { &&lwPLUSblez, NULL }  ,  { &&lwPLUSblez, NULL }  ,  { &&lwPLUSblez, NULL } 
 }; 

struct pointer arrayorPLUSor[T_SIZE] = {  { &&orPLUSor, NULL }  ,  { &&orPLUSor, NULL }  ,  { &&orPLUSor, NULL }  ,  { &&orPLUSor, NULL }  ,  { &&orPLUSor, NULL }  ,  { &&orPLUSor, NULL }  ,  { &&orPLUSor, NULL }  ,  { &&orPLUSor, NULL }  ,  { &&orPLUSor, NULL }  ,  { &&orPLUSor, NULL } 
 ,  { &&orPLUSor, NULL }  ,  { &&orPLUSor, NULL }  ,  { &&orPLUSor, NULL }  ,  { &&orPLUSor, NULL }  ,  { &&orPLUSor, NULL }  ,  { &&orPLUSor, NULL }  ,  { &&orPLUSor, NULL }  ,  { &&orPLUSor, NULL }  ,  { &&orPLUSor, NULL }  ,  { &&orPLUSor, NULL } 
 ,  { &&orPLUSor, NULL }  ,  { &&orPLUSor, NULL }  ,  { &&orPLUSor, NULL }  ,  { &&orPLUSor, NULL }  ,  { &&orPLUSor, NULL }  ,  { &&orPLUSor, NULL }  ,  { &&orPLUSor, NULL }  ,  { &&orPLUSor, NULL }  ,  { &&orPLUSor, NULL }  ,  { &&orPLUSor, NULL } 
 ,  { &&orPLUSor, NULL }  ,  { &&orPLUSor, NULL }  ,  { &&orPLUSor, NULL }  ,  { &&orPLUSor, NULL }  ,  { &&orPLUSor, NULL }  ,  { &&orPLUSor, NULL }  ,  { &&orPLUSor, NULL }  ,  { &&orPLUSor, NULL }  ,  { &&orPLUSor, NULL }  ,  { &&orPLUSor, NULL } 
 ,  { &&orPLUSor, NULL }  ,  { &&orPLUSor, NULL }  ,  { &&orPLUSor, NULL }  ,  { &&orPLUSorPLUSsltu, NULL }  ,  { &&orPLUSor, NULL }  ,  { &&orPLUSor, NULL }  ,  { &&orPLUSor, NULL }  ,  { &&orPLUSor, NULL }  ,  { &&orPLUSor, NULL }  ,  { &&orPLUSor, NULL } 
 ,  { &&orPLUSor, NULL }  ,  { &&orPLUSor, NULL }  ,  { &&orPLUSor, NULL }  ,  { &&orPLUSor, NULL }  ,  { &&orPLUSor, NULL }  ,  { &&orPLUSor, NULL }  ,  { &&orPLUSor, NULL }  ,  { &&orPLUSor, NULL }  ,  { &&orPLUSor, NULL }  ,  { &&orPLUSor, NULL } 
 ,  { &&orPLUSor, NULL }  ,  { &&orPLUSor, NULL }  ,  { &&orPLUSor, NULL }  ,  { &&orPLUSor, NULL }  ,  { &&orPLUSor, NULL }  ,  { &&orPLUSor, NULL }  ,  { &&orPLUSor, NULL }  ,  { &&orPLUSor, NULL }  ,  { &&orPLUSor, NULL }  ,  { &&orPLUSor, NULL } 
 ,  { &&orPLUSor, NULL }  ,  { &&orPLUSor, NULL }  ,  { &&orPLUSor, NULL }  ,  { &&orPLUSor, NULL }  ,  { &&orPLUSor, NULL }  ,  { &&orPLUSor, NULL }  ,  { &&orPLUSor, NULL }  ,  { &&orPLUSor, NULL }  ,  { &&orPLUSor, NULL }  ,  { &&orPLUSor, NULL } 
 ,  { &&orPLUSor, NULL }  ,  { &&orPLUSor, NULL }  ,  { &&orPLUSor, NULL }  ,  { &&orPLUSor, NULL }  ,  { &&orPLUSor, NULL }  ,  { &&orPLUSor, NULL }  ,  { &&orPLUSor, NULL }  ,  { &&orPLUSor, NULL }  ,  { &&orPLUSor, NULL }  ,  { &&orPLUSor, NULL } 
 ,  { &&orPLUSor, NULL }  ,  { &&orPLUSor, NULL }  ,  { &&orPLUSor, NULL }  ,  { &&orPLUSor, NULL }  ,  { &&orPLUSor, NULL }  ,  { &&orPLUSor, NULL }  ,  { &&orPLUSor, NULL }  ,  { &&orPLUSor, NULL }  ,  { &&orPLUSor, NULL }  ,  { &&orPLUSor, NULL } 
 ,  { &&orPLUSor, NULL }  ,  { &&orPLUSor, NULL }  ,  { &&orPLUSor, NULL }  ,  { &&orPLUSor, NULL }  ,  { &&orPLUSor, NULL }  ,  { &&orPLUSor, NULL }  ,  { &&orPLUSor, NULL }  ,  { &&orPLUSor, NULL }  ,  { &&orPLUSor, NULL }  ,  { &&orPLUSor, NULL } 
 }; 

struct pointer arraylwPLUSslti[T_SIZE] = {  { &&lwPLUSslti, NULL }  ,  { &&lwPLUSslti, NULL }  ,  { &&lwPLUSslti, NULL }  ,  { &&lwPLUSslti, NULL }  ,  { &&lwPLUSslti, NULL }  ,  { &&lwPLUSslti, NULL }  ,  { &&lwPLUSslti, NULL }  ,  { &&lwPLUSslti, NULL }  ,  { &&lwPLUSslti, NULL }  ,  { &&lwPLUSslti, NULL } 
 ,  { &&lwPLUSslti, NULL }  ,  { &&lwPLUSslti, NULL }  ,  { &&lwPLUSslti, NULL }  ,  { &&lwPLUSslti, NULL }  ,  { &&lwPLUSslti, NULL }  ,  { &&lwPLUSslti, NULL }  ,  { &&lwPLUSslti, NULL }  ,  { &&lwPLUSslti, NULL }  ,  { &&lwPLUSslti, NULL }  ,  { &&lwPLUSslti, NULL } 
 ,  { &&lwPLUSslti, NULL }  ,  { &&lwPLUSslti, NULL }  ,  { &&lwPLUSslti, NULL }  ,  { &&lwPLUSslti, NULL }  ,  { &&lwPLUSslti, NULL }  ,  { &&lwPLUSslti, NULL }  ,  { &&lwPLUSslti, NULL }  ,  { &&lwPLUSslti, NULL }  ,  { &&lwPLUSslti, NULL }  ,  { &&lwPLUSslti, NULL } 
 ,  { &&lwPLUSslti, NULL }  ,  { &&lwPLUSslti, NULL }  ,  { &&lwPLUSslti, NULL }  ,  { &&lwPLUSslti, NULL }  ,  { &&lwPLUSslti, NULL }  ,  { &&lwPLUSslti, NULL }  ,  { &&lwPLUSslti, NULL }  ,  { &&lwPLUSslti, NULL }  ,  { &&lwPLUSslti, NULL }  ,  { &&lwPLUSslti, NULL } 
 ,  { &&lwPLUSslti, NULL }  ,  { &&lwPLUSslti, NULL }  ,  { &&lwPLUSslti, NULL }  ,  { &&lwPLUSslti, NULL }  ,  { &&lwPLUSslti, NULL }  ,  { &&lwPLUSslti, NULL }  ,  { &&lwPLUSslti, NULL }  ,  { &&lwPLUSsltiPLUSbeq, NULL }  ,  { &&lwPLUSslti, NULL }  ,  { &&lwPLUSslti, NULL } 
 ,  { &&lwPLUSslti, NULL }  ,  { &&lwPLUSslti, NULL }  ,  { &&lwPLUSslti, NULL }  ,  { &&lwPLUSslti, NULL }  ,  { &&lwPLUSslti, NULL }  ,  { &&lwPLUSslti, NULL }  ,  { &&lwPLUSslti, NULL }  ,  { &&lwPLUSslti, NULL }  ,  { &&lwPLUSslti, NULL }  ,  { &&lwPLUSslti, NULL } 
 ,  { &&lwPLUSslti, NULL }  ,  { &&lwPLUSslti, NULL }  ,  { &&lwPLUSslti, NULL }  ,  { &&lwPLUSslti, NULL }  ,  { &&lwPLUSslti, NULL }  ,  { &&lwPLUSslti, NULL }  ,  { &&lwPLUSslti, NULL }  ,  { &&lwPLUSslti, NULL }  ,  { &&lwPLUSslti, NULL }  ,  { &&lwPLUSslti, NULL } 
 ,  { &&lwPLUSslti, NULL }  ,  { &&lwPLUSslti, NULL }  ,  { &&lwPLUSslti, NULL }  ,  { &&lwPLUSslti, NULL }  ,  { &&lwPLUSslti, NULL }  ,  { &&lwPLUSslti, NULL }  ,  { &&lwPLUSslti, NULL }  ,  { &&lwPLUSslti, NULL }  ,  { &&lwPLUSslti, NULL }  ,  { &&lwPLUSslti, NULL } 
 ,  { &&lwPLUSslti, NULL }  ,  { &&lwPLUSslti, NULL }  ,  { &&lwPLUSslti, NULL }  ,  { &&lwPLUSslti, NULL }  ,  { &&lwPLUSslti, NULL }  ,  { &&lwPLUSslti, NULL }  ,  { &&lwPLUSslti, NULL }  ,  { &&lwPLUSslti, NULL }  ,  { &&lwPLUSslti, NULL }  ,  { &&lwPLUSslti, NULL } 
 ,  { &&lwPLUSslti, NULL }  ,  { &&lwPLUSslti, NULL }  ,  { &&lwPLUSslti, NULL }  ,  { &&lwPLUSslti, NULL }  ,  { &&lwPLUSslti, NULL }  ,  { &&lwPLUSslti, NULL }  ,  { &&lwPLUSslti, NULL }  ,  { &&lwPLUSslti, NULL }  ,  { &&lwPLUSslti, NULL }  ,  { &&lwPLUSslti, NULL } 
 ,  { &&lwPLUSslti, NULL }  ,  { &&lwPLUSslti, NULL }  ,  { &&lwPLUSslti, NULL }  ,  { &&lwPLUSslti, NULL }  ,  { &&lwPLUSslti, NULL }  ,  { &&lwPLUSslti, NULL }  ,  { &&lwPLUSslti, NULL }  ,  { &&lwPLUSslti, NULL }  ,  { &&lwPLUSslti, NULL }  ,  { &&lwPLUSslti, NULL } 
 }; 

struct pointer arraylbuPLUSxor[T_SIZE] = {  { &&lbuPLUSxor, NULL }  ,  { &&lbuPLUSxor, NULL }  ,  { &&lbuPLUSxorPLUSsrl, NULL }  ,  { &&lbuPLUSxor, NULL }  ,  { &&lbuPLUSxor, NULL }  ,  { &&lbuPLUSxor, NULL }  ,  { &&lbuPLUSxor, NULL }  ,  { &&lbuPLUSxor, NULL }  ,  { &&lbuPLUSxor, NULL }  ,  { &&lbuPLUSxor, NULL } 
 ,  { &&lbuPLUSxor, NULL }  ,  { &&lbuPLUSxor, NULL }  ,  { &&lbuPLUSxor, NULL }  ,  { &&lbuPLUSxor, NULL }  ,  { &&lbuPLUSxor, NULL }  ,  { &&lbuPLUSxor, NULL }  ,  { &&lbuPLUSxor, NULL }  ,  { &&lbuPLUSxor, NULL }  ,  { &&lbuPLUSxor, NULL }  ,  { &&lbuPLUSxor, NULL } 
 ,  { &&lbuPLUSxor, NULL }  ,  { &&lbuPLUSxor, NULL }  ,  { &&lbuPLUSxor, NULL }  ,  { &&lbuPLUSxor, NULL }  ,  { &&lbuPLUSxor, NULL }  ,  { &&lbuPLUSxor, NULL }  ,  { &&lbuPLUSxor, NULL }  ,  { &&lbuPLUSxor, NULL }  ,  { &&lbuPLUSxor, NULL }  ,  { &&lbuPLUSxor, NULL } 
 ,  { &&lbuPLUSxor, NULL }  ,  { &&lbuPLUSxor, NULL }  ,  { &&lbuPLUSxor, NULL }  ,  { &&lbuPLUSxor, NULL }  ,  { &&lbuPLUSxor, NULL }  ,  { &&lbuPLUSxor, NULL }  ,  { &&lbuPLUSxor, NULL }  ,  { &&lbuPLUSxor, NULL }  ,  { &&lbuPLUSxor, NULL }  ,  { &&lbuPLUSxor, NULL } 
 ,  { &&lbuPLUSxor, NULL }  ,  { &&lbuPLUSxor, NULL }  ,  { &&lbuPLUSxor, NULL }  ,  { &&lbuPLUSxor, NULL }  ,  { &&lbuPLUSxor, NULL }  ,  { &&lbuPLUSxor, NULL }  ,  { &&lbuPLUSxor, NULL }  ,  { &&lbuPLUSxor, NULL }  ,  { &&lbuPLUSxor, NULL }  ,  { &&lbuPLUSxor, NULL } 
 ,  { &&lbuPLUSxor, NULL }  ,  { &&lbuPLUSxor, NULL }  ,  { &&lbuPLUSxor, NULL }  ,  { &&lbuPLUSxor, NULL }  ,  { &&lbuPLUSxor, NULL }  ,  { &&lbuPLUSxor, NULL }  ,  { &&lbuPLUSxor, NULL }  ,  { &&lbuPLUSxor, NULL }  ,  { &&lbuPLUSxor, NULL }  ,  { &&lbuPLUSxor, NULL } 
 ,  { &&lbuPLUSxor, NULL }  ,  { &&lbuPLUSxor, NULL }  ,  { &&lbuPLUSxor, NULL }  ,  { &&lbuPLUSxor, NULL }  ,  { &&lbuPLUSxor, NULL }  ,  { &&lbuPLUSxor, NULL }  ,  { &&lbuPLUSxor, NULL }  ,  { &&lbuPLUSxor, NULL }  ,  { &&lbuPLUSxor, NULL }  ,  { &&lbuPLUSxor, NULL } 
 ,  { &&lbuPLUSxor, NULL }  ,  { &&lbuPLUSxor, NULL }  ,  { &&lbuPLUSxor, NULL }  ,  { &&lbuPLUSxor, NULL }  ,  { &&lbuPLUSxor, NULL }  ,  { &&lbuPLUSxor, NULL }  ,  { &&lbuPLUSxor, NULL }  ,  { &&lbuPLUSxor, NULL }  ,  { &&lbuPLUSxor, NULL }  ,  { &&lbuPLUSxor, NULL } 
 ,  { &&lbuPLUSxor, NULL }  ,  { &&lbuPLUSxor, NULL }  ,  { &&lbuPLUSxor, NULL }  ,  { &&lbuPLUSxor, NULL }  ,  { &&lbuPLUSxor, NULL }  ,  { &&lbuPLUSxor, NULL }  ,  { &&lbuPLUSxor, NULL }  ,  { &&lbuPLUSxor, NULL }  ,  { &&lbuPLUSxor, NULL }  ,  { &&lbuPLUSxor, NULL } 
 ,  { &&lbuPLUSxor, NULL }  ,  { &&lbuPLUSxor, NULL }  ,  { &&lbuPLUSxor, NULL }  ,  { &&lbuPLUSxor, NULL }  ,  { &&lbuPLUSxor, NULL }  ,  { &&lbuPLUSxor, NULL }  ,  { &&lbuPLUSxor, NULL }  ,  { &&lbuPLUSxor, NULL }  ,  { &&lbuPLUSxor, NULL }  ,  { &&lbuPLUSxor, NULL } 
 ,  { &&lbuPLUSxor, NULL }  ,  { &&lbuPLUSxor, NULL }  ,  { &&lbuPLUSxor, NULL }  ,  { &&lbuPLUSxor, NULL }  ,  { &&lbuPLUSxor, NULL }  ,  { &&lbuPLUSxor, NULL }  ,  { &&lbuPLUSxor, NULL }  ,  { &&lbuPLUSxor, NULL }  ,  { &&lbuPLUSxor, NULL }  ,  { &&lbuPLUSxor, NULL } 
 }; 

struct pointer arrayadduPLUSslt[T_SIZE] = {  { &&adduPLUSslt, NULL }  ,  { &&adduPLUSslt, NULL }  ,  { &&adduPLUSslt, NULL }  ,  { &&adduPLUSslt, NULL }  ,  { &&adduPLUSslt, NULL }  ,  { &&adduPLUSslt, NULL }  ,  { &&adduPLUSslt, NULL }  ,  { &&adduPLUSslt, NULL }  ,  { &&adduPLUSslt, NULL }  ,  { &&adduPLUSslt, NULL } 
 ,  { &&adduPLUSslt, NULL }  ,  { &&adduPLUSslt, NULL }  ,  { &&adduPLUSslt, NULL }  ,  { &&adduPLUSslt, NULL }  ,  { &&adduPLUSslt, NULL }  ,  { &&adduPLUSslt, NULL }  ,  { &&adduPLUSslt, NULL }  ,  { &&adduPLUSslt, NULL }  ,  { &&adduPLUSslt, NULL }  ,  { &&adduPLUSslt, NULL } 
 ,  { &&adduPLUSslt, NULL }  ,  { &&adduPLUSslt, NULL }  ,  { &&adduPLUSslt, NULL }  ,  { &&adduPLUSslt, NULL }  ,  { &&adduPLUSslt, NULL }  ,  { &&adduPLUSslt, NULL }  ,  { &&adduPLUSslt, NULL }  ,  { &&adduPLUSslt, NULL }  ,  { &&adduPLUSslt, NULL }  ,  { &&adduPLUSslt, NULL } 
 ,  { &&adduPLUSslt, NULL }  ,  { &&adduPLUSslt, NULL }  ,  { &&adduPLUSslt, NULL }  ,  { &&adduPLUSslt, NULL }  ,  { &&adduPLUSslt, NULL }  ,  { &&adduPLUSslt, NULL }  ,  { &&adduPLUSslt, NULL }  ,  { &&adduPLUSslt, NULL }  ,  { &&adduPLUSslt, NULL }  ,  { &&adduPLUSslt, NULL } 
 ,  { &&adduPLUSslt, NULL }  ,  { &&adduPLUSslt, NULL }  ,  { &&adduPLUSslt, NULL }  ,  { &&adduPLUSslt, NULL }  ,  { &&adduPLUSslt, NULL }  ,  { &&adduPLUSslt, NULL }  ,  { &&adduPLUSslt, NULL }  ,  { &&adduPLUSsltPLUSbeq, NULL }  ,  { &&adduPLUSslt, NULL }  ,  { &&adduPLUSslt, NULL } 
 ,  { &&adduPLUSslt, NULL }  ,  { &&adduPLUSslt, NULL }  ,  { &&adduPLUSslt, NULL }  ,  { &&adduPLUSslt, NULL }  ,  { &&adduPLUSslt, NULL }  ,  { &&adduPLUSslt, NULL }  ,  { &&adduPLUSslt, NULL }  ,  { &&adduPLUSslt, NULL }  ,  { &&adduPLUSslt, NULL }  ,  { &&adduPLUSslt, NULL } 
 ,  { &&adduPLUSslt, NULL }  ,  { &&adduPLUSslt, NULL }  ,  { &&adduPLUSslt, NULL }  ,  { &&adduPLUSslt, NULL }  ,  { &&adduPLUSslt, NULL }  ,  { &&adduPLUSslt, NULL }  ,  { &&adduPLUSslt, NULL }  ,  { &&adduPLUSslt, NULL }  ,  { &&adduPLUSslt, NULL }  ,  { &&adduPLUSslt, NULL } 
 ,  { &&adduPLUSslt, NULL }  ,  { &&adduPLUSslt, NULL }  ,  { &&adduPLUSslt, NULL }  ,  { &&adduPLUSslt, NULL }  ,  { &&adduPLUSslt, NULL }  ,  { &&adduPLUSslt, NULL }  ,  { &&adduPLUSslt, NULL }  ,  { &&adduPLUSslt, NULL }  ,  { &&adduPLUSsltPLUSlw, NULL }  ,  { &&adduPLUSslt, NULL } 
 ,  { &&adduPLUSslt, NULL }  ,  { &&adduPLUSslt, NULL }  ,  { &&adduPLUSslt, NULL }  ,  { &&adduPLUSslt, NULL }  ,  { &&adduPLUSslt, NULL }  ,  { &&adduPLUSslt, NULL }  ,  { &&adduPLUSslt, NULL }  ,  { &&adduPLUSslt, NULL }  ,  { &&adduPLUSslt, NULL }  ,  { &&adduPLUSslt, NULL } 
 ,  { &&adduPLUSslt, NULL }  ,  { &&adduPLUSslt, NULL }  ,  { &&adduPLUSslt, NULL }  ,  { &&adduPLUSslt, NULL }  ,  { &&adduPLUSslt, NULL }  ,  { &&adduPLUSslt, NULL }  ,  { &&adduPLUSslt, NULL }  ,  { &&adduPLUSslt, NULL }  ,  { &&adduPLUSslt, NULL }  ,  { &&adduPLUSslt, NULL } 
 ,  { &&adduPLUSslt, NULL }  ,  { &&adduPLUSslt, NULL }  ,  { &&adduPLUSslt, NULL }  ,  { &&adduPLUSslt, NULL }  ,  { &&adduPLUSslt, NULL }  ,  { &&adduPLUSslt, NULL }  ,  { &&adduPLUSslt, NULL }  ,  { &&adduPLUSslt, NULL }  ,  { &&adduPLUSslt, NULL }  ,  { &&adduPLUSslt, NULL } 
 }; 

struct pointer arrayadduPLUSsll[T_SIZE] = {  { &&adduPLUSsllPLUSsll, NULL }  ,  { &&adduPLUSsll, NULL }  ,  { &&adduPLUSsll, NULL }  ,  { &&adduPLUSsll, NULL }  ,  { &&adduPLUSsll, NULL }  ,  { &&adduPLUSsll, NULL }  ,  { &&adduPLUSsll, NULL }  ,  { &&adduPLUSsll, NULL }  ,  { &&adduPLUSsll, NULL }  ,  { &&adduPLUSsll, NULL } 
 ,  { &&adduPLUSsll, NULL }  ,  { &&adduPLUSsll, NULL }  ,  { &&adduPLUSsll, NULL }  ,  { &&adduPLUSsll, NULL }  ,  { &&adduPLUSsll, NULL }  ,  { &&adduPLUSsll, NULL }  ,  { &&adduPLUSsll, NULL }  ,  { &&adduPLUSsll, NULL }  ,  { &&adduPLUSsll, NULL }  ,  { &&adduPLUSsll, NULL } 
 ,  { &&adduPLUSsll, NULL }  ,  { &&adduPLUSsll, NULL }  ,  { &&adduPLUSsll, NULL }  ,  { &&adduPLUSsll, NULL }  ,  { &&adduPLUSsll, NULL }  ,  { &&adduPLUSsll, NULL }  ,  { &&adduPLUSsll, NULL }  ,  { &&adduPLUSsll, NULL }  ,  { &&adduPLUSsll, NULL }  ,  { &&adduPLUSsll, NULL } 
 ,  { &&adduPLUSsll, NULL }  ,  { &&adduPLUSsll, NULL }  ,  { &&adduPLUSsll, NULL }  ,  { &&adduPLUSsllPLUSaddu, NULL }  ,  { &&adduPLUSsll, NULL }  ,  { &&adduPLUSsll, NULL }  ,  { &&adduPLUSsll, NULL }  ,  { &&adduPLUSsll, NULL }  ,  { &&adduPLUSsllPLUSxor, NULL }  ,  { &&adduPLUSsll, NULL } 
 ,  { &&adduPLUSsll, NULL }  ,  { &&adduPLUSsll, NULL }  ,  { &&adduPLUSsll, NULL }  ,  { &&adduPLUSsll, NULL }  ,  { &&adduPLUSsll, NULL }  ,  { &&adduPLUSsll, NULL }  ,  { &&adduPLUSsll, NULL }  ,  { &&adduPLUSsll, NULL }  ,  { &&adduPLUSsll, NULL }  ,  { &&adduPLUSsll, NULL } 
 ,  { &&adduPLUSsll, NULL }  ,  { &&adduPLUSsll, NULL }  ,  { &&adduPLUSsll, NULL }  ,  { &&adduPLUSsll, NULL }  ,  { &&adduPLUSsll, NULL }  ,  { &&adduPLUSsll, NULL }  ,  { &&adduPLUSsll, NULL }  ,  { &&adduPLUSsll, NULL }  ,  { &&adduPLUSsll, NULL }  ,  { &&adduPLUSsll, NULL } 
 ,  { &&adduPLUSsll, NULL }  ,  { &&adduPLUSsll, NULL }  ,  { &&adduPLUSsll, NULL }  ,  { &&adduPLUSsll, NULL }  ,  { &&adduPLUSsll, NULL }  ,  { &&adduPLUSsll, NULL }  ,  { &&adduPLUSsll, NULL }  ,  { &&adduPLUSsll, NULL }  ,  { &&adduPLUSsll, NULL }  ,  { &&adduPLUSsll, NULL } 
 ,  { &&adduPLUSsll, NULL }  ,  { &&adduPLUSsll, NULL }  ,  { &&adduPLUSsll, NULL }  ,  { &&adduPLUSsll, NULL }  ,  { &&adduPLUSsll, NULL }  ,  { &&adduPLUSsll, NULL }  ,  { &&adduPLUSsll, NULL }  ,  { &&adduPLUSsll, NULL }  ,  { &&adduPLUSsll, NULL }  ,  { &&adduPLUSsll, NULL } 
 ,  { &&adduPLUSsll, NULL }  ,  { &&adduPLUSsll, NULL }  ,  { &&adduPLUSsll, NULL }  ,  { &&adduPLUSsll, NULL }  ,  { &&adduPLUSsll, NULL }  ,  { &&adduPLUSsll, NULL }  ,  { &&adduPLUSsll, NULL }  ,  { &&adduPLUSsll, NULL }  ,  { &&adduPLUSsll, NULL }  ,  { &&adduPLUSsll, NULL } 
 ,  { &&adduPLUSsll, NULL }  ,  { &&adduPLUSsll, NULL }  ,  { &&adduPLUSsll, NULL }  ,  { &&adduPLUSsll, NULL }  ,  { &&adduPLUSsll, NULL }  ,  { &&adduPLUSsll, NULL }  ,  { &&adduPLUSsll, NULL }  ,  { &&adduPLUSsll, NULL }  ,  { &&adduPLUSsll, NULL }  ,  { &&adduPLUSsll, NULL } 
 ,  { &&adduPLUSsll, NULL }  ,  { &&adduPLUSsll, NULL }  ,  { &&adduPLUSsll, NULL }  ,  { &&adduPLUSsll, NULL }  ,  { &&adduPLUSsll, NULL }  ,  { &&adduPLUSsll, NULL }  ,  { &&adduPLUSsll, NULL }  ,  { &&adduPLUSsll, NULL }  ,  { &&adduPLUSsll, NULL }  ,  { &&adduPLUSsll, NULL } 
 }; 

struct pointer arraylwPLUSsw[T_SIZE] = {  { &&lwPLUSswPLUSsll, NULL }  ,  { &&lwPLUSsw, NULL }  ,  { &&lwPLUSsw, NULL }  ,  { &&lwPLUSsw, NULL }  ,  { &&lwPLUSsw, NULL }  ,  { &&lwPLUSsw, NULL }  ,  { &&lwPLUSsw, NULL }  ,  { &&lwPLUSsw, NULL }  ,  { &&lwPLUSsw, NULL }  ,  { &&lwPLUSsw, NULL } 
 ,  { &&lwPLUSsw, NULL }  ,  { &&lwPLUSsw, NULL }  ,  { &&lwPLUSsw, NULL }  ,  { &&lwPLUSsw, NULL }  ,  { &&lwPLUSsw, NULL }  ,  { &&lwPLUSsw, NULL }  ,  { &&lwPLUSsw, NULL }  ,  { &&lwPLUSsw, NULL }  ,  { &&lwPLUSsw, NULL }  ,  { &&lwPLUSsw, NULL } 
 ,  { &&lwPLUSsw, NULL }  ,  { &&lwPLUSsw, NULL }  ,  { &&lwPLUSsw, NULL }  ,  { &&lwPLUSsw, NULL }  ,  { &&lwPLUSsw, NULL }  ,  { &&lwPLUSsw, NULL }  ,  { &&lwPLUSsw, NULL }  ,  { &&lwPLUSsw, NULL }  ,  { &&lwPLUSsw, NULL }  ,  { &&lwPLUSsw, NULL } 
 ,  { &&lwPLUSsw, NULL }  ,  { &&lwPLUSsw, NULL }  ,  { &&lwPLUSsw, NULL }  ,  { &&lwPLUSsw, NULL }  ,  { &&lwPLUSsw, NULL }  ,  { &&lwPLUSsw, NULL }  ,  { &&lwPLUSsw, NULL }  ,  { &&lwPLUSsw, NULL }  ,  { &&lwPLUSsw, NULL }  ,  { &&lwPLUSsw, NULL } 
 ,  { &&lwPLUSsw, NULL }  ,  { &&lwPLUSsw, NULL }  ,  { &&lwPLUSsw, NULL }  ,  { &&lwPLUSsw, NULL }  ,  { &&lwPLUSsw, NULL }  ,  { &&lwPLUSsw, NULL }  ,  { &&lwPLUSsw, NULL }  ,  { &&lwPLUSsw, NULL }  ,  { &&lwPLUSsw, NULL }  ,  { &&lwPLUSsw, NULL } 
 ,  { &&lwPLUSsw, NULL }  ,  { &&lwPLUSsw, NULL }  ,  { &&lwPLUSsw, NULL }  ,  { &&lwPLUSsw, NULL }  ,  { &&lwPLUSsw, NULL }  ,  { &&lwPLUSsw, NULL }  ,  { &&lwPLUSsw, NULL }  ,  { &&lwPLUSsw, NULL }  ,  { &&lwPLUSsw, NULL }  ,  { &&lwPLUSsw, NULL } 
 ,  { &&lwPLUSsw, NULL }  ,  { &&lwPLUSsw, NULL }  ,  { &&lwPLUSsw, NULL }  ,  { &&lwPLUSsw, NULL }  ,  { &&lwPLUSsw, NULL }  ,  { &&lwPLUSsw, NULL }  ,  { &&lwPLUSsw, NULL }  ,  { &&lwPLUSsw, NULL }  ,  { &&lwPLUSsw, NULL }  ,  { &&lwPLUSsw, NULL } 
 ,  { &&lwPLUSsw, NULL }  ,  { &&lwPLUSsw, NULL }  ,  { &&lwPLUSsw, NULL }  ,  { &&lwPLUSsw, NULL }  ,  { &&lwPLUSsw, NULL }  ,  { &&lwPLUSsw, NULL }  ,  { &&lwPLUSsw, NULL }  ,  { &&lwPLUSsw, NULL }  ,  { &&lwPLUSswPLUSlw, NULL }  ,  { &&lwPLUSsw, NULL } 
 ,  { &&lwPLUSsw, NULL }  ,  { &&lwPLUSsw, NULL }  ,  { &&lwPLUSsw, NULL }  ,  { &&lwPLUSsw, NULL }  ,  { &&lwPLUSsw, NULL }  ,  { &&lwPLUSsw, NULL }  ,  { &&lwPLUSswPLUSsw, NULL }  ,  { &&lwPLUSsw, NULL }  ,  { &&lwPLUSsw, NULL }  ,  { &&lwPLUSsw, NULL } 
 ,  { &&lwPLUSsw, NULL }  ,  { &&lwPLUSsw, NULL }  ,  { &&lwPLUSsw, NULL }  ,  { &&lwPLUSsw, NULL }  ,  { &&lwPLUSsw, NULL }  ,  { &&lwPLUSsw, NULL }  ,  { &&lwPLUSsw, NULL }  ,  { &&lwPLUSsw, NULL }  ,  { &&lwPLUSsw, NULL }  ,  { &&lwPLUSsw, NULL } 
 ,  { &&lwPLUSsw, NULL }  ,  { &&lwPLUSsw, NULL }  ,  { &&lwPLUSsw, NULL }  ,  { &&lwPLUSsw, NULL }  ,  { &&lwPLUSsw, NULL }  ,  { &&lwPLUSsw, NULL }  ,  { &&lwPLUSsw, NULL }  ,  { &&lwPLUSsw, NULL }  ,  { &&lwPLUSsw, NULL }  ,  { &&lwPLUSsw, NULL } 
 }; 

struct pointer arrayjumpPLUSaddu[T_SIZE] = {  { &&jumpPLUSadduPLUSsll, NULL }  ,  { &&jumpPLUSaddu, NULL }  ,  { &&jumpPLUSaddu, NULL }  ,  { &&jumpPLUSaddu, NULL }  ,  { &&jumpPLUSaddu, NULL }  ,  { &&jumpPLUSaddu, NULL }  ,  { &&jumpPLUSaddu, NULL }  ,  { &&jumpPLUSaddu, NULL }  ,  { &&jumpPLUSaddu, NULL }  ,  { &&jumpPLUSaddu, NULL } 
 ,  { &&jumpPLUSaddu, NULL }  ,  { &&jumpPLUSaddu, NULL }  ,  { &&jumpPLUSaddu, NULL }  ,  { &&jumpPLUSaddu, NULL }  ,  { &&jumpPLUSaddu, NULL }  ,  { &&jumpPLUSaddu, NULL }  ,  { &&jumpPLUSaddu, NULL }  ,  { &&jumpPLUSaddu, NULL }  ,  { &&jumpPLUSaddu, NULL }  ,  { &&jumpPLUSaddu, NULL } 
 ,  { &&jumpPLUSaddu, NULL }  ,  { &&jumpPLUSaddu, NULL }  ,  { &&jumpPLUSaddu, NULL }  ,  { &&jumpPLUSaddu, NULL }  ,  { &&jumpPLUSaddu, NULL }  ,  { &&jumpPLUSaddu, NULL }  ,  { &&jumpPLUSaddu, NULL }  ,  { &&jumpPLUSaddu, NULL }  ,  { &&jumpPLUSaddu, NULL }  ,  { &&jumpPLUSaddu, NULL } 
 ,  { &&jumpPLUSaddu, NULL }  ,  { &&jumpPLUSaddu, NULL }  ,  { &&jumpPLUSaddu, NULL }  ,  { &&jumpPLUSaddu, NULL }  ,  { &&jumpPLUSaddu, NULL }  ,  { &&jumpPLUSaddu, NULL }  ,  { &&jumpPLUSaddu, NULL }  ,  { &&jumpPLUSaddu, NULL }  ,  { &&jumpPLUSaddu, NULL }  ,  { &&jumpPLUSaddu, NULL } 
 ,  { &&jumpPLUSaddu, NULL }  ,  { &&jumpPLUSaddu, NULL }  ,  { &&jumpPLUSaddu, NULL }  ,  { &&jumpPLUSaddu, NULL }  ,  { &&jumpPLUSaddu, NULL }  ,  { &&jumpPLUSaddu, NULL }  ,  { &&jumpPLUSaddu, NULL }  ,  { &&jumpPLUSaddu, NULL }  ,  { &&jumpPLUSaddu, NULL }  ,  { &&jumpPLUSaddu, NULL } 
 ,  { &&jumpPLUSaddu, NULL }  ,  { &&jumpPLUSaddu, NULL }  ,  { &&jumpPLUSaddu, NULL }  ,  { &&jumpPLUSaddu, NULL }  ,  { &&jumpPLUSaddu, NULL }  ,  { &&jumpPLUSaddu, NULL }  ,  { &&jumpPLUSaddu, NULL }  ,  { &&jumpPLUSaddu, NULL }  ,  { &&jumpPLUSaddu, NULL }  ,  { &&jumpPLUSaddu, NULL } 
 ,  { &&jumpPLUSaddu, NULL }  ,  { &&jumpPLUSaddu, NULL }  ,  { &&jumpPLUSaddu, NULL }  ,  { &&jumpPLUSaddu, NULL }  ,  { &&jumpPLUSaddu, NULL }  ,  { &&jumpPLUSaddu, NULL }  ,  { &&jumpPLUSaddu, NULL }  ,  { &&jumpPLUSaddu, NULL }  ,  { &&jumpPLUSaddu, NULL }  ,  { &&jumpPLUSaddu, NULL } 
 ,  { &&jumpPLUSaddu, NULL }  ,  { &&jumpPLUSaddu, NULL }  ,  { &&jumpPLUSaddu, NULL }  ,  { &&jumpPLUSaddu, NULL }  ,  { &&jumpPLUSaddu, NULL }  ,  { &&jumpPLUSaddu, NULL }  ,  { &&jumpPLUSaddu, NULL }  ,  { &&jumpPLUSaddu, NULL }  ,  { &&jumpPLUSadduPLUSlw, NULL }  ,  { &&jumpPLUSaddu, NULL } 
 ,  { &&jumpPLUSaddu, NULL }  ,  { &&jumpPLUSaddu, NULL }  ,  { &&jumpPLUSaddu, NULL }  ,  { &&jumpPLUSaddu, NULL }  ,  { &&jumpPLUSaddu, NULL }  ,  { &&jumpPLUSaddu, NULL }  ,  { &&jumpPLUSaddu, NULL }  ,  { &&jumpPLUSaddu, NULL }  ,  { &&jumpPLUSaddu, NULL }  ,  { &&jumpPLUSaddu, NULL } 
 ,  { &&jumpPLUSaddu, NULL }  ,  { &&jumpPLUSaddu, NULL }  ,  { &&jumpPLUSaddu, NULL }  ,  { &&jumpPLUSaddu, NULL }  ,  { &&jumpPLUSaddu, NULL }  ,  { &&jumpPLUSaddu, NULL }  ,  { &&jumpPLUSaddu, NULL }  ,  { &&jumpPLUSaddu, NULL }  ,  { &&jumpPLUSaddu, NULL }  ,  { &&jumpPLUSaddu, NULL } 
 ,  { &&jumpPLUSaddu, NULL }  ,  { &&jumpPLUSaddu, NULL }  ,  { &&jumpPLUSaddu, NULL }  ,  { &&jumpPLUSaddu, NULL }  ,  { &&jumpPLUSaddu, NULL }  ,  { &&jumpPLUSaddu, NULL }  ,  { &&jumpPLUSaddu, NULL }  ,  { &&jumpPLUSaddu, NULL }  ,  { &&jumpPLUSaddu, NULL }  ,  { &&jumpPLUSaddu, NULL } 
 }; 

struct pointer arrayoriPLUSsll[T_SIZE] = {  { &&oriPLUSsll, NULL }  ,  { &&oriPLUSsll, NULL }  ,  { &&oriPLUSsll, NULL }  ,  { &&oriPLUSsll, NULL }  ,  { &&oriPLUSsll, NULL }  ,  { &&oriPLUSsll, NULL }  ,  { &&oriPLUSsll, NULL }  ,  { &&oriPLUSsll, NULL }  ,  { &&oriPLUSsll, NULL }  ,  { &&oriPLUSsll, NULL } 
 ,  { &&oriPLUSsll, NULL }  ,  { &&oriPLUSsll, NULL }  ,  { &&oriPLUSsll, NULL }  ,  { &&oriPLUSsll, NULL }  ,  { &&oriPLUSsll, NULL }  ,  { &&oriPLUSsll, NULL }  ,  { &&oriPLUSsll, NULL }  ,  { &&oriPLUSsll, NULL }  ,  { &&oriPLUSsll, NULL }  ,  { &&oriPLUSsll, NULL } 
 ,  { &&oriPLUSsll, NULL }  ,  { &&oriPLUSsll, NULL }  ,  { &&oriPLUSsll, NULL }  ,  { &&oriPLUSsll, NULL }  ,  { &&oriPLUSsll, NULL }  ,  { &&oriPLUSsll, NULL }  ,  { &&oriPLUSsll, NULL }  ,  { &&oriPLUSsll, NULL }  ,  { &&oriPLUSsll, NULL }  ,  { &&oriPLUSsll, NULL } 
 ,  { &&oriPLUSsll, NULL }  ,  { &&oriPLUSsll, NULL }  ,  { &&oriPLUSsll, NULL }  ,  { &&oriPLUSsllPLUSaddu, NULL }  ,  { &&oriPLUSsll, NULL }  ,  { &&oriPLUSsll, NULL }  ,  { &&oriPLUSsll, NULL }  ,  { &&oriPLUSsll, NULL }  ,  { &&oriPLUSsllPLUSxor, NULL }  ,  { &&oriPLUSsll, NULL } 
 ,  { &&oriPLUSsll, NULL }  ,  { &&oriPLUSsll, NULL }  ,  { &&oriPLUSsll, NULL }  ,  { &&oriPLUSsll, NULL }  ,  { &&oriPLUSsll, NULL }  ,  { &&oriPLUSsll, NULL }  ,  { &&oriPLUSsll, NULL }  ,  { &&oriPLUSsll, NULL }  ,  { &&oriPLUSsll, NULL }  ,  { &&oriPLUSsll, NULL } 
 ,  { &&oriPLUSsll, NULL }  ,  { &&oriPLUSsll, NULL }  ,  { &&oriPLUSsll, NULL }  ,  { &&oriPLUSsll, NULL }  ,  { &&oriPLUSsll, NULL }  ,  { &&oriPLUSsll, NULL }  ,  { &&oriPLUSsll, NULL }  ,  { &&oriPLUSsll, NULL }  ,  { &&oriPLUSsll, NULL }  ,  { &&oriPLUSsll, NULL } 
 ,  { &&oriPLUSsll, NULL }  ,  { &&oriPLUSsll, NULL }  ,  { &&oriPLUSsll, NULL }  ,  { &&oriPLUSsll, NULL }  ,  { &&oriPLUSsll, NULL }  ,  { &&oriPLUSsll, NULL }  ,  { &&oriPLUSsll, NULL }  ,  { &&oriPLUSsll, NULL }  ,  { &&oriPLUSsll, NULL }  ,  { &&oriPLUSsll, NULL } 
 ,  { &&oriPLUSsll, NULL }  ,  { &&oriPLUSsll, NULL }  ,  { &&oriPLUSsll, NULL }  ,  { &&oriPLUSsll, NULL }  ,  { &&oriPLUSsll, NULL }  ,  { &&oriPLUSsll, NULL }  ,  { &&oriPLUSsll, NULL }  ,  { &&oriPLUSsll, NULL }  ,  { &&oriPLUSsll, NULL }  ,  { &&oriPLUSsll, NULL } 
 ,  { &&oriPLUSsll, NULL }  ,  { &&oriPLUSsll, NULL }  ,  { &&oriPLUSsll, NULL }  ,  { &&oriPLUSsll, NULL }  ,  { &&oriPLUSsll, NULL }  ,  { &&oriPLUSsll, NULL }  ,  { &&oriPLUSsll, NULL }  ,  { &&oriPLUSsll, NULL }  ,  { &&oriPLUSsll, NULL }  ,  { &&oriPLUSsll, NULL } 
 ,  { &&oriPLUSsll, NULL }  ,  { &&oriPLUSsll, NULL }  ,  { &&oriPLUSsll, NULL }  ,  { &&oriPLUSsll, NULL }  ,  { &&oriPLUSsll, NULL }  ,  { &&oriPLUSsll, NULL }  ,  { &&oriPLUSsll, NULL }  ,  { &&oriPLUSsll, NULL }  ,  { &&oriPLUSsll, NULL }  ,  { &&oriPLUSsll, NULL } 
 ,  { &&oriPLUSsll, NULL }  ,  { &&oriPLUSsll, NULL }  ,  { &&oriPLUSsll, NULL }  ,  { &&oriPLUSsll, NULL }  ,  { &&oriPLUSsll, NULL }  ,  { &&oriPLUSsll, NULL }  ,  { &&oriPLUSsll, NULL }  ,  { &&oriPLUSsll, NULL }  ,  { &&oriPLUSsll, NULL }  ,  { &&oriPLUSsll, NULL } 
 }; 

struct pointer arrayadduPLUSandi[T_SIZE] = {  { &&adduPLUSandi, NULL }  ,  { &&adduPLUSandi, NULL }  ,  { &&adduPLUSandi, NULL }  ,  { &&adduPLUSandi, NULL }  ,  { &&adduPLUSandi, NULL }  ,  { &&adduPLUSandi, NULL }  ,  { &&adduPLUSandi, NULL }  ,  { &&adduPLUSandi, NULL }  ,  { &&adduPLUSandi, NULL }  ,  { &&adduPLUSandi, NULL } 
 ,  { &&adduPLUSandi, NULL }  ,  { &&adduPLUSandi, NULL }  ,  { &&adduPLUSandi, NULL }  ,  { &&adduPLUSandi, NULL }  ,  { &&adduPLUSandi, NULL }  ,  { &&adduPLUSandi, NULL }  ,  { &&adduPLUSandi, NULL }  ,  { &&adduPLUSandi, NULL }  ,  { &&adduPLUSandi, NULL }  ,  { &&adduPLUSandi, NULL } 
 ,  { &&adduPLUSandi, NULL }  ,  { &&adduPLUSandi, NULL }  ,  { &&adduPLUSandi, NULL }  ,  { &&adduPLUSandi, NULL }  ,  { &&adduPLUSandi, NULL }  ,  { &&adduPLUSandi, NULL }  ,  { &&adduPLUSandi, NULL }  ,  { &&adduPLUSandi, NULL }  ,  { &&adduPLUSandi, NULL }  ,  { &&adduPLUSandi, NULL } 
 ,  { &&adduPLUSandi, NULL }  ,  { &&adduPLUSandi, NULL }  ,  { &&adduPLUSandi, NULL }  ,  { &&adduPLUSandi, NULL }  ,  { &&adduPLUSandi, NULL }  ,  { &&adduPLUSandi, NULL }  ,  { &&adduPLUSandi, NULL }  ,  { &&adduPLUSandi, NULL }  ,  { &&adduPLUSandiPLUSxor, NULL }  ,  { &&adduPLUSandi, NULL } 
 ,  { &&adduPLUSandi, NULL }  ,  { &&adduPLUSandi, NULL }  ,  { &&adduPLUSandi, NULL }  ,  { &&adduPLUSandi, NULL }  ,  { &&adduPLUSandi, NULL }  ,  { &&adduPLUSandi, NULL }  ,  { &&adduPLUSandi, NULL }  ,  { &&adduPLUSandi, NULL }  ,  { &&adduPLUSandi, NULL }  ,  { &&adduPLUSandi, NULL } 
 ,  { &&adduPLUSandi, NULL }  ,  { &&adduPLUSandi, NULL }  ,  { &&adduPLUSandi, NULL }  ,  { &&adduPLUSandi, NULL }  ,  { &&adduPLUSandi, NULL }  ,  { &&adduPLUSandi, NULL }  ,  { &&adduPLUSandi, NULL }  ,  { &&adduPLUSandi, NULL }  ,  { &&adduPLUSandi, NULL }  ,  { &&adduPLUSandi, NULL } 
 ,  { &&adduPLUSandi, NULL }  ,  { &&adduPLUSandi, NULL }  ,  { &&adduPLUSandi, NULL }  ,  { &&adduPLUSandi, NULL }  ,  { &&adduPLUSandi, NULL }  ,  { &&adduPLUSandi, NULL }  ,  { &&adduPLUSandi, NULL }  ,  { &&adduPLUSandi, NULL }  ,  { &&adduPLUSandi, NULL }  ,  { &&adduPLUSandi, NULL } 
 ,  { &&adduPLUSandi, NULL }  ,  { &&adduPLUSandi, NULL }  ,  { &&adduPLUSandi, NULL }  ,  { &&adduPLUSandi, NULL }  ,  { &&adduPLUSandi, NULL }  ,  { &&adduPLUSandi, NULL }  ,  { &&adduPLUSandi, NULL }  ,  { &&adduPLUSandi, NULL }  ,  { &&adduPLUSandi, NULL }  ,  { &&adduPLUSandi, NULL } 
 ,  { &&adduPLUSandi, NULL }  ,  { &&adduPLUSandi, NULL }  ,  { &&adduPLUSandi, NULL }  ,  { &&adduPLUSandi, NULL }  ,  { &&adduPLUSandi, NULL }  ,  { &&adduPLUSandi, NULL }  ,  { &&adduPLUSandi, NULL }  ,  { &&adduPLUSandi, NULL }  ,  { &&adduPLUSandi, NULL }  ,  { &&adduPLUSandi, NULL } 
 ,  { &&adduPLUSandi, NULL }  ,  { &&adduPLUSandi, NULL }  ,  { &&adduPLUSandi, NULL }  ,  { &&adduPLUSandi, NULL }  ,  { &&adduPLUSandi, NULL }  ,  { &&adduPLUSandi, NULL }  ,  { &&adduPLUSandi, NULL }  ,  { &&adduPLUSandi, NULL }  ,  { &&adduPLUSandi, NULL }  ,  { &&adduPLUSandi, NULL } 
 ,  { &&adduPLUSandi, NULL }  ,  { &&adduPLUSandi, NULL }  ,  { &&adduPLUSandi, NULL }  ,  { &&adduPLUSandi, NULL }  ,  { &&adduPLUSandi, NULL }  ,  { &&adduPLUSandi, NULL }  ,  { &&adduPLUSandi, NULL }  ,  { &&adduPLUSandi, NULL }  ,  { &&adduPLUSandi, NULL }  ,  { &&adduPLUSandi, NULL } 
 }; 

struct pointer arraymovnPLUSbne[T_SIZE] = {  { &&movnPLUSbne, NULL }  ,  { &&movnPLUSbne, NULL }  ,  { &&movnPLUSbne, NULL }  ,  { &&movnPLUSbne, NULL }  ,  { &&movnPLUSbne, NULL }  ,  { &&movnPLUSbne, NULL }  ,  { &&movnPLUSbne, NULL }  ,  { &&movnPLUSbne, NULL }  ,  { &&movnPLUSbne, NULL }  ,  { &&movnPLUSbne, NULL } 
 ,  { &&movnPLUSbne, NULL }  ,  { &&movnPLUSbne, NULL }  ,  { &&movnPLUSbne, NULL }  ,  { &&movnPLUSbne, NULL }  ,  { &&movnPLUSbne, NULL }  ,  { &&movnPLUSbne, NULL }  ,  { &&movnPLUSbne, NULL }  ,  { &&movnPLUSbne, NULL }  ,  { &&movnPLUSbne, NULL }  ,  { &&movnPLUSbne, NULL } 
 ,  { &&movnPLUSbne, NULL }  ,  { &&movnPLUSbne, NULL }  ,  { &&movnPLUSbne, NULL }  ,  { &&movnPLUSbne, NULL }  ,  { &&movnPLUSbne, NULL }  ,  { &&movnPLUSbne, NULL }  ,  { &&movnPLUSbne, NULL }  ,  { &&movnPLUSbne, NULL }  ,  { &&movnPLUSbne, NULL }  ,  { &&movnPLUSbne, NULL } 
 ,  { &&movnPLUSbne, NULL }  ,  { &&movnPLUSbne, NULL }  ,  { &&movnPLUSbne, NULL }  ,  { &&movnPLUSbnePLUSaddu, NULL }  ,  { &&movnPLUSbne, NULL }  ,  { &&movnPLUSbne, NULL }  ,  { &&movnPLUSbne, NULL }  ,  { &&movnPLUSbne, NULL }  ,  { &&movnPLUSbne, NULL }  ,  { &&movnPLUSbne, NULL } 
 ,  { &&movnPLUSbne, NULL }  ,  { &&movnPLUSbne, NULL }  ,  { &&movnPLUSbne, NULL }  ,  { &&movnPLUSbne, NULL }  ,  { &&movnPLUSbne, NULL }  ,  { &&movnPLUSbne, NULL }  ,  { &&movnPLUSbne, NULL }  ,  { &&movnPLUSbne, NULL }  ,  { &&movnPLUSbne, NULL }  ,  { &&movnPLUSbne, NULL } 
 ,  { &&movnPLUSbne, NULL }  ,  { &&movnPLUSbne, NULL }  ,  { &&movnPLUSbne, NULL }  ,  { &&movnPLUSbne, NULL }  ,  { &&movnPLUSbne, NULL }  ,  { &&movnPLUSbne, NULL }  ,  { &&movnPLUSbne, NULL }  ,  { &&movnPLUSbne, NULL }  ,  { &&movnPLUSbne, NULL }  ,  { &&movnPLUSbne, NULL } 
 ,  { &&movnPLUSbne, NULL }  ,  { &&movnPLUSbne, NULL }  ,  { &&movnPLUSbne, NULL }  ,  { &&movnPLUSbne, NULL }  ,  { &&movnPLUSbne, NULL }  ,  { &&movnPLUSbne, NULL }  ,  { &&movnPLUSbne, NULL }  ,  { &&movnPLUSbne, NULL }  ,  { &&movnPLUSbne, NULL }  ,  { &&movnPLUSbne, NULL } 
 ,  { &&movnPLUSbne, NULL }  ,  { &&movnPLUSbne, NULL }  ,  { &&movnPLUSbne, NULL }  ,  { &&movnPLUSbne, NULL }  ,  { &&movnPLUSbne, NULL }  ,  { &&movnPLUSbne, NULL }  ,  { &&movnPLUSbne, NULL }  ,  { &&movnPLUSbne, NULL }  ,  { &&movnPLUSbne, NULL }  ,  { &&movnPLUSbne, NULL } 
 ,  { &&movnPLUSbne, NULL }  ,  { &&movnPLUSbne, NULL }  ,  { &&movnPLUSbne, NULL }  ,  { &&movnPLUSbne, NULL }  ,  { &&movnPLUSbne, NULL }  ,  { &&movnPLUSbne, NULL }  ,  { &&movnPLUSbne, NULL }  ,  { &&movnPLUSbne, NULL }  ,  { &&movnPLUSbne, NULL }  ,  { &&movnPLUSbne, NULL } 
 ,  { &&movnPLUSbne, NULL }  ,  { &&movnPLUSbne, NULL }  ,  { &&movnPLUSbne, NULL }  ,  { &&movnPLUSbne, NULL }  ,  { &&movnPLUSbne, NULL }  ,  { &&movnPLUSbne, NULL }  ,  { &&movnPLUSbne, NULL }  ,  { &&movnPLUSbne, NULL }  ,  { &&movnPLUSbne, NULL }  ,  { &&movnPLUSbne, NULL } 
 ,  { &&movnPLUSbne, NULL }  ,  { &&movnPLUSbne, NULL }  ,  { &&movnPLUSbne, NULL }  ,  { &&movnPLUSbne, NULL }  ,  { &&movnPLUSbne, NULL }  ,  { &&movnPLUSbne, NULL }  ,  { &&movnPLUSbne, NULL }  ,  { &&movnPLUSbne, NULL }  ,  { &&movnPLUSbne, NULL }  ,  { &&movnPLUSbne, NULL } 
 }; 

struct pointer arrayadduPLUSsrl[T_SIZE] = {  { &&adduPLUSsrl, NULL }  ,  { &&adduPLUSsrl, NULL }  ,  { &&adduPLUSsrl, NULL }  ,  { &&adduPLUSsrl, NULL }  ,  { &&adduPLUSsrl, NULL }  ,  { &&adduPLUSsrl, NULL }  ,  { &&adduPLUSsrl, NULL }  ,  { &&adduPLUSsrl, NULL }  ,  { &&adduPLUSsrl, NULL }  ,  { &&adduPLUSsrl, NULL } 
 ,  { &&adduPLUSsrl, NULL }  ,  { &&adduPLUSsrl, NULL }  ,  { &&adduPLUSsrl, NULL }  ,  { &&adduPLUSsrl, NULL }  ,  { &&adduPLUSsrl, NULL }  ,  { &&adduPLUSsrl, NULL }  ,  { &&adduPLUSsrl, NULL }  ,  { &&adduPLUSsrl, NULL }  ,  { &&adduPLUSsrl, NULL }  ,  { &&adduPLUSsrl, NULL } 
 ,  { &&adduPLUSsrl, NULL }  ,  { &&adduPLUSsrl, NULL }  ,  { &&adduPLUSsrl, NULL }  ,  { &&adduPLUSsrl, NULL }  ,  { &&adduPLUSsrl, NULL }  ,  { &&adduPLUSsrl, NULL }  ,  { &&adduPLUSsrl, NULL }  ,  { &&adduPLUSsrl, NULL }  ,  { &&adduPLUSsrl, NULL }  ,  { &&adduPLUSsrl, NULL } 
 ,  { &&adduPLUSsrl, NULL }  ,  { &&adduPLUSsrl, NULL }  ,  { &&adduPLUSsrl, NULL }  ,  { &&adduPLUSsrlPLUSaddu, NULL }  ,  { &&adduPLUSsrl, NULL }  ,  { &&adduPLUSsrl, NULL }  ,  { &&adduPLUSsrl, NULL }  ,  { &&adduPLUSsrl, NULL }  ,  { &&adduPLUSsrl, NULL }  ,  { &&adduPLUSsrl, NULL } 
 ,  { &&adduPLUSsrl, NULL }  ,  { &&adduPLUSsrl, NULL }  ,  { &&adduPLUSsrl, NULL }  ,  { &&adduPLUSsrl, NULL }  ,  { &&adduPLUSsrl, NULL }  ,  { &&adduPLUSsrl, NULL }  ,  { &&adduPLUSsrl, NULL }  ,  { &&adduPLUSsrl, NULL }  ,  { &&adduPLUSsrl, NULL }  ,  { &&adduPLUSsrl, NULL } 
 ,  { &&adduPLUSsrl, NULL }  ,  { &&adduPLUSsrl, NULL }  ,  { &&adduPLUSsrl, NULL }  ,  { &&adduPLUSsrl, NULL }  ,  { &&adduPLUSsrl, NULL }  ,  { &&adduPLUSsrl, NULL }  ,  { &&adduPLUSsrl, NULL }  ,  { &&adduPLUSsrl, NULL }  ,  { &&adduPLUSsrl, NULL }  ,  { &&adduPLUSsrl, NULL } 
 ,  { &&adduPLUSsrl, NULL }  ,  { &&adduPLUSsrl, NULL }  ,  { &&adduPLUSsrl, NULL }  ,  { &&adduPLUSsrl, NULL }  ,  { &&adduPLUSsrl, NULL }  ,  { &&adduPLUSsrl, NULL }  ,  { &&adduPLUSsrl, NULL }  ,  { &&adduPLUSsrl, NULL }  ,  { &&adduPLUSsrl, NULL }  ,  { &&adduPLUSsrl, NULL } 
 ,  { &&adduPLUSsrl, NULL }  ,  { &&adduPLUSsrl, NULL }  ,  { &&adduPLUSsrl, NULL }  ,  { &&adduPLUSsrl, NULL }  ,  { &&adduPLUSsrl, NULL }  ,  { &&adduPLUSsrl, NULL }  ,  { &&adduPLUSsrl, NULL }  ,  { &&adduPLUSsrl, NULL }  ,  { &&adduPLUSsrl, NULL }  ,  { &&adduPLUSsrl, NULL } 
 ,  { &&adduPLUSsrl, NULL }  ,  { &&adduPLUSsrl, NULL }  ,  { &&adduPLUSsrl, NULL }  ,  { &&adduPLUSsrl, NULL }  ,  { &&adduPLUSsrl, NULL }  ,  { &&adduPLUSsrl, NULL }  ,  { &&adduPLUSsrl, NULL }  ,  { &&adduPLUSsrl, NULL }  ,  { &&adduPLUSsrl, NULL }  ,  { &&adduPLUSsrl, NULL } 
 ,  { &&adduPLUSsrl, NULL }  ,  { &&adduPLUSsrl, NULL }  ,  { &&adduPLUSsrl, NULL }  ,  { &&adduPLUSsrl, NULL }  ,  { &&adduPLUSsrl, NULL }  ,  { &&adduPLUSsrl, NULL }  ,  { &&adduPLUSsrl, NULL }  ,  { &&adduPLUSsrl, NULL }  ,  { &&adduPLUSsrl, NULL }  ,  { &&adduPLUSsrl, NULL } 
 ,  { &&adduPLUSsrl, NULL }  ,  { &&adduPLUSsrl, NULL }  ,  { &&adduPLUSsrl, NULL }  ,  { &&adduPLUSsrl, NULL }  ,  { &&adduPLUSsrl, NULL }  ,  { &&adduPLUSsrl, NULL }  ,  { &&adduPLUSsrl, NULL }  ,  { &&adduPLUSsrl, NULL }  ,  { &&adduPLUSsrl, NULL }  ,  { &&adduPLUSsrl, NULL } 
 }; 

struct pointer arraymfhiPLUSaddiu[T_SIZE] = {  { &&mfhiPLUSaddiu, NULL }  ,  { &&mfhiPLUSaddiu, NULL }  ,  { &&mfhiPLUSaddiu, NULL }  ,  { &&mfhiPLUSaddiu, NULL }  ,  { &&mfhiPLUSaddiu, NULL }  ,  { &&mfhiPLUSaddiu, NULL }  ,  { &&mfhiPLUSaddiu, NULL }  ,  { &&mfhiPLUSaddiu, NULL }  ,  { &&mfhiPLUSaddiu, NULL }  ,  { &&mfhiPLUSaddiu, NULL } 
 ,  { &&mfhiPLUSaddiu, NULL }  ,  { &&mfhiPLUSaddiu, NULL }  ,  { &&mfhiPLUSaddiu, NULL }  ,  { &&mfhiPLUSaddiu, NULL }  ,  { &&mfhiPLUSaddiu, NULL }  ,  { &&mfhiPLUSaddiu, NULL }  ,  { &&mfhiPLUSaddiu, NULL }  ,  { &&mfhiPLUSaddiu, NULL }  ,  { &&mfhiPLUSaddiu, NULL }  ,  { &&mfhiPLUSaddiu, NULL } 
 ,  { &&mfhiPLUSaddiu, NULL }  ,  { &&mfhiPLUSaddiu, NULL }  ,  { &&mfhiPLUSaddiu, NULL }  ,  { &&mfhiPLUSaddiu, NULL }  ,  { &&mfhiPLUSaddiu, NULL }  ,  { &&mfhiPLUSaddiu, NULL }  ,  { &&mfhiPLUSaddiu, NULL }  ,  { &&mfhiPLUSaddiu, NULL }  ,  { &&mfhiPLUSaddiu, NULL }  ,  { &&mfhiPLUSaddiu, NULL } 
 ,  { &&mfhiPLUSaddiu, NULL }  ,  { &&mfhiPLUSaddiu, NULL }  ,  { &&mfhiPLUSaddiu, NULL }  ,  { &&mfhiPLUSaddiu, NULL }  ,  { &&mfhiPLUSaddiu, NULL }  ,  { &&mfhiPLUSaddiu, NULL }  ,  { &&mfhiPLUSaddiu, NULL }  ,  { &&mfhiPLUSaddiu, NULL }  ,  { &&mfhiPLUSaddiu, NULL }  ,  { &&mfhiPLUSaddiu, NULL } 
 ,  { &&mfhiPLUSaddiu, NULL }  ,  { &&mfhiPLUSaddiu, NULL }  ,  { &&mfhiPLUSaddiu, NULL }  ,  { &&mfhiPLUSaddiu, NULL }  ,  { &&mfhiPLUSaddiu, NULL }  ,  { &&mfhiPLUSaddiu, NULL }  ,  { &&mfhiPLUSaddiu, NULL }  ,  { &&mfhiPLUSaddiu, NULL }  ,  { &&mfhiPLUSaddiu, NULL }  ,  { &&mfhiPLUSaddiu, NULL } 
 ,  { &&mfhiPLUSaddiu, NULL }  ,  { &&mfhiPLUSaddiu, NULL }  ,  { &&mfhiPLUSaddiuPLUSaddiu, NULL }  ,  { &&mfhiPLUSaddiu, NULL }  ,  { &&mfhiPLUSaddiu, NULL }  ,  { &&mfhiPLUSaddiu, NULL }  ,  { &&mfhiPLUSaddiu, NULL }  ,  { &&mfhiPLUSaddiu, NULL }  ,  { &&mfhiPLUSaddiu, NULL }  ,  { &&mfhiPLUSaddiu, NULL } 
 ,  { &&mfhiPLUSaddiu, NULL }  ,  { &&mfhiPLUSaddiu, NULL }  ,  { &&mfhiPLUSaddiu, NULL }  ,  { &&mfhiPLUSaddiu, NULL }  ,  { &&mfhiPLUSaddiu, NULL }  ,  { &&mfhiPLUSaddiu, NULL }  ,  { &&mfhiPLUSaddiu, NULL }  ,  { &&mfhiPLUSaddiu, NULL }  ,  { &&mfhiPLUSaddiu, NULL }  ,  { &&mfhiPLUSaddiu, NULL } 
 ,  { &&mfhiPLUSaddiu, NULL }  ,  { &&mfhiPLUSaddiu, NULL }  ,  { &&mfhiPLUSaddiu, NULL }  ,  { &&mfhiPLUSaddiu, NULL }  ,  { &&mfhiPLUSaddiu, NULL }  ,  { &&mfhiPLUSaddiu, NULL }  ,  { &&mfhiPLUSaddiu, NULL }  ,  { &&mfhiPLUSaddiu, NULL }  ,  { &&mfhiPLUSaddiu, NULL }  ,  { &&mfhiPLUSaddiu, NULL } 
 ,  { &&mfhiPLUSaddiu, NULL }  ,  { &&mfhiPLUSaddiu, NULL }  ,  { &&mfhiPLUSaddiu, NULL }  ,  { &&mfhiPLUSaddiu, NULL }  ,  { &&mfhiPLUSaddiu, NULL }  ,  { &&mfhiPLUSaddiu, NULL }  ,  { &&mfhiPLUSaddiu, NULL }  ,  { &&mfhiPLUSaddiu, NULL }  ,  { &&mfhiPLUSaddiu, NULL }  ,  { &&mfhiPLUSaddiu, NULL } 
 ,  { &&mfhiPLUSaddiu, NULL }  ,  { &&mfhiPLUSaddiu, NULL }  ,  { &&mfhiPLUSaddiu, NULL }  ,  { &&mfhiPLUSaddiu, NULL }  ,  { &&mfhiPLUSaddiu, NULL }  ,  { &&mfhiPLUSaddiu, NULL }  ,  { &&mfhiPLUSaddiu, NULL }  ,  { &&mfhiPLUSaddiu, NULL }  ,  { &&mfhiPLUSaddiu, NULL }  ,  { &&mfhiPLUSaddiu, NULL } 
 ,  { &&mfhiPLUSaddiu, NULL }  ,  { &&mfhiPLUSaddiu, NULL }  ,  { &&mfhiPLUSaddiu, NULL }  ,  { &&mfhiPLUSaddiu, NULL }  ,  { &&mfhiPLUSaddiu, NULL }  ,  { &&mfhiPLUSaddiu, NULL }  ,  { &&mfhiPLUSaddiu, NULL }  ,  { &&mfhiPLUSaddiu, NULL }  ,  { &&mfhiPLUSaddiu, NULL }  ,  { &&mfhiPLUSaddiu, NULL } 
 }; 

struct pointer arrayxorPLUSsll[T_SIZE] = {  { &&xorPLUSsll, NULL }  ,  { &&xorPLUSsll, NULL }  ,  { &&xorPLUSsll, NULL }  ,  { &&xorPLUSsll, NULL }  ,  { &&xorPLUSsll, NULL }  ,  { &&xorPLUSsll, NULL }  ,  { &&xorPLUSsll, NULL }  ,  { &&xorPLUSsll, NULL }  ,  { &&xorPLUSsll, NULL }  ,  { &&xorPLUSsll, NULL } 
 ,  { &&xorPLUSsll, NULL }  ,  { &&xorPLUSsll, NULL }  ,  { &&xorPLUSsll, NULL }  ,  { &&xorPLUSsll, NULL }  ,  { &&xorPLUSsll, NULL }  ,  { &&xorPLUSsll, NULL }  ,  { &&xorPLUSsll, NULL }  ,  { &&xorPLUSsll, NULL }  ,  { &&xorPLUSsll, NULL }  ,  { &&xorPLUSsll, NULL } 
 ,  { &&xorPLUSsll, NULL }  ,  { &&xorPLUSsll, NULL }  ,  { &&xorPLUSsll, NULL }  ,  { &&xorPLUSsll, NULL }  ,  { &&xorPLUSsll, NULL }  ,  { &&xorPLUSsll, NULL }  ,  { &&xorPLUSsll, NULL }  ,  { &&xorPLUSsll, NULL }  ,  { &&xorPLUSsll, NULL }  ,  { &&xorPLUSsll, NULL } 
 ,  { &&xorPLUSsll, NULL }  ,  { &&xorPLUSsll, NULL }  ,  { &&xorPLUSsll, NULL }  ,  { &&xorPLUSsll, NULL }  ,  { &&xorPLUSsll, NULL }  ,  { &&xorPLUSsll, NULL }  ,  { &&xorPLUSsll, NULL }  ,  { &&xorPLUSsll, NULL }  ,  { &&xorPLUSsllPLUSxor, NULL }  ,  { &&xorPLUSsll, NULL } 
 ,  { &&xorPLUSsll, NULL }  ,  { &&xorPLUSsll, NULL }  ,  { &&xorPLUSsll, NULL }  ,  { &&xorPLUSsll, NULL }  ,  { &&xorPLUSsll, NULL }  ,  { &&xorPLUSsll, NULL }  ,  { &&xorPLUSsll, NULL }  ,  { &&xorPLUSsll, NULL }  ,  { &&xorPLUSsll, NULL }  ,  { &&xorPLUSsll, NULL } 
 ,  { &&xorPLUSsll, NULL }  ,  { &&xorPLUSsll, NULL }  ,  { &&xorPLUSsll, NULL }  ,  { &&xorPLUSsll, NULL }  ,  { &&xorPLUSsll, NULL }  ,  { &&xorPLUSsll, NULL }  ,  { &&xorPLUSsll, NULL }  ,  { &&xorPLUSsll, NULL }  ,  { &&xorPLUSsll, NULL }  ,  { &&xorPLUSsll, NULL } 
 ,  { &&xorPLUSsll, NULL }  ,  { &&xorPLUSsll, NULL }  ,  { &&xorPLUSsll, NULL }  ,  { &&xorPLUSsll, NULL }  ,  { &&xorPLUSsll, NULL }  ,  { &&xorPLUSsll, NULL }  ,  { &&xorPLUSsll, NULL }  ,  { &&xorPLUSsll, NULL }  ,  { &&xorPLUSsll, NULL }  ,  { &&xorPLUSsll, NULL } 
 ,  { &&xorPLUSsll, NULL }  ,  { &&xorPLUSsll, NULL }  ,  { &&xorPLUSsll, NULL }  ,  { &&xorPLUSsll, NULL }  ,  { &&xorPLUSsll, NULL }  ,  { &&xorPLUSsll, NULL }  ,  { &&xorPLUSsll, NULL }  ,  { &&xorPLUSsll, NULL }  ,  { &&xorPLUSsll, NULL }  ,  { &&xorPLUSsll, NULL } 
 ,  { &&xorPLUSsll, NULL }  ,  { &&xorPLUSsll, NULL }  ,  { &&xorPLUSsll, NULL }  ,  { &&xorPLUSsll, NULL }  ,  { &&xorPLUSsll, NULL }  ,  { &&xorPLUSsll, NULL }  ,  { &&xorPLUSsll, NULL }  ,  { &&xorPLUSsll, NULL }  ,  { &&xorPLUSsll, NULL }  ,  { &&xorPLUSsll, NULL } 
 ,  { &&xorPLUSsll, NULL }  ,  { &&xorPLUSsll, NULL }  ,  { &&xorPLUSsll, NULL }  ,  { &&xorPLUSsll, NULL }  ,  { &&xorPLUSsll, NULL }  ,  { &&xorPLUSsll, NULL }  ,  { &&xorPLUSsll, NULL }  ,  { &&xorPLUSsll, NULL }  ,  { &&xorPLUSsll, NULL }  ,  { &&xorPLUSsll, NULL } 
 ,  { &&xorPLUSsll, NULL }  ,  { &&xorPLUSsll, NULL }  ,  { &&xorPLUSsll, NULL }  ,  { &&xorPLUSsll, NULL }  ,  { &&xorPLUSsll, NULL }  ,  { &&xorPLUSsll, NULL }  ,  { &&xorPLUSsll, NULL }  ,  { &&xorPLUSsll, NULL }  ,  { &&xorPLUSsll, NULL }  ,  { &&xorPLUSsll, NULL } 
 }; 

struct pointer arrayxorPLUSnor[T_SIZE] = {  { &&xorPLUSnor, NULL }  ,  { &&xorPLUSnor, NULL }  ,  { &&xorPLUSnor, NULL }  ,  { &&xorPLUSnor, NULL }  ,  { &&xorPLUSnor, NULL }  ,  { &&xorPLUSnor, NULL }  ,  { &&xorPLUSnor, NULL }  ,  { &&xorPLUSnor, NULL }  ,  { &&xorPLUSnorPLUSjr, NULL }  ,  { &&xorPLUSnor, NULL } 
 ,  { &&xorPLUSnor, NULL }  ,  { &&xorPLUSnor, NULL }  ,  { &&xorPLUSnor, NULL }  ,  { &&xorPLUSnor, NULL }  ,  { &&xorPLUSnor, NULL }  ,  { &&xorPLUSnor, NULL }  ,  { &&xorPLUSnor, NULL }  ,  { &&xorPLUSnor, NULL }  ,  { &&xorPLUSnor, NULL }  ,  { &&xorPLUSnor, NULL } 
 ,  { &&xorPLUSnor, NULL }  ,  { &&xorPLUSnor, NULL }  ,  { &&xorPLUSnor, NULL }  ,  { &&xorPLUSnor, NULL }  ,  { &&xorPLUSnor, NULL }  ,  { &&xorPLUSnor, NULL }  ,  { &&xorPLUSnor, NULL }  ,  { &&xorPLUSnor, NULL }  ,  { &&xorPLUSnor, NULL }  ,  { &&xorPLUSnor, NULL } 
 ,  { &&xorPLUSnor, NULL }  ,  { &&xorPLUSnor, NULL }  ,  { &&xorPLUSnor, NULL }  ,  { &&xorPLUSnor, NULL }  ,  { &&xorPLUSnor, NULL }  ,  { &&xorPLUSnor, NULL }  ,  { &&xorPLUSnor, NULL }  ,  { &&xorPLUSnor, NULL }  ,  { &&xorPLUSnor, NULL }  ,  { &&xorPLUSnor, NULL } 
 ,  { &&xorPLUSnor, NULL }  ,  { &&xorPLUSnor, NULL }  ,  { &&xorPLUSnor, NULL }  ,  { &&xorPLUSnor, NULL }  ,  { &&xorPLUSnor, NULL }  ,  { &&xorPLUSnor, NULL }  ,  { &&xorPLUSnor, NULL }  ,  { &&xorPLUSnor, NULL }  ,  { &&xorPLUSnor, NULL }  ,  { &&xorPLUSnor, NULL } 
 ,  { &&xorPLUSnor, NULL }  ,  { &&xorPLUSnor, NULL }  ,  { &&xorPLUSnor, NULL }  ,  { &&xorPLUSnor, NULL }  ,  { &&xorPLUSnor, NULL }  ,  { &&xorPLUSnor, NULL }  ,  { &&xorPLUSnor, NULL }  ,  { &&xorPLUSnor, NULL }  ,  { &&xorPLUSnor, NULL }  ,  { &&xorPLUSnor, NULL } 
 ,  { &&xorPLUSnor, NULL }  ,  { &&xorPLUSnor, NULL }  ,  { &&xorPLUSnor, NULL }  ,  { &&xorPLUSnor, NULL }  ,  { &&xorPLUSnor, NULL }  ,  { &&xorPLUSnor, NULL }  ,  { &&xorPLUSnor, NULL }  ,  { &&xorPLUSnor, NULL }  ,  { &&xorPLUSnor, NULL }  ,  { &&xorPLUSnor, NULL } 
 ,  { &&xorPLUSnor, NULL }  ,  { &&xorPLUSnor, NULL }  ,  { &&xorPLUSnor, NULL }  ,  { &&xorPLUSnor, NULL }  ,  { &&xorPLUSnor, NULL }  ,  { &&xorPLUSnor, NULL }  ,  { &&xorPLUSnor, NULL }  ,  { &&xorPLUSnor, NULL }  ,  { &&xorPLUSnor, NULL }  ,  { &&xorPLUSnor, NULL } 
 ,  { &&xorPLUSnor, NULL }  ,  { &&xorPLUSnor, NULL }  ,  { &&xorPLUSnor, NULL }  ,  { &&xorPLUSnor, NULL }  ,  { &&xorPLUSnor, NULL }  ,  { &&xorPLUSnor, NULL }  ,  { &&xorPLUSnor, NULL }  ,  { &&xorPLUSnor, NULL }  ,  { &&xorPLUSnor, NULL }  ,  { &&xorPLUSnor, NULL } 
 ,  { &&xorPLUSnor, NULL }  ,  { &&xorPLUSnor, NULL }  ,  { &&xorPLUSnor, NULL }  ,  { &&xorPLUSnor, NULL }  ,  { &&xorPLUSnor, NULL }  ,  { &&xorPLUSnor, NULL }  ,  { &&xorPLUSnor, NULL }  ,  { &&xorPLUSnor, NULL }  ,  { &&xorPLUSnor, NULL }  ,  { &&xorPLUSnor, NULL } 
 ,  { &&xorPLUSnor, NULL }  ,  { &&xorPLUSnor, NULL }  ,  { &&xorPLUSnor, NULL }  ,  { &&xorPLUSnor, NULL }  ,  { &&xorPLUSnor, NULL }  ,  { &&xorPLUSnor, NULL }  ,  { &&xorPLUSnor, NULL }  ,  { &&xorPLUSnor, NULL }  ,  { &&xorPLUSnor, NULL }  ,  { &&xorPLUSnor, NULL } 
 }; 

struct pointer arrayaddiuPLUSbeq[T_SIZE] = {  { &&addiuPLUSbeq, NULL }  ,  { &&addiuPLUSbeq, NULL }  ,  { &&addiuPLUSbeq, NULL }  ,  { &&addiuPLUSbeq, NULL }  ,  { &&addiuPLUSbeq, NULL }  ,  { &&addiuPLUSbeq, NULL }  ,  { &&addiuPLUSbeq, NULL }  ,  { &&addiuPLUSbeq, NULL }  ,  { &&addiuPLUSbeq, NULL }  ,  { &&addiuPLUSbeq, NULL } 
 ,  { &&addiuPLUSbeq, NULL }  ,  { &&addiuPLUSbeq, NULL }  ,  { &&addiuPLUSbeq, NULL }  ,  { &&addiuPLUSbeq, NULL }  ,  { &&addiuPLUSbeq, NULL }  ,  { &&addiuPLUSbeq, NULL }  ,  { &&addiuPLUSbeq, NULL }  ,  { &&addiuPLUSbeq, NULL }  ,  { &&addiuPLUSbeq, NULL }  ,  { &&addiuPLUSbeq, NULL } 
 ,  { &&addiuPLUSbeq, NULL }  ,  { &&addiuPLUSbeq, NULL }  ,  { &&addiuPLUSbeq, NULL }  ,  { &&addiuPLUSbeq, NULL }  ,  { &&addiuPLUSbeq, NULL }  ,  { &&addiuPLUSbeq, NULL }  ,  { &&addiuPLUSbeq, NULL }  ,  { &&addiuPLUSbeq, NULL }  ,  { &&addiuPLUSbeq, NULL }  ,  { &&addiuPLUSbeq, NULL } 
 ,  { &&addiuPLUSbeq, NULL }  ,  { &&addiuPLUSbeq, NULL }  ,  { &&addiuPLUSbeq, NULL }  ,  { &&addiuPLUSbeqPLUSaddu, NULL }  ,  { &&addiuPLUSbeq, NULL }  ,  { &&addiuPLUSbeq, NULL }  ,  { &&addiuPLUSbeq, NULL }  ,  { &&addiuPLUSbeq, NULL }  ,  { &&addiuPLUSbeq, NULL }  ,  { &&addiuPLUSbeq, NULL } 
 ,  { &&addiuPLUSbeq, NULL }  ,  { &&addiuPLUSbeq, NULL }  ,  { &&addiuPLUSbeq, NULL }  ,  { &&addiuPLUSbeq, NULL }  ,  { &&addiuPLUSbeq, NULL }  ,  { &&addiuPLUSbeq, NULL }  ,  { &&addiuPLUSbeq, NULL }  ,  { &&addiuPLUSbeq, NULL }  ,  { &&addiuPLUSbeq, NULL }  ,  { &&addiuPLUSbeq, NULL } 
 ,  { &&addiuPLUSbeq, NULL }  ,  { &&addiuPLUSbeq, NULL }  ,  { &&addiuPLUSbeq, NULL }  ,  { &&addiuPLUSbeq, NULL }  ,  { &&addiuPLUSbeq, NULL }  ,  { &&addiuPLUSbeq, NULL }  ,  { &&addiuPLUSbeq, NULL }  ,  { &&addiuPLUSbeq, NULL }  ,  { &&addiuPLUSbeq, NULL }  ,  { &&addiuPLUSbeq, NULL } 
 ,  { &&addiuPLUSbeq, NULL }  ,  { &&addiuPLUSbeq, NULL }  ,  { &&addiuPLUSbeq, NULL }  ,  { &&addiuPLUSbeq, NULL }  ,  { &&addiuPLUSbeq, NULL }  ,  { &&addiuPLUSbeq, NULL }  ,  { &&addiuPLUSbeq, NULL }  ,  { &&addiuPLUSbeq, NULL }  ,  { &&addiuPLUSbeq, NULL }  ,  { &&addiuPLUSbeq, NULL } 
 ,  { &&addiuPLUSbeq, NULL }  ,  { &&addiuPLUSbeq, NULL }  ,  { &&addiuPLUSbeq, NULL }  ,  { &&addiuPLUSbeq, NULL }  ,  { &&addiuPLUSbeq, NULL }  ,  { &&addiuPLUSbeq, NULL }  ,  { &&addiuPLUSbeq, NULL }  ,  { &&addiuPLUSbeq, NULL }  ,  { &&addiuPLUSbeq, NULL }  ,  { &&addiuPLUSbeq, NULL } 
 ,  { &&addiuPLUSbeq, NULL }  ,  { &&addiuPLUSbeq, NULL }  ,  { &&addiuPLUSbeq, NULL }  ,  { &&addiuPLUSbeq, NULL }  ,  { &&addiuPLUSbeq, NULL }  ,  { &&addiuPLUSbeq, NULL }  ,  { &&addiuPLUSbeqPLUSsw, NULL }  ,  { &&addiuPLUSbeq, NULL }  ,  { &&addiuPLUSbeq, NULL }  ,  { &&addiuPLUSbeq, NULL } 
 ,  { &&addiuPLUSbeq, NULL }  ,  { &&addiuPLUSbeq, NULL }  ,  { &&addiuPLUSbeq, NULL }  ,  { &&addiuPLUSbeq, NULL }  ,  { &&addiuPLUSbeq, NULL }  ,  { &&addiuPLUSbeq, NULL }  ,  { &&addiuPLUSbeq, NULL }  ,  { &&addiuPLUSbeq, NULL }  ,  { &&addiuPLUSbeq, NULL }  ,  { &&addiuPLUSbeq, NULL } 
 ,  { &&addiuPLUSbeq, NULL }  ,  { &&addiuPLUSbeq, NULL }  ,  { &&addiuPLUSbeq, NULL }  ,  { &&addiuPLUSbeq, NULL }  ,  { &&addiuPLUSbeq, NULL }  ,  { &&addiuPLUSbeq, NULL }  ,  { &&addiuPLUSbeq, NULL }  ,  { &&addiuPLUSbeq, NULL }  ,  { &&addiuPLUSbeq, NULL }  ,  { &&addiuPLUSbeq, NULL } 
 }; 

struct pointer arrayaddiuPLUSsysc[T_SIZE] = {  { &&addiuPLUSsysc, NULL }  ,  { &&addiuPLUSsysc, NULL }  ,  { &&addiuPLUSsysc, NULL }  ,  { &&addiuPLUSsysc, NULL }  ,  { &&addiuPLUSsysc, NULL }  ,  { &&addiuPLUSsysc, NULL }  ,  { &&addiuPLUSsysc, NULL }  ,  { &&addiuPLUSsysc, NULL }  ,  { &&addiuPLUSsyscPLUSjr, NULL }  ,  { &&addiuPLUSsysc, NULL } 
 ,  { &&addiuPLUSsysc, NULL }  ,  { &&addiuPLUSsysc, NULL }  ,  { &&addiuPLUSsysc, NULL }  ,  { &&addiuPLUSsysc, NULL }  ,  { &&addiuPLUSsysc, NULL }  ,  { &&addiuPLUSsysc, NULL }  ,  { &&addiuPLUSsysc, NULL }  ,  { &&addiuPLUSsysc, NULL }  ,  { &&addiuPLUSsysc, NULL }  ,  { &&addiuPLUSsysc, NULL } 
 ,  { &&addiuPLUSsysc, NULL }  ,  { &&addiuPLUSsysc, NULL }  ,  { &&addiuPLUSsysc, NULL }  ,  { &&addiuPLUSsysc, NULL }  ,  { &&addiuPLUSsysc, NULL }  ,  { &&addiuPLUSsysc, NULL }  ,  { &&addiuPLUSsysc, NULL }  ,  { &&addiuPLUSsysc, NULL }  ,  { &&addiuPLUSsysc, NULL }  ,  { &&addiuPLUSsysc, NULL } 
 ,  { &&addiuPLUSsysc, NULL }  ,  { &&addiuPLUSsysc, NULL }  ,  { &&addiuPLUSsysc, NULL }  ,  { &&addiuPLUSsysc, NULL }  ,  { &&addiuPLUSsysc, NULL }  ,  { &&addiuPLUSsysc, NULL }  ,  { &&addiuPLUSsysc, NULL }  ,  { &&addiuPLUSsysc, NULL }  ,  { &&addiuPLUSsysc, NULL }  ,  { &&addiuPLUSsysc, NULL } 
 ,  { &&addiuPLUSsysc, NULL }  ,  { &&addiuPLUSsysc, NULL }  ,  { &&addiuPLUSsysc, NULL }  ,  { &&addiuPLUSsysc, NULL }  ,  { &&addiuPLUSsysc, NULL }  ,  { &&addiuPLUSsysc, NULL }  ,  { &&addiuPLUSsyscPLUSjal, NULL }  ,  { &&addiuPLUSsysc, NULL }  ,  { &&addiuPLUSsysc, NULL }  ,  { &&addiuPLUSsysc, NULL } 
 ,  { &&addiuPLUSsysc, NULL }  ,  { &&addiuPLUSsysc, NULL }  ,  { &&addiuPLUSsysc, NULL }  ,  { &&addiuPLUSsysc, NULL }  ,  { &&addiuPLUSsysc, NULL }  ,  { &&addiuPLUSsysc, NULL }  ,  { &&addiuPLUSsysc, NULL }  ,  { &&addiuPLUSsysc, NULL }  ,  { &&addiuPLUSsysc, NULL }  ,  { &&addiuPLUSsysc, NULL } 
 ,  { &&addiuPLUSsysc, NULL }  ,  { &&addiuPLUSsysc, NULL }  ,  { &&addiuPLUSsysc, NULL }  ,  { &&addiuPLUSsysc, NULL }  ,  { &&addiuPLUSsysc, NULL }  ,  { &&addiuPLUSsysc, NULL }  ,  { &&addiuPLUSsysc, NULL }  ,  { &&addiuPLUSsysc, NULL }  ,  { &&addiuPLUSsysc, NULL }  ,  { &&addiuPLUSsysc, NULL } 
 ,  { &&addiuPLUSsysc, NULL }  ,  { &&addiuPLUSsysc, NULL }  ,  { &&addiuPLUSsysc, NULL }  ,  { &&addiuPLUSsysc, NULL }  ,  { &&addiuPLUSsysc, NULL }  ,  { &&addiuPLUSsysc, NULL }  ,  { &&addiuPLUSsysc, NULL }  ,  { &&addiuPLUSsysc, NULL }  ,  { &&addiuPLUSsysc, NULL }  ,  { &&addiuPLUSsysc, NULL } 
 ,  { &&addiuPLUSsysc, NULL }  ,  { &&addiuPLUSsysc, NULL }  ,  { &&addiuPLUSsysc, NULL }  ,  { &&addiuPLUSsysc, NULL }  ,  { &&addiuPLUSsysc, NULL }  ,  { &&addiuPLUSsysc, NULL }  ,  { &&addiuPLUSsysc, NULL }  ,  { &&addiuPLUSsysc, NULL }  ,  { &&addiuPLUSsysc, NULL }  ,  { &&addiuPLUSsysc, NULL } 
 ,  { &&addiuPLUSsysc, NULL }  ,  { &&addiuPLUSsysc, NULL }  ,  { &&addiuPLUSsysc, NULL }  ,  { &&addiuPLUSsysc, NULL }  ,  { &&addiuPLUSsysc, NULL }  ,  { &&addiuPLUSsysc, NULL }  ,  { &&addiuPLUSsysc, NULL }  ,  { &&addiuPLUSsysc, NULL }  ,  { &&addiuPLUSsysc, NULL }  ,  { &&addiuPLUSsysc, NULL } 
 ,  { &&addiuPLUSsysc, NULL }  ,  { &&addiuPLUSsysc, NULL }  ,  { &&addiuPLUSsysc, NULL }  ,  { &&addiuPLUSsysc, NULL }  ,  { &&addiuPLUSsysc, NULL }  ,  { &&addiuPLUSsysc, NULL }  ,  { &&addiuPLUSsysc, NULL }  ,  { &&addiuPLUSsysc, NULL }  ,  { &&addiuPLUSsysc, NULL }  ,  { &&addiuPLUSsysc, NULL } 
 }; 

struct pointer arrayandPLUSsll[T_SIZE] = {  { &&andPLUSsll, NULL }  ,  { &&andPLUSsll, NULL }  ,  { &&andPLUSsll, NULL }  ,  { &&andPLUSsll, NULL }  ,  { &&andPLUSsll, NULL }  ,  { &&andPLUSsll, NULL }  ,  { &&andPLUSsll, NULL }  ,  { &&andPLUSsll, NULL }  ,  { &&andPLUSsll, NULL }  ,  { &&andPLUSsll, NULL } 
 ,  { &&andPLUSsll, NULL }  ,  { &&andPLUSsll, NULL }  ,  { &&andPLUSsll, NULL }  ,  { &&andPLUSsll, NULL }  ,  { &&andPLUSsll, NULL }  ,  { &&andPLUSsll, NULL }  ,  { &&andPLUSsll, NULL }  ,  { &&andPLUSsll, NULL }  ,  { &&andPLUSsll, NULL }  ,  { &&andPLUSsll, NULL } 
 ,  { &&andPLUSsll, NULL }  ,  { &&andPLUSsll, NULL }  ,  { &&andPLUSsll, NULL }  ,  { &&andPLUSsll, NULL }  ,  { &&andPLUSsll, NULL }  ,  { &&andPLUSsll, NULL }  ,  { &&andPLUSsll, NULL }  ,  { &&andPLUSsll, NULL }  ,  { &&andPLUSsll, NULL }  ,  { &&andPLUSsll, NULL } 
 ,  { &&andPLUSsll, NULL }  ,  { &&andPLUSsll, NULL }  ,  { &&andPLUSsll, NULL }  ,  { &&andPLUSsll, NULL }  ,  { &&andPLUSsll, NULL }  ,  { &&andPLUSsll, NULL }  ,  { &&andPLUSsll, NULL }  ,  { &&andPLUSsll, NULL }  ,  { &&andPLUSsll, NULL }  ,  { &&andPLUSsll, NULL } 
 ,  { &&andPLUSsll, NULL }  ,  { &&andPLUSsll, NULL }  ,  { &&andPLUSsll, NULL }  ,  { &&andPLUSsll, NULL }  ,  { &&andPLUSsll, NULL }  ,  { &&andPLUSsll, NULL }  ,  { &&andPLUSsll, NULL }  ,  { &&andPLUSsll, NULL }  ,  { &&andPLUSsll, NULL }  ,  { &&andPLUSsll, NULL } 
 ,  { &&andPLUSsll, NULL }  ,  { &&andPLUSsll, NULL }  ,  { &&andPLUSsll, NULL }  ,  { &&andPLUSsll, NULL }  ,  { &&andPLUSsll, NULL }  ,  { &&andPLUSsll, NULL }  ,  { &&andPLUSsllPLUSori, NULL }  ,  { &&andPLUSsll, NULL }  ,  { &&andPLUSsllPLUSlui, NULL }  ,  { &&andPLUSsll, NULL } 
 ,  { &&andPLUSsll, NULL }  ,  { &&andPLUSsll, NULL }  ,  { &&andPLUSsll, NULL }  ,  { &&andPLUSsll, NULL }  ,  { &&andPLUSsll, NULL }  ,  { &&andPLUSsll, NULL }  ,  { &&andPLUSsll, NULL }  ,  { &&andPLUSsll, NULL }  ,  { &&andPLUSsll, NULL }  ,  { &&andPLUSsll, NULL } 
 ,  { &&andPLUSsll, NULL }  ,  { &&andPLUSsll, NULL }  ,  { &&andPLUSsll, NULL }  ,  { &&andPLUSsll, NULL }  ,  { &&andPLUSsll, NULL }  ,  { &&andPLUSsll, NULL }  ,  { &&andPLUSsll, NULL }  ,  { &&andPLUSsll, NULL }  ,  { &&andPLUSsll, NULL }  ,  { &&andPLUSsll, NULL } 
 ,  { &&andPLUSsll, NULL }  ,  { &&andPLUSsll, NULL }  ,  { &&andPLUSsll, NULL }  ,  { &&andPLUSsll, NULL }  ,  { &&andPLUSsll, NULL }  ,  { &&andPLUSsll, NULL }  ,  { &&andPLUSsll, NULL }  ,  { &&andPLUSsll, NULL }  ,  { &&andPLUSsll, NULL }  ,  { &&andPLUSsll, NULL } 
 ,  { &&andPLUSsll, NULL }  ,  { &&andPLUSsll, NULL }  ,  { &&andPLUSsll, NULL }  ,  { &&andPLUSsll, NULL }  ,  { &&andPLUSsll, NULL }  ,  { &&andPLUSsll, NULL }  ,  { &&andPLUSsll, NULL }  ,  { &&andPLUSsll, NULL }  ,  { &&andPLUSsll, NULL }  ,  { &&andPLUSsll, NULL } 
 ,  { &&andPLUSsll, NULL }  ,  { &&andPLUSsll, NULL }  ,  { &&andPLUSsll, NULL }  ,  { &&andPLUSsll, NULL }  ,  { &&andPLUSsll, NULL }  ,  { &&andPLUSsll, NULL }  ,  { &&andPLUSsll, NULL }  ,  { &&andPLUSsll, NULL }  ,  { &&andPLUSsll, NULL }  ,  { &&andPLUSsll, NULL } 
 }; 

struct pointer arraysltuPLUSlw[T_SIZE] = {  { &&sltuPLUSlw, NULL }  ,  { &&sltuPLUSlw, NULL }  ,  { &&sltuPLUSlw, NULL }  ,  { &&sltuPLUSlw, NULL }  ,  { &&sltuPLUSlw, NULL }  ,  { &&sltuPLUSlw, NULL }  ,  { &&sltuPLUSlw, NULL }  ,  { &&sltuPLUSlw, NULL }  ,  { &&sltuPLUSlw, NULL }  ,  { &&sltuPLUSlw, NULL } 
 ,  { &&sltuPLUSlw, NULL }  ,  { &&sltuPLUSlw, NULL }  ,  { &&sltuPLUSlw, NULL }  ,  { &&sltuPLUSlw, NULL }  ,  { &&sltuPLUSlw, NULL }  ,  { &&sltuPLUSlw, NULL }  ,  { &&sltuPLUSlw, NULL }  ,  { &&sltuPLUSlw, NULL }  ,  { &&sltuPLUSlw, NULL }  ,  { &&sltuPLUSlw, NULL } 
 ,  { &&sltuPLUSlw, NULL }  ,  { &&sltuPLUSlw, NULL }  ,  { &&sltuPLUSlw, NULL }  ,  { &&sltuPLUSlw, NULL }  ,  { &&sltuPLUSlw, NULL }  ,  { &&sltuPLUSlw, NULL }  ,  { &&sltuPLUSlw, NULL }  ,  { &&sltuPLUSlw, NULL }  ,  { &&sltuPLUSlw, NULL }  ,  { &&sltuPLUSlw, NULL } 
 ,  { &&sltuPLUSlw, NULL }  ,  { &&sltuPLUSlw, NULL }  ,  { &&sltuPLUSlw, NULL }  ,  { &&sltuPLUSlw, NULL }  ,  { &&sltuPLUSlw, NULL }  ,  { &&sltuPLUSlw, NULL }  ,  { &&sltuPLUSlw, NULL }  ,  { &&sltuPLUSlw, NULL }  ,  { &&sltuPLUSlw, NULL }  ,  { &&sltuPLUSlw, NULL } 
 ,  { &&sltuPLUSlw, NULL }  ,  { &&sltuPLUSlw, NULL }  ,  { &&sltuPLUSlw, NULL }  ,  { &&sltuPLUSlw, NULL }  ,  { &&sltuPLUSlw, NULL }  ,  { &&sltuPLUSlw, NULL }  ,  { &&sltuPLUSlw, NULL }  ,  { &&sltuPLUSlw, NULL }  ,  { &&sltuPLUSlw, NULL }  ,  { &&sltuPLUSlw, NULL } 
 ,  { &&sltuPLUSlw, NULL }  ,  { &&sltuPLUSlw, NULL }  ,  { &&sltuPLUSlw, NULL }  ,  { &&sltuPLUSlw, NULL }  ,  { &&sltuPLUSlw, NULL }  ,  { &&sltuPLUSlw, NULL }  ,  { &&sltuPLUSlw, NULL }  ,  { &&sltuPLUSlw, NULL }  ,  { &&sltuPLUSlw, NULL }  ,  { &&sltuPLUSlw, NULL } 
 ,  { &&sltuPLUSlw, NULL }  ,  { &&sltuPLUSlw, NULL }  ,  { &&sltuPLUSlw, NULL }  ,  { &&sltuPLUSlw, NULL }  ,  { &&sltuPLUSlw, NULL }  ,  { &&sltuPLUSlw, NULL }  ,  { &&sltuPLUSlw, NULL }  ,  { &&sltuPLUSlw, NULL }  ,  { &&sltuPLUSlw, NULL }  ,  { &&sltuPLUSlw, NULL } 
 ,  { &&sltuPLUSlw, NULL }  ,  { &&sltuPLUSlw, NULL }  ,  { &&sltuPLUSlw, NULL }  ,  { &&sltuPLUSlw, NULL }  ,  { &&sltuPLUSlw, NULL }  ,  { &&sltuPLUSlw, NULL }  ,  { &&sltuPLUSlw, NULL }  ,  { &&sltuPLUSlw, NULL }  ,  { &&sltuPLUSlwPLUSlw, NULL }  ,  { &&sltuPLUSlw, NULL } 
 ,  { &&sltuPLUSlw, NULL }  ,  { &&sltuPLUSlw, NULL }  ,  { &&sltuPLUSlw, NULL }  ,  { &&sltuPLUSlw, NULL }  ,  { &&sltuPLUSlw, NULL }  ,  { &&sltuPLUSlw, NULL }  ,  { &&sltuPLUSlw, NULL }  ,  { &&sltuPLUSlw, NULL }  ,  { &&sltuPLUSlw, NULL }  ,  { &&sltuPLUSlw, NULL } 
 ,  { &&sltuPLUSlw, NULL }  ,  { &&sltuPLUSlw, NULL }  ,  { &&sltuPLUSlw, NULL }  ,  { &&sltuPLUSlw, NULL }  ,  { &&sltuPLUSlw, NULL }  ,  { &&sltuPLUSlw, NULL }  ,  { &&sltuPLUSlw, NULL }  ,  { &&sltuPLUSlw, NULL }  ,  { &&sltuPLUSlw, NULL }  ,  { &&sltuPLUSlw, NULL } 
 ,  { &&sltuPLUSlw, NULL }  ,  { &&sltuPLUSlw, NULL }  ,  { &&sltuPLUSlw, NULL }  ,  { &&sltuPLUSlw, NULL }  ,  { &&sltuPLUSlw, NULL }  ,  { &&sltuPLUSlw, NULL }  ,  { &&sltuPLUSlw, NULL }  ,  { &&sltuPLUSlw, NULL }  ,  { &&sltuPLUSlw, NULL }  ,  { &&sltuPLUSlw, NULL } 
 }; 

struct pointer arraysllPLUSmult[T_SIZE] = {  { &&sllPLUSmult, NULL }  ,  { &&sllPLUSmult, NULL }  ,  { &&sllPLUSmult, NULL }  ,  { &&sllPLUSmult, NULL }  ,  { &&sllPLUSmult, NULL }  ,  { &&sllPLUSmult, NULL }  ,  { &&sllPLUSmult, NULL }  ,  { &&sllPLUSmult, NULL }  ,  { &&sllPLUSmult, NULL }  ,  { &&sllPLUSmult, NULL } 
 ,  { &&sllPLUSmult, NULL }  ,  { &&sllPLUSmult, NULL }  ,  { &&sllPLUSmult, NULL }  ,  { &&sllPLUSmult, NULL }  ,  { &&sllPLUSmult, NULL }  ,  { &&sllPLUSmult, NULL }  ,  { &&sllPLUSmultPLUSmfhi, NULL }  ,  { &&sllPLUSmult, NULL }  ,  { &&sllPLUSmult, NULL }  ,  { &&sllPLUSmult, NULL } 
 ,  { &&sllPLUSmult, NULL }  ,  { &&sllPLUSmult, NULL }  ,  { &&sllPLUSmult, NULL }  ,  { &&sllPLUSmult, NULL }  ,  { &&sllPLUSmult, NULL }  ,  { &&sllPLUSmult, NULL }  ,  { &&sllPLUSmult, NULL }  ,  { &&sllPLUSmult, NULL }  ,  { &&sllPLUSmult, NULL }  ,  { &&sllPLUSmult, NULL } 
 ,  { &&sllPLUSmult, NULL }  ,  { &&sllPLUSmult, NULL }  ,  { &&sllPLUSmult, NULL }  ,  { &&sllPLUSmult, NULL }  ,  { &&sllPLUSmult, NULL }  ,  { &&sllPLUSmult, NULL }  ,  { &&sllPLUSmult, NULL }  ,  { &&sllPLUSmult, NULL }  ,  { &&sllPLUSmult, NULL }  ,  { &&sllPLUSmult, NULL } 
 ,  { &&sllPLUSmult, NULL }  ,  { &&sllPLUSmult, NULL }  ,  { &&sllPLUSmult, NULL }  ,  { &&sllPLUSmult, NULL }  ,  { &&sllPLUSmult, NULL }  ,  { &&sllPLUSmult, NULL }  ,  { &&sllPLUSmult, NULL }  ,  { &&sllPLUSmult, NULL }  ,  { &&sllPLUSmult, NULL }  ,  { &&sllPLUSmult, NULL } 
 ,  { &&sllPLUSmult, NULL }  ,  { &&sllPLUSmult, NULL }  ,  { &&sllPLUSmult, NULL }  ,  { &&sllPLUSmult, NULL }  ,  { &&sllPLUSmult, NULL }  ,  { &&sllPLUSmult, NULL }  ,  { &&sllPLUSmult, NULL }  ,  { &&sllPLUSmult, NULL }  ,  { &&sllPLUSmult, NULL }  ,  { &&sllPLUSmult, NULL } 
 ,  { &&sllPLUSmult, NULL }  ,  { &&sllPLUSmult, NULL }  ,  { &&sllPLUSmult, NULL }  ,  { &&sllPLUSmult, NULL }  ,  { &&sllPLUSmult, NULL }  ,  { &&sllPLUSmult, NULL }  ,  { &&sllPLUSmult, NULL }  ,  { &&sllPLUSmult, NULL }  ,  { &&sllPLUSmult, NULL }  ,  { &&sllPLUSmult, NULL } 
 ,  { &&sllPLUSmult, NULL }  ,  { &&sllPLUSmult, NULL }  ,  { &&sllPLUSmult, NULL }  ,  { &&sllPLUSmult, NULL }  ,  { &&sllPLUSmult, NULL }  ,  { &&sllPLUSmult, NULL }  ,  { &&sllPLUSmult, NULL }  ,  { &&sllPLUSmult, NULL }  ,  { &&sllPLUSmult, NULL }  ,  { &&sllPLUSmult, NULL } 
 ,  { &&sllPLUSmult, NULL }  ,  { &&sllPLUSmult, NULL }  ,  { &&sllPLUSmult, NULL }  ,  { &&sllPLUSmult, NULL }  ,  { &&sllPLUSmult, NULL }  ,  { &&sllPLUSmult, NULL }  ,  { &&sllPLUSmult, NULL }  ,  { &&sllPLUSmult, NULL }  ,  { &&sllPLUSmult, NULL }  ,  { &&sllPLUSmult, NULL } 
 ,  { &&sllPLUSmult, NULL }  ,  { &&sllPLUSmult, NULL }  ,  { &&sllPLUSmult, NULL }  ,  { &&sllPLUSmult, NULL }  ,  { &&sllPLUSmult, NULL }  ,  { &&sllPLUSmult, NULL }  ,  { &&sllPLUSmult, NULL }  ,  { &&sllPLUSmult, NULL }  ,  { &&sllPLUSmult, NULL }  ,  { &&sllPLUSmult, NULL } 
 ,  { &&sllPLUSmult, NULL }  ,  { &&sllPLUSmult, NULL }  ,  { &&sllPLUSmult, NULL }  ,  { &&sllPLUSmult, NULL }  ,  { &&sllPLUSmult, NULL }  ,  { &&sllPLUSmult, NULL }  ,  { &&sllPLUSmult, NULL }  ,  { &&sllPLUSmult, NULL }  ,  { &&sllPLUSmult, NULL }  ,  { &&sllPLUSmult, NULL } 
 }; 

struct pointer arrayandPLUSor[T_SIZE] = {  { &&andPLUSorPLUSsll, NULL }  ,  { &&andPLUSor, NULL }  ,  { &&andPLUSorPLUSsrl, NULL }  ,  { &&andPLUSor, NULL }  ,  { &&andPLUSor, NULL }  ,  { &&andPLUSor, NULL }  ,  { &&andPLUSor, NULL }  ,  { &&andPLUSor, NULL }  ,  { &&andPLUSor, NULL }  ,  { &&andPLUSor, NULL } 
 ,  { &&andPLUSor, NULL }  ,  { &&andPLUSor, NULL }  ,  { &&andPLUSor, NULL }  ,  { &&andPLUSor, NULL }  ,  { &&andPLUSor, NULL }  ,  { &&andPLUSor, NULL }  ,  { &&andPLUSor, NULL }  ,  { &&andPLUSor, NULL }  ,  { &&andPLUSor, NULL }  ,  { &&andPLUSor, NULL } 
 ,  { &&andPLUSor, NULL }  ,  { &&andPLUSor, NULL }  ,  { &&andPLUSor, NULL }  ,  { &&andPLUSor, NULL }  ,  { &&andPLUSor, NULL }  ,  { &&andPLUSor, NULL }  ,  { &&andPLUSor, NULL }  ,  { &&andPLUSor, NULL }  ,  { &&andPLUSor, NULL }  ,  { &&andPLUSor, NULL } 
 ,  { &&andPLUSor, NULL }  ,  { &&andPLUSor, NULL }  ,  { &&andPLUSor, NULL }  ,  { &&andPLUSor, NULL }  ,  { &&andPLUSor, NULL }  ,  { &&andPLUSor, NULL }  ,  { &&andPLUSor, NULL }  ,  { &&andPLUSor, NULL }  ,  { &&andPLUSor, NULL }  ,  { &&andPLUSor, NULL } 
 ,  { &&andPLUSor, NULL }  ,  { &&andPLUSor, NULL }  ,  { &&andPLUSor, NULL }  ,  { &&andPLUSor, NULL }  ,  { &&andPLUSor, NULL }  ,  { &&andPLUSor, NULL }  ,  { &&andPLUSor, NULL }  ,  { &&andPLUSor, NULL }  ,  { &&andPLUSor, NULL }  ,  { &&andPLUSor, NULL } 
 ,  { &&andPLUSor, NULL }  ,  { &&andPLUSor, NULL }  ,  { &&andPLUSor, NULL }  ,  { &&andPLUSor, NULL }  ,  { &&andPLUSor, NULL }  ,  { &&andPLUSor, NULL }  ,  { &&andPLUSor, NULL }  ,  { &&andPLUSor, NULL }  ,  { &&andPLUSorPLUSlui, NULL }  ,  { &&andPLUSor, NULL } 
 ,  { &&andPLUSor, NULL }  ,  { &&andPLUSor, NULL }  ,  { &&andPLUSor, NULL }  ,  { &&andPLUSor, NULL }  ,  { &&andPLUSor, NULL }  ,  { &&andPLUSor, NULL }  ,  { &&andPLUSor, NULL }  ,  { &&andPLUSor, NULL }  ,  { &&andPLUSor, NULL }  ,  { &&andPLUSor, NULL } 
 ,  { &&andPLUSor, NULL }  ,  { &&andPLUSor, NULL }  ,  { &&andPLUSor, NULL }  ,  { &&andPLUSor, NULL }  ,  { &&andPLUSor, NULL }  ,  { &&andPLUSor, NULL }  ,  { &&andPLUSor, NULL }  ,  { &&andPLUSor, NULL }  ,  { &&andPLUSor, NULL }  ,  { &&andPLUSor, NULL } 
 ,  { &&andPLUSor, NULL }  ,  { &&andPLUSor, NULL }  ,  { &&andPLUSor, NULL }  ,  { &&andPLUSor, NULL }  ,  { &&andPLUSor, NULL }  ,  { &&andPLUSor, NULL }  ,  { &&andPLUSor, NULL }  ,  { &&andPLUSor, NULL }  ,  { &&andPLUSor, NULL }  ,  { &&andPLUSor, NULL } 
 ,  { &&andPLUSor, NULL }  ,  { &&andPLUSor, NULL }  ,  { &&andPLUSor, NULL }  ,  { &&andPLUSor, NULL }  ,  { &&andPLUSor, NULL }  ,  { &&andPLUSor, NULL }  ,  { &&andPLUSor, NULL }  ,  { &&andPLUSor, NULL }  ,  { &&andPLUSor, NULL }  ,  { &&andPLUSor, NULL } 
 ,  { &&andPLUSor, NULL }  ,  { &&andPLUSor, NULL }  ,  { &&andPLUSor, NULL }  ,  { &&andPLUSor, NULL }  ,  { &&andPLUSor, NULL }  ,  { &&andPLUSor, NULL }  ,  { &&andPLUSor, NULL }  ,  { &&andPLUSor, NULL }  ,  { &&andPLUSor, NULL }  ,  { &&andPLUSor, NULL } 
 }; 

struct pointer arrayjumpPLUSaddiu[T_SIZE] = {  { &&jumpPLUSaddiuPLUSsll, NULL }  ,  { &&jumpPLUSaddiu, NULL }  ,  { &&jumpPLUSaddiu, NULL }  ,  { &&jumpPLUSaddiu, NULL }  ,  { &&jumpPLUSaddiu, NULL }  ,  { &&jumpPLUSaddiu, NULL }  ,  { &&jumpPLUSaddiu, NULL }  ,  { &&jumpPLUSaddiu, NULL }  ,  { &&jumpPLUSaddiu, NULL }  ,  { &&jumpPLUSaddiu, NULL } 
 ,  { &&jumpPLUSaddiu, NULL }  ,  { &&jumpPLUSaddiu, NULL }  ,  { &&jumpPLUSaddiu, NULL }  ,  { &&jumpPLUSaddiu, NULL }  ,  { &&jumpPLUSaddiu, NULL }  ,  { &&jumpPLUSaddiu, NULL }  ,  { &&jumpPLUSaddiu, NULL }  ,  { &&jumpPLUSaddiu, NULL }  ,  { &&jumpPLUSaddiu, NULL }  ,  { &&jumpPLUSaddiu, NULL } 
 ,  { &&jumpPLUSaddiu, NULL }  ,  { &&jumpPLUSaddiu, NULL }  ,  { &&jumpPLUSaddiu, NULL }  ,  { &&jumpPLUSaddiu, NULL }  ,  { &&jumpPLUSaddiu, NULL }  ,  { &&jumpPLUSaddiu, NULL }  ,  { &&jumpPLUSaddiu, NULL }  ,  { &&jumpPLUSaddiu, NULL }  ,  { &&jumpPLUSaddiu, NULL }  ,  { &&jumpPLUSaddiu, NULL } 
 ,  { &&jumpPLUSaddiu, NULL }  ,  { &&jumpPLUSaddiu, NULL }  ,  { &&jumpPLUSaddiu, NULL }  ,  { &&jumpPLUSaddiu, NULL }  ,  { &&jumpPLUSaddiu, NULL }  ,  { &&jumpPLUSaddiu, NULL }  ,  { &&jumpPLUSaddiu, NULL }  ,  { &&jumpPLUSaddiu, NULL }  ,  { &&jumpPLUSaddiu, NULL }  ,  { &&jumpPLUSaddiu, NULL } 
 ,  { &&jumpPLUSaddiu, NULL }  ,  { &&jumpPLUSaddiu, NULL }  ,  { &&jumpPLUSaddiu, NULL }  ,  { &&jumpPLUSaddiu, NULL }  ,  { &&jumpPLUSaddiu, NULL }  ,  { &&jumpPLUSaddiu, NULL }  ,  { &&jumpPLUSaddiu, NULL }  ,  { &&jumpPLUSaddiu, NULL }  ,  { &&jumpPLUSaddiu, NULL }  ,  { &&jumpPLUSaddiu, NULL } 
 ,  { &&jumpPLUSaddiu, NULL }  ,  { &&jumpPLUSaddiu, NULL }  ,  { &&jumpPLUSaddiu, NULL }  ,  { &&jumpPLUSaddiuPLUSslti, NULL }  ,  { &&jumpPLUSaddiu, NULL }  ,  { &&jumpPLUSaddiu, NULL }  ,  { &&jumpPLUSaddiu, NULL }  ,  { &&jumpPLUSaddiu, NULL }  ,  { &&jumpPLUSaddiu, NULL }  ,  { &&jumpPLUSaddiu, NULL } 
 ,  { &&jumpPLUSaddiu, NULL }  ,  { &&jumpPLUSaddiu, NULL }  ,  { &&jumpPLUSaddiu, NULL }  ,  { &&jumpPLUSaddiu, NULL }  ,  { &&jumpPLUSaddiu, NULL }  ,  { &&jumpPLUSaddiu, NULL }  ,  { &&jumpPLUSaddiu, NULL }  ,  { &&jumpPLUSaddiu, NULL }  ,  { &&jumpPLUSaddiu, NULL }  ,  { &&jumpPLUSaddiu, NULL } 
 ,  { &&jumpPLUSaddiu, NULL }  ,  { &&jumpPLUSaddiu, NULL }  ,  { &&jumpPLUSaddiu, NULL }  ,  { &&jumpPLUSaddiu, NULL }  ,  { &&jumpPLUSaddiu, NULL }  ,  { &&jumpPLUSaddiu, NULL }  ,  { &&jumpPLUSaddiu, NULL }  ,  { &&jumpPLUSaddiu, NULL }  ,  { &&jumpPLUSaddiuPLUSlw, NULL }  ,  { &&jumpPLUSaddiu, NULL } 
 ,  { &&jumpPLUSaddiu, NULL }  ,  { &&jumpPLUSaddiu, NULL }  ,  { &&jumpPLUSaddiu, NULL }  ,  { &&jumpPLUSaddiu, NULL }  ,  { &&jumpPLUSaddiu, NULL }  ,  { &&jumpPLUSaddiu, NULL }  ,  { &&jumpPLUSaddiu, NULL }  ,  { &&jumpPLUSaddiu, NULL }  ,  { &&jumpPLUSaddiu, NULL }  ,  { &&jumpPLUSaddiu, NULL } 
 ,  { &&jumpPLUSaddiu, NULL }  ,  { &&jumpPLUSaddiu, NULL }  ,  { &&jumpPLUSaddiu, NULL }  ,  { &&jumpPLUSaddiu, NULL }  ,  { &&jumpPLUSaddiu, NULL }  ,  { &&jumpPLUSaddiu, NULL }  ,  { &&jumpPLUSaddiu, NULL }  ,  { &&jumpPLUSaddiu, NULL }  ,  { &&jumpPLUSaddiu, NULL }  ,  { &&jumpPLUSaddiu, NULL } 
 ,  { &&jumpPLUSaddiu, NULL }  ,  { &&jumpPLUSaddiu, NULL }  ,  { &&jumpPLUSaddiu, NULL }  ,  { &&jumpPLUSaddiu, NULL }  ,  { &&jumpPLUSaddiu, NULL }  ,  { &&jumpPLUSaddiu, NULL }  ,  { &&jumpPLUSaddiu, NULL }  ,  { &&jumpPLUSaddiu, NULL }  ,  { &&jumpPLUSaddiu, NULL }  ,  { &&jumpPLUSaddiu, NULL } 
 }; 

struct pointer arrayjalPLUSsll[T_SIZE] = {  { &&jalPLUSsll, NULL }  ,  { &&jalPLUSsll, NULL }  ,  { &&jalPLUSsll, NULL }  ,  { &&jalPLUSsll, NULL }  ,  { &&jalPLUSsll, NULL }  ,  { &&jalPLUSsll, NULL }  ,  { &&jalPLUSsll, NULL }  ,  { &&jalPLUSsll, NULL }  ,  { &&jalPLUSsll, NULL }  ,  { &&jalPLUSsll, NULL } 
 ,  { &&jalPLUSsll, NULL }  ,  { &&jalPLUSsll, NULL }  ,  { &&jalPLUSsll, NULL }  ,  { &&jalPLUSsll, NULL }  ,  { &&jalPLUSsll, NULL }  ,  { &&jalPLUSsll, NULL }  ,  { &&jalPLUSsll, NULL }  ,  { &&jalPLUSsll, NULL }  ,  { &&jalPLUSsll, NULL }  ,  { &&jalPLUSsll, NULL } 
 ,  { &&jalPLUSsll, NULL }  ,  { &&jalPLUSsll, NULL }  ,  { &&jalPLUSsll, NULL }  ,  { &&jalPLUSsll, NULL }  ,  { &&jalPLUSsll, NULL }  ,  { &&jalPLUSsll, NULL }  ,  { &&jalPLUSsll, NULL }  ,  { &&jalPLUSsll, NULL }  ,  { &&jalPLUSsll, NULL }  ,  { &&jalPLUSsll, NULL } 
 ,  { &&jalPLUSsll, NULL }  ,  { &&jalPLUSsll, NULL }  ,  { &&jalPLUSsll, NULL }  ,  { &&jalPLUSsll, NULL }  ,  { &&jalPLUSsll, NULL }  ,  { &&jalPLUSsll, NULL }  ,  { &&jalPLUSsll, NULL }  ,  { &&jalPLUSsll, NULL }  ,  { &&jalPLUSsll, NULL }  ,  { &&jalPLUSsll, NULL } 
 ,  { &&jalPLUSsll, NULL }  ,  { &&jalPLUSsll, NULL }  ,  { &&jalPLUSsll, NULL }  ,  { &&jalPLUSsll, NULL }  ,  { &&jalPLUSsll, NULL }  ,  { &&jalPLUSsll, NULL }  ,  { &&jalPLUSsll, NULL }  ,  { &&jalPLUSsll, NULL }  ,  { &&jalPLUSsll, NULL }  ,  { &&jalPLUSsll, NULL } 
 ,  { &&jalPLUSsll, NULL }  ,  { &&jalPLUSsll, NULL }  ,  { &&jalPLUSsllPLUSaddiu, NULL }  ,  { &&jalPLUSsll, NULL }  ,  { &&jalPLUSsll, NULL }  ,  { &&jalPLUSsll, NULL }  ,  { &&jalPLUSsll, NULL }  ,  { &&jalPLUSsll, NULL }  ,  { &&jalPLUSsll, NULL }  ,  { &&jalPLUSsll, NULL } 
 ,  { &&jalPLUSsll, NULL }  ,  { &&jalPLUSsll, NULL }  ,  { &&jalPLUSsll, NULL }  ,  { &&jalPLUSsll, NULL }  ,  { &&jalPLUSsll, NULL }  ,  { &&jalPLUSsll, NULL }  ,  { &&jalPLUSsll, NULL }  ,  { &&jalPLUSsll, NULL }  ,  { &&jalPLUSsll, NULL }  ,  { &&jalPLUSsll, NULL } 
 ,  { &&jalPLUSsll, NULL }  ,  { &&jalPLUSsll, NULL }  ,  { &&jalPLUSsll, NULL }  ,  { &&jalPLUSsll, NULL }  ,  { &&jalPLUSsll, NULL }  ,  { &&jalPLUSsll, NULL }  ,  { &&jalPLUSsll, NULL }  ,  { &&jalPLUSsll, NULL }  ,  { &&jalPLUSsll, NULL }  ,  { &&jalPLUSsll, NULL } 
 ,  { &&jalPLUSsll, NULL }  ,  { &&jalPLUSsll, NULL }  ,  { &&jalPLUSsll, NULL }  ,  { &&jalPLUSsll, NULL }  ,  { &&jalPLUSsll, NULL }  ,  { &&jalPLUSsll, NULL }  ,  { &&jalPLUSsll, NULL }  ,  { &&jalPLUSsll, NULL }  ,  { &&jalPLUSsll, NULL }  ,  { &&jalPLUSsll, NULL } 
 ,  { &&jalPLUSsll, NULL }  ,  { &&jalPLUSsll, NULL }  ,  { &&jalPLUSsll, NULL }  ,  { &&jalPLUSsll, NULL }  ,  { &&jalPLUSsll, NULL }  ,  { &&jalPLUSsll, NULL }  ,  { &&jalPLUSsll, NULL }  ,  { &&jalPLUSsll, NULL }  ,  { &&jalPLUSsll, NULL }  ,  { &&jalPLUSsll, NULL } 
 ,  { &&jalPLUSsll, NULL }  ,  { &&jalPLUSsll, NULL }  ,  { &&jalPLUSsll, NULL }  ,  { &&jalPLUSsll, NULL }  ,  { &&jalPLUSsll, NULL }  ,  { &&jalPLUSsll, NULL }  ,  { &&jalPLUSsll, NULL }  ,  { &&jalPLUSsll, NULL }  ,  { &&jalPLUSsll, NULL }  ,  { &&jalPLUSsll, NULL } 
 }; 

struct pointer arrayaddiuPLUSlw[T_SIZE] = {  { &&addiuPLUSlw, NULL }  ,  { &&addiuPLUSlwPLUSerror, NULL }  ,  { &&addiuPLUSlw, NULL }  ,  { &&addiuPLUSlw, NULL }  ,  { &&addiuPLUSlw, NULL }  ,  { &&addiuPLUSlwPLUSerror, NULL }  ,  { &&addiuPLUSlw, NULL }  ,  { &&addiuPLUSlw, NULL }  ,  { &&addiuPLUSlwPLUSjr, NULL }  ,  { &&addiuPLUSlw, NULL } 
 ,  { &&addiuPLUSlw, NULL }  ,  { &&addiuPLUSlw, NULL }  ,  { &&addiuPLUSlw, NULL }  ,  { &&addiuPLUSlwPLUSerror, NULL }  ,  { &&addiuPLUSlwPLUSerror, NULL }  ,  { &&addiuPLUSlwPLUSerror, NULL }  ,  { &&addiuPLUSlw, NULL }  ,  { &&addiuPLUSlw, NULL }  ,  { &&addiuPLUSlw, NULL }  ,  { &&addiuPLUSlw, NULL } 
 ,  { &&addiuPLUSlwPLUSerror, NULL }  ,  { &&addiuPLUSlwPLUSerror, NULL }  ,  { &&addiuPLUSlwPLUSerror, NULL }  ,  { &&addiuPLUSlwPLUSerror, NULL }  ,  { &&addiuPLUSlw, NULL }  ,  { &&addiuPLUSlw, NULL }  ,  { &&addiuPLUSlw, NULL }  ,  { &&addiuPLUSlw, NULL }  ,  { &&addiuPLUSlwPLUSerror, NULL }  ,  { &&addiuPLUSlwPLUSerror, NULL } 
 ,  { &&addiuPLUSlwPLUSerror, NULL }  ,  { &&addiuPLUSlwPLUSerror, NULL }  ,  { &&addiuPLUSlw, NULL }  ,  { &&addiuPLUSlwPLUSaddu, NULL }  ,  { &&addiuPLUSlw, NULL }  ,  { &&addiuPLUSlw, NULL }  ,  { &&addiuPLUSlw, NULL }  ,  { &&addiuPLUSlw, NULL }  ,  { &&addiuPLUSlw, NULL }  ,  { &&addiuPLUSlw, NULL } 
 ,  { &&addiuPLUSlwPLUSerror, NULL }  ,  { &&addiuPLUSlwPLUSerror, NULL }  ,  { &&addiuPLUSlw, NULL }  ,  { &&addiuPLUSlwPLUSsltu, NULL }  ,  { &&addiuPLUSlw, NULL }  ,  { &&addiuPLUSlw, NULL }  ,  { &&addiuPLUSlw, NULL }  ,  { &&addiuPLUSlwPLUSbeq, NULL }  ,  { &&addiuPLUSlwPLUSbne, NULL }  ,  { &&addiuPLUSlw, NULL } 
 ,  { &&addiuPLUSlw, NULL }  ,  { &&addiuPLUSlw, NULL }  ,  { &&addiuPLUSlw, NULL }  ,  { &&addiuPLUSlw, NULL }  ,  { &&addiuPLUSlw, NULL }  ,  { &&addiuPLUSlw, NULL }  ,  { &&addiuPLUSlw, NULL }  ,  { &&addiuPLUSlw, NULL }  ,  { &&addiuPLUSlw, NULL }  ,  { &&addiuPLUSlwPLUSerror, NULL } 
 ,  { &&addiuPLUSlwPLUSerror, NULL }  ,  { &&addiuPLUSlwPLUSerror, NULL }  ,  { &&addiuPLUSlwPLUSerror, NULL }  ,  { &&addiuPLUSlwPLUSerror, NULL }  ,  { &&addiuPLUSlwPLUSerror, NULL }  ,  { &&addiuPLUSlwPLUSerror, NULL }  ,  { &&addiuPLUSlwPLUSerror, NULL }  ,  { &&addiuPLUSlw, NULL }  ,  { &&addiuPLUSlw, NULL }  ,  { &&addiuPLUSlw, NULL } 
 ,  { &&addiuPLUSlwPLUSerror, NULL }  ,  { &&addiuPLUSlwPLUSerror, NULL }  ,  { &&addiuPLUSlwPLUSerror, NULL }  ,  { &&addiuPLUSlwPLUSerror, NULL }  ,  { &&addiuPLUSlwPLUSerror, NULL }  ,  { &&addiuPLUSlw, NULL }  ,  { &&addiuPLUSlw, NULL }  ,  { &&addiuPLUSlw, NULL }  ,  { &&addiuPLUSlwPLUSlw, NULL }  ,  { &&addiuPLUSlw, NULL } 
 ,  { &&addiuPLUSlw, NULL }  ,  { &&addiuPLUSlw, NULL }  ,  { &&addiuPLUSlwPLUSerror, NULL }  ,  { &&addiuPLUSlw, NULL }  ,  { &&addiuPLUSlw, NULL }  ,  { &&addiuPLUSlw, NULL }  ,  { &&addiuPLUSlw, NULL }  ,  { &&addiuPLUSlwPLUSerror, NULL }  ,  { &&addiuPLUSlwPLUSerror, NULL }  ,  { &&addiuPLUSlw, NULL } 
 ,  { &&addiuPLUSlwPLUSerror, NULL }  ,  { &&addiuPLUSlwPLUSerror, NULL }  ,  { &&addiuPLUSlwPLUSerror, NULL }  ,  { &&addiuPLUSlwPLUSerror, NULL }  ,  { &&addiuPLUSlwPLUSerror, NULL }  ,  { &&addiuPLUSlwPLUSerror, NULL }  ,  { &&addiuPLUSlwPLUSerror, NULL }  ,  { &&addiuPLUSlwPLUSerror, NULL }  ,  { &&addiuPLUSlwPLUSerror, NULL }  ,  { &&addiuPLUSlwPLUSerror, NULL } 
 ,  { &&addiuPLUSlwPLUSerror, NULL }  ,  { &&addiuPLUSlwPLUSerror, NULL }  ,  { &&addiuPLUSlwPLUSerror, NULL }  ,  { &&addiuPLUSlwPLUSerror, NULL }  ,  { &&addiuPLUSlwPLUSerror, NULL }  ,  { &&addiuPLUSlwPLUSerror, NULL }  ,  { &&addiuPLUSlwPLUSerror, NULL }  ,  { &&addiuPLUSlwPLUSerror, NULL }  ,  { &&addiuPLUSlwPLUSerror, NULL }  ,  { &&addiuPLUSlwPLUSerror, NULL } 
 }; 

struct pointer arrayadduPLUSmult[T_SIZE] = {  { &&adduPLUSmult, NULL }  ,  { &&adduPLUSmult, NULL }  ,  { &&adduPLUSmult, NULL }  ,  { &&adduPLUSmult, NULL }  ,  { &&adduPLUSmult, NULL }  ,  { &&adduPLUSmult, NULL }  ,  { &&adduPLUSmult, NULL }  ,  { &&adduPLUSmult, NULL }  ,  { &&adduPLUSmult, NULL }  ,  { &&adduPLUSmult, NULL } 
 ,  { &&adduPLUSmult, NULL }  ,  { &&adduPLUSmult, NULL }  ,  { &&adduPLUSmult, NULL }  ,  { &&adduPLUSmult, NULL }  ,  { &&adduPLUSmult, NULL }  ,  { &&adduPLUSmult, NULL }  ,  { &&adduPLUSmultPLUSmfhi, NULL }  ,  { &&adduPLUSmult, NULL }  ,  { &&adduPLUSmult, NULL }  ,  { &&adduPLUSmult, NULL } 
 ,  { &&adduPLUSmult, NULL }  ,  { &&adduPLUSmult, NULL }  ,  { &&adduPLUSmult, NULL }  ,  { &&adduPLUSmult, NULL }  ,  { &&adduPLUSmult, NULL }  ,  { &&adduPLUSmult, NULL }  ,  { &&adduPLUSmult, NULL }  ,  { &&adduPLUSmult, NULL }  ,  { &&adduPLUSmult, NULL }  ,  { &&adduPLUSmult, NULL } 
 ,  { &&adduPLUSmult, NULL }  ,  { &&adduPLUSmult, NULL }  ,  { &&adduPLUSmult, NULL }  ,  { &&adduPLUSmult, NULL }  ,  { &&adduPLUSmult, NULL }  ,  { &&adduPLUSmult, NULL }  ,  { &&adduPLUSmult, NULL }  ,  { &&adduPLUSmult, NULL }  ,  { &&adduPLUSmult, NULL }  ,  { &&adduPLUSmult, NULL } 
 ,  { &&adduPLUSmult, NULL }  ,  { &&adduPLUSmult, NULL }  ,  { &&adduPLUSmult, NULL }  ,  { &&adduPLUSmult, NULL }  ,  { &&adduPLUSmult, NULL }  ,  { &&adduPLUSmult, NULL }  ,  { &&adduPLUSmult, NULL }  ,  { &&adduPLUSmult, NULL }  ,  { &&adduPLUSmult, NULL }  ,  { &&adduPLUSmult, NULL } 
 ,  { &&adduPLUSmult, NULL }  ,  { &&adduPLUSmult, NULL }  ,  { &&adduPLUSmult, NULL }  ,  { &&adduPLUSmult, NULL }  ,  { &&adduPLUSmult, NULL }  ,  { &&adduPLUSmult, NULL }  ,  { &&adduPLUSmult, NULL }  ,  { &&adduPLUSmult, NULL }  ,  { &&adduPLUSmult, NULL }  ,  { &&adduPLUSmult, NULL } 
 ,  { &&adduPLUSmult, NULL }  ,  { &&adduPLUSmult, NULL }  ,  { &&adduPLUSmult, NULL }  ,  { &&adduPLUSmult, NULL }  ,  { &&adduPLUSmult, NULL }  ,  { &&adduPLUSmult, NULL }  ,  { &&adduPLUSmult, NULL }  ,  { &&adduPLUSmult, NULL }  ,  { &&adduPLUSmult, NULL }  ,  { &&adduPLUSmult, NULL } 
 ,  { &&adduPLUSmult, NULL }  ,  { &&adduPLUSmult, NULL }  ,  { &&adduPLUSmult, NULL }  ,  { &&adduPLUSmult, NULL }  ,  { &&adduPLUSmult, NULL }  ,  { &&adduPLUSmult, NULL }  ,  { &&adduPLUSmult, NULL }  ,  { &&adduPLUSmult, NULL }  ,  { &&adduPLUSmult, NULL }  ,  { &&adduPLUSmult, NULL } 
 ,  { &&adduPLUSmult, NULL }  ,  { &&adduPLUSmult, NULL }  ,  { &&adduPLUSmult, NULL }  ,  { &&adduPLUSmult, NULL }  ,  { &&adduPLUSmult, NULL }  ,  { &&adduPLUSmult, NULL }  ,  { &&adduPLUSmult, NULL }  ,  { &&adduPLUSmult, NULL }  ,  { &&adduPLUSmult, NULL }  ,  { &&adduPLUSmult, NULL } 
 ,  { &&adduPLUSmult, NULL }  ,  { &&adduPLUSmult, NULL }  ,  { &&adduPLUSmult, NULL }  ,  { &&adduPLUSmult, NULL }  ,  { &&adduPLUSmult, NULL }  ,  { &&adduPLUSmult, NULL }  ,  { &&adduPLUSmult, NULL }  ,  { &&adduPLUSmult, NULL }  ,  { &&adduPLUSmult, NULL }  ,  { &&adduPLUSmult, NULL } 
 ,  { &&adduPLUSmult, NULL }  ,  { &&adduPLUSmult, NULL }  ,  { &&adduPLUSmult, NULL }  ,  { &&adduPLUSmult, NULL }  ,  { &&adduPLUSmult, NULL }  ,  { &&adduPLUSmult, NULL }  ,  { &&adduPLUSmult, NULL }  ,  { &&adduPLUSmult, NULL }  ,  { &&adduPLUSmult, NULL }  ,  { &&adduPLUSmult, NULL } 
 }; 

struct pointer arrayorPLUSsw[T_SIZE] = {  { &&orPLUSsw, NULL }  ,  { &&orPLUSsw, NULL }  ,  { &&orPLUSsw, NULL }  ,  { &&orPLUSsw, NULL }  ,  { &&orPLUSsw, NULL }  ,  { &&orPLUSsw, NULL }  ,  { &&orPLUSsw, NULL }  ,  { &&orPLUSsw, NULL }  ,  { &&orPLUSsw, NULL }  ,  { &&orPLUSsw, NULL } 
 ,  { &&orPLUSsw, NULL }  ,  { &&orPLUSsw, NULL }  ,  { &&orPLUSsw, NULL }  ,  { &&orPLUSsw, NULL }  ,  { &&orPLUSsw, NULL }  ,  { &&orPLUSsw, NULL }  ,  { &&orPLUSsw, NULL }  ,  { &&orPLUSsw, NULL }  ,  { &&orPLUSsw, NULL }  ,  { &&orPLUSsw, NULL } 
 ,  { &&orPLUSsw, NULL }  ,  { &&orPLUSsw, NULL }  ,  { &&orPLUSsw, NULL }  ,  { &&orPLUSsw, NULL }  ,  { &&orPLUSsw, NULL }  ,  { &&orPLUSsw, NULL }  ,  { &&orPLUSsw, NULL }  ,  { &&orPLUSsw, NULL }  ,  { &&orPLUSsw, NULL }  ,  { &&orPLUSsw, NULL } 
 ,  { &&orPLUSsw, NULL }  ,  { &&orPLUSsw, NULL }  ,  { &&orPLUSsw, NULL }  ,  { &&orPLUSsw, NULL }  ,  { &&orPLUSsw, NULL }  ,  { &&orPLUSsw, NULL }  ,  { &&orPLUSsw, NULL }  ,  { &&orPLUSsw, NULL }  ,  { &&orPLUSsw, NULL }  ,  { &&orPLUSsw, NULL } 
 ,  { &&orPLUSsw, NULL }  ,  { &&orPLUSsw, NULL }  ,  { &&orPLUSsw, NULL }  ,  { &&orPLUSsw, NULL }  ,  { &&orPLUSsw, NULL }  ,  { &&orPLUSsw, NULL }  ,  { &&orPLUSsw, NULL }  ,  { &&orPLUSsw, NULL }  ,  { &&orPLUSsw, NULL }  ,  { &&orPLUSsw, NULL } 
 ,  { &&orPLUSsw, NULL }  ,  { &&orPLUSsw, NULL }  ,  { &&orPLUSsw, NULL }  ,  { &&orPLUSsw, NULL }  ,  { &&orPLUSsw, NULL }  ,  { &&orPLUSsw, NULL }  ,  { &&orPLUSsw, NULL }  ,  { &&orPLUSsw, NULL }  ,  { &&orPLUSsw, NULL }  ,  { &&orPLUSsw, NULL } 
 ,  { &&orPLUSsw, NULL }  ,  { &&orPLUSsw, NULL }  ,  { &&orPLUSsw, NULL }  ,  { &&orPLUSsw, NULL }  ,  { &&orPLUSsw, NULL }  ,  { &&orPLUSsw, NULL }  ,  { &&orPLUSsw, NULL }  ,  { &&orPLUSsw, NULL }  ,  { &&orPLUSsw, NULL }  ,  { &&orPLUSsw, NULL } 
 ,  { &&orPLUSsw, NULL }  ,  { &&orPLUSsw, NULL }  ,  { &&orPLUSsw, NULL }  ,  { &&orPLUSsw, NULL }  ,  { &&orPLUSsw, NULL }  ,  { &&orPLUSsw, NULL }  ,  { &&orPLUSsw, NULL }  ,  { &&orPLUSsw, NULL }  ,  { &&orPLUSsw, NULL }  ,  { &&orPLUSsw, NULL } 
 ,  { &&orPLUSsw, NULL }  ,  { &&orPLUSsw, NULL }  ,  { &&orPLUSsw, NULL }  ,  { &&orPLUSsw, NULL }  ,  { &&orPLUSsw, NULL }  ,  { &&orPLUSsw, NULL }  ,  { &&orPLUSswPLUSsw, NULL }  ,  { &&orPLUSsw, NULL }  ,  { &&orPLUSsw, NULL }  ,  { &&orPLUSsw, NULL } 
 ,  { &&orPLUSsw, NULL }  ,  { &&orPLUSsw, NULL }  ,  { &&orPLUSsw, NULL }  ,  { &&orPLUSsw, NULL }  ,  { &&orPLUSsw, NULL }  ,  { &&orPLUSsw, NULL }  ,  { &&orPLUSsw, NULL }  ,  { &&orPLUSsw, NULL }  ,  { &&orPLUSsw, NULL }  ,  { &&orPLUSsw, NULL } 
 ,  { &&orPLUSsw, NULL }  ,  { &&orPLUSsw, NULL }  ,  { &&orPLUSsw, NULL }  ,  { &&orPLUSsw, NULL }  ,  { &&orPLUSsw, NULL }  ,  { &&orPLUSsw, NULL }  ,  { &&orPLUSsw, NULL }  ,  { &&orPLUSsw, NULL }  ,  { &&orPLUSsw, NULL }  ,  { &&orPLUSsw, NULL } 
 }; 

struct pointer arrayxorPLUSaddiu[T_SIZE] = {  { &&xorPLUSaddiu, NULL }  ,  { &&xorPLUSaddiu, NULL }  ,  { &&xorPLUSaddiu, NULL }  ,  { &&xorPLUSaddiu, NULL }  ,  { &&xorPLUSaddiu, NULL }  ,  { &&xorPLUSaddiu, NULL }  ,  { &&xorPLUSaddiu, NULL }  ,  { &&xorPLUSaddiu, NULL }  ,  { &&xorPLUSaddiu, NULL }  ,  { &&xorPLUSaddiu, NULL } 
 ,  { &&xorPLUSaddiu, NULL }  ,  { &&xorPLUSaddiu, NULL }  ,  { &&xorPLUSaddiu, NULL }  ,  { &&xorPLUSaddiu, NULL }  ,  { &&xorPLUSaddiu, NULL }  ,  { &&xorPLUSaddiu, NULL }  ,  { &&xorPLUSaddiu, NULL }  ,  { &&xorPLUSaddiu, NULL }  ,  { &&xorPLUSaddiu, NULL }  ,  { &&xorPLUSaddiu, NULL } 
 ,  { &&xorPLUSaddiu, NULL }  ,  { &&xorPLUSaddiu, NULL }  ,  { &&xorPLUSaddiu, NULL }  ,  { &&xorPLUSaddiu, NULL }  ,  { &&xorPLUSaddiu, NULL }  ,  { &&xorPLUSaddiu, NULL }  ,  { &&xorPLUSaddiu, NULL }  ,  { &&xorPLUSaddiu, NULL }  ,  { &&xorPLUSaddiu, NULL }  ,  { &&xorPLUSaddiu, NULL } 
 ,  { &&xorPLUSaddiu, NULL }  ,  { &&xorPLUSaddiu, NULL }  ,  { &&xorPLUSaddiu, NULL }  ,  { &&xorPLUSaddiu, NULL }  ,  { &&xorPLUSaddiu, NULL }  ,  { &&xorPLUSaddiu, NULL }  ,  { &&xorPLUSaddiu, NULL }  ,  { &&xorPLUSaddiu, NULL }  ,  { &&xorPLUSaddiu, NULL }  ,  { &&xorPLUSaddiu, NULL } 
 ,  { &&xorPLUSaddiu, NULL }  ,  { &&xorPLUSaddiu, NULL }  ,  { &&xorPLUSaddiu, NULL }  ,  { &&xorPLUSaddiu, NULL }  ,  { &&xorPLUSaddiu, NULL }  ,  { &&xorPLUSaddiu, NULL }  ,  { &&xorPLUSaddiu, NULL }  ,  { &&xorPLUSaddiu, NULL }  ,  { &&xorPLUSaddiu, NULL }  ,  { &&xorPLUSaddiu, NULL } 
 ,  { &&xorPLUSaddiu, NULL }  ,  { &&xorPLUSaddiu, NULL }  ,  { &&xorPLUSaddiu, NULL }  ,  { &&xorPLUSaddiu, NULL }  ,  { &&xorPLUSaddiu, NULL }  ,  { &&xorPLUSaddiu, NULL }  ,  { &&xorPLUSaddiu, NULL }  ,  { &&xorPLUSaddiu, NULL }  ,  { &&xorPLUSaddiu, NULL }  ,  { &&xorPLUSaddiu, NULL } 
 ,  { &&xorPLUSaddiu, NULL }  ,  { &&xorPLUSaddiu, NULL }  ,  { &&xorPLUSaddiu, NULL }  ,  { &&xorPLUSaddiu, NULL }  ,  { &&xorPLUSaddiu, NULL }  ,  { &&xorPLUSaddiu, NULL }  ,  { &&xorPLUSaddiu, NULL }  ,  { &&xorPLUSaddiu, NULL }  ,  { &&xorPLUSaddiu, NULL }  ,  { &&xorPLUSaddiu, NULL } 
 ,  { &&xorPLUSaddiu, NULL }  ,  { &&xorPLUSaddiu, NULL }  ,  { &&xorPLUSaddiu, NULL }  ,  { &&xorPLUSaddiu, NULL }  ,  { &&xorPLUSaddiu, NULL }  ,  { &&xorPLUSaddiu, NULL }  ,  { &&xorPLUSaddiu, NULL }  ,  { &&xorPLUSaddiu, NULL }  ,  { &&xorPLUSaddiu, NULL }  ,  { &&xorPLUSaddiu, NULL } 
 ,  { &&xorPLUSaddiu, NULL }  ,  { &&xorPLUSaddiu, NULL }  ,  { &&xorPLUSaddiu, NULL }  ,  { &&xorPLUSaddiu, NULL }  ,  { &&xorPLUSaddiu, NULL }  ,  { &&xorPLUSaddiu, NULL }  ,  { &&xorPLUSaddiuPLUSsw, NULL }  ,  { &&xorPLUSaddiu, NULL }  ,  { &&xorPLUSaddiu, NULL }  ,  { &&xorPLUSaddiu, NULL } 
 ,  { &&xorPLUSaddiu, NULL }  ,  { &&xorPLUSaddiu, NULL }  ,  { &&xorPLUSaddiu, NULL }  ,  { &&xorPLUSaddiu, NULL }  ,  { &&xorPLUSaddiu, NULL }  ,  { &&xorPLUSaddiu, NULL }  ,  { &&xorPLUSaddiu, NULL }  ,  { &&xorPLUSaddiu, NULL }  ,  { &&xorPLUSaddiu, NULL }  ,  { &&xorPLUSaddiu, NULL } 
 ,  { &&xorPLUSaddiu, NULL }  ,  { &&xorPLUSaddiu, NULL }  ,  { &&xorPLUSaddiu, NULL }  ,  { &&xorPLUSaddiu, NULL }  ,  { &&xorPLUSaddiu, NULL }  ,  { &&xorPLUSaddiu, NULL }  ,  { &&xorPLUSaddiu, NULL }  ,  { &&xorPLUSaddiu, NULL }  ,  { &&xorPLUSaddiu, NULL }  ,  { &&xorPLUSaddiu, NULL } 
 }; 

struct pointer arraysltuPLUSmovn[T_SIZE] = {  { &&sltuPLUSmovn, NULL }  ,  { &&sltuPLUSmovn, NULL }  ,  { &&sltuPLUSmovn, NULL }  ,  { &&sltuPLUSmovn, NULL }  ,  { &&sltuPLUSmovn, NULL }  ,  { &&sltuPLUSmovn, NULL }  ,  { &&sltuPLUSmovn, NULL }  ,  { &&sltuPLUSmovn, NULL }  ,  { &&sltuPLUSmovn, NULL }  ,  { &&sltuPLUSmovn, NULL } 
 ,  { &&sltuPLUSmovn, NULL }  ,  { &&sltuPLUSmovn, NULL }  ,  { &&sltuPLUSmovn, NULL }  ,  { &&sltuPLUSmovn, NULL }  ,  { &&sltuPLUSmovn, NULL }  ,  { &&sltuPLUSmovn, NULL }  ,  { &&sltuPLUSmovn, NULL }  ,  { &&sltuPLUSmovn, NULL }  ,  { &&sltuPLUSmovn, NULL }  ,  { &&sltuPLUSmovn, NULL } 
 ,  { &&sltuPLUSmovn, NULL }  ,  { &&sltuPLUSmovn, NULL }  ,  { &&sltuPLUSmovn, NULL }  ,  { &&sltuPLUSmovn, NULL }  ,  { &&sltuPLUSmovn, NULL }  ,  { &&sltuPLUSmovn, NULL }  ,  { &&sltuPLUSmovn, NULL }  ,  { &&sltuPLUSmovn, NULL }  ,  { &&sltuPLUSmovn, NULL }  ,  { &&sltuPLUSmovn, NULL } 
 ,  { &&sltuPLUSmovn, NULL }  ,  { &&sltuPLUSmovn, NULL }  ,  { &&sltuPLUSmovn, NULL }  ,  { &&sltuPLUSmovn, NULL }  ,  { &&sltuPLUSmovn, NULL }  ,  { &&sltuPLUSmovn, NULL }  ,  { &&sltuPLUSmovn, NULL }  ,  { &&sltuPLUSmovn, NULL }  ,  { &&sltuPLUSmovn, NULL }  ,  { &&sltuPLUSmovn, NULL } 
 ,  { &&sltuPLUSmovn, NULL }  ,  { &&sltuPLUSmovn, NULL }  ,  { &&sltuPLUSmovn, NULL }  ,  { &&sltuPLUSmovn, NULL }  ,  { &&sltuPLUSmovn, NULL }  ,  { &&sltuPLUSmovnPLUSjump, NULL }  ,  { &&sltuPLUSmovn, NULL }  ,  { &&sltuPLUSmovn, NULL }  ,  { &&sltuPLUSmovn, NULL }  ,  { &&sltuPLUSmovn, NULL } 
 ,  { &&sltuPLUSmovn, NULL }  ,  { &&sltuPLUSmovn, NULL }  ,  { &&sltuPLUSmovn, NULL }  ,  { &&sltuPLUSmovn, NULL }  ,  { &&sltuPLUSmovn, NULL }  ,  { &&sltuPLUSmovn, NULL }  ,  { &&sltuPLUSmovn, NULL }  ,  { &&sltuPLUSmovn, NULL }  ,  { &&sltuPLUSmovn, NULL }  ,  { &&sltuPLUSmovn, NULL } 
 ,  { &&sltuPLUSmovn, NULL }  ,  { &&sltuPLUSmovn, NULL }  ,  { &&sltuPLUSmovn, NULL }  ,  { &&sltuPLUSmovn, NULL }  ,  { &&sltuPLUSmovn, NULL }  ,  { &&sltuPLUSmovn, NULL }  ,  { &&sltuPLUSmovn, NULL }  ,  { &&sltuPLUSmovn, NULL }  ,  { &&sltuPLUSmovn, NULL }  ,  { &&sltuPLUSmovn, NULL } 
 ,  { &&sltuPLUSmovn, NULL }  ,  { &&sltuPLUSmovn, NULL }  ,  { &&sltuPLUSmovn, NULL }  ,  { &&sltuPLUSmovn, NULL }  ,  { &&sltuPLUSmovn, NULL }  ,  { &&sltuPLUSmovn, NULL }  ,  { &&sltuPLUSmovn, NULL }  ,  { &&sltuPLUSmovn, NULL }  ,  { &&sltuPLUSmovn, NULL }  ,  { &&sltuPLUSmovn, NULL } 
 ,  { &&sltuPLUSmovn, NULL }  ,  { &&sltuPLUSmovn, NULL }  ,  { &&sltuPLUSmovn, NULL }  ,  { &&sltuPLUSmovn, NULL }  ,  { &&sltuPLUSmovn, NULL }  ,  { &&sltuPLUSmovn, NULL }  ,  { &&sltuPLUSmovn, NULL }  ,  { &&sltuPLUSmovn, NULL }  ,  { &&sltuPLUSmovn, NULL }  ,  { &&sltuPLUSmovn, NULL } 
 ,  { &&sltuPLUSmovn, NULL }  ,  { &&sltuPLUSmovn, NULL }  ,  { &&sltuPLUSmovn, NULL }  ,  { &&sltuPLUSmovn, NULL }  ,  { &&sltuPLUSmovn, NULL }  ,  { &&sltuPLUSmovn, NULL }  ,  { &&sltuPLUSmovn, NULL }  ,  { &&sltuPLUSmovn, NULL }  ,  { &&sltuPLUSmovn, NULL }  ,  { &&sltuPLUSmovn, NULL } 
 ,  { &&sltuPLUSmovn, NULL }  ,  { &&sltuPLUSmovn, NULL }  ,  { &&sltuPLUSmovn, NULL }  ,  { &&sltuPLUSmovn, NULL }  ,  { &&sltuPLUSmovn, NULL }  ,  { &&sltuPLUSmovn, NULL }  ,  { &&sltuPLUSmovn, NULL }  ,  { &&sltuPLUSmovn, NULL }  ,  { &&sltuPLUSmovn, NULL }  ,  { &&sltuPLUSmovn, NULL } 
 }; 

struct pointer arrayjalPLUSaddu[T_SIZE] = {  { &&jalPLUSaddu, NULL }  ,  { &&jalPLUSaddu, NULL }  ,  { &&jalPLUSaddu, NULL }  ,  { &&jalPLUSaddu, NULL }  ,  { &&jalPLUSaddu, NULL }  ,  { &&jalPLUSaddu, NULL }  ,  { &&jalPLUSaddu, NULL }  ,  { &&jalPLUSaddu, NULL }  ,  { &&jalPLUSaddu, NULL }  ,  { &&jalPLUSaddu, NULL } 
 ,  { &&jalPLUSaddu, NULL }  ,  { &&jalPLUSaddu, NULL }  ,  { &&jalPLUSaddu, NULL }  ,  { &&jalPLUSaddu, NULL }  ,  { &&jalPLUSaddu, NULL }  ,  { &&jalPLUSaddu, NULL }  ,  { &&jalPLUSaddu, NULL }  ,  { &&jalPLUSaddu, NULL }  ,  { &&jalPLUSaddu, NULL }  ,  { &&jalPLUSaddu, NULL } 
 ,  { &&jalPLUSaddu, NULL }  ,  { &&jalPLUSaddu, NULL }  ,  { &&jalPLUSaddu, NULL }  ,  { &&jalPLUSaddu, NULL }  ,  { &&jalPLUSaddu, NULL }  ,  { &&jalPLUSaddu, NULL }  ,  { &&jalPLUSaddu, NULL }  ,  { &&jalPLUSaddu, NULL }  ,  { &&jalPLUSaddu, NULL }  ,  { &&jalPLUSaddu, NULL } 
 ,  { &&jalPLUSaddu, NULL }  ,  { &&jalPLUSaddu, NULL }  ,  { &&jalPLUSaddu, NULL }  ,  { &&jalPLUSaddu, NULL }  ,  { &&jalPLUSaddu, NULL }  ,  { &&jalPLUSaddu, NULL }  ,  { &&jalPLUSaddu, NULL }  ,  { &&jalPLUSaddu, NULL }  ,  { &&jalPLUSaddu, NULL }  ,  { &&jalPLUSaddu, NULL } 
 ,  { &&jalPLUSaddu, NULL }  ,  { &&jalPLUSaddu, NULL }  ,  { &&jalPLUSaddu, NULL }  ,  { &&jalPLUSaddu, NULL }  ,  { &&jalPLUSaddu, NULL }  ,  { &&jalPLUSaddu, NULL }  ,  { &&jalPLUSaddu, NULL }  ,  { &&jalPLUSaddu, NULL }  ,  { &&jalPLUSaddu, NULL }  ,  { &&jalPLUSaddu, NULL } 
 ,  { &&jalPLUSaddu, NULL }  ,  { &&jalPLUSaddu, NULL }  ,  { &&jalPLUSadduPLUSaddiu, NULL }  ,  { &&jalPLUSaddu, NULL }  ,  { &&jalPLUSaddu, NULL }  ,  { &&jalPLUSaddu, NULL }  ,  { &&jalPLUSaddu, NULL }  ,  { &&jalPLUSaddu, NULL }  ,  { &&jalPLUSadduPLUSlui, NULL }  ,  { &&jalPLUSaddu, NULL } 
 ,  { &&jalPLUSaddu, NULL }  ,  { &&jalPLUSaddu, NULL }  ,  { &&jalPLUSaddu, NULL }  ,  { &&jalPLUSaddu, NULL }  ,  { &&jalPLUSaddu, NULL }  ,  { &&jalPLUSaddu, NULL }  ,  { &&jalPLUSaddu, NULL }  ,  { &&jalPLUSaddu, NULL }  ,  { &&jalPLUSaddu, NULL }  ,  { &&jalPLUSaddu, NULL } 
 ,  { &&jalPLUSaddu, NULL }  ,  { &&jalPLUSaddu, NULL }  ,  { &&jalPLUSaddu, NULL }  ,  { &&jalPLUSaddu, NULL }  ,  { &&jalPLUSaddu, NULL }  ,  { &&jalPLUSaddu, NULL }  ,  { &&jalPLUSaddu, NULL }  ,  { &&jalPLUSaddu, NULL }  ,  { &&jalPLUSaddu, NULL }  ,  { &&jalPLUSadduPLUSlbu, NULL } 
 ,  { &&jalPLUSaddu, NULL }  ,  { &&jalPLUSaddu, NULL }  ,  { &&jalPLUSaddu, NULL }  ,  { &&jalPLUSaddu, NULL }  ,  { &&jalPLUSaddu, NULL }  ,  { &&jalPLUSaddu, NULL }  ,  { &&jalPLUSaddu, NULL }  ,  { &&jalPLUSaddu, NULL }  ,  { &&jalPLUSaddu, NULL }  ,  { &&jalPLUSaddu, NULL } 
 ,  { &&jalPLUSaddu, NULL }  ,  { &&jalPLUSaddu, NULL }  ,  { &&jalPLUSaddu, NULL }  ,  { &&jalPLUSaddu, NULL }  ,  { &&jalPLUSaddu, NULL }  ,  { &&jalPLUSaddu, NULL }  ,  { &&jalPLUSaddu, NULL }  ,  { &&jalPLUSaddu, NULL }  ,  { &&jalPLUSaddu, NULL }  ,  { &&jalPLUSaddu, NULL } 
 ,  { &&jalPLUSaddu, NULL }  ,  { &&jalPLUSaddu, NULL }  ,  { &&jalPLUSaddu, NULL }  ,  { &&jalPLUSaddu, NULL }  ,  { &&jalPLUSaddu, NULL }  ,  { &&jalPLUSaddu, NULL }  ,  { &&jalPLUSaddu, NULL }  ,  { &&jalPLUSaddu, NULL }  ,  { &&jalPLUSaddu, NULL }  ,  { &&jalPLUSaddu, NULL } 
 }; 

struct pointer arrayswPLUSsll[T_SIZE] = {  { &&swPLUSsll, NULL }  ,  { &&swPLUSsll, NULL }  ,  { &&swPLUSsll, NULL }  ,  { &&swPLUSsll, NULL }  ,  { &&swPLUSsll, NULL }  ,  { &&swPLUSsll, NULL }  ,  { &&swPLUSsll, NULL }  ,  { &&swPLUSsll, NULL }  ,  { &&swPLUSsll, NULL }  ,  { &&swPLUSsll, NULL } 
 ,  { &&swPLUSsll, NULL }  ,  { &&swPLUSsll, NULL }  ,  { &&swPLUSsll, NULL }  ,  { &&swPLUSsll, NULL }  ,  { &&swPLUSsll, NULL }  ,  { &&swPLUSsll, NULL }  ,  { &&swPLUSsll, NULL }  ,  { &&swPLUSsll, NULL }  ,  { &&swPLUSsll, NULL }  ,  { &&swPLUSsll, NULL } 
 ,  { &&swPLUSsll, NULL }  ,  { &&swPLUSsll, NULL }  ,  { &&swPLUSsll, NULL }  ,  { &&swPLUSsll, NULL }  ,  { &&swPLUSsll, NULL }  ,  { &&swPLUSsll, NULL }  ,  { &&swPLUSsll, NULL }  ,  { &&swPLUSsll, NULL }  ,  { &&swPLUSsll, NULL }  ,  { &&swPLUSsll, NULL } 
 ,  { &&swPLUSsll, NULL }  ,  { &&swPLUSsll, NULL }  ,  { &&swPLUSsll, NULL }  ,  { &&swPLUSsllPLUSaddu, NULL }  ,  { &&swPLUSsll, NULL }  ,  { &&swPLUSsll, NULL }  ,  { &&swPLUSsll, NULL }  ,  { &&swPLUSsll, NULL }  ,  { &&swPLUSsll, NULL }  ,  { &&swPLUSsll, NULL } 
 ,  { &&swPLUSsll, NULL }  ,  { &&swPLUSsll, NULL }  ,  { &&swPLUSsllPLUSslt, NULL }  ,  { &&swPLUSsll, NULL }  ,  { &&swPLUSsll, NULL }  ,  { &&swPLUSsll, NULL }  ,  { &&swPLUSsll, NULL }  ,  { &&swPLUSsll, NULL }  ,  { &&swPLUSsll, NULL }  ,  { &&swPLUSsll, NULL } 
 ,  { &&swPLUSsll, NULL }  ,  { &&swPLUSsll, NULL }  ,  { &&swPLUSsll, NULL }  ,  { &&swPLUSsll, NULL }  ,  { &&swPLUSsll, NULL }  ,  { &&swPLUSsll, NULL }  ,  { &&swPLUSsll, NULL }  ,  { &&swPLUSsll, NULL }  ,  { &&swPLUSsll, NULL }  ,  { &&swPLUSsll, NULL } 
 ,  { &&swPLUSsll, NULL }  ,  { &&swPLUSsll, NULL }  ,  { &&swPLUSsll, NULL }  ,  { &&swPLUSsll, NULL }  ,  { &&swPLUSsll, NULL }  ,  { &&swPLUSsll, NULL }  ,  { &&swPLUSsll, NULL }  ,  { &&swPLUSsll, NULL }  ,  { &&swPLUSsll, NULL }  ,  { &&swPLUSsll, NULL } 
 ,  { &&swPLUSsll, NULL }  ,  { &&swPLUSsll, NULL }  ,  { &&swPLUSsll, NULL }  ,  { &&swPLUSsll, NULL }  ,  { &&swPLUSsll, NULL }  ,  { &&swPLUSsll, NULL }  ,  { &&swPLUSsll, NULL }  ,  { &&swPLUSsll, NULL }  ,  { &&swPLUSsll, NULL }  ,  { &&swPLUSsll, NULL } 
 ,  { &&swPLUSsll, NULL }  ,  { &&swPLUSsll, NULL }  ,  { &&swPLUSsll, NULL }  ,  { &&swPLUSsll, NULL }  ,  { &&swPLUSsll, NULL }  ,  { &&swPLUSsll, NULL }  ,  { &&swPLUSsll, NULL }  ,  { &&swPLUSsll, NULL }  ,  { &&swPLUSsll, NULL }  ,  { &&swPLUSsll, NULL } 
 ,  { &&swPLUSsll, NULL }  ,  { &&swPLUSsll, NULL }  ,  { &&swPLUSsll, NULL }  ,  { &&swPLUSsll, NULL }  ,  { &&swPLUSsll, NULL }  ,  { &&swPLUSsll, NULL }  ,  { &&swPLUSsll, NULL }  ,  { &&swPLUSsll, NULL }  ,  { &&swPLUSsll, NULL }  ,  { &&swPLUSsll, NULL } 
 ,  { &&swPLUSsll, NULL }  ,  { &&swPLUSsll, NULL }  ,  { &&swPLUSsll, NULL }  ,  { &&swPLUSsll, NULL }  ,  { &&swPLUSsll, NULL }  ,  { &&swPLUSsll, NULL }  ,  { &&swPLUSsll, NULL }  ,  { &&swPLUSsll, NULL }  ,  { &&swPLUSsll, NULL }  ,  { &&swPLUSsll, NULL } 
 }; 

struct pointer arrayjumpPLUSsll[T_SIZE] = {  { &&jumpPLUSsllPLUSsll, NULL }  ,  { &&jumpPLUSsll, NULL }  ,  { &&jumpPLUSsll, NULL }  ,  { &&jumpPLUSsll, NULL }  ,  { &&jumpPLUSsll, NULL }  ,  { &&jumpPLUSsll, NULL }  ,  { &&jumpPLUSsll, NULL }  ,  { &&jumpPLUSsll, NULL }  ,  { &&jumpPLUSsll, NULL }  ,  { &&jumpPLUSsll, NULL } 
 ,  { &&jumpPLUSsll, NULL }  ,  { &&jumpPLUSsll, NULL }  ,  { &&jumpPLUSsll, NULL }  ,  { &&jumpPLUSsll, NULL }  ,  { &&jumpPLUSsll, NULL }  ,  { &&jumpPLUSsll, NULL }  ,  { &&jumpPLUSsll, NULL }  ,  { &&jumpPLUSsll, NULL }  ,  { &&jumpPLUSsll, NULL }  ,  { &&jumpPLUSsll, NULL } 
 ,  { &&jumpPLUSsll, NULL }  ,  { &&jumpPLUSsll, NULL }  ,  { &&jumpPLUSsll, NULL }  ,  { &&jumpPLUSsll, NULL }  ,  { &&jumpPLUSsll, NULL }  ,  { &&jumpPLUSsll, NULL }  ,  { &&jumpPLUSsll, NULL }  ,  { &&jumpPLUSsll, NULL }  ,  { &&jumpPLUSsll, NULL }  ,  { &&jumpPLUSsll, NULL } 
 ,  { &&jumpPLUSsll, NULL }  ,  { &&jumpPLUSsll, NULL }  ,  { &&jumpPLUSsll, NULL }  ,  { &&jumpPLUSsll, NULL }  ,  { &&jumpPLUSsll, NULL }  ,  { &&jumpPLUSsll, NULL }  ,  { &&jumpPLUSsll, NULL }  ,  { &&jumpPLUSsll, NULL }  ,  { &&jumpPLUSsll, NULL }  ,  { &&jumpPLUSsll, NULL } 
 ,  { &&jumpPLUSsll, NULL }  ,  { &&jumpPLUSsll, NULL }  ,  { &&jumpPLUSsll, NULL }  ,  { &&jumpPLUSsll, NULL }  ,  { &&jumpPLUSsll, NULL }  ,  { &&jumpPLUSsll, NULL }  ,  { &&jumpPLUSsll, NULL }  ,  { &&jumpPLUSsll, NULL }  ,  { &&jumpPLUSsll, NULL }  ,  { &&jumpPLUSsll, NULL } 
 ,  { &&jumpPLUSsll, NULL }  ,  { &&jumpPLUSsll, NULL }  ,  { &&jumpPLUSsll, NULL }  ,  { &&jumpPLUSsll, NULL }  ,  { &&jumpPLUSsll, NULL }  ,  { &&jumpPLUSsll, NULL }  ,  { &&jumpPLUSsll, NULL }  ,  { &&jumpPLUSsll, NULL }  ,  { &&jumpPLUSsll, NULL }  ,  { &&jumpPLUSsll, NULL } 
 ,  { &&jumpPLUSsll, NULL }  ,  { &&jumpPLUSsll, NULL }  ,  { &&jumpPLUSsll, NULL }  ,  { &&jumpPLUSsll, NULL }  ,  { &&jumpPLUSsll, NULL }  ,  { &&jumpPLUSsll, NULL }  ,  { &&jumpPLUSsll, NULL }  ,  { &&jumpPLUSsll, NULL }  ,  { &&jumpPLUSsll, NULL }  ,  { &&jumpPLUSsll, NULL } 
 ,  { &&jumpPLUSsll, NULL }  ,  { &&jumpPLUSsll, NULL }  ,  { &&jumpPLUSsll, NULL }  ,  { &&jumpPLUSsll, NULL }  ,  { &&jumpPLUSsll, NULL }  ,  { &&jumpPLUSsll, NULL }  ,  { &&jumpPLUSsll, NULL }  ,  { &&jumpPLUSsll, NULL }  ,  { &&jumpPLUSsllPLUSlw, NULL }  ,  { &&jumpPLUSsll, NULL } 
 ,  { &&jumpPLUSsll, NULL }  ,  { &&jumpPLUSsll, NULL }  ,  { &&jumpPLUSsll, NULL }  ,  { &&jumpPLUSsll, NULL }  ,  { &&jumpPLUSsll, NULL }  ,  { &&jumpPLUSsll, NULL }  ,  { &&jumpPLUSsllPLUSsw, NULL }  ,  { &&jumpPLUSsll, NULL }  ,  { &&jumpPLUSsll, NULL }  ,  { &&jumpPLUSsll, NULL } 
 ,  { &&jumpPLUSsll, NULL }  ,  { &&jumpPLUSsll, NULL }  ,  { &&jumpPLUSsll, NULL }  ,  { &&jumpPLUSsll, NULL }  ,  { &&jumpPLUSsll, NULL }  ,  { &&jumpPLUSsll, NULL }  ,  { &&jumpPLUSsll, NULL }  ,  { &&jumpPLUSsll, NULL }  ,  { &&jumpPLUSsll, NULL }  ,  { &&jumpPLUSsll, NULL } 
 ,  { &&jumpPLUSsll, NULL }  ,  { &&jumpPLUSsll, NULL }  ,  { &&jumpPLUSsll, NULL }  ,  { &&jumpPLUSsll, NULL }  ,  { &&jumpPLUSsll, NULL }  ,  { &&jumpPLUSsll, NULL }  ,  { &&jumpPLUSsll, NULL }  ,  { &&jumpPLUSsll, NULL }  ,  { &&jumpPLUSsll, NULL }  ,  { &&jumpPLUSsll, NULL } 
 }; 

struct pointer arraylwPLUSjump[T_SIZE] = {  { &&lwPLUSjumpPLUSsll, NULL }  ,  { &&lwPLUSjump, NULL }  ,  { &&lwPLUSjump, NULL }  ,  { &&lwPLUSjump, NULL }  ,  { &&lwPLUSjump, NULL }  ,  { &&lwPLUSjump, NULL }  ,  { &&lwPLUSjump, NULL }  ,  { &&lwPLUSjump, NULL }  ,  { &&lwPLUSjump, NULL }  ,  { &&lwPLUSjump, NULL } 
 ,  { &&lwPLUSjump, NULL }  ,  { &&lwPLUSjump, NULL }  ,  { &&lwPLUSjump, NULL }  ,  { &&lwPLUSjump, NULL }  ,  { &&lwPLUSjump, NULL }  ,  { &&lwPLUSjump, NULL }  ,  { &&lwPLUSjump, NULL }  ,  { &&lwPLUSjump, NULL }  ,  { &&lwPLUSjump, NULL }  ,  { &&lwPLUSjump, NULL } 
 ,  { &&lwPLUSjump, NULL }  ,  { &&lwPLUSjump, NULL }  ,  { &&lwPLUSjump, NULL }  ,  { &&lwPLUSjump, NULL }  ,  { &&lwPLUSjump, NULL }  ,  { &&lwPLUSjump, NULL }  ,  { &&lwPLUSjump, NULL }  ,  { &&lwPLUSjump, NULL }  ,  { &&lwPLUSjump, NULL }  ,  { &&lwPLUSjump, NULL } 
 ,  { &&lwPLUSjump, NULL }  ,  { &&lwPLUSjump, NULL }  ,  { &&lwPLUSjump, NULL }  ,  { &&lwPLUSjump, NULL }  ,  { &&lwPLUSjump, NULL }  ,  { &&lwPLUSjump, NULL }  ,  { &&lwPLUSjump, NULL }  ,  { &&lwPLUSjump, NULL }  ,  { &&lwPLUSjump, NULL }  ,  { &&lwPLUSjump, NULL } 
 ,  { &&lwPLUSjump, NULL }  ,  { &&lwPLUSjump, NULL }  ,  { &&lwPLUSjump, NULL }  ,  { &&lwPLUSjump, NULL }  ,  { &&lwPLUSjump, NULL }  ,  { &&lwPLUSjump, NULL }  ,  { &&lwPLUSjump, NULL }  ,  { &&lwPLUSjump, NULL }  ,  { &&lwPLUSjump, NULL }  ,  { &&lwPLUSjump, NULL } 
 ,  { &&lwPLUSjump, NULL }  ,  { &&lwPLUSjump, NULL }  ,  { &&lwPLUSjump, NULL }  ,  { &&lwPLUSjump, NULL }  ,  { &&lwPLUSjump, NULL }  ,  { &&lwPLUSjump, NULL }  ,  { &&lwPLUSjump, NULL }  ,  { &&lwPLUSjump, NULL }  ,  { &&lwPLUSjump, NULL }  ,  { &&lwPLUSjump, NULL } 
 ,  { &&lwPLUSjump, NULL }  ,  { &&lwPLUSjump, NULL }  ,  { &&lwPLUSjump, NULL }  ,  { &&lwPLUSjump, NULL }  ,  { &&lwPLUSjump, NULL }  ,  { &&lwPLUSjump, NULL }  ,  { &&lwPLUSjump, NULL }  ,  { &&lwPLUSjump, NULL }  ,  { &&lwPLUSjump, NULL }  ,  { &&lwPLUSjump, NULL } 
 ,  { &&lwPLUSjump, NULL }  ,  { &&lwPLUSjump, NULL }  ,  { &&lwPLUSjump, NULL }  ,  { &&lwPLUSjump, NULL }  ,  { &&lwPLUSjump, NULL }  ,  { &&lwPLUSjump, NULL }  ,  { &&lwPLUSjump, NULL }  ,  { &&lwPLUSjump, NULL }  ,  { &&lwPLUSjump, NULL }  ,  { &&lwPLUSjump, NULL } 
 ,  { &&lwPLUSjump, NULL }  ,  { &&lwPLUSjump, NULL }  ,  { &&lwPLUSjump, NULL }  ,  { &&lwPLUSjump, NULL }  ,  { &&lwPLUSjump, NULL }  ,  { &&lwPLUSjump, NULL }  ,  { &&lwPLUSjump, NULL }  ,  { &&lwPLUSjump, NULL }  ,  { &&lwPLUSjump, NULL }  ,  { &&lwPLUSjump, NULL } 
 ,  { &&lwPLUSjump, NULL }  ,  { &&lwPLUSjump, NULL }  ,  { &&lwPLUSjump, NULL }  ,  { &&lwPLUSjump, NULL }  ,  { &&lwPLUSjump, NULL }  ,  { &&lwPLUSjump, NULL }  ,  { &&lwPLUSjump, NULL }  ,  { &&lwPLUSjump, NULL }  ,  { &&lwPLUSjump, NULL }  ,  { &&lwPLUSjump, NULL } 
 ,  { &&lwPLUSjump, NULL }  ,  { &&lwPLUSjump, NULL }  ,  { &&lwPLUSjump, NULL }  ,  { &&lwPLUSjump, NULL }  ,  { &&lwPLUSjump, NULL }  ,  { &&lwPLUSjump, NULL }  ,  { &&lwPLUSjump, NULL }  ,  { &&lwPLUSjump, NULL }  ,  { &&lwPLUSjump, NULL }  ,  { &&lwPLUSjump, NULL } 
 }; 

struct pointer arrayerrorPLUSaddu[T_SIZE] = {  { &&errorPLUSaddu, NULL }  ,  { &&errorPLUSaddu, NULL }  ,  { &&errorPLUSaddu, NULL }  ,  { &&errorPLUSaddu, NULL }  ,  { &&errorPLUSaddu, NULL }  ,  { &&errorPLUSaddu, NULL }  ,  { &&errorPLUSaddu, NULL }  ,  { &&errorPLUSaddu, NULL }  ,  { &&errorPLUSaddu, NULL }  ,  { &&errorPLUSaddu, NULL } 
 ,  { &&errorPLUSaddu, NULL }  ,  { &&errorPLUSaddu, NULL }  ,  { &&errorPLUSaddu, NULL }  ,  { &&errorPLUSaddu, NULL }  ,  { &&errorPLUSaddu, NULL }  ,  { &&errorPLUSaddu, NULL }  ,  { &&errorPLUSaddu, NULL }  ,  { &&errorPLUSaddu, NULL }  ,  { &&errorPLUSaddu, NULL }  ,  { &&errorPLUSaddu, NULL } 
 ,  { &&errorPLUSaddu, NULL }  ,  { &&errorPLUSaddu, NULL }  ,  { &&errorPLUSaddu, NULL }  ,  { &&errorPLUSaddu, NULL }  ,  { &&errorPLUSaddu, NULL }  ,  { &&errorPLUSaddu, NULL }  ,  { &&errorPLUSaddu, NULL }  ,  { &&errorPLUSaddu, NULL }  ,  { &&errorPLUSaddu, NULL }  ,  { &&errorPLUSaddu, NULL } 
 ,  { &&errorPLUSaddu, NULL }  ,  { &&errorPLUSaddu, NULL }  ,  { &&errorPLUSaddu, NULL }  ,  { &&errorPLUSadduPLUSaddu, NULL }  ,  { &&errorPLUSaddu, NULL }  ,  { &&errorPLUSaddu, NULL }  ,  { &&errorPLUSaddu, NULL }  ,  { &&errorPLUSaddu, NULL }  ,  { &&errorPLUSaddu, NULL }  ,  { &&errorPLUSaddu, NULL } 
 ,  { &&errorPLUSaddu, NULL }  ,  { &&errorPLUSaddu, NULL }  ,  { &&errorPLUSaddu, NULL }  ,  { &&errorPLUSaddu, NULL }  ,  { &&errorPLUSaddu, NULL }  ,  { &&errorPLUSaddu, NULL }  ,  { &&errorPLUSaddu, NULL }  ,  { &&errorPLUSaddu, NULL }  ,  { &&errorPLUSaddu, NULL }  ,  { &&errorPLUSaddu, NULL } 
 ,  { &&errorPLUSaddu, NULL }  ,  { &&errorPLUSaddu, NULL }  ,  { &&errorPLUSaddu, NULL }  ,  { &&errorPLUSaddu, NULL }  ,  { &&errorPLUSaddu, NULL }  ,  { &&errorPLUSaddu, NULL }  ,  { &&errorPLUSaddu, NULL }  ,  { &&errorPLUSaddu, NULL }  ,  { &&errorPLUSaddu, NULL }  ,  { &&errorPLUSaddu, NULL } 
 ,  { &&errorPLUSaddu, NULL }  ,  { &&errorPLUSaddu, NULL }  ,  { &&errorPLUSaddu, NULL }  ,  { &&errorPLUSaddu, NULL }  ,  { &&errorPLUSaddu, NULL }  ,  { &&errorPLUSaddu, NULL }  ,  { &&errorPLUSaddu, NULL }  ,  { &&errorPLUSaddu, NULL }  ,  { &&errorPLUSaddu, NULL }  ,  { &&errorPLUSaddu, NULL } 
 ,  { &&errorPLUSaddu, NULL }  ,  { &&errorPLUSaddu, NULL }  ,  { &&errorPLUSaddu, NULL }  ,  { &&errorPLUSaddu, NULL }  ,  { &&errorPLUSaddu, NULL }  ,  { &&errorPLUSaddu, NULL }  ,  { &&errorPLUSaddu, NULL }  ,  { &&errorPLUSaddu, NULL }  ,  { &&errorPLUSaddu, NULL }  ,  { &&errorPLUSaddu, NULL } 
 ,  { &&errorPLUSaddu, NULL }  ,  { &&errorPLUSaddu, NULL }  ,  { &&errorPLUSaddu, NULL }  ,  { &&errorPLUSaddu, NULL }  ,  { &&errorPLUSaddu, NULL }  ,  { &&errorPLUSaddu, NULL }  ,  { &&errorPLUSaddu, NULL }  ,  { &&errorPLUSaddu, NULL }  ,  { &&errorPLUSaddu, NULL }  ,  { &&errorPLUSaddu, NULL } 
 ,  { &&errorPLUSaddu, NULL }  ,  { &&errorPLUSaddu, NULL }  ,  { &&errorPLUSaddu, NULL }  ,  { &&errorPLUSaddu, NULL }  ,  { &&errorPLUSaddu, NULL }  ,  { &&errorPLUSaddu, NULL }  ,  { &&errorPLUSaddu, NULL }  ,  { &&errorPLUSaddu, NULL }  ,  { &&errorPLUSaddu, NULL }  ,  { &&errorPLUSaddu, NULL } 
 ,  { &&errorPLUSaddu, NULL }  ,  { &&errorPLUSaddu, NULL }  ,  { &&errorPLUSaddu, NULL }  ,  { &&errorPLUSaddu, NULL }  ,  { &&errorPLUSaddu, NULL }  ,  { &&errorPLUSaddu, NULL }  ,  { &&errorPLUSaddu, NULL }  ,  { &&errorPLUSaddu, NULL }  ,  { &&errorPLUSaddu, NULL }  ,  { &&errorPLUSaddu, NULL } 
 }; 

struct pointer arrayadduPLUSjal[T_SIZE] = {  { &&adduPLUSjal, NULL }  ,  { &&adduPLUSjal, NULL }  ,  { &&adduPLUSjal, NULL }  ,  { &&adduPLUSjal, NULL }  ,  { &&adduPLUSjal, NULL }  ,  { &&adduPLUSjal, NULL }  ,  { &&adduPLUSjal, NULL }  ,  { &&adduPLUSjal, NULL }  ,  { &&adduPLUSjal, NULL }  ,  { &&adduPLUSjal, NULL } 
 ,  { &&adduPLUSjal, NULL }  ,  { &&adduPLUSjal, NULL }  ,  { &&adduPLUSjal, NULL }  ,  { &&adduPLUSjal, NULL }  ,  { &&adduPLUSjal, NULL }  ,  { &&adduPLUSjal, NULL }  ,  { &&adduPLUSjal, NULL }  ,  { &&adduPLUSjal, NULL }  ,  { &&adduPLUSjal, NULL }  ,  { &&adduPLUSjal, NULL } 
 ,  { &&adduPLUSjal, NULL }  ,  { &&adduPLUSjal, NULL }  ,  { &&adduPLUSjal, NULL }  ,  { &&adduPLUSjal, NULL }  ,  { &&adduPLUSjal, NULL }  ,  { &&adduPLUSjal, NULL }  ,  { &&adduPLUSjal, NULL }  ,  { &&adduPLUSjal, NULL }  ,  { &&adduPLUSjal, NULL }  ,  { &&adduPLUSjal, NULL } 
 ,  { &&adduPLUSjal, NULL }  ,  { &&adduPLUSjal, NULL }  ,  { &&adduPLUSjal, NULL }  ,  { &&adduPLUSjalPLUSaddu, NULL }  ,  { &&adduPLUSjal, NULL }  ,  { &&adduPLUSjal, NULL }  ,  { &&adduPLUSjal, NULL }  ,  { &&adduPLUSjal, NULL }  ,  { &&adduPLUSjal, NULL }  ,  { &&adduPLUSjal, NULL } 
 ,  { &&adduPLUSjal, NULL }  ,  { &&adduPLUSjal, NULL }  ,  { &&adduPLUSjal, NULL }  ,  { &&adduPLUSjal, NULL }  ,  { &&adduPLUSjal, NULL }  ,  { &&adduPLUSjal, NULL }  ,  { &&adduPLUSjal, NULL }  ,  { &&adduPLUSjal, NULL }  ,  { &&adduPLUSjal, NULL }  ,  { &&adduPLUSjal, NULL } 
 ,  { &&adduPLUSjal, NULL }  ,  { &&adduPLUSjal, NULL }  ,  { &&adduPLUSjal, NULL }  ,  { &&adduPLUSjal, NULL }  ,  { &&adduPLUSjal, NULL }  ,  { &&adduPLUSjal, NULL }  ,  { &&adduPLUSjal, NULL }  ,  { &&adduPLUSjal, NULL }  ,  { &&adduPLUSjal, NULL }  ,  { &&adduPLUSjal, NULL } 
 ,  { &&adduPLUSjal, NULL }  ,  { &&adduPLUSjal, NULL }  ,  { &&adduPLUSjal, NULL }  ,  { &&adduPLUSjal, NULL }  ,  { &&adduPLUSjal, NULL }  ,  { &&adduPLUSjal, NULL }  ,  { &&adduPLUSjal, NULL }  ,  { &&adduPLUSjal, NULL }  ,  { &&adduPLUSjal, NULL }  ,  { &&adduPLUSjal, NULL } 
 ,  { &&adduPLUSjal, NULL }  ,  { &&adduPLUSjal, NULL }  ,  { &&adduPLUSjal, NULL }  ,  { &&adduPLUSjal, NULL }  ,  { &&adduPLUSjal, NULL }  ,  { &&adduPLUSjal, NULL }  ,  { &&adduPLUSjal, NULL }  ,  { &&adduPLUSjal, NULL }  ,  { &&adduPLUSjal, NULL }  ,  { &&adduPLUSjal, NULL } 
 ,  { &&adduPLUSjal, NULL }  ,  { &&adduPLUSjal, NULL }  ,  { &&adduPLUSjal, NULL }  ,  { &&adduPLUSjal, NULL }  ,  { &&adduPLUSjal, NULL }  ,  { &&adduPLUSjal, NULL }  ,  { &&adduPLUSjal, NULL }  ,  { &&adduPLUSjal, NULL }  ,  { &&adduPLUSjal, NULL }  ,  { &&adduPLUSjal, NULL } 
 ,  { &&adduPLUSjal, NULL }  ,  { &&adduPLUSjal, NULL }  ,  { &&adduPLUSjal, NULL }  ,  { &&adduPLUSjal, NULL }  ,  { &&adduPLUSjal, NULL }  ,  { &&adduPLUSjal, NULL }  ,  { &&adduPLUSjal, NULL }  ,  { &&adduPLUSjal, NULL }  ,  { &&adduPLUSjal, NULL }  ,  { &&adduPLUSjal, NULL } 
 ,  { &&adduPLUSjal, NULL }  ,  { &&adduPLUSjal, NULL }  ,  { &&adduPLUSjal, NULL }  ,  { &&adduPLUSjal, NULL }  ,  { &&adduPLUSjal, NULL }  ,  { &&adduPLUSjal, NULL }  ,  { &&adduPLUSjal, NULL }  ,  { &&adduPLUSjal, NULL }  ,  { &&adduPLUSjal, NULL }  ,  { &&adduPLUSjal, NULL } 
 }; 

struct pointer arrayaddiuPLUSlbu[T_SIZE] = {  { &&addiuPLUSlbu, NULL }  ,  { &&addiuPLUSlbu, NULL }  ,  { &&addiuPLUSlbu, NULL }  ,  { &&addiuPLUSlbu, NULL }  ,  { &&addiuPLUSlbu, NULL }  ,  { &&addiuPLUSlbu, NULL }  ,  { &&addiuPLUSlbu, NULL }  ,  { &&addiuPLUSlbu, NULL }  ,  { &&addiuPLUSlbu, NULL }  ,  { &&addiuPLUSlbu, NULL } 
 ,  { &&addiuPLUSlbu, NULL }  ,  { &&addiuPLUSlbu, NULL }  ,  { &&addiuPLUSlbu, NULL }  ,  { &&addiuPLUSlbu, NULL }  ,  { &&addiuPLUSlbu, NULL }  ,  { &&addiuPLUSlbu, NULL }  ,  { &&addiuPLUSlbu, NULL }  ,  { &&addiuPLUSlbu, NULL }  ,  { &&addiuPLUSlbu, NULL }  ,  { &&addiuPLUSlbu, NULL } 
 ,  { &&addiuPLUSlbu, NULL }  ,  { &&addiuPLUSlbu, NULL }  ,  { &&addiuPLUSlbu, NULL }  ,  { &&addiuPLUSlbu, NULL }  ,  { &&addiuPLUSlbu, NULL }  ,  { &&addiuPLUSlbu, NULL }  ,  { &&addiuPLUSlbu, NULL }  ,  { &&addiuPLUSlbu, NULL }  ,  { &&addiuPLUSlbu, NULL }  ,  { &&addiuPLUSlbu, NULL } 
 ,  { &&addiuPLUSlbu, NULL }  ,  { &&addiuPLUSlbu, NULL }  ,  { &&addiuPLUSlbu, NULL }  ,  { &&addiuPLUSlbu, NULL }  ,  { &&addiuPLUSlbu, NULL }  ,  { &&addiuPLUSlbuPLUSsubu, NULL }  ,  { &&addiuPLUSlbu, NULL }  ,  { &&addiuPLUSlbu, NULL }  ,  { &&addiuPLUSlbu, NULL }  ,  { &&addiuPLUSlbu, NULL } 
 ,  { &&addiuPLUSlbu, NULL }  ,  { &&addiuPLUSlbu, NULL }  ,  { &&addiuPLUSlbu, NULL }  ,  { &&addiuPLUSlbu, NULL }  ,  { &&addiuPLUSlbu, NULL }  ,  { &&addiuPLUSlbu, NULL }  ,  { &&addiuPLUSlbu, NULL }  ,  { &&addiuPLUSlbu, NULL }  ,  { &&addiuPLUSlbu, NULL }  ,  { &&addiuPLUSlbu, NULL } 
 ,  { &&addiuPLUSlbu, NULL }  ,  { &&addiuPLUSlbu, NULL }  ,  { &&addiuPLUSlbu, NULL }  ,  { &&addiuPLUSlbu, NULL }  ,  { &&addiuPLUSlbu, NULL }  ,  { &&addiuPLUSlbu, NULL }  ,  { &&addiuPLUSlbu, NULL }  ,  { &&addiuPLUSlbu, NULL }  ,  { &&addiuPLUSlbu, NULL }  ,  { &&addiuPLUSlbu, NULL } 
 ,  { &&addiuPLUSlbu, NULL }  ,  { &&addiuPLUSlbu, NULL }  ,  { &&addiuPLUSlbu, NULL }  ,  { &&addiuPLUSlbu, NULL }  ,  { &&addiuPLUSlbu, NULL }  ,  { &&addiuPLUSlbu, NULL }  ,  { &&addiuPLUSlbu, NULL }  ,  { &&addiuPLUSlbu, NULL }  ,  { &&addiuPLUSlbu, NULL }  ,  { &&addiuPLUSlbu, NULL } 
 ,  { &&addiuPLUSlbu, NULL }  ,  { &&addiuPLUSlbu, NULL }  ,  { &&addiuPLUSlbu, NULL }  ,  { &&addiuPLUSlbu, NULL }  ,  { &&addiuPLUSlbu, NULL }  ,  { &&addiuPLUSlbu, NULL }  ,  { &&addiuPLUSlbu, NULL }  ,  { &&addiuPLUSlbu, NULL }  ,  { &&addiuPLUSlbu, NULL }  ,  { &&addiuPLUSlbu, NULL } 
 ,  { &&addiuPLUSlbu, NULL }  ,  { &&addiuPLUSlbu, NULL }  ,  { &&addiuPLUSlbu, NULL }  ,  { &&addiuPLUSlbu, NULL }  ,  { &&addiuPLUSlbu, NULL }  ,  { &&addiuPLUSlbu, NULL }  ,  { &&addiuPLUSlbu, NULL }  ,  { &&addiuPLUSlbu, NULL }  ,  { &&addiuPLUSlbu, NULL }  ,  { &&addiuPLUSlbu, NULL } 
 ,  { &&addiuPLUSlbu, NULL }  ,  { &&addiuPLUSlbu, NULL }  ,  { &&addiuPLUSlbu, NULL }  ,  { &&addiuPLUSlbu, NULL }  ,  { &&addiuPLUSlbu, NULL }  ,  { &&addiuPLUSlbu, NULL }  ,  { &&addiuPLUSlbu, NULL }  ,  { &&addiuPLUSlbu, NULL }  ,  { &&addiuPLUSlbu, NULL }  ,  { &&addiuPLUSlbu, NULL } 
 ,  { &&addiuPLUSlbu, NULL }  ,  { &&addiuPLUSlbu, NULL }  ,  { &&addiuPLUSlbu, NULL }  ,  { &&addiuPLUSlbu, NULL }  ,  { &&addiuPLUSlbu, NULL }  ,  { &&addiuPLUSlbu, NULL }  ,  { &&addiuPLUSlbu, NULL }  ,  { &&addiuPLUSlbu, NULL }  ,  { &&addiuPLUSlbu, NULL }  ,  { &&addiuPLUSlbu, NULL } 
 }; 

struct pointer arraysrlPLUSori[T_SIZE] = {  { &&srlPLUSori, NULL }  ,  { &&srlPLUSori, NULL }  ,  { &&srlPLUSori, NULL }  ,  { &&srlPLUSori, NULL }  ,  { &&srlPLUSori, NULL }  ,  { &&srlPLUSori, NULL }  ,  { &&srlPLUSori, NULL }  ,  { &&srlPLUSori, NULL }  ,  { &&srlPLUSori, NULL }  ,  { &&srlPLUSori, NULL } 
 ,  { &&srlPLUSori, NULL }  ,  { &&srlPLUSori, NULL }  ,  { &&srlPLUSori, NULL }  ,  { &&srlPLUSori, NULL }  ,  { &&srlPLUSori, NULL }  ,  { &&srlPLUSori, NULL }  ,  { &&srlPLUSori, NULL }  ,  { &&srlPLUSori, NULL }  ,  { &&srlPLUSori, NULL }  ,  { &&srlPLUSori, NULL } 
 ,  { &&srlPLUSori, NULL }  ,  { &&srlPLUSori, NULL }  ,  { &&srlPLUSori, NULL }  ,  { &&srlPLUSori, NULL }  ,  { &&srlPLUSori, NULL }  ,  { &&srlPLUSori, NULL }  ,  { &&srlPLUSori, NULL }  ,  { &&srlPLUSori, NULL }  ,  { &&srlPLUSori, NULL }  ,  { &&srlPLUSori, NULL } 
 ,  { &&srlPLUSori, NULL }  ,  { &&srlPLUSori, NULL }  ,  { &&srlPLUSori, NULL }  ,  { &&srlPLUSori, NULL }  ,  { &&srlPLUSori, NULL }  ,  { &&srlPLUSori, NULL }  ,  { &&srlPLUSoriPLUSand, NULL }  ,  { &&srlPLUSori, NULL }  ,  { &&srlPLUSori, NULL }  ,  { &&srlPLUSori, NULL } 
 ,  { &&srlPLUSori, NULL }  ,  { &&srlPLUSori, NULL }  ,  { &&srlPLUSori, NULL }  ,  { &&srlPLUSori, NULL }  ,  { &&srlPLUSori, NULL }  ,  { &&srlPLUSori, NULL }  ,  { &&srlPLUSori, NULL }  ,  { &&srlPLUSori, NULL }  ,  { &&srlPLUSori, NULL }  ,  { &&srlPLUSori, NULL } 
 ,  { &&srlPLUSori, NULL }  ,  { &&srlPLUSori, NULL }  ,  { &&srlPLUSori, NULL }  ,  { &&srlPLUSori, NULL }  ,  { &&srlPLUSori, NULL }  ,  { &&srlPLUSori, NULL }  ,  { &&srlPLUSori, NULL }  ,  { &&srlPLUSori, NULL }  ,  { &&srlPLUSori, NULL }  ,  { &&srlPLUSori, NULL } 
 ,  { &&srlPLUSori, NULL }  ,  { &&srlPLUSori, NULL }  ,  { &&srlPLUSori, NULL }  ,  { &&srlPLUSori, NULL }  ,  { &&srlPLUSori, NULL }  ,  { &&srlPLUSori, NULL }  ,  { &&srlPLUSori, NULL }  ,  { &&srlPLUSori, NULL }  ,  { &&srlPLUSori, NULL }  ,  { &&srlPLUSori, NULL } 
 ,  { &&srlPLUSori, NULL }  ,  { &&srlPLUSori, NULL }  ,  { &&srlPLUSori, NULL }  ,  { &&srlPLUSori, NULL }  ,  { &&srlPLUSori, NULL }  ,  { &&srlPLUSori, NULL }  ,  { &&srlPLUSori, NULL }  ,  { &&srlPLUSori, NULL }  ,  { &&srlPLUSori, NULL }  ,  { &&srlPLUSori, NULL } 
 ,  { &&srlPLUSori, NULL }  ,  { &&srlPLUSori, NULL }  ,  { &&srlPLUSori, NULL }  ,  { &&srlPLUSori, NULL }  ,  { &&srlPLUSori, NULL }  ,  { &&srlPLUSori, NULL }  ,  { &&srlPLUSori, NULL }  ,  { &&srlPLUSori, NULL }  ,  { &&srlPLUSori, NULL }  ,  { &&srlPLUSori, NULL } 
 ,  { &&srlPLUSori, NULL }  ,  { &&srlPLUSori, NULL }  ,  { &&srlPLUSori, NULL }  ,  { &&srlPLUSori, NULL }  ,  { &&srlPLUSori, NULL }  ,  { &&srlPLUSori, NULL }  ,  { &&srlPLUSori, NULL }  ,  { &&srlPLUSori, NULL }  ,  { &&srlPLUSori, NULL }  ,  { &&srlPLUSori, NULL } 
 ,  { &&srlPLUSori, NULL }  ,  { &&srlPLUSori, NULL }  ,  { &&srlPLUSori, NULL }  ,  { &&srlPLUSori, NULL }  ,  { &&srlPLUSori, NULL }  ,  { &&srlPLUSori, NULL }  ,  { &&srlPLUSori, NULL }  ,  { &&srlPLUSori, NULL }  ,  { &&srlPLUSori, NULL }  ,  { &&srlPLUSori, NULL } 
 }; 

struct pointer arraylwPLUSbgtz[T_SIZE] = {  { &&lwPLUSbgtzPLUSsll, NULL }  ,  { &&lwPLUSbgtz, NULL }  ,  { &&lwPLUSbgtz, NULL }  ,  { &&lwPLUSbgtz, NULL }  ,  { &&lwPLUSbgtz, NULL }  ,  { &&lwPLUSbgtz, NULL }  ,  { &&lwPLUSbgtz, NULL }  ,  { &&lwPLUSbgtz, NULL }  ,  { &&lwPLUSbgtz, NULL }  ,  { &&lwPLUSbgtz, NULL } 
 ,  { &&lwPLUSbgtz, NULL }  ,  { &&lwPLUSbgtz, NULL }  ,  { &&lwPLUSbgtz, NULL }  ,  { &&lwPLUSbgtz, NULL }  ,  { &&lwPLUSbgtz, NULL }  ,  { &&lwPLUSbgtz, NULL }  ,  { &&lwPLUSbgtz, NULL }  ,  { &&lwPLUSbgtz, NULL }  ,  { &&lwPLUSbgtz, NULL }  ,  { &&lwPLUSbgtz, NULL } 
 ,  { &&lwPLUSbgtz, NULL }  ,  { &&lwPLUSbgtz, NULL }  ,  { &&lwPLUSbgtz, NULL }  ,  { &&lwPLUSbgtz, NULL }  ,  { &&lwPLUSbgtz, NULL }  ,  { &&lwPLUSbgtz, NULL }  ,  { &&lwPLUSbgtz, NULL }  ,  { &&lwPLUSbgtz, NULL }  ,  { &&lwPLUSbgtz, NULL }  ,  { &&lwPLUSbgtz, NULL } 
 ,  { &&lwPLUSbgtz, NULL }  ,  { &&lwPLUSbgtz, NULL }  ,  { &&lwPLUSbgtz, NULL }  ,  { &&lwPLUSbgtz, NULL }  ,  { &&lwPLUSbgtz, NULL }  ,  { &&lwPLUSbgtz, NULL }  ,  { &&lwPLUSbgtz, NULL }  ,  { &&lwPLUSbgtz, NULL }  ,  { &&lwPLUSbgtz, NULL }  ,  { &&lwPLUSbgtz, NULL } 
 ,  { &&lwPLUSbgtz, NULL }  ,  { &&lwPLUSbgtz, NULL }  ,  { &&lwPLUSbgtz, NULL }  ,  { &&lwPLUSbgtz, NULL }  ,  { &&lwPLUSbgtz, NULL }  ,  { &&lwPLUSbgtz, NULL }  ,  { &&lwPLUSbgtz, NULL }  ,  { &&lwPLUSbgtz, NULL }  ,  { &&lwPLUSbgtz, NULL }  ,  { &&lwPLUSbgtz, NULL } 
 ,  { &&lwPLUSbgtz, NULL }  ,  { &&lwPLUSbgtz, NULL }  ,  { &&lwPLUSbgtz, NULL }  ,  { &&lwPLUSbgtz, NULL }  ,  { &&lwPLUSbgtz, NULL }  ,  { &&lwPLUSbgtz, NULL }  ,  { &&lwPLUSbgtz, NULL }  ,  { &&lwPLUSbgtz, NULL }  ,  { &&lwPLUSbgtz, NULL }  ,  { &&lwPLUSbgtz, NULL } 
 ,  { &&lwPLUSbgtz, NULL }  ,  { &&lwPLUSbgtz, NULL }  ,  { &&lwPLUSbgtz, NULL }  ,  { &&lwPLUSbgtz, NULL }  ,  { &&lwPLUSbgtz, NULL }  ,  { &&lwPLUSbgtz, NULL }  ,  { &&lwPLUSbgtz, NULL }  ,  { &&lwPLUSbgtz, NULL }  ,  { &&lwPLUSbgtz, NULL }  ,  { &&lwPLUSbgtz, NULL } 
 ,  { &&lwPLUSbgtz, NULL }  ,  { &&lwPLUSbgtz, NULL }  ,  { &&lwPLUSbgtz, NULL }  ,  { &&lwPLUSbgtz, NULL }  ,  { &&lwPLUSbgtz, NULL }  ,  { &&lwPLUSbgtz, NULL }  ,  { &&lwPLUSbgtz, NULL }  ,  { &&lwPLUSbgtz, NULL }  ,  { &&lwPLUSbgtz, NULL }  ,  { &&lwPLUSbgtz, NULL } 
 ,  { &&lwPLUSbgtz, NULL }  ,  { &&lwPLUSbgtz, NULL }  ,  { &&lwPLUSbgtz, NULL }  ,  { &&lwPLUSbgtz, NULL }  ,  { &&lwPLUSbgtz, NULL }  ,  { &&lwPLUSbgtz, NULL }  ,  { &&lwPLUSbgtz, NULL }  ,  { &&lwPLUSbgtz, NULL }  ,  { &&lwPLUSbgtz, NULL }  ,  { &&lwPLUSbgtz, NULL } 
 ,  { &&lwPLUSbgtz, NULL }  ,  { &&lwPLUSbgtz, NULL }  ,  { &&lwPLUSbgtz, NULL }  ,  { &&lwPLUSbgtz, NULL }  ,  { &&lwPLUSbgtz, NULL }  ,  { &&lwPLUSbgtz, NULL }  ,  { &&lwPLUSbgtz, NULL }  ,  { &&lwPLUSbgtz, NULL }  ,  { &&lwPLUSbgtz, NULL }  ,  { &&lwPLUSbgtz, NULL } 
 ,  { &&lwPLUSbgtz, NULL }  ,  { &&lwPLUSbgtz, NULL }  ,  { &&lwPLUSbgtz, NULL }  ,  { &&lwPLUSbgtz, NULL }  ,  { &&lwPLUSbgtz, NULL }  ,  { &&lwPLUSbgtz, NULL }  ,  { &&lwPLUSbgtz, NULL }  ,  { &&lwPLUSbgtz, NULL }  ,  { &&lwPLUSbgtz, NULL }  ,  { &&lwPLUSbgtz, NULL } 
 }; 

struct pointer arraylwPLUSlw[T_SIZE] = {  { &&lwPLUSlw, NULL }  ,  { &&lwPLUSlwPLUSerror, NULL }  ,  { &&lwPLUSlw, NULL }  ,  { &&lwPLUSlw, NULL }  ,  { &&lwPLUSlw, NULL }  ,  { &&lwPLUSlwPLUSerror, NULL }  ,  { &&lwPLUSlw, NULL }  ,  { &&lwPLUSlw, NULL }  ,  { &&lwPLUSlwPLUSjr, NULL }  ,  { &&lwPLUSlw, NULL } 
 ,  { &&lwPLUSlw, NULL }  ,  { &&lwPLUSlw, NULL }  ,  { &&lwPLUSlw, NULL }  ,  { &&lwPLUSlwPLUSerror, NULL }  ,  { &&lwPLUSlwPLUSerror, NULL }  ,  { &&lwPLUSlwPLUSerror, NULL }  ,  { &&lwPLUSlw, NULL }  ,  { &&lwPLUSlw, NULL }  ,  { &&lwPLUSlw, NULL }  ,  { &&lwPLUSlw, NULL } 
 ,  { &&lwPLUSlwPLUSerror, NULL }  ,  { &&lwPLUSlwPLUSerror, NULL }  ,  { &&lwPLUSlwPLUSerror, NULL }  ,  { &&lwPLUSlwPLUSerror, NULL }  ,  { &&lwPLUSlw, NULL }  ,  { &&lwPLUSlw, NULL }  ,  { &&lwPLUSlw, NULL }  ,  { &&lwPLUSlw, NULL }  ,  { &&lwPLUSlwPLUSerror, NULL }  ,  { &&lwPLUSlwPLUSerror, NULL } 
 ,  { &&lwPLUSlwPLUSerror, NULL }  ,  { &&lwPLUSlwPLUSerror, NULL }  ,  { &&lwPLUSlw, NULL }  ,  { &&lwPLUSlwPLUSaddu, NULL }  ,  { &&lwPLUSlw, NULL }  ,  { &&lwPLUSlw, NULL }  ,  { &&lwPLUSlw, NULL }  ,  { &&lwPLUSlw, NULL }  ,  { &&lwPLUSlw, NULL }  ,  { &&lwPLUSlw, NULL } 
 ,  { &&lwPLUSlwPLUSerror, NULL }  ,  { &&lwPLUSlwPLUSerror, NULL }  ,  { &&lwPLUSlw, NULL }  ,  { &&lwPLUSlwPLUSsltu, NULL }  ,  { &&lwPLUSlw, NULL }  ,  { &&lwPLUSlw, NULL }  ,  { &&lwPLUSlwPLUSjal, NULL }  ,  { &&lwPLUSlw, NULL }  ,  { &&lwPLUSlw, NULL }  ,  { &&lwPLUSlwPLUSblez, NULL } 
 ,  { &&lwPLUSlw, NULL }  ,  { &&lwPLUSlw, NULL }  ,  { &&lwPLUSlwPLUSaddiu, NULL }  ,  { &&lwPLUSlw, NULL }  ,  { &&lwPLUSlw, NULL }  ,  { &&lwPLUSlw, NULL }  ,  { &&lwPLUSlw, NULL }  ,  { &&lwPLUSlw, NULL }  ,  { &&lwPLUSlw, NULL }  ,  { &&lwPLUSlwPLUSerror, NULL } 
 ,  { &&lwPLUSlwPLUSerror, NULL }  ,  { &&lwPLUSlwPLUSerror, NULL }  ,  { &&lwPLUSlwPLUSerror, NULL }  ,  { &&lwPLUSlwPLUSerror, NULL }  ,  { &&lwPLUSlwPLUSerror, NULL }  ,  { &&lwPLUSlwPLUSerror, NULL }  ,  { &&lwPLUSlwPLUSerror, NULL }  ,  { &&lwPLUSlw, NULL }  ,  { &&lwPLUSlw, NULL }  ,  { &&lwPLUSlw, NULL } 
 ,  { &&lwPLUSlwPLUSerror, NULL }  ,  { &&lwPLUSlwPLUSerror, NULL }  ,  { &&lwPLUSlwPLUSerror, NULL }  ,  { &&lwPLUSlwPLUSerror, NULL }  ,  { &&lwPLUSlwPLUSerror, NULL }  ,  { &&lwPLUSlw, NULL }  ,  { &&lwPLUSlw, NULL }  ,  { &&lwPLUSlw, NULL }  ,  { &&lwPLUSlwPLUSlw, NULL }  ,  { &&lwPLUSlw, NULL } 
 ,  { &&lwPLUSlw, NULL }  ,  { &&lwPLUSlw, NULL }  ,  { &&lwPLUSlwPLUSerror, NULL }  ,  { &&lwPLUSlw, NULL }  ,  { &&lwPLUSlw, NULL }  ,  { &&lwPLUSlw, NULL }  ,  { &&lwPLUSlw, NULL }  ,  { &&lwPLUSlwPLUSerror, NULL }  ,  { &&lwPLUSlwPLUSerror, NULL }  ,  { &&lwPLUSlw, NULL } 
 ,  { &&lwPLUSlwPLUSerror, NULL }  ,  { &&lwPLUSlwPLUSerror, NULL }  ,  { &&lwPLUSlwPLUSerror, NULL }  ,  { &&lwPLUSlwPLUSerror, NULL }  ,  { &&lwPLUSlwPLUSerror, NULL }  ,  { &&lwPLUSlwPLUSerror, NULL }  ,  { &&lwPLUSlwPLUSerror, NULL }  ,  { &&lwPLUSlwPLUSerror, NULL }  ,  { &&lwPLUSlwPLUSerror, NULL }  ,  { &&lwPLUSlwPLUSerror, NULL } 
 ,  { &&lwPLUSlwPLUSerror, NULL }  ,  { &&lwPLUSlwPLUSerror, NULL }  ,  { &&lwPLUSlwPLUSerror, NULL }  ,  { &&lwPLUSlwPLUSerror, NULL }  ,  { &&lwPLUSlwPLUSerror, NULL }  ,  { &&lwPLUSlwPLUSerror, NULL }  ,  { &&lwPLUSlwPLUSerror, NULL }  ,  { &&lwPLUSlwPLUSerror, NULL }  ,  { &&lwPLUSlwPLUSerror, NULL }  ,  { &&lwPLUSlwPLUSerror, NULL } 
 }; 

struct pointer arrayandiPLUSxor[T_SIZE] = {  { &&andiPLUSxor, NULL }  ,  { &&andiPLUSxor, NULL }  ,  { &&andiPLUSxor, NULL }  ,  { &&andiPLUSxor, NULL }  ,  { &&andiPLUSxor, NULL }  ,  { &&andiPLUSxor, NULL }  ,  { &&andiPLUSxor, NULL }  ,  { &&andiPLUSxor, NULL }  ,  { &&andiPLUSxor, NULL }  ,  { &&andiPLUSxor, NULL } 
 ,  { &&andiPLUSxor, NULL }  ,  { &&andiPLUSxor, NULL }  ,  { &&andiPLUSxor, NULL }  ,  { &&andiPLUSxor, NULL }  ,  { &&andiPLUSxor, NULL }  ,  { &&andiPLUSxor, NULL }  ,  { &&andiPLUSxor, NULL }  ,  { &&andiPLUSxor, NULL }  ,  { &&andiPLUSxor, NULL }  ,  { &&andiPLUSxor, NULL } 
 ,  { &&andiPLUSxor, NULL }  ,  { &&andiPLUSxor, NULL }  ,  { &&andiPLUSxor, NULL }  ,  { &&andiPLUSxor, NULL }  ,  { &&andiPLUSxor, NULL }  ,  { &&andiPLUSxor, NULL }  ,  { &&andiPLUSxor, NULL }  ,  { &&andiPLUSxor, NULL }  ,  { &&andiPLUSxor, NULL }  ,  { &&andiPLUSxor, NULL } 
 ,  { &&andiPLUSxor, NULL }  ,  { &&andiPLUSxor, NULL }  ,  { &&andiPLUSxor, NULL }  ,  { &&andiPLUSxor, NULL }  ,  { &&andiPLUSxor, NULL }  ,  { &&andiPLUSxor, NULL }  ,  { &&andiPLUSxor, NULL }  ,  { &&andiPLUSxor, NULL }  ,  { &&andiPLUSxor, NULL }  ,  { &&andiPLUSxor, NULL } 
 ,  { &&andiPLUSxor, NULL }  ,  { &&andiPLUSxor, NULL }  ,  { &&andiPLUSxor, NULL }  ,  { &&andiPLUSxor, NULL }  ,  { &&andiPLUSxor, NULL }  ,  { &&andiPLUSxor, NULL }  ,  { &&andiPLUSxor, NULL }  ,  { &&andiPLUSxor, NULL }  ,  { &&andiPLUSxor, NULL }  ,  { &&andiPLUSxor, NULL } 
 ,  { &&andiPLUSxor, NULL }  ,  { &&andiPLUSxor, NULL }  ,  { &&andiPLUSxor, NULL }  ,  { &&andiPLUSxor, NULL }  ,  { &&andiPLUSxor, NULL }  ,  { &&andiPLUSxorPLUSandi, NULL }  ,  { &&andiPLUSxor, NULL }  ,  { &&andiPLUSxor, NULL }  ,  { &&andiPLUSxor, NULL }  ,  { &&andiPLUSxor, NULL } 
 ,  { &&andiPLUSxor, NULL }  ,  { &&andiPLUSxor, NULL }  ,  { &&andiPLUSxor, NULL }  ,  { &&andiPLUSxor, NULL }  ,  { &&andiPLUSxor, NULL }  ,  { &&andiPLUSxor, NULL }  ,  { &&andiPLUSxor, NULL }  ,  { &&andiPLUSxor, NULL }  ,  { &&andiPLUSxor, NULL }  ,  { &&andiPLUSxor, NULL } 
 ,  { &&andiPLUSxor, NULL }  ,  { &&andiPLUSxor, NULL }  ,  { &&andiPLUSxor, NULL }  ,  { &&andiPLUSxor, NULL }  ,  { &&andiPLUSxor, NULL }  ,  { &&andiPLUSxor, NULL }  ,  { &&andiPLUSxor, NULL }  ,  { &&andiPLUSxor, NULL }  ,  { &&andiPLUSxor, NULL }  ,  { &&andiPLUSxor, NULL } 
 ,  { &&andiPLUSxor, NULL }  ,  { &&andiPLUSxor, NULL }  ,  { &&andiPLUSxor, NULL }  ,  { &&andiPLUSxor, NULL }  ,  { &&andiPLUSxor, NULL }  ,  { &&andiPLUSxor, NULL }  ,  { &&andiPLUSxor, NULL }  ,  { &&andiPLUSxor, NULL }  ,  { &&andiPLUSxor, NULL }  ,  { &&andiPLUSxor, NULL } 
 ,  { &&andiPLUSxor, NULL }  ,  { &&andiPLUSxor, NULL }  ,  { &&andiPLUSxor, NULL }  ,  { &&andiPLUSxor, NULL }  ,  { &&andiPLUSxor, NULL }  ,  { &&andiPLUSxor, NULL }  ,  { &&andiPLUSxor, NULL }  ,  { &&andiPLUSxor, NULL }  ,  { &&andiPLUSxor, NULL }  ,  { &&andiPLUSxor, NULL } 
 ,  { &&andiPLUSxor, NULL }  ,  { &&andiPLUSxor, NULL }  ,  { &&andiPLUSxor, NULL }  ,  { &&andiPLUSxor, NULL }  ,  { &&andiPLUSxor, NULL }  ,  { &&andiPLUSxor, NULL }  ,  { &&andiPLUSxor, NULL }  ,  { &&andiPLUSxor, NULL }  ,  { &&andiPLUSxor, NULL }  ,  { &&andiPLUSxor, NULL } 
 }; 

struct pointer arrayswPLUSaddiu[T_SIZE] = {  { &&swPLUSaddiuPLUSsll, NULL }  ,  { &&swPLUSaddiu, NULL }  ,  { &&swPLUSaddiuPLUSsrl, NULL }  ,  { &&swPLUSaddiu, NULL }  ,  { &&swPLUSaddiu, NULL }  ,  { &&swPLUSaddiu, NULL }  ,  { &&swPLUSaddiu, NULL }  ,  { &&swPLUSaddiu, NULL }  ,  { &&swPLUSaddiu, NULL }  ,  { &&swPLUSaddiu, NULL } 
 ,  { &&swPLUSaddiu, NULL }  ,  { &&swPLUSaddiu, NULL }  ,  { &&swPLUSaddiu, NULL }  ,  { &&swPLUSaddiu, NULL }  ,  { &&swPLUSaddiu, NULL }  ,  { &&swPLUSaddiu, NULL }  ,  { &&swPLUSaddiu, NULL }  ,  { &&swPLUSaddiu, NULL }  ,  { &&swPLUSaddiu, NULL }  ,  { &&swPLUSaddiu, NULL } 
 ,  { &&swPLUSaddiu, NULL }  ,  { &&swPLUSaddiu, NULL }  ,  { &&swPLUSaddiu, NULL }  ,  { &&swPLUSaddiu, NULL }  ,  { &&swPLUSaddiu, NULL }  ,  { &&swPLUSaddiu, NULL }  ,  { &&swPLUSaddiu, NULL }  ,  { &&swPLUSaddiu, NULL }  ,  { &&swPLUSaddiu, NULL }  ,  { &&swPLUSaddiu, NULL } 
 ,  { &&swPLUSaddiu, NULL }  ,  { &&swPLUSaddiu, NULL }  ,  { &&swPLUSaddiu, NULL }  ,  { &&swPLUSaddiuPLUSaddu, NULL }  ,  { &&swPLUSaddiu, NULL }  ,  { &&swPLUSaddiu, NULL }  ,  { &&swPLUSaddiu, NULL }  ,  { &&swPLUSaddiu, NULL }  ,  { &&swPLUSaddiu, NULL }  ,  { &&swPLUSaddiu, NULL } 
 ,  { &&swPLUSaddiu, NULL }  ,  { &&swPLUSaddiu, NULL }  ,  { &&swPLUSaddiu, NULL }  ,  { &&swPLUSaddiu, NULL }  ,  { &&swPLUSaddiu, NULL }  ,  { &&swPLUSaddiu, NULL }  ,  { &&swPLUSaddiuPLUSjal, NULL }  ,  { &&swPLUSaddiu, NULL }  ,  { &&swPLUSaddiu, NULL }  ,  { &&swPLUSaddiu, NULL } 
 ,  { &&swPLUSaddiu, NULL }  ,  { &&swPLUSaddiu, NULL }  ,  { &&swPLUSaddiuPLUSaddiu, NULL }  ,  { &&swPLUSaddiuPLUSslti, NULL }  ,  { &&swPLUSaddiu, NULL }  ,  { &&swPLUSaddiu, NULL }  ,  { &&swPLUSaddiu, NULL }  ,  { &&swPLUSaddiu, NULL }  ,  { &&swPLUSaddiu, NULL }  ,  { &&swPLUSaddiu, NULL } 
 ,  { &&swPLUSaddiu, NULL }  ,  { &&swPLUSaddiu, NULL }  ,  { &&swPLUSaddiu, NULL }  ,  { &&swPLUSaddiu, NULL }  ,  { &&swPLUSaddiu, NULL }  ,  { &&swPLUSaddiu, NULL }  ,  { &&swPLUSaddiu, NULL }  ,  { &&swPLUSaddiu, NULL }  ,  { &&swPLUSaddiu, NULL }  ,  { &&swPLUSaddiu, NULL } 
 ,  { &&swPLUSaddiu, NULL }  ,  { &&swPLUSaddiu, NULL }  ,  { &&swPLUSaddiu, NULL }  ,  { &&swPLUSaddiu, NULL }  ,  { &&swPLUSaddiu, NULL }  ,  { &&swPLUSaddiu, NULL }  ,  { &&swPLUSaddiu, NULL }  ,  { &&swPLUSaddiu, NULL }  ,  { &&swPLUSaddiu, NULL }  ,  { &&swPLUSaddiu, NULL } 
 ,  { &&swPLUSaddiu, NULL }  ,  { &&swPLUSaddiu, NULL }  ,  { &&swPLUSaddiu, NULL }  ,  { &&swPLUSaddiu, NULL }  ,  { &&swPLUSaddiu, NULL }  ,  { &&swPLUSaddiu, NULL }  ,  { &&swPLUSaddiuPLUSsw, NULL }  ,  { &&swPLUSaddiu, NULL }  ,  { &&swPLUSaddiu, NULL }  ,  { &&swPLUSaddiu, NULL } 
 ,  { &&swPLUSaddiu, NULL }  ,  { &&swPLUSaddiu, NULL }  ,  { &&swPLUSaddiu, NULL }  ,  { &&swPLUSaddiu, NULL }  ,  { &&swPLUSaddiu, NULL }  ,  { &&swPLUSaddiu, NULL }  ,  { &&swPLUSaddiu, NULL }  ,  { &&swPLUSaddiu, NULL }  ,  { &&swPLUSaddiu, NULL }  ,  { &&swPLUSaddiu, NULL } 
 ,  { &&swPLUSaddiu, NULL }  ,  { &&swPLUSaddiu, NULL }  ,  { &&swPLUSaddiu, NULL }  ,  { &&swPLUSaddiu, NULL }  ,  { &&swPLUSaddiu, NULL }  ,  { &&swPLUSaddiu, NULL }  ,  { &&swPLUSaddiu, NULL }  ,  { &&swPLUSaddiu, NULL }  ,  { &&swPLUSaddiu, NULL }  ,  { &&swPLUSaddiu, NULL } 
 }; 

struct pointer arrayandiPLUSor[T_SIZE] = {  { &&andiPLUSorPLUSsll, NULL }  ,  { &&andiPLUSor, NULL }  ,  { &&andiPLUSorPLUSsrl, NULL }  ,  { &&andiPLUSor, NULL }  ,  { &&andiPLUSor, NULL }  ,  { &&andiPLUSor, NULL }  ,  { &&andiPLUSor, NULL }  ,  { &&andiPLUSor, NULL }  ,  { &&andiPLUSor, NULL }  ,  { &&andiPLUSor, NULL } 
 ,  { &&andiPLUSor, NULL }  ,  { &&andiPLUSor, NULL }  ,  { &&andiPLUSor, NULL }  ,  { &&andiPLUSor, NULL }  ,  { &&andiPLUSor, NULL }  ,  { &&andiPLUSor, NULL }  ,  { &&andiPLUSor, NULL }  ,  { &&andiPLUSor, NULL }  ,  { &&andiPLUSor, NULL }  ,  { &&andiPLUSor, NULL } 
 ,  { &&andiPLUSor, NULL }  ,  { &&andiPLUSor, NULL }  ,  { &&andiPLUSor, NULL }  ,  { &&andiPLUSor, NULL }  ,  { &&andiPLUSor, NULL }  ,  { &&andiPLUSor, NULL }  ,  { &&andiPLUSor, NULL }  ,  { &&andiPLUSor, NULL }  ,  { &&andiPLUSor, NULL }  ,  { &&andiPLUSor, NULL } 
 ,  { &&andiPLUSor, NULL }  ,  { &&andiPLUSor, NULL }  ,  { &&andiPLUSor, NULL }  ,  { &&andiPLUSor, NULL }  ,  { &&andiPLUSor, NULL }  ,  { &&andiPLUSor, NULL }  ,  { &&andiPLUSor, NULL }  ,  { &&andiPLUSor, NULL }  ,  { &&andiPLUSor, NULL }  ,  { &&andiPLUSor, NULL } 
 ,  { &&andiPLUSor, NULL }  ,  { &&andiPLUSor, NULL }  ,  { &&andiPLUSor, NULL }  ,  { &&andiPLUSor, NULL }  ,  { &&andiPLUSor, NULL }  ,  { &&andiPLUSor, NULL }  ,  { &&andiPLUSor, NULL }  ,  { &&andiPLUSor, NULL }  ,  { &&andiPLUSor, NULL }  ,  { &&andiPLUSor, NULL } 
 ,  { &&andiPLUSor, NULL }  ,  { &&andiPLUSor, NULL }  ,  { &&andiPLUSor, NULL }  ,  { &&andiPLUSor, NULL }  ,  { &&andiPLUSor, NULL }  ,  { &&andiPLUSor, NULL }  ,  { &&andiPLUSor, NULL }  ,  { &&andiPLUSor, NULL }  ,  { &&andiPLUSor, NULL }  ,  { &&andiPLUSor, NULL } 
 ,  { &&andiPLUSor, NULL }  ,  { &&andiPLUSor, NULL }  ,  { &&andiPLUSor, NULL }  ,  { &&andiPLUSor, NULL }  ,  { &&andiPLUSor, NULL }  ,  { &&andiPLUSor, NULL }  ,  { &&andiPLUSor, NULL }  ,  { &&andiPLUSor, NULL }  ,  { &&andiPLUSor, NULL }  ,  { &&andiPLUSor, NULL } 
 ,  { &&andiPLUSor, NULL }  ,  { &&andiPLUSor, NULL }  ,  { &&andiPLUSor, NULL }  ,  { &&andiPLUSor, NULL }  ,  { &&andiPLUSor, NULL }  ,  { &&andiPLUSor, NULL }  ,  { &&andiPLUSor, NULL }  ,  { &&andiPLUSor, NULL }  ,  { &&andiPLUSor, NULL }  ,  { &&andiPLUSor, NULL } 
 ,  { &&andiPLUSor, NULL }  ,  { &&andiPLUSor, NULL }  ,  { &&andiPLUSor, NULL }  ,  { &&andiPLUSor, NULL }  ,  { &&andiPLUSor, NULL }  ,  { &&andiPLUSor, NULL }  ,  { &&andiPLUSor, NULL }  ,  { &&andiPLUSor, NULL }  ,  { &&andiPLUSor, NULL }  ,  { &&andiPLUSor, NULL } 
 ,  { &&andiPLUSor, NULL }  ,  { &&andiPLUSor, NULL }  ,  { &&andiPLUSor, NULL }  ,  { &&andiPLUSor, NULL }  ,  { &&andiPLUSor, NULL }  ,  { &&andiPLUSor, NULL }  ,  { &&andiPLUSor, NULL }  ,  { &&andiPLUSor, NULL }  ,  { &&andiPLUSor, NULL }  ,  { &&andiPLUSor, NULL } 
 ,  { &&andiPLUSor, NULL }  ,  { &&andiPLUSor, NULL }  ,  { &&andiPLUSor, NULL }  ,  { &&andiPLUSor, NULL }  ,  { &&andiPLUSor, NULL }  ,  { &&andiPLUSor, NULL }  ,  { &&andiPLUSor, NULL }  ,  { &&andiPLUSor, NULL }  ,  { &&andiPLUSor, NULL }  ,  { &&andiPLUSor, NULL } 
 }; 

struct pointer arraysrlPLUSerror[T_SIZE] = {  { &&srlPLUSerror, NULL }  ,  { &&srlPLUSerror, NULL }  ,  { &&srlPLUSerror, NULL }  ,  { &&srlPLUSerror, NULL }  ,  { &&srlPLUSerror, NULL }  ,  { &&srlPLUSerror, NULL }  ,  { &&srlPLUSerror, NULL }  ,  { &&srlPLUSerror, NULL }  ,  { &&srlPLUSerror, NULL }  ,  { &&srlPLUSerror, NULL } 
 ,  { &&srlPLUSerror, NULL }  ,  { &&srlPLUSerror, NULL }  ,  { &&srlPLUSerror, NULL }  ,  { &&srlPLUSerror, NULL }  ,  { &&srlPLUSerror, NULL }  ,  { &&srlPLUSerror, NULL }  ,  { &&srlPLUSerror, NULL }  ,  { &&srlPLUSerror, NULL }  ,  { &&srlPLUSerror, NULL }  ,  { &&srlPLUSerror, NULL } 
 ,  { &&srlPLUSerror, NULL }  ,  { &&srlPLUSerror, NULL }  ,  { &&srlPLUSerror, NULL }  ,  { &&srlPLUSerror, NULL }  ,  { &&srlPLUSerror, NULL }  ,  { &&srlPLUSerror, NULL }  ,  { &&srlPLUSerror, NULL }  ,  { &&srlPLUSerror, NULL }  ,  { &&srlPLUSerror, NULL }  ,  { &&srlPLUSerror, NULL } 
 ,  { &&srlPLUSerror, NULL }  ,  { &&srlPLUSerror, NULL }  ,  { &&srlPLUSerror, NULL }  ,  { &&srlPLUSerror, NULL }  ,  { &&srlPLUSerror, NULL }  ,  { &&srlPLUSerrorPLUSsubu, NULL }  ,  { &&srlPLUSerror, NULL }  ,  { &&srlPLUSerror, NULL }  ,  { &&srlPLUSerror, NULL }  ,  { &&srlPLUSerror, NULL } 
 ,  { &&srlPLUSerror, NULL }  ,  { &&srlPLUSerror, NULL }  ,  { &&srlPLUSerror, NULL }  ,  { &&srlPLUSerror, NULL }  ,  { &&srlPLUSerror, NULL }  ,  { &&srlPLUSerror, NULL }  ,  { &&srlPLUSerror, NULL }  ,  { &&srlPLUSerror, NULL }  ,  { &&srlPLUSerror, NULL }  ,  { &&srlPLUSerror, NULL } 
 ,  { &&srlPLUSerror, NULL }  ,  { &&srlPLUSerror, NULL }  ,  { &&srlPLUSerror, NULL }  ,  { &&srlPLUSerror, NULL }  ,  { &&srlPLUSerror, NULL }  ,  { &&srlPLUSerror, NULL }  ,  { &&srlPLUSerror, NULL }  ,  { &&srlPLUSerror, NULL }  ,  { &&srlPLUSerror, NULL }  ,  { &&srlPLUSerror, NULL } 
 ,  { &&srlPLUSerror, NULL }  ,  { &&srlPLUSerror, NULL }  ,  { &&srlPLUSerror, NULL }  ,  { &&srlPLUSerror, NULL }  ,  { &&srlPLUSerror, NULL }  ,  { &&srlPLUSerror, NULL }  ,  { &&srlPLUSerror, NULL }  ,  { &&srlPLUSerror, NULL }  ,  { &&srlPLUSerror, NULL }  ,  { &&srlPLUSerror, NULL } 
 ,  { &&srlPLUSerror, NULL }  ,  { &&srlPLUSerror, NULL }  ,  { &&srlPLUSerror, NULL }  ,  { &&srlPLUSerror, NULL }  ,  { &&srlPLUSerror, NULL }  ,  { &&srlPLUSerror, NULL }  ,  { &&srlPLUSerror, NULL }  ,  { &&srlPLUSerror, NULL }  ,  { &&srlPLUSerror, NULL }  ,  { &&srlPLUSerror, NULL } 
 ,  { &&srlPLUSerror, NULL }  ,  { &&srlPLUSerror, NULL }  ,  { &&srlPLUSerror, NULL }  ,  { &&srlPLUSerror, NULL }  ,  { &&srlPLUSerror, NULL }  ,  { &&srlPLUSerror, NULL }  ,  { &&srlPLUSerror, NULL }  ,  { &&srlPLUSerror, NULL }  ,  { &&srlPLUSerror, NULL }  ,  { &&srlPLUSerror, NULL } 
 ,  { &&srlPLUSerror, NULL }  ,  { &&srlPLUSerror, NULL }  ,  { &&srlPLUSerror, NULL }  ,  { &&srlPLUSerror, NULL }  ,  { &&srlPLUSerror, NULL }  ,  { &&srlPLUSerror, NULL }  ,  { &&srlPLUSerror, NULL }  ,  { &&srlPLUSerror, NULL }  ,  { &&srlPLUSerror, NULL }  ,  { &&srlPLUSerror, NULL } 
 ,  { &&srlPLUSerror, NULL }  ,  { &&srlPLUSerror, NULL }  ,  { &&srlPLUSerror, NULL }  ,  { &&srlPLUSerror, NULL }  ,  { &&srlPLUSerror, NULL }  ,  { &&srlPLUSerror, NULL }  ,  { &&srlPLUSerror, NULL }  ,  { &&srlPLUSerror, NULL }  ,  { &&srlPLUSerror, NULL }  ,  { &&srlPLUSerror, NULL } 
 }; 

struct pointer arrayoriPLUSaddu[T_SIZE] = {  { &&oriPLUSaddu, NULL }  ,  { &&oriPLUSaddu, NULL }  ,  { &&oriPLUSaddu, NULL }  ,  { &&oriPLUSaddu, NULL }  ,  { &&oriPLUSaddu, NULL }  ,  { &&oriPLUSaddu, NULL }  ,  { &&oriPLUSaddu, NULL }  ,  { &&oriPLUSaddu, NULL }  ,  { &&oriPLUSaddu, NULL }  ,  { &&oriPLUSaddu, NULL } 
 ,  { &&oriPLUSaddu, NULL }  ,  { &&oriPLUSaddu, NULL }  ,  { &&oriPLUSaddu, NULL }  ,  { &&oriPLUSaddu, NULL }  ,  { &&oriPLUSaddu, NULL }  ,  { &&oriPLUSaddu, NULL }  ,  { &&oriPLUSaddu, NULL }  ,  { &&oriPLUSaddu, NULL }  ,  { &&oriPLUSaddu, NULL }  ,  { &&oriPLUSaddu, NULL } 
 ,  { &&oriPLUSaddu, NULL }  ,  { &&oriPLUSaddu, NULL }  ,  { &&oriPLUSaddu, NULL }  ,  { &&oriPLUSaddu, NULL }  ,  { &&oriPLUSaddu, NULL }  ,  { &&oriPLUSaddu, NULL }  ,  { &&oriPLUSaddu, NULL }  ,  { &&oriPLUSaddu, NULL }  ,  { &&oriPLUSaddu, NULL }  ,  { &&oriPLUSaddu, NULL } 
 ,  { &&oriPLUSaddu, NULL }  ,  { &&oriPLUSaddu, NULL }  ,  { &&oriPLUSaddu, NULL }  ,  { &&oriPLUSaddu, NULL }  ,  { &&oriPLUSaddu, NULL }  ,  { &&oriPLUSaddu, NULL }  ,  { &&oriPLUSaddu, NULL }  ,  { &&oriPLUSaddu, NULL }  ,  { &&oriPLUSaddu, NULL }  ,  { &&oriPLUSaddu, NULL } 
 ,  { &&oriPLUSaddu, NULL }  ,  { &&oriPLUSaddu, NULL }  ,  { &&oriPLUSaddu, NULL }  ,  { &&oriPLUSaddu, NULL }  ,  { &&oriPLUSaddu, NULL }  ,  { &&oriPLUSaddu, NULL }  ,  { &&oriPLUSaddu, NULL }  ,  { &&oriPLUSaddu, NULL }  ,  { &&oriPLUSaddu, NULL }  ,  { &&oriPLUSaddu, NULL } 
 ,  { &&oriPLUSaddu, NULL }  ,  { &&oriPLUSaddu, NULL }  ,  { &&oriPLUSaddu, NULL }  ,  { &&oriPLUSaddu, NULL }  ,  { &&oriPLUSaddu, NULL }  ,  { &&oriPLUSaddu, NULL }  ,  { &&oriPLUSaddu, NULL }  ,  { &&oriPLUSaddu, NULL }  ,  { &&oriPLUSaddu, NULL }  ,  { &&oriPLUSaddu, NULL } 
 ,  { &&oriPLUSaddu, NULL }  ,  { &&oriPLUSaddu, NULL }  ,  { &&oriPLUSaddu, NULL }  ,  { &&oriPLUSaddu, NULL }  ,  { &&oriPLUSaddu, NULL }  ,  { &&oriPLUSaddu, NULL }  ,  { &&oriPLUSaddu, NULL }  ,  { &&oriPLUSaddu, NULL }  ,  { &&oriPLUSaddu, NULL }  ,  { &&oriPLUSaddu, NULL } 
 ,  { &&oriPLUSaddu, NULL }  ,  { &&oriPLUSaddu, NULL }  ,  { &&oriPLUSaddu, NULL }  ,  { &&oriPLUSaddu, NULL }  ,  { &&oriPLUSaddu, NULL }  ,  { &&oriPLUSaddu, NULL }  ,  { &&oriPLUSaddu, NULL }  ,  { &&oriPLUSaddu, NULL }  ,  { &&oriPLUSaddu, NULL }  ,  { &&oriPLUSaddu, NULL } 
 ,  { &&oriPLUSaddu, NULL }  ,  { &&oriPLUSaddu, NULL }  ,  { &&oriPLUSaddu, NULL }  ,  { &&oriPLUSaddu, NULL }  ,  { &&oriPLUSaddu, NULL }  ,  { &&oriPLUSaddu, NULL }  ,  { &&oriPLUSadduPLUSsw, NULL }  ,  { &&oriPLUSaddu, NULL }  ,  { &&oriPLUSaddu, NULL }  ,  { &&oriPLUSaddu, NULL } 
 ,  { &&oriPLUSaddu, NULL }  ,  { &&oriPLUSaddu, NULL }  ,  { &&oriPLUSaddu, NULL }  ,  { &&oriPLUSaddu, NULL }  ,  { &&oriPLUSaddu, NULL }  ,  { &&oriPLUSaddu, NULL }  ,  { &&oriPLUSaddu, NULL }  ,  { &&oriPLUSaddu, NULL }  ,  { &&oriPLUSaddu, NULL }  ,  { &&oriPLUSaddu, NULL } 
 ,  { &&oriPLUSaddu, NULL }  ,  { &&oriPLUSaddu, NULL }  ,  { &&oriPLUSaddu, NULL }  ,  { &&oriPLUSaddu, NULL }  ,  { &&oriPLUSaddu, NULL }  ,  { &&oriPLUSaddu, NULL }  ,  { &&oriPLUSaddu, NULL }  ,  { &&oriPLUSaddu, NULL }  ,  { &&oriPLUSaddu, NULL }  ,  { &&oriPLUSaddu, NULL } 
 }; 

struct pointer arraysllPLUSand[T_SIZE] = {  { &&sllPLUSand, NULL }  ,  { &&sllPLUSand, NULL }  ,  { &&sllPLUSand, NULL }  ,  { &&sllPLUSand, NULL }  ,  { &&sllPLUSand, NULL }  ,  { &&sllPLUSand, NULL }  ,  { &&sllPLUSand, NULL }  ,  { &&sllPLUSand, NULL }  ,  { &&sllPLUSand, NULL }  ,  { &&sllPLUSand, NULL } 
 ,  { &&sllPLUSand, NULL }  ,  { &&sllPLUSand, NULL }  ,  { &&sllPLUSand, NULL }  ,  { &&sllPLUSand, NULL }  ,  { &&sllPLUSand, NULL }  ,  { &&sllPLUSand, NULL }  ,  { &&sllPLUSand, NULL }  ,  { &&sllPLUSand, NULL }  ,  { &&sllPLUSand, NULL }  ,  { &&sllPLUSand, NULL } 
 ,  { &&sllPLUSand, NULL }  ,  { &&sllPLUSand, NULL }  ,  { &&sllPLUSand, NULL }  ,  { &&sllPLUSand, NULL }  ,  { &&sllPLUSand, NULL }  ,  { &&sllPLUSand, NULL }  ,  { &&sllPLUSand, NULL }  ,  { &&sllPLUSand, NULL }  ,  { &&sllPLUSand, NULL }  ,  { &&sllPLUSand, NULL } 
 ,  { &&sllPLUSand, NULL }  ,  { &&sllPLUSand, NULL }  ,  { &&sllPLUSand, NULL }  ,  { &&sllPLUSand, NULL }  ,  { &&sllPLUSand, NULL }  ,  { &&sllPLUSand, NULL }  ,  { &&sllPLUSand, NULL }  ,  { &&sllPLUSandPLUSor, NULL }  ,  { &&sllPLUSand, NULL }  ,  { &&sllPLUSand, NULL } 
 ,  { &&sllPLUSand, NULL }  ,  { &&sllPLUSand, NULL }  ,  { &&sllPLUSand, NULL }  ,  { &&sllPLUSand, NULL }  ,  { &&sllPLUSand, NULL }  ,  { &&sllPLUSand, NULL }  ,  { &&sllPLUSand, NULL }  ,  { &&sllPLUSand, NULL }  ,  { &&sllPLUSand, NULL }  ,  { &&sllPLUSand, NULL } 
 ,  { &&sllPLUSand, NULL }  ,  { &&sllPLUSand, NULL }  ,  { &&sllPLUSand, NULL }  ,  { &&sllPLUSand, NULL }  ,  { &&sllPLUSand, NULL }  ,  { &&sllPLUSand, NULL }  ,  { &&sllPLUSand, NULL }  ,  { &&sllPLUSand, NULL }  ,  { &&sllPLUSand, NULL }  ,  { &&sllPLUSand, NULL } 
 ,  { &&sllPLUSand, NULL }  ,  { &&sllPLUSand, NULL }  ,  { &&sllPLUSand, NULL }  ,  { &&sllPLUSand, NULL }  ,  { &&sllPLUSand, NULL }  ,  { &&sllPLUSand, NULL }  ,  { &&sllPLUSand, NULL }  ,  { &&sllPLUSand, NULL }  ,  { &&sllPLUSand, NULL }  ,  { &&sllPLUSand, NULL } 
 ,  { &&sllPLUSand, NULL }  ,  { &&sllPLUSand, NULL }  ,  { &&sllPLUSand, NULL }  ,  { &&sllPLUSand, NULL }  ,  { &&sllPLUSand, NULL }  ,  { &&sllPLUSand, NULL }  ,  { &&sllPLUSand, NULL }  ,  { &&sllPLUSand, NULL }  ,  { &&sllPLUSand, NULL }  ,  { &&sllPLUSand, NULL } 
 ,  { &&sllPLUSand, NULL }  ,  { &&sllPLUSand, NULL }  ,  { &&sllPLUSand, NULL }  ,  { &&sllPLUSand, NULL }  ,  { &&sllPLUSand, NULL }  ,  { &&sllPLUSand, NULL }  ,  { &&sllPLUSand, NULL }  ,  { &&sllPLUSand, NULL }  ,  { &&sllPLUSand, NULL }  ,  { &&sllPLUSand, NULL } 
 ,  { &&sllPLUSand, NULL }  ,  { &&sllPLUSand, NULL }  ,  { &&sllPLUSand, NULL }  ,  { &&sllPLUSand, NULL }  ,  { &&sllPLUSand, NULL }  ,  { &&sllPLUSand, NULL }  ,  { &&sllPLUSand, NULL }  ,  { &&sllPLUSand, NULL }  ,  { &&sllPLUSand, NULL }  ,  { &&sllPLUSand, NULL } 
 ,  { &&sllPLUSand, NULL }  ,  { &&sllPLUSand, NULL }  ,  { &&sllPLUSand, NULL }  ,  { &&sllPLUSand, NULL }  ,  { &&sllPLUSand, NULL }  ,  { &&sllPLUSand, NULL }  ,  { &&sllPLUSand, NULL }  ,  { &&sllPLUSand, NULL }  ,  { &&sllPLUSand, NULL }  ,  { &&sllPLUSand, NULL } 
 }; 

struct pointer arraylbuPLUSaddiu[T_SIZE] = {  { &&lbuPLUSaddiu, NULL }  ,  { &&lbuPLUSaddiu, NULL }  ,  { &&lbuPLUSaddiuPLUSsrl, NULL }  ,  { &&lbuPLUSaddiu, NULL }  ,  { &&lbuPLUSaddiu, NULL }  ,  { &&lbuPLUSaddiu, NULL }  ,  { &&lbuPLUSaddiu, NULL }  ,  { &&lbuPLUSaddiu, NULL }  ,  { &&lbuPLUSaddiu, NULL }  ,  { &&lbuPLUSaddiu, NULL } 
 ,  { &&lbuPLUSaddiu, NULL }  ,  { &&lbuPLUSaddiu, NULL }  ,  { &&lbuPLUSaddiu, NULL }  ,  { &&lbuPLUSaddiu, NULL }  ,  { &&lbuPLUSaddiu, NULL }  ,  { &&lbuPLUSaddiu, NULL }  ,  { &&lbuPLUSaddiu, NULL }  ,  { &&lbuPLUSaddiu, NULL }  ,  { &&lbuPLUSaddiu, NULL }  ,  { &&lbuPLUSaddiu, NULL } 
 ,  { &&lbuPLUSaddiu, NULL }  ,  { &&lbuPLUSaddiu, NULL }  ,  { &&lbuPLUSaddiu, NULL }  ,  { &&lbuPLUSaddiu, NULL }  ,  { &&lbuPLUSaddiu, NULL }  ,  { &&lbuPLUSaddiu, NULL }  ,  { &&lbuPLUSaddiu, NULL }  ,  { &&lbuPLUSaddiu, NULL }  ,  { &&lbuPLUSaddiu, NULL }  ,  { &&lbuPLUSaddiu, NULL } 
 ,  { &&lbuPLUSaddiu, NULL }  ,  { &&lbuPLUSaddiu, NULL }  ,  { &&lbuPLUSaddiu, NULL }  ,  { &&lbuPLUSaddiu, NULL }  ,  { &&lbuPLUSaddiu, NULL }  ,  { &&lbuPLUSaddiu, NULL }  ,  { &&lbuPLUSaddiu, NULL }  ,  { &&lbuPLUSaddiu, NULL }  ,  { &&lbuPLUSaddiu, NULL }  ,  { &&lbuPLUSaddiu, NULL } 
 ,  { &&lbuPLUSaddiu, NULL }  ,  { &&lbuPLUSaddiu, NULL }  ,  { &&lbuPLUSaddiu, NULL }  ,  { &&lbuPLUSaddiu, NULL }  ,  { &&lbuPLUSaddiu, NULL }  ,  { &&lbuPLUSaddiu, NULL }  ,  { &&lbuPLUSaddiu, NULL }  ,  { &&lbuPLUSaddiu, NULL }  ,  { &&lbuPLUSaddiu, NULL }  ,  { &&lbuPLUSaddiu, NULL } 
 ,  { &&lbuPLUSaddiu, NULL }  ,  { &&lbuPLUSaddiu, NULL }  ,  { &&lbuPLUSaddiu, NULL }  ,  { &&lbuPLUSaddiu, NULL }  ,  { &&lbuPLUSaddiu, NULL }  ,  { &&lbuPLUSaddiu, NULL }  ,  { &&lbuPLUSaddiu, NULL }  ,  { &&lbuPLUSaddiu, NULL }  ,  { &&lbuPLUSaddiu, NULL }  ,  { &&lbuPLUSaddiu, NULL } 
 ,  { &&lbuPLUSaddiu, NULL }  ,  { &&lbuPLUSaddiu, NULL }  ,  { &&lbuPLUSaddiu, NULL }  ,  { &&lbuPLUSaddiu, NULL }  ,  { &&lbuPLUSaddiu, NULL }  ,  { &&lbuPLUSaddiu, NULL }  ,  { &&lbuPLUSaddiu, NULL }  ,  { &&lbuPLUSaddiu, NULL }  ,  { &&lbuPLUSaddiu, NULL }  ,  { &&lbuPLUSaddiu, NULL } 
 ,  { &&lbuPLUSaddiu, NULL }  ,  { &&lbuPLUSaddiu, NULL }  ,  { &&lbuPLUSaddiu, NULL }  ,  { &&lbuPLUSaddiu, NULL }  ,  { &&lbuPLUSaddiu, NULL }  ,  { &&lbuPLUSaddiu, NULL }  ,  { &&lbuPLUSaddiu, NULL }  ,  { &&lbuPLUSaddiu, NULL }  ,  { &&lbuPLUSaddiu, NULL }  ,  { &&lbuPLUSaddiu, NULL } 
 ,  { &&lbuPLUSaddiu, NULL }  ,  { &&lbuPLUSaddiu, NULL }  ,  { &&lbuPLUSaddiu, NULL }  ,  { &&lbuPLUSaddiu, NULL }  ,  { &&lbuPLUSaddiu, NULL }  ,  { &&lbuPLUSaddiu, NULL }  ,  { &&lbuPLUSaddiu, NULL }  ,  { &&lbuPLUSaddiu, NULL }  ,  { &&lbuPLUSaddiu, NULL }  ,  { &&lbuPLUSaddiu, NULL } 
 ,  { &&lbuPLUSaddiu, NULL }  ,  { &&lbuPLUSaddiu, NULL }  ,  { &&lbuPLUSaddiu, NULL }  ,  { &&lbuPLUSaddiu, NULL }  ,  { &&lbuPLUSaddiu, NULL }  ,  { &&lbuPLUSaddiu, NULL }  ,  { &&lbuPLUSaddiu, NULL }  ,  { &&lbuPLUSaddiu, NULL }  ,  { &&lbuPLUSaddiu, NULL }  ,  { &&lbuPLUSaddiu, NULL } 
 ,  { &&lbuPLUSaddiu, NULL }  ,  { &&lbuPLUSaddiu, NULL }  ,  { &&lbuPLUSaddiu, NULL }  ,  { &&lbuPLUSaddiu, NULL }  ,  { &&lbuPLUSaddiu, NULL }  ,  { &&lbuPLUSaddiu, NULL }  ,  { &&lbuPLUSaddiu, NULL }  ,  { &&lbuPLUSaddiu, NULL }  ,  { &&lbuPLUSaddiu, NULL }  ,  { &&lbuPLUSaddiu, NULL } 
 }; 

struct pointer arrayaddiuPLUSxor[T_SIZE] = {  { &&addiuPLUSxor, NULL }  ,  { &&addiuPLUSxor, NULL }  ,  { &&addiuPLUSxor, NULL }  ,  { &&addiuPLUSxor, NULL }  ,  { &&addiuPLUSxor, NULL }  ,  { &&addiuPLUSxor, NULL }  ,  { &&addiuPLUSxor, NULL }  ,  { &&addiuPLUSxor, NULL }  ,  { &&addiuPLUSxor, NULL }  ,  { &&addiuPLUSxor, NULL } 
 ,  { &&addiuPLUSxor, NULL }  ,  { &&addiuPLUSxor, NULL }  ,  { &&addiuPLUSxor, NULL }  ,  { &&addiuPLUSxor, NULL }  ,  { &&addiuPLUSxor, NULL }  ,  { &&addiuPLUSxor, NULL }  ,  { &&addiuPLUSxor, NULL }  ,  { &&addiuPLUSxor, NULL }  ,  { &&addiuPLUSxor, NULL }  ,  { &&addiuPLUSxor, NULL } 
 ,  { &&addiuPLUSxor, NULL }  ,  { &&addiuPLUSxor, NULL }  ,  { &&addiuPLUSxor, NULL }  ,  { &&addiuPLUSxor, NULL }  ,  { &&addiuPLUSxor, NULL }  ,  { &&addiuPLUSxor, NULL }  ,  { &&addiuPLUSxor, NULL }  ,  { &&addiuPLUSxor, NULL }  ,  { &&addiuPLUSxor, NULL }  ,  { &&addiuPLUSxor, NULL } 
 ,  { &&addiuPLUSxor, NULL }  ,  { &&addiuPLUSxor, NULL }  ,  { &&addiuPLUSxor, NULL }  ,  { &&addiuPLUSxor, NULL }  ,  { &&addiuPLUSxor, NULL }  ,  { &&addiuPLUSxor, NULL }  ,  { &&addiuPLUSxor, NULL }  ,  { &&addiuPLUSxor, NULL }  ,  { &&addiuPLUSxor, NULL }  ,  { &&addiuPLUSxor, NULL } 
 ,  { &&addiuPLUSxor, NULL }  ,  { &&addiuPLUSxor, NULL }  ,  { &&addiuPLUSxor, NULL }  ,  { &&addiuPLUSxor, NULL }  ,  { &&addiuPLUSxor, NULL }  ,  { &&addiuPLUSxor, NULL }  ,  { &&addiuPLUSxor, NULL }  ,  { &&addiuPLUSxor, NULL }  ,  { &&addiuPLUSxor, NULL }  ,  { &&addiuPLUSxor, NULL } 
 ,  { &&addiuPLUSxor, NULL }  ,  { &&addiuPLUSxor, NULL }  ,  { &&addiuPLUSxor, NULL }  ,  { &&addiuPLUSxor, NULL }  ,  { &&addiuPLUSxor, NULL }  ,  { &&addiuPLUSxorPLUSandi, NULL }  ,  { &&addiuPLUSxor, NULL }  ,  { &&addiuPLUSxor, NULL }  ,  { &&addiuPLUSxor, NULL }  ,  { &&addiuPLUSxor, NULL } 
 ,  { &&addiuPLUSxor, NULL }  ,  { &&addiuPLUSxor, NULL }  ,  { &&addiuPLUSxor, NULL }  ,  { &&addiuPLUSxor, NULL }  ,  { &&addiuPLUSxor, NULL }  ,  { &&addiuPLUSxor, NULL }  ,  { &&addiuPLUSxor, NULL }  ,  { &&addiuPLUSxor, NULL }  ,  { &&addiuPLUSxor, NULL }  ,  { &&addiuPLUSxor, NULL } 
 ,  { &&addiuPLUSxor, NULL }  ,  { &&addiuPLUSxor, NULL }  ,  { &&addiuPLUSxor, NULL }  ,  { &&addiuPLUSxor, NULL }  ,  { &&addiuPLUSxor, NULL }  ,  { &&addiuPLUSxor, NULL }  ,  { &&addiuPLUSxor, NULL }  ,  { &&addiuPLUSxor, NULL }  ,  { &&addiuPLUSxor, NULL }  ,  { &&addiuPLUSxor, NULL } 
 ,  { &&addiuPLUSxor, NULL }  ,  { &&addiuPLUSxor, NULL }  ,  { &&addiuPLUSxor, NULL }  ,  { &&addiuPLUSxor, NULL }  ,  { &&addiuPLUSxor, NULL }  ,  { &&addiuPLUSxor, NULL }  ,  { &&addiuPLUSxor, NULL }  ,  { &&addiuPLUSxor, NULL }  ,  { &&addiuPLUSxor, NULL }  ,  { &&addiuPLUSxor, NULL } 
 ,  { &&addiuPLUSxor, NULL }  ,  { &&addiuPLUSxor, NULL }  ,  { &&addiuPLUSxor, NULL }  ,  { &&addiuPLUSxor, NULL }  ,  { &&addiuPLUSxor, NULL }  ,  { &&addiuPLUSxor, NULL }  ,  { &&addiuPLUSxor, NULL }  ,  { &&addiuPLUSxor, NULL }  ,  { &&addiuPLUSxor, NULL }  ,  { &&addiuPLUSxor, NULL } 
 ,  { &&addiuPLUSxor, NULL }  ,  { &&addiuPLUSxor, NULL }  ,  { &&addiuPLUSxor, NULL }  ,  { &&addiuPLUSxor, NULL }  ,  { &&addiuPLUSxor, NULL }  ,  { &&addiuPLUSxor, NULL }  ,  { &&addiuPLUSxor, NULL }  ,  { &&addiuPLUSxor, NULL }  ,  { &&addiuPLUSxor, NULL }  ,  { &&addiuPLUSxor, NULL } 
 }; 

struct pointer arrayorPLUSsll[T_SIZE] = {  { &&orPLUSsll, NULL }  ,  { &&orPLUSsll, NULL }  ,  { &&orPLUSsllPLUSsrl, NULL }  ,  { &&orPLUSsll, NULL }  ,  { &&orPLUSsll, NULL }  ,  { &&orPLUSsll, NULL }  ,  { &&orPLUSsll, NULL }  ,  { &&orPLUSsll, NULL }  ,  { &&orPLUSsll, NULL }  ,  { &&orPLUSsll, NULL } 
 ,  { &&orPLUSsll, NULL }  ,  { &&orPLUSsll, NULL }  ,  { &&orPLUSsll, NULL }  ,  { &&orPLUSsll, NULL }  ,  { &&orPLUSsll, NULL }  ,  { &&orPLUSsll, NULL }  ,  { &&orPLUSsll, NULL }  ,  { &&orPLUSsll, NULL }  ,  { &&orPLUSsll, NULL }  ,  { &&orPLUSsll, NULL } 
 ,  { &&orPLUSsll, NULL }  ,  { &&orPLUSsll, NULL }  ,  { &&orPLUSsll, NULL }  ,  { &&orPLUSsll, NULL }  ,  { &&orPLUSsll, NULL }  ,  { &&orPLUSsll, NULL }  ,  { &&orPLUSsll, NULL }  ,  { &&orPLUSsll, NULL }  ,  { &&orPLUSsll, NULL }  ,  { &&orPLUSsll, NULL } 
 ,  { &&orPLUSsll, NULL }  ,  { &&orPLUSsll, NULL }  ,  { &&orPLUSsll, NULL }  ,  { &&orPLUSsll, NULL }  ,  { &&orPLUSsll, NULL }  ,  { &&orPLUSsll, NULL }  ,  { &&orPLUSsllPLUSand, NULL }  ,  { &&orPLUSsllPLUSor, NULL }  ,  { &&orPLUSsll, NULL }  ,  { &&orPLUSsll, NULL } 
 ,  { &&orPLUSsll, NULL }  ,  { &&orPLUSsll, NULL }  ,  { &&orPLUSsll, NULL }  ,  { &&orPLUSsll, NULL }  ,  { &&orPLUSsll, NULL }  ,  { &&orPLUSsll, NULL }  ,  { &&orPLUSsll, NULL }  ,  { &&orPLUSsll, NULL }  ,  { &&orPLUSsll, NULL }  ,  { &&orPLUSsll, NULL } 
 ,  { &&orPLUSsll, NULL }  ,  { &&orPLUSsll, NULL }  ,  { &&orPLUSsll, NULL }  ,  { &&orPLUSsll, NULL }  ,  { &&orPLUSsll, NULL }  ,  { &&orPLUSsll, NULL }  ,  { &&orPLUSsll, NULL }  ,  { &&orPLUSsll, NULL }  ,  { &&orPLUSsll, NULL }  ,  { &&orPLUSsll, NULL } 
 ,  { &&orPLUSsll, NULL }  ,  { &&orPLUSsll, NULL }  ,  { &&orPLUSsll, NULL }  ,  { &&orPLUSsll, NULL }  ,  { &&orPLUSsll, NULL }  ,  { &&orPLUSsll, NULL }  ,  { &&orPLUSsll, NULL }  ,  { &&orPLUSsll, NULL }  ,  { &&orPLUSsll, NULL }  ,  { &&orPLUSsll, NULL } 
 ,  { &&orPLUSsll, NULL }  ,  { &&orPLUSsll, NULL }  ,  { &&orPLUSsll, NULL }  ,  { &&orPLUSsll, NULL }  ,  { &&orPLUSsll, NULL }  ,  { &&orPLUSsll, NULL }  ,  { &&orPLUSsll, NULL }  ,  { &&orPLUSsll, NULL }  ,  { &&orPLUSsll, NULL }  ,  { &&orPLUSsllPLUSlbu, NULL } 
 ,  { &&orPLUSsll, NULL }  ,  { &&orPLUSsll, NULL }  ,  { &&orPLUSsll, NULL }  ,  { &&orPLUSsllPLUSsb, NULL }  ,  { &&orPLUSsll, NULL }  ,  { &&orPLUSsll, NULL }  ,  { &&orPLUSsll, NULL }  ,  { &&orPLUSsll, NULL }  ,  { &&orPLUSsll, NULL }  ,  { &&orPLUSsll, NULL } 
 ,  { &&orPLUSsll, NULL }  ,  { &&orPLUSsll, NULL }  ,  { &&orPLUSsll, NULL }  ,  { &&orPLUSsll, NULL }  ,  { &&orPLUSsll, NULL }  ,  { &&orPLUSsll, NULL }  ,  { &&orPLUSsll, NULL }  ,  { &&orPLUSsll, NULL }  ,  { &&orPLUSsll, NULL }  ,  { &&orPLUSsll, NULL } 
 ,  { &&orPLUSsll, NULL }  ,  { &&orPLUSsll, NULL }  ,  { &&orPLUSsll, NULL }  ,  { &&orPLUSsll, NULL }  ,  { &&orPLUSsll, NULL }  ,  { &&orPLUSsll, NULL }  ,  { &&orPLUSsll, NULL }  ,  { &&orPLUSsll, NULL }  ,  { &&orPLUSsll, NULL }  ,  { &&orPLUSsll, NULL } 
 }; 

struct pointer arraysltPLUSbeq[T_SIZE] = {  { &&sltPLUSbeqPLUSsll, NULL }  ,  { &&sltPLUSbeq, NULL }  ,  { &&sltPLUSbeq, NULL }  ,  { &&sltPLUSbeq, NULL }  ,  { &&sltPLUSbeq, NULL }  ,  { &&sltPLUSbeq, NULL }  ,  { &&sltPLUSbeq, NULL }  ,  { &&sltPLUSbeq, NULL }  ,  { &&sltPLUSbeq, NULL }  ,  { &&sltPLUSbeq, NULL } 
 ,  { &&sltPLUSbeq, NULL }  ,  { &&sltPLUSbeq, NULL }  ,  { &&sltPLUSbeq, NULL }  ,  { &&sltPLUSbeq, NULL }  ,  { &&sltPLUSbeq, NULL }  ,  { &&sltPLUSbeq, NULL }  ,  { &&sltPLUSbeq, NULL }  ,  { &&sltPLUSbeq, NULL }  ,  { &&sltPLUSbeq, NULL }  ,  { &&sltPLUSbeq, NULL } 
 ,  { &&sltPLUSbeq, NULL }  ,  { &&sltPLUSbeq, NULL }  ,  { &&sltPLUSbeq, NULL }  ,  { &&sltPLUSbeq, NULL }  ,  { &&sltPLUSbeq, NULL }  ,  { &&sltPLUSbeq, NULL }  ,  { &&sltPLUSbeq, NULL }  ,  { &&sltPLUSbeq, NULL }  ,  { &&sltPLUSbeq, NULL }  ,  { &&sltPLUSbeq, NULL } 
 ,  { &&sltPLUSbeq, NULL }  ,  { &&sltPLUSbeq, NULL }  ,  { &&sltPLUSbeq, NULL }  ,  { &&sltPLUSbeqPLUSaddu, NULL }  ,  { &&sltPLUSbeq, NULL }  ,  { &&sltPLUSbeq, NULL }  ,  { &&sltPLUSbeq, NULL }  ,  { &&sltPLUSbeq, NULL }  ,  { &&sltPLUSbeq, NULL }  ,  { &&sltPLUSbeq, NULL } 
 ,  { &&sltPLUSbeq, NULL }  ,  { &&sltPLUSbeq, NULL }  ,  { &&sltPLUSbeq, NULL }  ,  { &&sltPLUSbeq, NULL }  ,  { &&sltPLUSbeq, NULL }  ,  { &&sltPLUSbeq, NULL }  ,  { &&sltPLUSbeq, NULL }  ,  { &&sltPLUSbeq, NULL }  ,  { &&sltPLUSbeq, NULL }  ,  { &&sltPLUSbeq, NULL } 
 ,  { &&sltPLUSbeq, NULL }  ,  { &&sltPLUSbeq, NULL }  ,  { &&sltPLUSbeq, NULL }  ,  { &&sltPLUSbeq, NULL }  ,  { &&sltPLUSbeq, NULL }  ,  { &&sltPLUSbeq, NULL }  ,  { &&sltPLUSbeq, NULL }  ,  { &&sltPLUSbeq, NULL }  ,  { &&sltPLUSbeq, NULL }  ,  { &&sltPLUSbeq, NULL } 
 ,  { &&sltPLUSbeq, NULL }  ,  { &&sltPLUSbeq, NULL }  ,  { &&sltPLUSbeq, NULL }  ,  { &&sltPLUSbeq, NULL }  ,  { &&sltPLUSbeq, NULL }  ,  { &&sltPLUSbeq, NULL }  ,  { &&sltPLUSbeq, NULL }  ,  { &&sltPLUSbeq, NULL }  ,  { &&sltPLUSbeq, NULL }  ,  { &&sltPLUSbeq, NULL } 
 ,  { &&sltPLUSbeq, NULL }  ,  { &&sltPLUSbeq, NULL }  ,  { &&sltPLUSbeq, NULL }  ,  { &&sltPLUSbeq, NULL }  ,  { &&sltPLUSbeq, NULL }  ,  { &&sltPLUSbeq, NULL }  ,  { &&sltPLUSbeq, NULL }  ,  { &&sltPLUSbeq, NULL }  ,  { &&sltPLUSbeq, NULL }  ,  { &&sltPLUSbeq, NULL } 
 ,  { &&sltPLUSbeq, NULL }  ,  { &&sltPLUSbeq, NULL }  ,  { &&sltPLUSbeq, NULL }  ,  { &&sltPLUSbeq, NULL }  ,  { &&sltPLUSbeq, NULL }  ,  { &&sltPLUSbeq, NULL }  ,  { &&sltPLUSbeq, NULL }  ,  { &&sltPLUSbeq, NULL }  ,  { &&sltPLUSbeq, NULL }  ,  { &&sltPLUSbeq, NULL } 
 ,  { &&sltPLUSbeq, NULL }  ,  { &&sltPLUSbeq, NULL }  ,  { &&sltPLUSbeq, NULL }  ,  { &&sltPLUSbeq, NULL }  ,  { &&sltPLUSbeq, NULL }  ,  { &&sltPLUSbeq, NULL }  ,  { &&sltPLUSbeq, NULL }  ,  { &&sltPLUSbeq, NULL }  ,  { &&sltPLUSbeq, NULL }  ,  { &&sltPLUSbeq, NULL } 
 ,  { &&sltPLUSbeq, NULL }  ,  { &&sltPLUSbeq, NULL }  ,  { &&sltPLUSbeq, NULL }  ,  { &&sltPLUSbeq, NULL }  ,  { &&sltPLUSbeq, NULL }  ,  { &&sltPLUSbeq, NULL }  ,  { &&sltPLUSbeq, NULL }  ,  { &&sltPLUSbeq, NULL }  ,  { &&sltPLUSbeq, NULL }  ,  { &&sltPLUSbeq, NULL } 
 }; 

struct pointer arraylwPLUSori[T_SIZE] = {  { &&lwPLUSoriPLUSsll, NULL }  ,  { &&lwPLUSori, NULL }  ,  { &&lwPLUSori, NULL }  ,  { &&lwPLUSori, NULL }  ,  { &&lwPLUSori, NULL }  ,  { &&lwPLUSori, NULL }  ,  { &&lwPLUSori, NULL }  ,  { &&lwPLUSori, NULL }  ,  { &&lwPLUSori, NULL }  ,  { &&lwPLUSori, NULL } 
 ,  { &&lwPLUSori, NULL }  ,  { &&lwPLUSori, NULL }  ,  { &&lwPLUSori, NULL }  ,  { &&lwPLUSori, NULL }  ,  { &&lwPLUSori, NULL }  ,  { &&lwPLUSori, NULL }  ,  { &&lwPLUSori, NULL }  ,  { &&lwPLUSori, NULL }  ,  { &&lwPLUSori, NULL }  ,  { &&lwPLUSori, NULL } 
 ,  { &&lwPLUSori, NULL }  ,  { &&lwPLUSori, NULL }  ,  { &&lwPLUSori, NULL }  ,  { &&lwPLUSori, NULL }  ,  { &&lwPLUSori, NULL }  ,  { &&lwPLUSori, NULL }  ,  { &&lwPLUSori, NULL }  ,  { &&lwPLUSori, NULL }  ,  { &&lwPLUSori, NULL }  ,  { &&lwPLUSori, NULL } 
 ,  { &&lwPLUSori, NULL }  ,  { &&lwPLUSori, NULL }  ,  { &&lwPLUSori, NULL }  ,  { &&lwPLUSori, NULL }  ,  { &&lwPLUSori, NULL }  ,  { &&lwPLUSori, NULL }  ,  { &&lwPLUSori, NULL }  ,  { &&lwPLUSori, NULL }  ,  { &&lwPLUSori, NULL }  ,  { &&lwPLUSori, NULL } 
 ,  { &&lwPLUSori, NULL }  ,  { &&lwPLUSori, NULL }  ,  { &&lwPLUSori, NULL }  ,  { &&lwPLUSori, NULL }  ,  { &&lwPLUSori, NULL }  ,  { &&lwPLUSori, NULL }  ,  { &&lwPLUSori, NULL }  ,  { &&lwPLUSori, NULL }  ,  { &&lwPLUSori, NULL }  ,  { &&lwPLUSori, NULL } 
 ,  { &&lwPLUSori, NULL }  ,  { &&lwPLUSori, NULL }  ,  { &&lwPLUSori, NULL }  ,  { &&lwPLUSori, NULL }  ,  { &&lwPLUSori, NULL }  ,  { &&lwPLUSori, NULL }  ,  { &&lwPLUSori, NULL }  ,  { &&lwPLUSori, NULL }  ,  { &&lwPLUSori, NULL }  ,  { &&lwPLUSori, NULL } 
 ,  { &&lwPLUSori, NULL }  ,  { &&lwPLUSori, NULL }  ,  { &&lwPLUSori, NULL }  ,  { &&lwPLUSori, NULL }  ,  { &&lwPLUSori, NULL }  ,  { &&lwPLUSori, NULL }  ,  { &&lwPLUSori, NULL }  ,  { &&lwPLUSori, NULL }  ,  { &&lwPLUSori, NULL }  ,  { &&lwPLUSori, NULL } 
 ,  { &&lwPLUSori, NULL }  ,  { &&lwPLUSori, NULL }  ,  { &&lwPLUSori, NULL }  ,  { &&lwPLUSori, NULL }  ,  { &&lwPLUSori, NULL }  ,  { &&lwPLUSori, NULL }  ,  { &&lwPLUSori, NULL }  ,  { &&lwPLUSori, NULL }  ,  { &&lwPLUSori, NULL }  ,  { &&lwPLUSori, NULL } 
 ,  { &&lwPLUSori, NULL }  ,  { &&lwPLUSori, NULL }  ,  { &&lwPLUSori, NULL }  ,  { &&lwPLUSori, NULL }  ,  { &&lwPLUSori, NULL }  ,  { &&lwPLUSori, NULL }  ,  { &&lwPLUSori, NULL }  ,  { &&lwPLUSori, NULL }  ,  { &&lwPLUSori, NULL }  ,  { &&lwPLUSori, NULL } 
 ,  { &&lwPLUSori, NULL }  ,  { &&lwPLUSori, NULL }  ,  { &&lwPLUSori, NULL }  ,  { &&lwPLUSori, NULL }  ,  { &&lwPLUSori, NULL }  ,  { &&lwPLUSori, NULL }  ,  { &&lwPLUSori, NULL }  ,  { &&lwPLUSori, NULL }  ,  { &&lwPLUSori, NULL }  ,  { &&lwPLUSori, NULL } 
 ,  { &&lwPLUSori, NULL }  ,  { &&lwPLUSori, NULL }  ,  { &&lwPLUSori, NULL }  ,  { &&lwPLUSori, NULL }  ,  { &&lwPLUSori, NULL }  ,  { &&lwPLUSori, NULL }  ,  { &&lwPLUSori, NULL }  ,  { &&lwPLUSori, NULL }  ,  { &&lwPLUSori, NULL }  ,  { &&lwPLUSori, NULL } 
 }; 

struct pointer arrayadduPLUSaddu[T_SIZE] = {  { &&adduPLUSadduPLUSsll, NULL }  ,  { &&adduPLUSaddu, NULL }  ,  { &&adduPLUSaddu, NULL }  ,  { &&adduPLUSaddu, NULL }  ,  { &&adduPLUSaddu, NULL }  ,  { &&adduPLUSaddu, NULL }  ,  { &&adduPLUSaddu, NULL }  ,  { &&adduPLUSaddu, NULL }  ,  { &&adduPLUSaddu, NULL }  ,  { &&adduPLUSaddu, NULL } 
 ,  { &&adduPLUSaddu, NULL }  ,  { &&adduPLUSaddu, NULL }  ,  { &&adduPLUSaddu, NULL }  ,  { &&adduPLUSaddu, NULL }  ,  { &&adduPLUSaddu, NULL }  ,  { &&adduPLUSaddu, NULL }  ,  { &&adduPLUSaddu, NULL }  ,  { &&adduPLUSaddu, NULL }  ,  { &&adduPLUSaddu, NULL }  ,  { &&adduPLUSaddu, NULL } 
 ,  { &&adduPLUSaddu, NULL }  ,  { &&adduPLUSaddu, NULL }  ,  { &&adduPLUSaddu, NULL }  ,  { &&adduPLUSaddu, NULL }  ,  { &&adduPLUSaddu, NULL }  ,  { &&adduPLUSaddu, NULL }  ,  { &&adduPLUSaddu, NULL }  ,  { &&adduPLUSaddu, NULL }  ,  { &&adduPLUSaddu, NULL }  ,  { &&adduPLUSaddu, NULL } 
 ,  { &&adduPLUSaddu, NULL }  ,  { &&adduPLUSaddu, NULL }  ,  { &&adduPLUSaddu, NULL }  ,  { &&adduPLUSadduPLUSaddu, NULL }  ,  { &&adduPLUSaddu, NULL }  ,  { &&adduPLUSaddu, NULL }  ,  { &&adduPLUSaddu, NULL }  ,  { &&adduPLUSaddu, NULL }  ,  { &&adduPLUSaddu, NULL }  ,  { &&adduPLUSaddu, NULL } 
 ,  { &&adduPLUSaddu, NULL }  ,  { &&adduPLUSaddu, NULL }  ,  { &&adduPLUSaddu, NULL }  ,  { &&adduPLUSaddu, NULL }  ,  { &&adduPLUSaddu, NULL }  ,  { &&adduPLUSadduPLUSjump, NULL }  ,  { &&adduPLUSaddu, NULL }  ,  { &&adduPLUSaddu, NULL }  ,  { &&adduPLUSadduPLUSbne, NULL }  ,  { &&adduPLUSaddu, NULL } 
 ,  { &&adduPLUSaddu, NULL }  ,  { &&adduPLUSaddu, NULL }  ,  { &&adduPLUSadduPLUSaddiu, NULL }  ,  { &&adduPLUSaddu, NULL }  ,  { &&adduPLUSaddu, NULL }  ,  { &&adduPLUSaddu, NULL }  ,  { &&adduPLUSaddu, NULL }  ,  { &&adduPLUSaddu, NULL }  ,  { &&adduPLUSaddu, NULL }  ,  { &&adduPLUSaddu, NULL } 
 ,  { &&adduPLUSaddu, NULL }  ,  { &&adduPLUSaddu, NULL }  ,  { &&adduPLUSaddu, NULL }  ,  { &&adduPLUSaddu, NULL }  ,  { &&adduPLUSaddu, NULL }  ,  { &&adduPLUSaddu, NULL }  ,  { &&adduPLUSaddu, NULL }  ,  { &&adduPLUSaddu, NULL }  ,  { &&adduPLUSaddu, NULL }  ,  { &&adduPLUSaddu, NULL } 
 ,  { &&adduPLUSaddu, NULL }  ,  { &&adduPLUSaddu, NULL }  ,  { &&adduPLUSaddu, NULL }  ,  { &&adduPLUSaddu, NULL }  ,  { &&adduPLUSaddu, NULL }  ,  { &&adduPLUSaddu, NULL }  ,  { &&adduPLUSaddu, NULL }  ,  { &&adduPLUSaddu, NULL }  ,  { &&adduPLUSadduPLUSlw, NULL }  ,  { &&adduPLUSaddu, NULL } 
 ,  { &&adduPLUSaddu, NULL }  ,  { &&adduPLUSaddu, NULL }  ,  { &&adduPLUSaddu, NULL }  ,  { &&adduPLUSaddu, NULL }  ,  { &&adduPLUSaddu, NULL }  ,  { &&adduPLUSaddu, NULL }  ,  { &&adduPLUSadduPLUSsw, NULL }  ,  { &&adduPLUSaddu, NULL }  ,  { &&adduPLUSaddu, NULL }  ,  { &&adduPLUSaddu, NULL } 
 ,  { &&adduPLUSaddu, NULL }  ,  { &&adduPLUSaddu, NULL }  ,  { &&adduPLUSaddu, NULL }  ,  { &&adduPLUSaddu, NULL }  ,  { &&adduPLUSaddu, NULL }  ,  { &&adduPLUSaddu, NULL }  ,  { &&adduPLUSaddu, NULL }  ,  { &&adduPLUSaddu, NULL }  ,  { &&adduPLUSaddu, NULL }  ,  { &&adduPLUSaddu, NULL } 
 ,  { &&adduPLUSaddu, NULL }  ,  { &&adduPLUSaddu, NULL }  ,  { &&adduPLUSaddu, NULL }  ,  { &&adduPLUSaddu, NULL }  ,  { &&adduPLUSaddu, NULL }  ,  { &&adduPLUSaddu, NULL }  ,  { &&adduPLUSaddu, NULL }  ,  { &&adduPLUSaddu, NULL }  ,  { &&adduPLUSaddu, NULL }  ,  { &&adduPLUSaddu, NULL } 
 }; 

struct pointer arraymovnPLUSandi[T_SIZE] = {  { &&movnPLUSandi, NULL }  ,  { &&movnPLUSandi, NULL }  ,  { &&movnPLUSandi, NULL }  ,  { &&movnPLUSandi, NULL }  ,  { &&movnPLUSandi, NULL }  ,  { &&movnPLUSandi, NULL }  ,  { &&movnPLUSandi, NULL }  ,  { &&movnPLUSandi, NULL }  ,  { &&movnPLUSandi, NULL }  ,  { &&movnPLUSandi, NULL } 
 ,  { &&movnPLUSandi, NULL }  ,  { &&movnPLUSandi, NULL }  ,  { &&movnPLUSandi, NULL }  ,  { &&movnPLUSandi, NULL }  ,  { &&movnPLUSandi, NULL }  ,  { &&movnPLUSandi, NULL }  ,  { &&movnPLUSandi, NULL }  ,  { &&movnPLUSandi, NULL }  ,  { &&movnPLUSandi, NULL }  ,  { &&movnPLUSandi, NULL } 
 ,  { &&movnPLUSandi, NULL }  ,  { &&movnPLUSandi, NULL }  ,  { &&movnPLUSandi, NULL }  ,  { &&movnPLUSandi, NULL }  ,  { &&movnPLUSandi, NULL }  ,  { &&movnPLUSandi, NULL }  ,  { &&movnPLUSandi, NULL }  ,  { &&movnPLUSandi, NULL }  ,  { &&movnPLUSandi, NULL }  ,  { &&movnPLUSandi, NULL } 
 ,  { &&movnPLUSandi, NULL }  ,  { &&movnPLUSandi, NULL }  ,  { &&movnPLUSandi, NULL }  ,  { &&movnPLUSandi, NULL }  ,  { &&movnPLUSandi, NULL }  ,  { &&movnPLUSandi, NULL }  ,  { &&movnPLUSandi, NULL }  ,  { &&movnPLUSandiPLUSor, NULL }  ,  { &&movnPLUSandi, NULL }  ,  { &&movnPLUSandi, NULL } 
 ,  { &&movnPLUSandi, NULL }  ,  { &&movnPLUSandi, NULL }  ,  { &&movnPLUSandi, NULL }  ,  { &&movnPLUSandi, NULL }  ,  { &&movnPLUSandi, NULL }  ,  { &&movnPLUSandi, NULL }  ,  { &&movnPLUSandi, NULL }  ,  { &&movnPLUSandi, NULL }  ,  { &&movnPLUSandi, NULL }  ,  { &&movnPLUSandi, NULL } 
 ,  { &&movnPLUSandi, NULL }  ,  { &&movnPLUSandi, NULL }  ,  { &&movnPLUSandi, NULL }  ,  { &&movnPLUSandi, NULL }  ,  { &&movnPLUSandi, NULL }  ,  { &&movnPLUSandi, NULL }  ,  { &&movnPLUSandi, NULL }  ,  { &&movnPLUSandi, NULL }  ,  { &&movnPLUSandi, NULL }  ,  { &&movnPLUSandi, NULL } 
 ,  { &&movnPLUSandi, NULL }  ,  { &&movnPLUSandi, NULL }  ,  { &&movnPLUSandi, NULL }  ,  { &&movnPLUSandi, NULL }  ,  { &&movnPLUSandi, NULL }  ,  { &&movnPLUSandi, NULL }  ,  { &&movnPLUSandi, NULL }  ,  { &&movnPLUSandi, NULL }  ,  { &&movnPLUSandi, NULL }  ,  { &&movnPLUSandi, NULL } 
 ,  { &&movnPLUSandi, NULL }  ,  { &&movnPLUSandi, NULL }  ,  { &&movnPLUSandi, NULL }  ,  { &&movnPLUSandi, NULL }  ,  { &&movnPLUSandi, NULL }  ,  { &&movnPLUSandi, NULL }  ,  { &&movnPLUSandi, NULL }  ,  { &&movnPLUSandi, NULL }  ,  { &&movnPLUSandi, NULL }  ,  { &&movnPLUSandi, NULL } 
 ,  { &&movnPLUSandi, NULL }  ,  { &&movnPLUSandi, NULL }  ,  { &&movnPLUSandi, NULL }  ,  { &&movnPLUSandi, NULL }  ,  { &&movnPLUSandi, NULL }  ,  { &&movnPLUSandi, NULL }  ,  { &&movnPLUSandi, NULL }  ,  { &&movnPLUSandi, NULL }  ,  { &&movnPLUSandi, NULL }  ,  { &&movnPLUSandi, NULL } 
 ,  { &&movnPLUSandi, NULL }  ,  { &&movnPLUSandi, NULL }  ,  { &&movnPLUSandi, NULL }  ,  { &&movnPLUSandi, NULL }  ,  { &&movnPLUSandi, NULL }  ,  { &&movnPLUSandi, NULL }  ,  { &&movnPLUSandi, NULL }  ,  { &&movnPLUSandi, NULL }  ,  { &&movnPLUSandi, NULL }  ,  { &&movnPLUSandi, NULL } 
 ,  { &&movnPLUSandi, NULL }  ,  { &&movnPLUSandi, NULL }  ,  { &&movnPLUSandi, NULL }  ,  { &&movnPLUSandi, NULL }  ,  { &&movnPLUSandi, NULL }  ,  { &&movnPLUSandi, NULL }  ,  { &&movnPLUSandi, NULL }  ,  { &&movnPLUSandi, NULL }  ,  { &&movnPLUSandi, NULL }  ,  { &&movnPLUSandi, NULL } 
 }; 

struct pointer arrayxorPLUSsrl[T_SIZE] = {  { &&xorPLUSsrlPLUSsll, NULL }  ,  { &&xorPLUSsrlPLUSerror, NULL }  ,  { &&xorPLUSsrl, NULL }  ,  { &&xorPLUSsrl, NULL }  ,  { &&xorPLUSsrl, NULL }  ,  { &&xorPLUSsrlPLUSerror, NULL }  ,  { &&xorPLUSsrl, NULL }  ,  { &&xorPLUSsrl, NULL }  ,  { &&xorPLUSsrl, NULL }  ,  { &&xorPLUSsrl, NULL } 
 ,  { &&xorPLUSsrl, NULL }  ,  { &&xorPLUSsrl, NULL }  ,  { &&xorPLUSsrl, NULL }  ,  { &&xorPLUSsrlPLUSerror, NULL }  ,  { &&xorPLUSsrlPLUSerror, NULL }  ,  { &&xorPLUSsrlPLUSerror, NULL }  ,  { &&xorPLUSsrl, NULL }  ,  { &&xorPLUSsrl, NULL }  ,  { &&xorPLUSsrl, NULL }  ,  { &&xorPLUSsrl, NULL } 
 ,  { &&xorPLUSsrlPLUSerror, NULL }  ,  { &&xorPLUSsrlPLUSerror, NULL }  ,  { &&xorPLUSsrlPLUSerror, NULL }  ,  { &&xorPLUSsrlPLUSerror, NULL }  ,  { &&xorPLUSsrl, NULL }  ,  { &&xorPLUSsrl, NULL }  ,  { &&xorPLUSsrl, NULL }  ,  { &&xorPLUSsrl, NULL }  ,  { &&xorPLUSsrlPLUSerror, NULL }  ,  { &&xorPLUSsrlPLUSerror, NULL } 
 ,  { &&xorPLUSsrlPLUSerror, NULL }  ,  { &&xorPLUSsrlPLUSerror, NULL }  ,  { &&xorPLUSsrl, NULL }  ,  { &&xorPLUSsrl, NULL }  ,  { &&xorPLUSsrl, NULL }  ,  { &&xorPLUSsrl, NULL }  ,  { &&xorPLUSsrl, NULL }  ,  { &&xorPLUSsrl, NULL }  ,  { &&xorPLUSsrlPLUSxor, NULL }  ,  { &&xorPLUSsrl, NULL } 
 ,  { &&xorPLUSsrlPLUSerror, NULL }  ,  { &&xorPLUSsrlPLUSerror, NULL }  ,  { &&xorPLUSsrl, NULL }  ,  { &&xorPLUSsrl, NULL }  ,  { &&xorPLUSsrl, NULL }  ,  { &&xorPLUSsrl, NULL }  ,  { &&xorPLUSsrl, NULL }  ,  { &&xorPLUSsrl, NULL }  ,  { &&xorPLUSsrl, NULL }  ,  { &&xorPLUSsrl, NULL } 
 ,  { &&xorPLUSsrl, NULL }  ,  { &&xorPLUSsrl, NULL }  ,  { &&xorPLUSsrl, NULL }  ,  { &&xorPLUSsrl, NULL }  ,  { &&xorPLUSsrl, NULL }  ,  { &&xorPLUSsrl, NULL }  ,  { &&xorPLUSsrl, NULL }  ,  { &&xorPLUSsrl, NULL }  ,  { &&xorPLUSsrl, NULL }  ,  { &&xorPLUSsrlPLUSerror, NULL } 
 ,  { &&xorPLUSsrlPLUSerror, NULL }  ,  { &&xorPLUSsrlPLUSerror, NULL }  ,  { &&xorPLUSsrlPLUSerror, NULL }  ,  { &&xorPLUSsrlPLUSerror, NULL }  ,  { &&xorPLUSsrlPLUSerror, NULL }  ,  { &&xorPLUSsrlPLUSerror, NULL }  ,  { &&xorPLUSsrlPLUSerror, NULL }  ,  { &&xorPLUSsrl, NULL }  ,  { &&xorPLUSsrl, NULL }  ,  { &&xorPLUSsrl, NULL } 
 ,  { &&xorPLUSsrlPLUSerror, NULL }  ,  { &&xorPLUSsrlPLUSerror, NULL }  ,  { &&xorPLUSsrlPLUSerror, NULL }  ,  { &&xorPLUSsrlPLUSerror, NULL }  ,  { &&xorPLUSsrlPLUSerror, NULL }  ,  { &&xorPLUSsrl, NULL }  ,  { &&xorPLUSsrl, NULL }  ,  { &&xorPLUSsrl, NULL }  ,  { &&xorPLUSsrl, NULL }  ,  { &&xorPLUSsrl, NULL } 
 ,  { &&xorPLUSsrl, NULL }  ,  { &&xorPLUSsrl, NULL }  ,  { &&xorPLUSsrlPLUSerror, NULL }  ,  { &&xorPLUSsrl, NULL }  ,  { &&xorPLUSsrl, NULL }  ,  { &&xorPLUSsrl, NULL }  ,  { &&xorPLUSsrl, NULL }  ,  { &&xorPLUSsrlPLUSerror, NULL }  ,  { &&xorPLUSsrlPLUSerror, NULL }  ,  { &&xorPLUSsrl, NULL } 
 ,  { &&xorPLUSsrlPLUSerror, NULL }  ,  { &&xorPLUSsrlPLUSerror, NULL }  ,  { &&xorPLUSsrlPLUSerror, NULL }  ,  { &&xorPLUSsrlPLUSerror, NULL }  ,  { &&xorPLUSsrlPLUSerror, NULL }  ,  { &&xorPLUSsrlPLUSerror, NULL }  ,  { &&xorPLUSsrlPLUSerror, NULL }  ,  { &&xorPLUSsrlPLUSerror, NULL }  ,  { &&xorPLUSsrlPLUSerror, NULL }  ,  { &&xorPLUSsrlPLUSerror, NULL } 
 ,  { &&xorPLUSsrlPLUSerror, NULL }  ,  { &&xorPLUSsrlPLUSerror, NULL }  ,  { &&xorPLUSsrlPLUSerror, NULL }  ,  { &&xorPLUSsrlPLUSerror, NULL }  ,  { &&xorPLUSsrlPLUSerror, NULL }  ,  { &&xorPLUSsrlPLUSerror, NULL }  ,  { &&xorPLUSsrlPLUSerror, NULL }  ,  { &&xorPLUSsrlPLUSerror, NULL }  ,  { &&xorPLUSsrlPLUSerror, NULL }  ,  { &&xorPLUSsrlPLUSerror, NULL } 
 }; 

struct pointer arraysllPLUSlw[T_SIZE] = {  { &&sllPLUSlw, NULL }  ,  { &&sllPLUSlw, NULL }  ,  { &&sllPLUSlw, NULL }  ,  { &&sllPLUSlw, NULL }  ,  { &&sllPLUSlw, NULL }  ,  { &&sllPLUSlw, NULL }  ,  { &&sllPLUSlw, NULL }  ,  { &&sllPLUSlw, NULL }  ,  { &&sllPLUSlw, NULL }  ,  { &&sllPLUSlw, NULL } 
 ,  { &&sllPLUSlw, NULL }  ,  { &&sllPLUSlw, NULL }  ,  { &&sllPLUSlw, NULL }  ,  { &&sllPLUSlw, NULL }  ,  { &&sllPLUSlw, NULL }  ,  { &&sllPLUSlw, NULL }  ,  { &&sllPLUSlw, NULL }  ,  { &&sllPLUSlw, NULL }  ,  { &&sllPLUSlw, NULL }  ,  { &&sllPLUSlw, NULL } 
 ,  { &&sllPLUSlw, NULL }  ,  { &&sllPLUSlw, NULL }  ,  { &&sllPLUSlw, NULL }  ,  { &&sllPLUSlw, NULL }  ,  { &&sllPLUSlw, NULL }  ,  { &&sllPLUSlw, NULL }  ,  { &&sllPLUSlw, NULL }  ,  { &&sllPLUSlw, NULL }  ,  { &&sllPLUSlw, NULL }  ,  { &&sllPLUSlw, NULL } 
 ,  { &&sllPLUSlw, NULL }  ,  { &&sllPLUSlw, NULL }  ,  { &&sllPLUSlw, NULL }  ,  { &&sllPLUSlwPLUSaddu, NULL }  ,  { &&sllPLUSlw, NULL }  ,  { &&sllPLUSlw, NULL }  ,  { &&sllPLUSlw, NULL }  ,  { &&sllPLUSlw, NULL }  ,  { &&sllPLUSlwPLUSxor, NULL }  ,  { &&sllPLUSlw, NULL } 
 ,  { &&sllPLUSlw, NULL }  ,  { &&sllPLUSlw, NULL }  ,  { &&sllPLUSlw, NULL }  ,  { &&sllPLUSlw, NULL }  ,  { &&sllPLUSlw, NULL }  ,  { &&sllPLUSlw, NULL }  ,  { &&sllPLUSlw, NULL }  ,  { &&sllPLUSlwPLUSbeq, NULL }  ,  { &&sllPLUSlw, NULL }  ,  { &&sllPLUSlw, NULL } 
 ,  { &&sllPLUSlw, NULL }  ,  { &&sllPLUSlw, NULL }  ,  { &&sllPLUSlwPLUSaddiu, NULL }  ,  { &&sllPLUSlwPLUSslti, NULL }  ,  { &&sllPLUSlw, NULL }  ,  { &&sllPLUSlw, NULL }  ,  { &&sllPLUSlw, NULL }  ,  { &&sllPLUSlw, NULL }  ,  { &&sllPLUSlw, NULL }  ,  { &&sllPLUSlw, NULL } 
 ,  { &&sllPLUSlw, NULL }  ,  { &&sllPLUSlw, NULL }  ,  { &&sllPLUSlw, NULL }  ,  { &&sllPLUSlw, NULL }  ,  { &&sllPLUSlw, NULL }  ,  { &&sllPLUSlw, NULL }  ,  { &&sllPLUSlw, NULL }  ,  { &&sllPLUSlw, NULL }  ,  { &&sllPLUSlw, NULL }  ,  { &&sllPLUSlw, NULL } 
 ,  { &&sllPLUSlw, NULL }  ,  { &&sllPLUSlw, NULL }  ,  { &&sllPLUSlw, NULL }  ,  { &&sllPLUSlw, NULL }  ,  { &&sllPLUSlw, NULL }  ,  { &&sllPLUSlw, NULL }  ,  { &&sllPLUSlw, NULL }  ,  { &&sllPLUSlw, NULL }  ,  { &&sllPLUSlwPLUSlw, NULL }  ,  { &&sllPLUSlw, NULL } 
 ,  { &&sllPLUSlw, NULL }  ,  { &&sllPLUSlw, NULL }  ,  { &&sllPLUSlw, NULL }  ,  { &&sllPLUSlw, NULL }  ,  { &&sllPLUSlw, NULL }  ,  { &&sllPLUSlw, NULL }  ,  { &&sllPLUSlwPLUSsw, NULL }  ,  { &&sllPLUSlw, NULL }  ,  { &&sllPLUSlw, NULL }  ,  { &&sllPLUSlw, NULL } 
 ,  { &&sllPLUSlw, NULL }  ,  { &&sllPLUSlw, NULL }  ,  { &&sllPLUSlw, NULL }  ,  { &&sllPLUSlw, NULL }  ,  { &&sllPLUSlw, NULL }  ,  { &&sllPLUSlw, NULL }  ,  { &&sllPLUSlw, NULL }  ,  { &&sllPLUSlw, NULL }  ,  { &&sllPLUSlw, NULL }  ,  { &&sllPLUSlw, NULL } 
 ,  { &&sllPLUSlw, NULL }  ,  { &&sllPLUSlw, NULL }  ,  { &&sllPLUSlw, NULL }  ,  { &&sllPLUSlw, NULL }  ,  { &&sllPLUSlw, NULL }  ,  { &&sllPLUSlw, NULL }  ,  { &&sllPLUSlw, NULL }  ,  { &&sllPLUSlw, NULL }  ,  { &&sllPLUSlw, NULL }  ,  { &&sllPLUSlw, NULL } 
 }; 

struct pointer arrayadduPLUSlw[T_SIZE] = {  { &&adduPLUSlwPLUSsll, NULL }  ,  { &&adduPLUSlw, NULL }  ,  { &&adduPLUSlw, NULL }  ,  { &&adduPLUSlw, NULL }  ,  { &&adduPLUSlw, NULL }  ,  { &&adduPLUSlw, NULL }  ,  { &&adduPLUSlw, NULL }  ,  { &&adduPLUSlw, NULL }  ,  { &&adduPLUSlw, NULL }  ,  { &&adduPLUSlw, NULL } 
 ,  { &&adduPLUSlw, NULL }  ,  { &&adduPLUSlw, NULL }  ,  { &&adduPLUSlw, NULL }  ,  { &&adduPLUSlw, NULL }  ,  { &&adduPLUSlw, NULL }  ,  { &&adduPLUSlw, NULL }  ,  { &&adduPLUSlw, NULL }  ,  { &&adduPLUSlw, NULL }  ,  { &&adduPLUSlw, NULL }  ,  { &&adduPLUSlw, NULL } 
 ,  { &&adduPLUSlw, NULL }  ,  { &&adduPLUSlw, NULL }  ,  { &&adduPLUSlw, NULL }  ,  { &&adduPLUSlw, NULL }  ,  { &&adduPLUSlw, NULL }  ,  { &&adduPLUSlw, NULL }  ,  { &&adduPLUSlw, NULL }  ,  { &&adduPLUSlw, NULL }  ,  { &&adduPLUSlw, NULL }  ,  { &&adduPLUSlw, NULL } 
 ,  { &&adduPLUSlw, NULL }  ,  { &&adduPLUSlw, NULL }  ,  { &&adduPLUSlw, NULL }  ,  { &&adduPLUSlwPLUSaddu, NULL }  ,  { &&adduPLUSlw, NULL }  ,  { &&adduPLUSlw, NULL }  ,  { &&adduPLUSlw, NULL }  ,  { &&adduPLUSlw, NULL }  ,  { &&adduPLUSlw, NULL }  ,  { &&adduPLUSlw, NULL } 
 ,  { &&adduPLUSlw, NULL }  ,  { &&adduPLUSlw, NULL }  ,  { &&adduPLUSlwPLUSslt, NULL }  ,  { &&adduPLUSlwPLUSsltu, NULL }  ,  { &&adduPLUSlw, NULL }  ,  { &&adduPLUSlwPLUSjump, NULL }  ,  { &&adduPLUSlwPLUSjal, NULL }  ,  { &&adduPLUSlwPLUSbeq, NULL }  ,  { &&adduPLUSlw, NULL }  ,  { &&adduPLUSlwPLUSblez, NULL } 
 ,  { &&adduPLUSlwPLUSbgtz, NULL }  ,  { &&adduPLUSlw, NULL }  ,  { &&adduPLUSlwPLUSaddiu, NULL }  ,  { &&adduPLUSlw, NULL }  ,  { &&adduPLUSlw, NULL }  ,  { &&adduPLUSlw, NULL }  ,  { &&adduPLUSlwPLUSori, NULL }  ,  { &&adduPLUSlw, NULL }  ,  { &&adduPLUSlw, NULL }  ,  { &&adduPLUSlw, NULL } 
 ,  { &&adduPLUSlw, NULL }  ,  { &&adduPLUSlw, NULL }  ,  { &&adduPLUSlw, NULL }  ,  { &&adduPLUSlw, NULL }  ,  { &&adduPLUSlw, NULL }  ,  { &&adduPLUSlw, NULL }  ,  { &&adduPLUSlw, NULL }  ,  { &&adduPLUSlw, NULL }  ,  { &&adduPLUSlw, NULL }  ,  { &&adduPLUSlw, NULL } 
 ,  { &&adduPLUSlw, NULL }  ,  { &&adduPLUSlw, NULL }  ,  { &&adduPLUSlw, NULL }  ,  { &&adduPLUSlw, NULL }  ,  { &&adduPLUSlw, NULL }  ,  { &&adduPLUSlw, NULL }  ,  { &&adduPLUSlw, NULL }  ,  { &&adduPLUSlw, NULL }  ,  { &&adduPLUSlwPLUSlw, NULL }  ,  { &&adduPLUSlwPLUSlbu, NULL } 
 ,  { &&adduPLUSlw, NULL }  ,  { &&adduPLUSlw, NULL }  ,  { &&adduPLUSlw, NULL }  ,  { &&adduPLUSlw, NULL }  ,  { &&adduPLUSlw, NULL }  ,  { &&adduPLUSlw, NULL }  ,  { &&adduPLUSlwPLUSsw, NULL }  ,  { &&adduPLUSlw, NULL }  ,  { &&adduPLUSlw, NULL }  ,  { &&adduPLUSlw, NULL } 
 ,  { &&adduPLUSlw, NULL }  ,  { &&adduPLUSlw, NULL }  ,  { &&adduPLUSlw, NULL }  ,  { &&adduPLUSlw, NULL }  ,  { &&adduPLUSlw, NULL }  ,  { &&adduPLUSlw, NULL }  ,  { &&adduPLUSlw, NULL }  ,  { &&adduPLUSlw, NULL }  ,  { &&adduPLUSlw, NULL }  ,  { &&adduPLUSlw, NULL } 
 ,  { &&adduPLUSlw, NULL }  ,  { &&adduPLUSlw, NULL }  ,  { &&adduPLUSlw, NULL }  ,  { &&adduPLUSlw, NULL }  ,  { &&adduPLUSlw, NULL }  ,  { &&adduPLUSlw, NULL }  ,  { &&adduPLUSlw, NULL }  ,  { &&adduPLUSlw, NULL }  ,  { &&adduPLUSlw, NULL }  ,  { &&adduPLUSlw, NULL } 
 }; 

struct pointer arraysrlPLUSsra[T_SIZE] = {  { &&srlPLUSsra, NULL }  ,  { &&srlPLUSsra, NULL }  ,  { &&srlPLUSsra, NULL }  ,  { &&srlPLUSsra, NULL }  ,  { &&srlPLUSsra, NULL }  ,  { &&srlPLUSsra, NULL }  ,  { &&srlPLUSsra, NULL }  ,  { &&srlPLUSsra, NULL }  ,  { &&srlPLUSsra, NULL }  ,  { &&srlPLUSsra, NULL } 
 ,  { &&srlPLUSsra, NULL }  ,  { &&srlPLUSsra, NULL }  ,  { &&srlPLUSsra, NULL }  ,  { &&srlPLUSsra, NULL }  ,  { &&srlPLUSsra, NULL }  ,  { &&srlPLUSsra, NULL }  ,  { &&srlPLUSsra, NULL }  ,  { &&srlPLUSsra, NULL }  ,  { &&srlPLUSsra, NULL }  ,  { &&srlPLUSsra, NULL } 
 ,  { &&srlPLUSsra, NULL }  ,  { &&srlPLUSsra, NULL }  ,  { &&srlPLUSsra, NULL }  ,  { &&srlPLUSsra, NULL }  ,  { &&srlPLUSsra, NULL }  ,  { &&srlPLUSsra, NULL }  ,  { &&srlPLUSsra, NULL }  ,  { &&srlPLUSsra, NULL }  ,  { &&srlPLUSsra, NULL }  ,  { &&srlPLUSsra, NULL } 
 ,  { &&srlPLUSsra, NULL }  ,  { &&srlPLUSsra, NULL }  ,  { &&srlPLUSsra, NULL }  ,  { &&srlPLUSsraPLUSaddu, NULL }  ,  { &&srlPLUSsra, NULL }  ,  { &&srlPLUSsra, NULL }  ,  { &&srlPLUSsra, NULL }  ,  { &&srlPLUSsra, NULL }  ,  { &&srlPLUSsra, NULL }  ,  { &&srlPLUSsra, NULL } 
 ,  { &&srlPLUSsra, NULL }  ,  { &&srlPLUSsra, NULL }  ,  { &&srlPLUSsra, NULL }  ,  { &&srlPLUSsra, NULL }  ,  { &&srlPLUSsra, NULL }  ,  { &&srlPLUSsra, NULL }  ,  { &&srlPLUSsra, NULL }  ,  { &&srlPLUSsra, NULL }  ,  { &&srlPLUSsra, NULL }  ,  { &&srlPLUSsra, NULL } 
 ,  { &&srlPLUSsra, NULL }  ,  { &&srlPLUSsra, NULL }  ,  { &&srlPLUSsra, NULL }  ,  { &&srlPLUSsra, NULL }  ,  { &&srlPLUSsra, NULL }  ,  { &&srlPLUSsra, NULL }  ,  { &&srlPLUSsra, NULL }  ,  { &&srlPLUSsra, NULL }  ,  { &&srlPLUSsra, NULL }  ,  { &&srlPLUSsra, NULL } 
 ,  { &&srlPLUSsra, NULL }  ,  { &&srlPLUSsra, NULL }  ,  { &&srlPLUSsra, NULL }  ,  { &&srlPLUSsra, NULL }  ,  { &&srlPLUSsra, NULL }  ,  { &&srlPLUSsra, NULL }  ,  { &&srlPLUSsra, NULL }  ,  { &&srlPLUSsra, NULL }  ,  { &&srlPLUSsra, NULL }  ,  { &&srlPLUSsra, NULL } 
 ,  { &&srlPLUSsra, NULL }  ,  { &&srlPLUSsra, NULL }  ,  { &&srlPLUSsra, NULL }  ,  { &&srlPLUSsra, NULL }  ,  { &&srlPLUSsra, NULL }  ,  { &&srlPLUSsra, NULL }  ,  { &&srlPLUSsra, NULL }  ,  { &&srlPLUSsra, NULL }  ,  { &&srlPLUSsra, NULL }  ,  { &&srlPLUSsra, NULL } 
 ,  { &&srlPLUSsra, NULL }  ,  { &&srlPLUSsra, NULL }  ,  { &&srlPLUSsra, NULL }  ,  { &&srlPLUSsra, NULL }  ,  { &&srlPLUSsra, NULL }  ,  { &&srlPLUSsra, NULL }  ,  { &&srlPLUSsra, NULL }  ,  { &&srlPLUSsra, NULL }  ,  { &&srlPLUSsra, NULL }  ,  { &&srlPLUSsra, NULL } 
 ,  { &&srlPLUSsra, NULL }  ,  { &&srlPLUSsra, NULL }  ,  { &&srlPLUSsra, NULL }  ,  { &&srlPLUSsra, NULL }  ,  { &&srlPLUSsra, NULL }  ,  { &&srlPLUSsra, NULL }  ,  { &&srlPLUSsra, NULL }  ,  { &&srlPLUSsra, NULL }  ,  { &&srlPLUSsra, NULL }  ,  { &&srlPLUSsra, NULL } 
 ,  { &&srlPLUSsra, NULL }  ,  { &&srlPLUSsra, NULL }  ,  { &&srlPLUSsra, NULL }  ,  { &&srlPLUSsra, NULL }  ,  { &&srlPLUSsra, NULL }  ,  { &&srlPLUSsra, NULL }  ,  { &&srlPLUSsra, NULL }  ,  { &&srlPLUSsra, NULL }  ,  { &&srlPLUSsra, NULL }  ,  { &&srlPLUSsra, NULL } 
 }; 

struct pointer arrayadduPLUSslti[T_SIZE] = {  { &&adduPLUSslti, NULL }  ,  { &&adduPLUSslti, NULL }  ,  { &&adduPLUSslti, NULL }  ,  { &&adduPLUSslti, NULL }  ,  { &&adduPLUSslti, NULL }  ,  { &&adduPLUSslti, NULL }  ,  { &&adduPLUSslti, NULL }  ,  { &&adduPLUSslti, NULL }  ,  { &&adduPLUSslti, NULL }  ,  { &&adduPLUSslti, NULL } 
 ,  { &&adduPLUSslti, NULL }  ,  { &&adduPLUSslti, NULL }  ,  { &&adduPLUSslti, NULL }  ,  { &&adduPLUSslti, NULL }  ,  { &&adduPLUSslti, NULL }  ,  { &&adduPLUSslti, NULL }  ,  { &&adduPLUSslti, NULL }  ,  { &&adduPLUSslti, NULL }  ,  { &&adduPLUSslti, NULL }  ,  { &&adduPLUSslti, NULL } 
 ,  { &&adduPLUSslti, NULL }  ,  { &&adduPLUSslti, NULL }  ,  { &&adduPLUSslti, NULL }  ,  { &&adduPLUSslti, NULL }  ,  { &&adduPLUSslti, NULL }  ,  { &&adduPLUSslti, NULL }  ,  { &&adduPLUSslti, NULL }  ,  { &&adduPLUSslti, NULL }  ,  { &&adduPLUSslti, NULL }  ,  { &&adduPLUSslti, NULL } 
 ,  { &&adduPLUSslti, NULL }  ,  { &&adduPLUSslti, NULL }  ,  { &&adduPLUSslti, NULL }  ,  { &&adduPLUSslti, NULL }  ,  { &&adduPLUSslti, NULL }  ,  { &&adduPLUSslti, NULL }  ,  { &&adduPLUSslti, NULL }  ,  { &&adduPLUSslti, NULL }  ,  { &&adduPLUSslti, NULL }  ,  { &&adduPLUSslti, NULL } 
 ,  { &&adduPLUSslti, NULL }  ,  { &&adduPLUSslti, NULL }  ,  { &&adduPLUSslti, NULL }  ,  { &&adduPLUSslti, NULL }  ,  { &&adduPLUSslti, NULL }  ,  { &&adduPLUSslti, NULL }  ,  { &&adduPLUSslti, NULL }  ,  { &&adduPLUSsltiPLUSbeq, NULL }  ,  { &&adduPLUSslti, NULL }  ,  { &&adduPLUSslti, NULL } 
 ,  { &&adduPLUSslti, NULL }  ,  { &&adduPLUSslti, NULL }  ,  { &&adduPLUSslti, NULL }  ,  { &&adduPLUSslti, NULL }  ,  { &&adduPLUSslti, NULL }  ,  { &&adduPLUSslti, NULL }  ,  { &&adduPLUSslti, NULL }  ,  { &&adduPLUSslti, NULL }  ,  { &&adduPLUSslti, NULL }  ,  { &&adduPLUSslti, NULL } 
 ,  { &&adduPLUSslti, NULL }  ,  { &&adduPLUSslti, NULL }  ,  { &&adduPLUSslti, NULL }  ,  { &&adduPLUSslti, NULL }  ,  { &&adduPLUSslti, NULL }  ,  { &&adduPLUSslti, NULL }  ,  { &&adduPLUSslti, NULL }  ,  { &&adduPLUSslti, NULL }  ,  { &&adduPLUSslti, NULL }  ,  { &&adduPLUSslti, NULL } 
 ,  { &&adduPLUSslti, NULL }  ,  { &&adduPLUSslti, NULL }  ,  { &&adduPLUSslti, NULL }  ,  { &&adduPLUSslti, NULL }  ,  { &&adduPLUSslti, NULL }  ,  { &&adduPLUSslti, NULL }  ,  { &&adduPLUSslti, NULL }  ,  { &&adduPLUSslti, NULL }  ,  { &&adduPLUSslti, NULL }  ,  { &&adduPLUSslti, NULL } 
 ,  { &&adduPLUSslti, NULL }  ,  { &&adduPLUSslti, NULL }  ,  { &&adduPLUSslti, NULL }  ,  { &&adduPLUSslti, NULL }  ,  { &&adduPLUSslti, NULL }  ,  { &&adduPLUSslti, NULL }  ,  { &&adduPLUSsltiPLUSsw, NULL }  ,  { &&adduPLUSslti, NULL }  ,  { &&adduPLUSslti, NULL }  ,  { &&adduPLUSslti, NULL } 
 ,  { &&adduPLUSslti, NULL }  ,  { &&adduPLUSslti, NULL }  ,  { &&adduPLUSslti, NULL }  ,  { &&adduPLUSslti, NULL }  ,  { &&adduPLUSslti, NULL }  ,  { &&adduPLUSslti, NULL }  ,  { &&adduPLUSslti, NULL }  ,  { &&adduPLUSslti, NULL }  ,  { &&adduPLUSslti, NULL }  ,  { &&adduPLUSslti, NULL } 
 ,  { &&adduPLUSslti, NULL }  ,  { &&adduPLUSslti, NULL }  ,  { &&adduPLUSslti, NULL }  ,  { &&adduPLUSslti, NULL }  ,  { &&adduPLUSslti, NULL }  ,  { &&adduPLUSslti, NULL }  ,  { &&adduPLUSslti, NULL }  ,  { &&adduPLUSslti, NULL }  ,  { &&adduPLUSslti, NULL }  ,  { &&adduPLUSslti, NULL } 
 }; 

struct pointer arrayadduPLUSjump[T_SIZE] = {  { &&adduPLUSjumpPLUSsll, NULL }  ,  { &&adduPLUSjump, NULL }  ,  { &&adduPLUSjump, NULL }  ,  { &&adduPLUSjump, NULL }  ,  { &&adduPLUSjump, NULL }  ,  { &&adduPLUSjump, NULL }  ,  { &&adduPLUSjump, NULL }  ,  { &&adduPLUSjump, NULL }  ,  { &&adduPLUSjump, NULL }  ,  { &&adduPLUSjump, NULL } 
 ,  { &&adduPLUSjump, NULL }  ,  { &&adduPLUSjump, NULL }  ,  { &&adduPLUSjump, NULL }  ,  { &&adduPLUSjump, NULL }  ,  { &&adduPLUSjump, NULL }  ,  { &&adduPLUSjump, NULL }  ,  { &&adduPLUSjump, NULL }  ,  { &&adduPLUSjump, NULL }  ,  { &&adduPLUSjump, NULL }  ,  { &&adduPLUSjump, NULL } 
 ,  { &&adduPLUSjump, NULL }  ,  { &&adduPLUSjump, NULL }  ,  { &&adduPLUSjump, NULL }  ,  { &&adduPLUSjump, NULL }  ,  { &&adduPLUSjump, NULL }  ,  { &&adduPLUSjump, NULL }  ,  { &&adduPLUSjump, NULL }  ,  { &&adduPLUSjump, NULL }  ,  { &&adduPLUSjump, NULL }  ,  { &&adduPLUSjump, NULL } 
 ,  { &&adduPLUSjump, NULL }  ,  { &&adduPLUSjump, NULL }  ,  { &&adduPLUSjump, NULL }  ,  { &&adduPLUSjumpPLUSaddu, NULL }  ,  { &&adduPLUSjump, NULL }  ,  { &&adduPLUSjump, NULL }  ,  { &&adduPLUSjump, NULL }  ,  { &&adduPLUSjump, NULL }  ,  { &&adduPLUSjump, NULL }  ,  { &&adduPLUSjump, NULL } 
 ,  { &&adduPLUSjump, NULL }  ,  { &&adduPLUSjump, NULL }  ,  { &&adduPLUSjump, NULL }  ,  { &&adduPLUSjump, NULL }  ,  { &&adduPLUSjump, NULL }  ,  { &&adduPLUSjump, NULL }  ,  { &&adduPLUSjump, NULL }  ,  { &&adduPLUSjump, NULL }  ,  { &&adduPLUSjump, NULL }  ,  { &&adduPLUSjump, NULL } 
 ,  { &&adduPLUSjump, NULL }  ,  { &&adduPLUSjump, NULL }  ,  { &&adduPLUSjump, NULL }  ,  { &&adduPLUSjump, NULL }  ,  { &&adduPLUSjump, NULL }  ,  { &&adduPLUSjump, NULL }  ,  { &&adduPLUSjump, NULL }  ,  { &&adduPLUSjump, NULL }  ,  { &&adduPLUSjump, NULL }  ,  { &&adduPLUSjump, NULL } 
 ,  { &&adduPLUSjump, NULL }  ,  { &&adduPLUSjump, NULL }  ,  { &&adduPLUSjump, NULL }  ,  { &&adduPLUSjump, NULL }  ,  { &&adduPLUSjump, NULL }  ,  { &&adduPLUSjump, NULL }  ,  { &&adduPLUSjump, NULL }  ,  { &&adduPLUSjump, NULL }  ,  { &&adduPLUSjump, NULL }  ,  { &&adduPLUSjump, NULL } 
 ,  { &&adduPLUSjump, NULL }  ,  { &&adduPLUSjump, NULL }  ,  { &&adduPLUSjump, NULL }  ,  { &&adduPLUSjump, NULL }  ,  { &&adduPLUSjump, NULL }  ,  { &&adduPLUSjump, NULL }  ,  { &&adduPLUSjump, NULL }  ,  { &&adduPLUSjump, NULL }  ,  { &&adduPLUSjump, NULL }  ,  { &&adduPLUSjump, NULL } 
 ,  { &&adduPLUSjump, NULL }  ,  { &&adduPLUSjump, NULL }  ,  { &&adduPLUSjump, NULL }  ,  { &&adduPLUSjump, NULL }  ,  { &&adduPLUSjump, NULL }  ,  { &&adduPLUSjump, NULL }  ,  { &&adduPLUSjump, NULL }  ,  { &&adduPLUSjump, NULL }  ,  { &&adduPLUSjump, NULL }  ,  { &&adduPLUSjump, NULL } 
 ,  { &&adduPLUSjump, NULL }  ,  { &&adduPLUSjump, NULL }  ,  { &&adduPLUSjump, NULL }  ,  { &&adduPLUSjump, NULL }  ,  { &&adduPLUSjump, NULL }  ,  { &&adduPLUSjump, NULL }  ,  { &&adduPLUSjump, NULL }  ,  { &&adduPLUSjump, NULL }  ,  { &&adduPLUSjump, NULL }  ,  { &&adduPLUSjump, NULL } 
 ,  { &&adduPLUSjump, NULL }  ,  { &&adduPLUSjump, NULL }  ,  { &&adduPLUSjump, NULL }  ,  { &&adduPLUSjump, NULL }  ,  { &&adduPLUSjump, NULL }  ,  { &&adduPLUSjump, NULL }  ,  { &&adduPLUSjump, NULL }  ,  { &&adduPLUSjump, NULL }  ,  { &&adduPLUSjump, NULL }  ,  { &&adduPLUSjump, NULL } 
 }; 

struct pointer arrayadduPLUSsubu[T_SIZE] = {  { &&adduPLUSsubu, NULL }  ,  { &&adduPLUSsubu, NULL }  ,  { &&adduPLUSsubu, NULL }  ,  { &&adduPLUSsubu, NULL }  ,  { &&adduPLUSsubu, NULL }  ,  { &&adduPLUSsubu, NULL }  ,  { &&adduPLUSsubu, NULL }  ,  { &&adduPLUSsubu, NULL }  ,  { &&adduPLUSsubu, NULL }  ,  { &&adduPLUSsubu, NULL } 
 ,  { &&adduPLUSsubu, NULL }  ,  { &&adduPLUSsubu, NULL }  ,  { &&adduPLUSsubu, NULL }  ,  { &&adduPLUSsubu, NULL }  ,  { &&adduPLUSsubu, NULL }  ,  { &&adduPLUSsubu, NULL }  ,  { &&adduPLUSsubu, NULL }  ,  { &&adduPLUSsubu, NULL }  ,  { &&adduPLUSsubu, NULL }  ,  { &&adduPLUSsubu, NULL } 
 ,  { &&adduPLUSsubu, NULL }  ,  { &&adduPLUSsubu, NULL }  ,  { &&adduPLUSsubu, NULL }  ,  { &&adduPLUSsubu, NULL }  ,  { &&adduPLUSsubu, NULL }  ,  { &&adduPLUSsubu, NULL }  ,  { &&adduPLUSsubu, NULL }  ,  { &&adduPLUSsubu, NULL }  ,  { &&adduPLUSsubu, NULL }  ,  { &&adduPLUSsubu, NULL } 
 ,  { &&adduPLUSsubu, NULL }  ,  { &&adduPLUSsubu, NULL }  ,  { &&adduPLUSsubu, NULL }  ,  { &&adduPLUSsubuPLUSaddu, NULL }  ,  { &&adduPLUSsubu, NULL }  ,  { &&adduPLUSsubu, NULL }  ,  { &&adduPLUSsubu, NULL }  ,  { &&adduPLUSsubu, NULL }  ,  { &&adduPLUSsubu, NULL }  ,  { &&adduPLUSsubu, NULL } 
 ,  { &&adduPLUSsubu, NULL }  ,  { &&adduPLUSsubu, NULL }  ,  { &&adduPLUSsubu, NULL }  ,  { &&adduPLUSsubu, NULL }  ,  { &&adduPLUSsubu, NULL }  ,  { &&adduPLUSsubu, NULL }  ,  { &&adduPLUSsubu, NULL }  ,  { &&adduPLUSsubu, NULL }  ,  { &&adduPLUSsubu, NULL }  ,  { &&adduPLUSsubu, NULL } 
 ,  { &&adduPLUSsubu, NULL }  ,  { &&adduPLUSsubu, NULL }  ,  { &&adduPLUSsubu, NULL }  ,  { &&adduPLUSsubu, NULL }  ,  { &&adduPLUSsubu, NULL }  ,  { &&adduPLUSsubu, NULL }  ,  { &&adduPLUSsubu, NULL }  ,  { &&adduPLUSsubu, NULL }  ,  { &&adduPLUSsubu, NULL }  ,  { &&adduPLUSsubu, NULL } 
 ,  { &&adduPLUSsubu, NULL }  ,  { &&adduPLUSsubu, NULL }  ,  { &&adduPLUSsubu, NULL }  ,  { &&adduPLUSsubu, NULL }  ,  { &&adduPLUSsubu, NULL }  ,  { &&adduPLUSsubu, NULL }  ,  { &&adduPLUSsubu, NULL }  ,  { &&adduPLUSsubu, NULL }  ,  { &&adduPLUSsubu, NULL }  ,  { &&adduPLUSsubu, NULL } 
 ,  { &&adduPLUSsubu, NULL }  ,  { &&adduPLUSsubu, NULL }  ,  { &&adduPLUSsubu, NULL }  ,  { &&adduPLUSsubu, NULL }  ,  { &&adduPLUSsubu, NULL }  ,  { &&adduPLUSsubu, NULL }  ,  { &&adduPLUSsubu, NULL }  ,  { &&adduPLUSsubu, NULL }  ,  { &&adduPLUSsubu, NULL }  ,  { &&adduPLUSsubu, NULL } 
 ,  { &&adduPLUSsubu, NULL }  ,  { &&adduPLUSsubu, NULL }  ,  { &&adduPLUSsubu, NULL }  ,  { &&adduPLUSsubu, NULL }  ,  { &&adduPLUSsubu, NULL }  ,  { &&adduPLUSsubu, NULL }  ,  { &&adduPLUSsubuPLUSsw, NULL }  ,  { &&adduPLUSsubu, NULL }  ,  { &&adduPLUSsubu, NULL }  ,  { &&adduPLUSsubu, NULL } 
 ,  { &&adduPLUSsubu, NULL }  ,  { &&adduPLUSsubu, NULL }  ,  { &&adduPLUSsubu, NULL }  ,  { &&adduPLUSsubu, NULL }  ,  { &&adduPLUSsubu, NULL }  ,  { &&adduPLUSsubu, NULL }  ,  { &&adduPLUSsubu, NULL }  ,  { &&adduPLUSsubu, NULL }  ,  { &&adduPLUSsubu, NULL }  ,  { &&adduPLUSsubu, NULL } 
 ,  { &&adduPLUSsubu, NULL }  ,  { &&adduPLUSsubu, NULL }  ,  { &&adduPLUSsubu, NULL }  ,  { &&adduPLUSsubu, NULL }  ,  { &&adduPLUSsubu, NULL }  ,  { &&adduPLUSsubu, NULL }  ,  { &&adduPLUSsubu, NULL }  ,  { &&adduPLUSsubu, NULL }  ,  { &&adduPLUSsubu, NULL }  ,  { &&adduPLUSsubu, NULL } 
 }; 

struct pointer arraysllPLUSaddiu[T_SIZE] = {  { &&sllPLUSaddiuPLUSsll, NULL }  ,  { &&sllPLUSaddiu, NULL }  ,  { &&sllPLUSaddiu, NULL }  ,  { &&sllPLUSaddiu, NULL }  ,  { &&sllPLUSaddiu, NULL }  ,  { &&sllPLUSaddiu, NULL }  ,  { &&sllPLUSaddiu, NULL }  ,  { &&sllPLUSaddiu, NULL }  ,  { &&sllPLUSaddiu, NULL }  ,  { &&sllPLUSaddiu, NULL } 
 ,  { &&sllPLUSaddiu, NULL }  ,  { &&sllPLUSaddiu, NULL }  ,  { &&sllPLUSaddiuPLUSsysc, NULL }  ,  { &&sllPLUSaddiu, NULL }  ,  { &&sllPLUSaddiu, NULL }  ,  { &&sllPLUSaddiu, NULL }  ,  { &&sllPLUSaddiu, NULL }  ,  { &&sllPLUSaddiu, NULL }  ,  { &&sllPLUSaddiu, NULL }  ,  { &&sllPLUSaddiu, NULL } 
 ,  { &&sllPLUSaddiu, NULL }  ,  { &&sllPLUSaddiu, NULL }  ,  { &&sllPLUSaddiu, NULL }  ,  { &&sllPLUSaddiu, NULL }  ,  { &&sllPLUSaddiu, NULL }  ,  { &&sllPLUSaddiu, NULL }  ,  { &&sllPLUSaddiu, NULL }  ,  { &&sllPLUSaddiu, NULL }  ,  { &&sllPLUSaddiu, NULL }  ,  { &&sllPLUSaddiu, NULL } 
 ,  { &&sllPLUSaddiu, NULL }  ,  { &&sllPLUSaddiu, NULL }  ,  { &&sllPLUSaddiu, NULL }  ,  { &&sllPLUSaddiu, NULL }  ,  { &&sllPLUSaddiu, NULL }  ,  { &&sllPLUSaddiu, NULL }  ,  { &&sllPLUSaddiu, NULL }  ,  { &&sllPLUSaddiu, NULL }  ,  { &&sllPLUSaddiu, NULL }  ,  { &&sllPLUSaddiu, NULL } 
 ,  { &&sllPLUSaddiu, NULL }  ,  { &&sllPLUSaddiu, NULL }  ,  { &&sllPLUSaddiu, NULL }  ,  { &&sllPLUSaddiu, NULL }  ,  { &&sllPLUSaddiu, NULL }  ,  { &&sllPLUSaddiu, NULL }  ,  { &&sllPLUSaddiu, NULL }  ,  { &&sllPLUSaddiu, NULL }  ,  { &&sllPLUSaddiuPLUSbne, NULL }  ,  { &&sllPLUSaddiuPLUSblez, NULL } 
 ,  { &&sllPLUSaddiu, NULL }  ,  { &&sllPLUSaddiu, NULL }  ,  { &&sllPLUSaddiuPLUSaddiu, NULL }  ,  { &&sllPLUSaddiuPLUSslti, NULL }  ,  { &&sllPLUSaddiu, NULL }  ,  { &&sllPLUSaddiu, NULL }  ,  { &&sllPLUSaddiu, NULL }  ,  { &&sllPLUSaddiu, NULL }  ,  { &&sllPLUSaddiuPLUSlui, NULL }  ,  { &&sllPLUSaddiu, NULL } 
 ,  { &&sllPLUSaddiu, NULL }  ,  { &&sllPLUSaddiu, NULL }  ,  { &&sllPLUSaddiu, NULL }  ,  { &&sllPLUSaddiu, NULL }  ,  { &&sllPLUSaddiu, NULL }  ,  { &&sllPLUSaddiu, NULL }  ,  { &&sllPLUSaddiu, NULL }  ,  { &&sllPLUSaddiu, NULL }  ,  { &&sllPLUSaddiu, NULL }  ,  { &&sllPLUSaddiu, NULL } 
 ,  { &&sllPLUSaddiu, NULL }  ,  { &&sllPLUSaddiu, NULL }  ,  { &&sllPLUSaddiu, NULL }  ,  { &&sllPLUSaddiu, NULL }  ,  { &&sllPLUSaddiu, NULL }  ,  { &&sllPLUSaddiu, NULL }  ,  { &&sllPLUSaddiu, NULL }  ,  { &&sllPLUSaddiu, NULL }  ,  { &&sllPLUSaddiuPLUSlw, NULL }  ,  { &&sllPLUSaddiu, NULL } 
 ,  { &&sllPLUSaddiu, NULL }  ,  { &&sllPLUSaddiu, NULL }  ,  { &&sllPLUSaddiu, NULL }  ,  { &&sllPLUSaddiu, NULL }  ,  { &&sllPLUSaddiu, NULL }  ,  { &&sllPLUSaddiu, NULL }  ,  { &&sllPLUSaddiuPLUSsw, NULL }  ,  { &&sllPLUSaddiu, NULL }  ,  { &&sllPLUSaddiu, NULL }  ,  { &&sllPLUSaddiu, NULL } 
 ,  { &&sllPLUSaddiu, NULL }  ,  { &&sllPLUSaddiu, NULL }  ,  { &&sllPLUSaddiu, NULL }  ,  { &&sllPLUSaddiu, NULL }  ,  { &&sllPLUSaddiu, NULL }  ,  { &&sllPLUSaddiu, NULL }  ,  { &&sllPLUSaddiu, NULL }  ,  { &&sllPLUSaddiu, NULL }  ,  { &&sllPLUSaddiu, NULL }  ,  { &&sllPLUSaddiu, NULL } 
 ,  { &&sllPLUSaddiu, NULL }  ,  { &&sllPLUSaddiu, NULL }  ,  { &&sllPLUSaddiu, NULL }  ,  { &&sllPLUSaddiu, NULL }  ,  { &&sllPLUSaddiu, NULL }  ,  { &&sllPLUSaddiu, NULL }  ,  { &&sllPLUSaddiu, NULL }  ,  { &&sllPLUSaddiu, NULL }  ,  { &&sllPLUSaddiu, NULL }  ,  { &&sllPLUSaddiu, NULL } 
 }; 

struct pointer arraymfhiPLUSsrl[T_SIZE] = {  { &&mfhiPLUSsrl, NULL }  ,  { &&mfhiPLUSsrl, NULL }  ,  { &&mfhiPLUSsrl, NULL }  ,  { &&mfhiPLUSsrl, NULL }  ,  { &&mfhiPLUSsrl, NULL }  ,  { &&mfhiPLUSsrl, NULL }  ,  { &&mfhiPLUSsrl, NULL }  ,  { &&mfhiPLUSsrl, NULL }  ,  { &&mfhiPLUSsrl, NULL }  ,  { &&mfhiPLUSsrl, NULL } 
 ,  { &&mfhiPLUSsrl, NULL }  ,  { &&mfhiPLUSsrl, NULL }  ,  { &&mfhiPLUSsrl, NULL }  ,  { &&mfhiPLUSsrl, NULL }  ,  { &&mfhiPLUSsrl, NULL }  ,  { &&mfhiPLUSsrl, NULL }  ,  { &&mfhiPLUSsrl, NULL }  ,  { &&mfhiPLUSsrl, NULL }  ,  { &&mfhiPLUSsrl, NULL }  ,  { &&mfhiPLUSsrl, NULL } 
 ,  { &&mfhiPLUSsrl, NULL }  ,  { &&mfhiPLUSsrl, NULL }  ,  { &&mfhiPLUSsrl, NULL }  ,  { &&mfhiPLUSsrl, NULL }  ,  { &&mfhiPLUSsrl, NULL }  ,  { &&mfhiPLUSsrl, NULL }  ,  { &&mfhiPLUSsrl, NULL }  ,  { &&mfhiPLUSsrl, NULL }  ,  { &&mfhiPLUSsrl, NULL }  ,  { &&mfhiPLUSsrl, NULL } 
 ,  { &&mfhiPLUSsrl, NULL }  ,  { &&mfhiPLUSsrl, NULL }  ,  { &&mfhiPLUSsrl, NULL }  ,  { &&mfhiPLUSsrlPLUSaddu, NULL }  ,  { &&mfhiPLUSsrl, NULL }  ,  { &&mfhiPLUSsrl, NULL }  ,  { &&mfhiPLUSsrl, NULL }  ,  { &&mfhiPLUSsrl, NULL }  ,  { &&mfhiPLUSsrl, NULL }  ,  { &&mfhiPLUSsrl, NULL } 
 ,  { &&mfhiPLUSsrl, NULL }  ,  { &&mfhiPLUSsrl, NULL }  ,  { &&mfhiPLUSsrl, NULL }  ,  { &&mfhiPLUSsrl, NULL }  ,  { &&mfhiPLUSsrl, NULL }  ,  { &&mfhiPLUSsrl, NULL }  ,  { &&mfhiPLUSsrl, NULL }  ,  { &&mfhiPLUSsrl, NULL }  ,  { &&mfhiPLUSsrl, NULL }  ,  { &&mfhiPLUSsrl, NULL } 
 ,  { &&mfhiPLUSsrl, NULL }  ,  { &&mfhiPLUSsrl, NULL }  ,  { &&mfhiPLUSsrl, NULL }  ,  { &&mfhiPLUSsrl, NULL }  ,  { &&mfhiPLUSsrl, NULL }  ,  { &&mfhiPLUSsrl, NULL }  ,  { &&mfhiPLUSsrl, NULL }  ,  { &&mfhiPLUSsrl, NULL }  ,  { &&mfhiPLUSsrl, NULL }  ,  { &&mfhiPLUSsrl, NULL } 
 ,  { &&mfhiPLUSsrl, NULL }  ,  { &&mfhiPLUSsrl, NULL }  ,  { &&mfhiPLUSsrl, NULL }  ,  { &&mfhiPLUSsrl, NULL }  ,  { &&mfhiPLUSsrl, NULL }  ,  { &&mfhiPLUSsrl, NULL }  ,  { &&mfhiPLUSsrl, NULL }  ,  { &&mfhiPLUSsrl, NULL }  ,  { &&mfhiPLUSsrl, NULL }  ,  { &&mfhiPLUSsrl, NULL } 
 ,  { &&mfhiPLUSsrl, NULL }  ,  { &&mfhiPLUSsrl, NULL }  ,  { &&mfhiPLUSsrl, NULL }  ,  { &&mfhiPLUSsrl, NULL }  ,  { &&mfhiPLUSsrl, NULL }  ,  { &&mfhiPLUSsrl, NULL }  ,  { &&mfhiPLUSsrl, NULL }  ,  { &&mfhiPLUSsrl, NULL }  ,  { &&mfhiPLUSsrl, NULL }  ,  { &&mfhiPLUSsrl, NULL } 
 ,  { &&mfhiPLUSsrl, NULL }  ,  { &&mfhiPLUSsrl, NULL }  ,  { &&mfhiPLUSsrl, NULL }  ,  { &&mfhiPLUSsrl, NULL }  ,  { &&mfhiPLUSsrl, NULL }  ,  { &&mfhiPLUSsrl, NULL }  ,  { &&mfhiPLUSsrl, NULL }  ,  { &&mfhiPLUSsrl, NULL }  ,  { &&mfhiPLUSsrl, NULL }  ,  { &&mfhiPLUSsrl, NULL } 
 ,  { &&mfhiPLUSsrl, NULL }  ,  { &&mfhiPLUSsrl, NULL }  ,  { &&mfhiPLUSsrl, NULL }  ,  { &&mfhiPLUSsrl, NULL }  ,  { &&mfhiPLUSsrl, NULL }  ,  { &&mfhiPLUSsrl, NULL }  ,  { &&mfhiPLUSsrl, NULL }  ,  { &&mfhiPLUSsrl, NULL }  ,  { &&mfhiPLUSsrl, NULL }  ,  { &&mfhiPLUSsrl, NULL } 
 ,  { &&mfhiPLUSsrl, NULL }  ,  { &&mfhiPLUSsrl, NULL }  ,  { &&mfhiPLUSsrl, NULL }  ,  { &&mfhiPLUSsrl, NULL }  ,  { &&mfhiPLUSsrl, NULL }  ,  { &&mfhiPLUSsrl, NULL }  ,  { &&mfhiPLUSsrl, NULL }  ,  { &&mfhiPLUSsrl, NULL }  ,  { &&mfhiPLUSsrl, NULL }  ,  { &&mfhiPLUSsrl, NULL } 
 }; 

struct pointer arraysbPLUSsh[T_SIZE] = {  { &&sbPLUSsh, NULL }  ,  { &&sbPLUSsh, NULL }  ,  { &&sbPLUSsh, NULL }  ,  { &&sbPLUSsh, NULL }  ,  { &&sbPLUSsh, NULL }  ,  { &&sbPLUSsh, NULL }  ,  { &&sbPLUSsh, NULL }  ,  { &&sbPLUSsh, NULL }  ,  { &&sbPLUSsh, NULL }  ,  { &&sbPLUSsh, NULL } 
 ,  { &&sbPLUSsh, NULL }  ,  { &&sbPLUSsh, NULL }  ,  { &&sbPLUSsh, NULL }  ,  { &&sbPLUSsh, NULL }  ,  { &&sbPLUSsh, NULL }  ,  { &&sbPLUSsh, NULL }  ,  { &&sbPLUSsh, NULL }  ,  { &&sbPLUSsh, NULL }  ,  { &&sbPLUSsh, NULL }  ,  { &&sbPLUSsh, NULL } 
 ,  { &&sbPLUSsh, NULL }  ,  { &&sbPLUSsh, NULL }  ,  { &&sbPLUSsh, NULL }  ,  { &&sbPLUSsh, NULL }  ,  { &&sbPLUSsh, NULL }  ,  { &&sbPLUSsh, NULL }  ,  { &&sbPLUSsh, NULL }  ,  { &&sbPLUSsh, NULL }  ,  { &&sbPLUSsh, NULL }  ,  { &&sbPLUSsh, NULL } 
 ,  { &&sbPLUSsh, NULL }  ,  { &&sbPLUSsh, NULL }  ,  { &&sbPLUSsh, NULL }  ,  { &&sbPLUSsh, NULL }  ,  { &&sbPLUSsh, NULL }  ,  { &&sbPLUSsh, NULL }  ,  { &&sbPLUSsh, NULL }  ,  { &&sbPLUSshPLUSor, NULL }  ,  { &&sbPLUSsh, NULL }  ,  { &&sbPLUSsh, NULL } 
 ,  { &&sbPLUSsh, NULL }  ,  { &&sbPLUSsh, NULL }  ,  { &&sbPLUSsh, NULL }  ,  { &&sbPLUSsh, NULL }  ,  { &&sbPLUSsh, NULL }  ,  { &&sbPLUSsh, NULL }  ,  { &&sbPLUSsh, NULL }  ,  { &&sbPLUSsh, NULL }  ,  { &&sbPLUSsh, NULL }  ,  { &&sbPLUSsh, NULL } 
 ,  { &&sbPLUSsh, NULL }  ,  { &&sbPLUSsh, NULL }  ,  { &&sbPLUSsh, NULL }  ,  { &&sbPLUSsh, NULL }  ,  { &&sbPLUSsh, NULL }  ,  { &&sbPLUSsh, NULL }  ,  { &&sbPLUSsh, NULL }  ,  { &&sbPLUSsh, NULL }  ,  { &&sbPLUSsh, NULL }  ,  { &&sbPLUSsh, NULL } 
 ,  { &&sbPLUSsh, NULL }  ,  { &&sbPLUSsh, NULL }  ,  { &&sbPLUSsh, NULL }  ,  { &&sbPLUSsh, NULL }  ,  { &&sbPLUSsh, NULL }  ,  { &&sbPLUSsh, NULL }  ,  { &&sbPLUSsh, NULL }  ,  { &&sbPLUSsh, NULL }  ,  { &&sbPLUSsh, NULL }  ,  { &&sbPLUSsh, NULL } 
 ,  { &&sbPLUSsh, NULL }  ,  { &&sbPLUSsh, NULL }  ,  { &&sbPLUSsh, NULL }  ,  { &&sbPLUSsh, NULL }  ,  { &&sbPLUSsh, NULL }  ,  { &&sbPLUSsh, NULL }  ,  { &&sbPLUSsh, NULL }  ,  { &&sbPLUSsh, NULL }  ,  { &&sbPLUSsh, NULL }  ,  { &&sbPLUSsh, NULL } 
 ,  { &&sbPLUSsh, NULL }  ,  { &&sbPLUSsh, NULL }  ,  { &&sbPLUSsh, NULL }  ,  { &&sbPLUSsh, NULL }  ,  { &&sbPLUSsh, NULL }  ,  { &&sbPLUSsh, NULL }  ,  { &&sbPLUSsh, NULL }  ,  { &&sbPLUSsh, NULL }  ,  { &&sbPLUSsh, NULL }  ,  { &&sbPLUSsh, NULL } 
 ,  { &&sbPLUSsh, NULL }  ,  { &&sbPLUSsh, NULL }  ,  { &&sbPLUSsh, NULL }  ,  { &&sbPLUSsh, NULL }  ,  { &&sbPLUSsh, NULL }  ,  { &&sbPLUSsh, NULL }  ,  { &&sbPLUSsh, NULL }  ,  { &&sbPLUSsh, NULL }  ,  { &&sbPLUSsh, NULL }  ,  { &&sbPLUSsh, NULL } 
 ,  { &&sbPLUSsh, NULL }  ,  { &&sbPLUSsh, NULL }  ,  { &&sbPLUSsh, NULL }  ,  { &&sbPLUSsh, NULL }  ,  { &&sbPLUSsh, NULL }  ,  { &&sbPLUSsh, NULL }  ,  { &&sbPLUSsh, NULL }  ,  { &&sbPLUSsh, NULL }  ,  { &&sbPLUSsh, NULL }  ,  { &&sbPLUSsh, NULL } 
 }; 

struct pointer arraylwPLUSaddu[T_SIZE] = {  { &&lwPLUSadduPLUSsll, NULL }  ,  { &&lwPLUSaddu, NULL }  ,  { &&lwPLUSaddu, NULL }  ,  { &&lwPLUSaddu, NULL }  ,  { &&lwPLUSaddu, NULL }  ,  { &&lwPLUSaddu, NULL }  ,  { &&lwPLUSaddu, NULL }  ,  { &&lwPLUSaddu, NULL }  ,  { &&lwPLUSaddu, NULL }  ,  { &&lwPLUSaddu, NULL } 
 ,  { &&lwPLUSaddu, NULL }  ,  { &&lwPLUSaddu, NULL }  ,  { &&lwPLUSaddu, NULL }  ,  { &&lwPLUSaddu, NULL }  ,  { &&lwPLUSaddu, NULL }  ,  { &&lwPLUSaddu, NULL }  ,  { &&lwPLUSaddu, NULL }  ,  { &&lwPLUSaddu, NULL }  ,  { &&lwPLUSaddu, NULL }  ,  { &&lwPLUSaddu, NULL } 
 ,  { &&lwPLUSaddu, NULL }  ,  { &&lwPLUSaddu, NULL }  ,  { &&lwPLUSaddu, NULL }  ,  { &&lwPLUSaddu, NULL }  ,  { &&lwPLUSaddu, NULL }  ,  { &&lwPLUSaddu, NULL }  ,  { &&lwPLUSaddu, NULL }  ,  { &&lwPLUSaddu, NULL }  ,  { &&lwPLUSaddu, NULL }  ,  { &&lwPLUSaddu, NULL } 
 ,  { &&lwPLUSaddu, NULL }  ,  { &&lwPLUSaddu, NULL }  ,  { &&lwPLUSaddu, NULL }  ,  { &&lwPLUSadduPLUSaddu, NULL }  ,  { &&lwPLUSaddu, NULL }  ,  { &&lwPLUSaddu, NULL }  ,  { &&lwPLUSaddu, NULL }  ,  { &&lwPLUSaddu, NULL }  ,  { &&lwPLUSaddu, NULL }  ,  { &&lwPLUSaddu, NULL } 
 ,  { &&lwPLUSaddu, NULL }  ,  { &&lwPLUSaddu, NULL }  ,  { &&lwPLUSadduPLUSslt, NULL }  ,  { &&lwPLUSaddu, NULL }  ,  { &&lwPLUSaddu, NULL }  ,  { &&lwPLUSaddu, NULL }  ,  { &&lwPLUSaddu, NULL }  ,  { &&lwPLUSaddu, NULL }  ,  { &&lwPLUSaddu, NULL }  ,  { &&lwPLUSaddu, NULL } 
 ,  { &&lwPLUSaddu, NULL }  ,  { &&lwPLUSaddu, NULL }  ,  { &&lwPLUSaddu, NULL }  ,  { &&lwPLUSaddu, NULL }  ,  { &&lwPLUSaddu, NULL }  ,  { &&lwPLUSaddu, NULL }  ,  { &&lwPLUSaddu, NULL }  ,  { &&lwPLUSaddu, NULL }  ,  { &&lwPLUSaddu, NULL }  ,  { &&lwPLUSaddu, NULL } 
 ,  { &&lwPLUSaddu, NULL }  ,  { &&lwPLUSaddu, NULL }  ,  { &&lwPLUSaddu, NULL }  ,  { &&lwPLUSaddu, NULL }  ,  { &&lwPLUSaddu, NULL }  ,  { &&lwPLUSaddu, NULL }  ,  { &&lwPLUSaddu, NULL }  ,  { &&lwPLUSaddu, NULL }  ,  { &&lwPLUSaddu, NULL }  ,  { &&lwPLUSaddu, NULL } 
 ,  { &&lwPLUSaddu, NULL }  ,  { &&lwPLUSaddu, NULL }  ,  { &&lwPLUSaddu, NULL }  ,  { &&lwPLUSaddu, NULL }  ,  { &&lwPLUSaddu, NULL }  ,  { &&lwPLUSaddu, NULL }  ,  { &&lwPLUSaddu, NULL }  ,  { &&lwPLUSaddu, NULL }  ,  { &&lwPLUSadduPLUSlw, NULL }  ,  { &&lwPLUSaddu, NULL } 
 ,  { &&lwPLUSaddu, NULL }  ,  { &&lwPLUSaddu, NULL }  ,  { &&lwPLUSaddu, NULL }  ,  { &&lwPLUSaddu, NULL }  ,  { &&lwPLUSaddu, NULL }  ,  { &&lwPLUSaddu, NULL }  ,  { &&lwPLUSadduPLUSsw, NULL }  ,  { &&lwPLUSaddu, NULL }  ,  { &&lwPLUSaddu, NULL }  ,  { &&lwPLUSaddu, NULL } 
 ,  { &&lwPLUSaddu, NULL }  ,  { &&lwPLUSaddu, NULL }  ,  { &&lwPLUSaddu, NULL }  ,  { &&lwPLUSaddu, NULL }  ,  { &&lwPLUSaddu, NULL }  ,  { &&lwPLUSaddu, NULL }  ,  { &&lwPLUSaddu, NULL }  ,  { &&lwPLUSaddu, NULL }  ,  { &&lwPLUSaddu, NULL }  ,  { &&lwPLUSaddu, NULL } 
 ,  { &&lwPLUSaddu, NULL }  ,  { &&lwPLUSaddu, NULL }  ,  { &&lwPLUSaddu, NULL }  ,  { &&lwPLUSaddu, NULL }  ,  { &&lwPLUSaddu, NULL }  ,  { &&lwPLUSaddu, NULL }  ,  { &&lwPLUSaddu, NULL }  ,  { &&lwPLUSaddu, NULL }  ,  { &&lwPLUSaddu, NULL }  ,  { &&lwPLUSaddu, NULL } 
 }; 

struct pointer arrayoriPLUSand[T_SIZE] = {  { &&oriPLUSandPLUSsll, NULL }  ,  { &&oriPLUSand, NULL }  ,  { &&oriPLUSand, NULL }  ,  { &&oriPLUSand, NULL }  ,  { &&oriPLUSand, NULL }  ,  { &&oriPLUSand, NULL }  ,  { &&oriPLUSand, NULL }  ,  { &&oriPLUSand, NULL }  ,  { &&oriPLUSand, NULL }  ,  { &&oriPLUSand, NULL } 
 ,  { &&oriPLUSand, NULL }  ,  { &&oriPLUSand, NULL }  ,  { &&oriPLUSand, NULL }  ,  { &&oriPLUSand, NULL }  ,  { &&oriPLUSand, NULL }  ,  { &&oriPLUSand, NULL }  ,  { &&oriPLUSand, NULL }  ,  { &&oriPLUSand, NULL }  ,  { &&oriPLUSand, NULL }  ,  { &&oriPLUSand, NULL } 
 ,  { &&oriPLUSand, NULL }  ,  { &&oriPLUSand, NULL }  ,  { &&oriPLUSand, NULL }  ,  { &&oriPLUSand, NULL }  ,  { &&oriPLUSand, NULL }  ,  { &&oriPLUSand, NULL }  ,  { &&oriPLUSand, NULL }  ,  { &&oriPLUSand, NULL }  ,  { &&oriPLUSand, NULL }  ,  { &&oriPLUSand, NULL } 
 ,  { &&oriPLUSand, NULL }  ,  { &&oriPLUSand, NULL }  ,  { &&oriPLUSand, NULL }  ,  { &&oriPLUSand, NULL }  ,  { &&oriPLUSand, NULL }  ,  { &&oriPLUSand, NULL }  ,  { &&oriPLUSand, NULL }  ,  { &&oriPLUSandPLUSor, NULL }  ,  { &&oriPLUSand, NULL }  ,  { &&oriPLUSand, NULL } 
 ,  { &&oriPLUSand, NULL }  ,  { &&oriPLUSand, NULL }  ,  { &&oriPLUSand, NULL }  ,  { &&oriPLUSand, NULL }  ,  { &&oriPLUSand, NULL }  ,  { &&oriPLUSand, NULL }  ,  { &&oriPLUSand, NULL }  ,  { &&oriPLUSand, NULL }  ,  { &&oriPLUSand, NULL }  ,  { &&oriPLUSand, NULL } 
 ,  { &&oriPLUSand, NULL }  ,  { &&oriPLUSand, NULL }  ,  { &&oriPLUSand, NULL }  ,  { &&oriPLUSand, NULL }  ,  { &&oriPLUSand, NULL }  ,  { &&oriPLUSand, NULL }  ,  { &&oriPLUSand, NULL }  ,  { &&oriPLUSand, NULL }  ,  { &&oriPLUSand, NULL }  ,  { &&oriPLUSand, NULL } 
 ,  { &&oriPLUSand, NULL }  ,  { &&oriPLUSand, NULL }  ,  { &&oriPLUSand, NULL }  ,  { &&oriPLUSand, NULL }  ,  { &&oriPLUSand, NULL }  ,  { &&oriPLUSand, NULL }  ,  { &&oriPLUSand, NULL }  ,  { &&oriPLUSand, NULL }  ,  { &&oriPLUSand, NULL }  ,  { &&oriPLUSand, NULL } 
 ,  { &&oriPLUSand, NULL }  ,  { &&oriPLUSand, NULL }  ,  { &&oriPLUSand, NULL }  ,  { &&oriPLUSand, NULL }  ,  { &&oriPLUSand, NULL }  ,  { &&oriPLUSand, NULL }  ,  { &&oriPLUSand, NULL }  ,  { &&oriPLUSand, NULL }  ,  { &&oriPLUSand, NULL }  ,  { &&oriPLUSand, NULL } 
 ,  { &&oriPLUSand, NULL }  ,  { &&oriPLUSand, NULL }  ,  { &&oriPLUSand, NULL }  ,  { &&oriPLUSand, NULL }  ,  { &&oriPLUSand, NULL }  ,  { &&oriPLUSand, NULL }  ,  { &&oriPLUSand, NULL }  ,  { &&oriPLUSand, NULL }  ,  { &&oriPLUSand, NULL }  ,  { &&oriPLUSand, NULL } 
 ,  { &&oriPLUSand, NULL }  ,  { &&oriPLUSand, NULL }  ,  { &&oriPLUSand, NULL }  ,  { &&oriPLUSand, NULL }  ,  { &&oriPLUSand, NULL }  ,  { &&oriPLUSand, NULL }  ,  { &&oriPLUSand, NULL }  ,  { &&oriPLUSand, NULL }  ,  { &&oriPLUSand, NULL }  ,  { &&oriPLUSand, NULL } 
 ,  { &&oriPLUSand, NULL }  ,  { &&oriPLUSand, NULL }  ,  { &&oriPLUSand, NULL }  ,  { &&oriPLUSand, NULL }  ,  { &&oriPLUSand, NULL }  ,  { &&oriPLUSand, NULL }  ,  { &&oriPLUSand, NULL }  ,  { &&oriPLUSand, NULL }  ,  { &&oriPLUSand, NULL }  ,  { &&oriPLUSand, NULL } 
 }; 

struct pointer arrayandiPLUSsubu[T_SIZE] = {  { &&andiPLUSsubu, NULL }  ,  { &&andiPLUSsubu, NULL }  ,  { &&andiPLUSsubu, NULL }  ,  { &&andiPLUSsubu, NULL }  ,  { &&andiPLUSsubu, NULL }  ,  { &&andiPLUSsubu, NULL }  ,  { &&andiPLUSsubu, NULL }  ,  { &&andiPLUSsubu, NULL }  ,  { &&andiPLUSsubu, NULL }  ,  { &&andiPLUSsubu, NULL } 
 ,  { &&andiPLUSsubu, NULL }  ,  { &&andiPLUSsubu, NULL }  ,  { &&andiPLUSsubu, NULL }  ,  { &&andiPLUSsubu, NULL }  ,  { &&andiPLUSsubu, NULL }  ,  { &&andiPLUSsubu, NULL }  ,  { &&andiPLUSsubu, NULL }  ,  { &&andiPLUSsubu, NULL }  ,  { &&andiPLUSsubu, NULL }  ,  { &&andiPLUSsubu, NULL } 
 ,  { &&andiPLUSsubu, NULL }  ,  { &&andiPLUSsubu, NULL }  ,  { &&andiPLUSsubu, NULL }  ,  { &&andiPLUSsubu, NULL }  ,  { &&andiPLUSsubu, NULL }  ,  { &&andiPLUSsubu, NULL }  ,  { &&andiPLUSsubu, NULL }  ,  { &&andiPLUSsubu, NULL }  ,  { &&andiPLUSsubu, NULL }  ,  { &&andiPLUSsubu, NULL } 
 ,  { &&andiPLUSsubu, NULL }  ,  { &&andiPLUSsubu, NULL }  ,  { &&andiPLUSsubu, NULL }  ,  { &&andiPLUSsubu, NULL }  ,  { &&andiPLUSsubu, NULL }  ,  { &&andiPLUSsubu, NULL }  ,  { &&andiPLUSsubuPLUSand, NULL }  ,  { &&andiPLUSsubu, NULL }  ,  { &&andiPLUSsubu, NULL }  ,  { &&andiPLUSsubu, NULL } 
 ,  { &&andiPLUSsubu, NULL }  ,  { &&andiPLUSsubu, NULL }  ,  { &&andiPLUSsubu, NULL }  ,  { &&andiPLUSsubu, NULL }  ,  { &&andiPLUSsubu, NULL }  ,  { &&andiPLUSsubu, NULL }  ,  { &&andiPLUSsubu, NULL }  ,  { &&andiPLUSsubu, NULL }  ,  { &&andiPLUSsubu, NULL }  ,  { &&andiPLUSsubu, NULL } 
 ,  { &&andiPLUSsubu, NULL }  ,  { &&andiPLUSsubu, NULL }  ,  { &&andiPLUSsubu, NULL }  ,  { &&andiPLUSsubu, NULL }  ,  { &&andiPLUSsubu, NULL }  ,  { &&andiPLUSsubu, NULL }  ,  { &&andiPLUSsubu, NULL }  ,  { &&andiPLUSsubu, NULL }  ,  { &&andiPLUSsubu, NULL }  ,  { &&andiPLUSsubu, NULL } 
 ,  { &&andiPLUSsubu, NULL }  ,  { &&andiPLUSsubu, NULL }  ,  { &&andiPLUSsubu, NULL }  ,  { &&andiPLUSsubu, NULL }  ,  { &&andiPLUSsubu, NULL }  ,  { &&andiPLUSsubu, NULL }  ,  { &&andiPLUSsubu, NULL }  ,  { &&andiPLUSsubu, NULL }  ,  { &&andiPLUSsubu, NULL }  ,  { &&andiPLUSsubu, NULL } 
 ,  { &&andiPLUSsubu, NULL }  ,  { &&andiPLUSsubu, NULL }  ,  { &&andiPLUSsubu, NULL }  ,  { &&andiPLUSsubu, NULL }  ,  { &&andiPLUSsubu, NULL }  ,  { &&andiPLUSsubu, NULL }  ,  { &&andiPLUSsubu, NULL }  ,  { &&andiPLUSsubu, NULL }  ,  { &&andiPLUSsubu, NULL }  ,  { &&andiPLUSsubu, NULL } 
 ,  { &&andiPLUSsubu, NULL }  ,  { &&andiPLUSsubu, NULL }  ,  { &&andiPLUSsubu, NULL }  ,  { &&andiPLUSsubu, NULL }  ,  { &&andiPLUSsubu, NULL }  ,  { &&andiPLUSsubu, NULL }  ,  { &&andiPLUSsubu, NULL }  ,  { &&andiPLUSsubu, NULL }  ,  { &&andiPLUSsubu, NULL }  ,  { &&andiPLUSsubu, NULL } 
 ,  { &&andiPLUSsubu, NULL }  ,  { &&andiPLUSsubu, NULL }  ,  { &&andiPLUSsubu, NULL }  ,  { &&andiPLUSsubu, NULL }  ,  { &&andiPLUSsubu, NULL }  ,  { &&andiPLUSsubu, NULL }  ,  { &&andiPLUSsubu, NULL }  ,  { &&andiPLUSsubu, NULL }  ,  { &&andiPLUSsubu, NULL }  ,  { &&andiPLUSsubu, NULL } 
 ,  { &&andiPLUSsubu, NULL }  ,  { &&andiPLUSsubu, NULL }  ,  { &&andiPLUSsubu, NULL }  ,  { &&andiPLUSsubu, NULL }  ,  { &&andiPLUSsubu, NULL }  ,  { &&andiPLUSsubu, NULL }  ,  { &&andiPLUSsubu, NULL }  ,  { &&andiPLUSsubu, NULL }  ,  { &&andiPLUSsubu, NULL }  ,  { &&andiPLUSsubu, NULL } 
 }; 

struct pointer arraysltPLUSlw[T_SIZE] = {  { &&sltPLUSlw, NULL }  ,  { &&sltPLUSlw, NULL }  ,  { &&sltPLUSlw, NULL }  ,  { &&sltPLUSlw, NULL }  ,  { &&sltPLUSlw, NULL }  ,  { &&sltPLUSlw, NULL }  ,  { &&sltPLUSlw, NULL }  ,  { &&sltPLUSlw, NULL }  ,  { &&sltPLUSlw, NULL }  ,  { &&sltPLUSlw, NULL } 
 ,  { &&sltPLUSlw, NULL }  ,  { &&sltPLUSlw, NULL }  ,  { &&sltPLUSlw, NULL }  ,  { &&sltPLUSlw, NULL }  ,  { &&sltPLUSlw, NULL }  ,  { &&sltPLUSlw, NULL }  ,  { &&sltPLUSlw, NULL }  ,  { &&sltPLUSlw, NULL }  ,  { &&sltPLUSlw, NULL }  ,  { &&sltPLUSlw, NULL } 
 ,  { &&sltPLUSlw, NULL }  ,  { &&sltPLUSlw, NULL }  ,  { &&sltPLUSlw, NULL }  ,  { &&sltPLUSlw, NULL }  ,  { &&sltPLUSlw, NULL }  ,  { &&sltPLUSlw, NULL }  ,  { &&sltPLUSlw, NULL }  ,  { &&sltPLUSlw, NULL }  ,  { &&sltPLUSlw, NULL }  ,  { &&sltPLUSlw, NULL } 
 ,  { &&sltPLUSlw, NULL }  ,  { &&sltPLUSlw, NULL }  ,  { &&sltPLUSlw, NULL }  ,  { &&sltPLUSlw, NULL }  ,  { &&sltPLUSlw, NULL }  ,  { &&sltPLUSlw, NULL }  ,  { &&sltPLUSlw, NULL }  ,  { &&sltPLUSlw, NULL }  ,  { &&sltPLUSlw, NULL }  ,  { &&sltPLUSlw, NULL } 
 ,  { &&sltPLUSlw, NULL }  ,  { &&sltPLUSlw, NULL }  ,  { &&sltPLUSlw, NULL }  ,  { &&sltPLUSlw, NULL }  ,  { &&sltPLUSlw, NULL }  ,  { &&sltPLUSlw, NULL }  ,  { &&sltPLUSlw, NULL }  ,  { &&sltPLUSlwPLUSbeq, NULL }  ,  { &&sltPLUSlw, NULL }  ,  { &&sltPLUSlw, NULL } 
 ,  { &&sltPLUSlw, NULL }  ,  { &&sltPLUSlw, NULL }  ,  { &&sltPLUSlw, NULL }  ,  { &&sltPLUSlw, NULL }  ,  { &&sltPLUSlw, NULL }  ,  { &&sltPLUSlw, NULL }  ,  { &&sltPLUSlw, NULL }  ,  { &&sltPLUSlw, NULL }  ,  { &&sltPLUSlw, NULL }  ,  { &&sltPLUSlw, NULL } 
 ,  { &&sltPLUSlw, NULL }  ,  { &&sltPLUSlw, NULL }  ,  { &&sltPLUSlw, NULL }  ,  { &&sltPLUSlw, NULL }  ,  { &&sltPLUSlw, NULL }  ,  { &&sltPLUSlw, NULL }  ,  { &&sltPLUSlw, NULL }  ,  { &&sltPLUSlw, NULL }  ,  { &&sltPLUSlw, NULL }  ,  { &&sltPLUSlw, NULL } 
 ,  { &&sltPLUSlw, NULL }  ,  { &&sltPLUSlw, NULL }  ,  { &&sltPLUSlw, NULL }  ,  { &&sltPLUSlw, NULL }  ,  { &&sltPLUSlw, NULL }  ,  { &&sltPLUSlw, NULL }  ,  { &&sltPLUSlw, NULL }  ,  { &&sltPLUSlw, NULL }  ,  { &&sltPLUSlw, NULL }  ,  { &&sltPLUSlw, NULL } 
 ,  { &&sltPLUSlw, NULL }  ,  { &&sltPLUSlw, NULL }  ,  { &&sltPLUSlw, NULL }  ,  { &&sltPLUSlw, NULL }  ,  { &&sltPLUSlw, NULL }  ,  { &&sltPLUSlw, NULL }  ,  { &&sltPLUSlw, NULL }  ,  { &&sltPLUSlw, NULL }  ,  { &&sltPLUSlw, NULL }  ,  { &&sltPLUSlw, NULL } 
 ,  { &&sltPLUSlw, NULL }  ,  { &&sltPLUSlw, NULL }  ,  { &&sltPLUSlw, NULL }  ,  { &&sltPLUSlw, NULL }  ,  { &&sltPLUSlw, NULL }  ,  { &&sltPLUSlw, NULL }  ,  { &&sltPLUSlw, NULL }  ,  { &&sltPLUSlw, NULL }  ,  { &&sltPLUSlw, NULL }  ,  { &&sltPLUSlw, NULL } 
 ,  { &&sltPLUSlw, NULL }  ,  { &&sltPLUSlw, NULL }  ,  { &&sltPLUSlw, NULL }  ,  { &&sltPLUSlw, NULL }  ,  { &&sltPLUSlw, NULL }  ,  { &&sltPLUSlw, NULL }  ,  { &&sltPLUSlw, NULL }  ,  { &&sltPLUSlw, NULL }  ,  { &&sltPLUSlw, NULL }  ,  { &&sltPLUSlw, NULL } 
 }; 

struct pointer arrayblezPLUSsll[T_SIZE] = {  { &&blezPLUSsll, NULL }  ,  { &&blezPLUSsll, NULL }  ,  { &&blezPLUSsll, NULL }  ,  { &&blezPLUSsll, NULL }  ,  { &&blezPLUSsll, NULL }  ,  { &&blezPLUSsll, NULL }  ,  { &&blezPLUSsll, NULL }  ,  { &&blezPLUSsll, NULL }  ,  { &&blezPLUSsll, NULL }  ,  { &&blezPLUSsll, NULL } 
 ,  { &&blezPLUSsll, NULL }  ,  { &&blezPLUSsll, NULL }  ,  { &&blezPLUSsll, NULL }  ,  { &&blezPLUSsll, NULL }  ,  { &&blezPLUSsll, NULL }  ,  { &&blezPLUSsll, NULL }  ,  { &&blezPLUSsll, NULL }  ,  { &&blezPLUSsll, NULL }  ,  { &&blezPLUSsll, NULL }  ,  { &&blezPLUSsll, NULL } 
 ,  { &&blezPLUSsll, NULL }  ,  { &&blezPLUSsll, NULL }  ,  { &&blezPLUSsll, NULL }  ,  { &&blezPLUSsll, NULL }  ,  { &&blezPLUSsll, NULL }  ,  { &&blezPLUSsll, NULL }  ,  { &&blezPLUSsll, NULL }  ,  { &&blezPLUSsll, NULL }  ,  { &&blezPLUSsll, NULL }  ,  { &&blezPLUSsll, NULL } 
 ,  { &&blezPLUSsll, NULL }  ,  { &&blezPLUSsll, NULL }  ,  { &&blezPLUSsll, NULL }  ,  { &&blezPLUSsllPLUSaddu, NULL }  ,  { &&blezPLUSsll, NULL }  ,  { &&blezPLUSsll, NULL }  ,  { &&blezPLUSsll, NULL }  ,  { &&blezPLUSsll, NULL }  ,  { &&blezPLUSsll, NULL }  ,  { &&blezPLUSsll, NULL } 
 ,  { &&blezPLUSsll, NULL }  ,  { &&blezPLUSsll, NULL }  ,  { &&blezPLUSsll, NULL }  ,  { &&blezPLUSsll, NULL }  ,  { &&blezPLUSsll, NULL }  ,  { &&blezPLUSsll, NULL }  ,  { &&blezPLUSsll, NULL }  ,  { &&blezPLUSsll, NULL }  ,  { &&blezPLUSsll, NULL }  ,  { &&blezPLUSsll, NULL } 
 ,  { &&blezPLUSsll, NULL }  ,  { &&blezPLUSsll, NULL }  ,  { &&blezPLUSsllPLUSaddiu, NULL }  ,  { &&blezPLUSsll, NULL }  ,  { &&blezPLUSsll, NULL }  ,  { &&blezPLUSsll, NULL }  ,  { &&blezPLUSsll, NULL }  ,  { &&blezPLUSsll, NULL }  ,  { &&blezPLUSsll, NULL }  ,  { &&blezPLUSsll, NULL } 
 ,  { &&blezPLUSsll, NULL }  ,  { &&blezPLUSsll, NULL }  ,  { &&blezPLUSsll, NULL }  ,  { &&blezPLUSsll, NULL }  ,  { &&blezPLUSsll, NULL }  ,  { &&blezPLUSsll, NULL }  ,  { &&blezPLUSsll, NULL }  ,  { &&blezPLUSsll, NULL }  ,  { &&blezPLUSsll, NULL }  ,  { &&blezPLUSsll, NULL } 
 ,  { &&blezPLUSsll, NULL }  ,  { &&blezPLUSsll, NULL }  ,  { &&blezPLUSsll, NULL }  ,  { &&blezPLUSsll, NULL }  ,  { &&blezPLUSsll, NULL }  ,  { &&blezPLUSsll, NULL }  ,  { &&blezPLUSsll, NULL }  ,  { &&blezPLUSsll, NULL }  ,  { &&blezPLUSsllPLUSlw, NULL }  ,  { &&blezPLUSsll, NULL } 
 ,  { &&blezPLUSsll, NULL }  ,  { &&blezPLUSsll, NULL }  ,  { &&blezPLUSsll, NULL }  ,  { &&blezPLUSsll, NULL }  ,  { &&blezPLUSsll, NULL }  ,  { &&blezPLUSsll, NULL }  ,  { &&blezPLUSsll, NULL }  ,  { &&blezPLUSsll, NULL }  ,  { &&blezPLUSsll, NULL }  ,  { &&blezPLUSsll, NULL } 
 ,  { &&blezPLUSsll, NULL }  ,  { &&blezPLUSsll, NULL }  ,  { &&blezPLUSsll, NULL }  ,  { &&blezPLUSsll, NULL }  ,  { &&blezPLUSsll, NULL }  ,  { &&blezPLUSsll, NULL }  ,  { &&blezPLUSsll, NULL }  ,  { &&blezPLUSsll, NULL }  ,  { &&blezPLUSsll, NULL }  ,  { &&blezPLUSsll, NULL } 
 ,  { &&blezPLUSsll, NULL }  ,  { &&blezPLUSsll, NULL }  ,  { &&blezPLUSsll, NULL }  ,  { &&blezPLUSsll, NULL }  ,  { &&blezPLUSsll, NULL }  ,  { &&blezPLUSsll, NULL }  ,  { &&blezPLUSsll, NULL }  ,  { &&blezPLUSsll, NULL }  ,  { &&blezPLUSsll, NULL }  ,  { &&blezPLUSsll, NULL } 
 }; 

struct pointer arraysllPLUSsw[T_SIZE] = {  { &&sllPLUSsw, NULL }  ,  { &&sllPLUSsw, NULL }  ,  { &&sllPLUSsw, NULL }  ,  { &&sllPLUSsw, NULL }  ,  { &&sllPLUSsw, NULL }  ,  { &&sllPLUSsw, NULL }  ,  { &&sllPLUSsw, NULL }  ,  { &&sllPLUSsw, NULL }  ,  { &&sllPLUSsw, NULL }  ,  { &&sllPLUSsw, NULL } 
 ,  { &&sllPLUSsw, NULL }  ,  { &&sllPLUSsw, NULL }  ,  { &&sllPLUSsw, NULL }  ,  { &&sllPLUSsw, NULL }  ,  { &&sllPLUSsw, NULL }  ,  { &&sllPLUSsw, NULL }  ,  { &&sllPLUSsw, NULL }  ,  { &&sllPLUSsw, NULL }  ,  { &&sllPLUSsw, NULL }  ,  { &&sllPLUSsw, NULL } 
 ,  { &&sllPLUSsw, NULL }  ,  { &&sllPLUSsw, NULL }  ,  { &&sllPLUSsw, NULL }  ,  { &&sllPLUSsw, NULL }  ,  { &&sllPLUSsw, NULL }  ,  { &&sllPLUSsw, NULL }  ,  { &&sllPLUSsw, NULL }  ,  { &&sllPLUSsw, NULL }  ,  { &&sllPLUSsw, NULL }  ,  { &&sllPLUSsw, NULL } 
 ,  { &&sllPLUSsw, NULL }  ,  { &&sllPLUSsw, NULL }  ,  { &&sllPLUSsw, NULL }  ,  { &&sllPLUSswPLUSaddu, NULL }  ,  { &&sllPLUSsw, NULL }  ,  { &&sllPLUSsw, NULL }  ,  { &&sllPLUSsw, NULL }  ,  { &&sllPLUSsw, NULL }  ,  { &&sllPLUSsw, NULL }  ,  { &&sllPLUSsw, NULL } 
 ,  { &&sllPLUSsw, NULL }  ,  { &&sllPLUSsw, NULL }  ,  { &&sllPLUSsw, NULL }  ,  { &&sllPLUSsw, NULL }  ,  { &&sllPLUSsw, NULL }  ,  { &&sllPLUSsw, NULL }  ,  { &&sllPLUSsw, NULL }  ,  { &&sllPLUSsw, NULL }  ,  { &&sllPLUSsw, NULL }  ,  { &&sllPLUSsw, NULL } 
 ,  { &&sllPLUSsw, NULL }  ,  { &&sllPLUSsw, NULL }  ,  { &&sllPLUSsw, NULL }  ,  { &&sllPLUSswPLUSslti, NULL }  ,  { &&sllPLUSsw, NULL }  ,  { &&sllPLUSsw, NULL }  ,  { &&sllPLUSsw, NULL }  ,  { &&sllPLUSsw, NULL }  ,  { &&sllPLUSswPLUSlui, NULL }  ,  { &&sllPLUSsw, NULL } 
 ,  { &&sllPLUSsw, NULL }  ,  { &&sllPLUSsw, NULL }  ,  { &&sllPLUSsw, NULL }  ,  { &&sllPLUSsw, NULL }  ,  { &&sllPLUSsw, NULL }  ,  { &&sllPLUSsw, NULL }  ,  { &&sllPLUSsw, NULL }  ,  { &&sllPLUSsw, NULL }  ,  { &&sllPLUSsw, NULL }  ,  { &&sllPLUSsw, NULL } 
 ,  { &&sllPLUSsw, NULL }  ,  { &&sllPLUSsw, NULL }  ,  { &&sllPLUSsw, NULL }  ,  { &&sllPLUSsw, NULL }  ,  { &&sllPLUSsw, NULL }  ,  { &&sllPLUSsw, NULL }  ,  { &&sllPLUSsw, NULL }  ,  { &&sllPLUSsw, NULL }  ,  { &&sllPLUSsw, NULL }  ,  { &&sllPLUSsw, NULL } 
 ,  { &&sllPLUSsw, NULL }  ,  { &&sllPLUSsw, NULL }  ,  { &&sllPLUSsw, NULL }  ,  { &&sllPLUSsw, NULL }  ,  { &&sllPLUSsw, NULL }  ,  { &&sllPLUSsw, NULL }  ,  { &&sllPLUSswPLUSsw, NULL }  ,  { &&sllPLUSsw, NULL }  ,  { &&sllPLUSsw, NULL }  ,  { &&sllPLUSsw, NULL } 
 ,  { &&sllPLUSsw, NULL }  ,  { &&sllPLUSsw, NULL }  ,  { &&sllPLUSsw, NULL }  ,  { &&sllPLUSsw, NULL }  ,  { &&sllPLUSsw, NULL }  ,  { &&sllPLUSsw, NULL }  ,  { &&sllPLUSsw, NULL }  ,  { &&sllPLUSsw, NULL }  ,  { &&sllPLUSsw, NULL }  ,  { &&sllPLUSsw, NULL } 
 ,  { &&sllPLUSsw, NULL }  ,  { &&sllPLUSsw, NULL }  ,  { &&sllPLUSsw, NULL }  ,  { &&sllPLUSsw, NULL }  ,  { &&sllPLUSsw, NULL }  ,  { &&sllPLUSsw, NULL }  ,  { &&sllPLUSsw, NULL }  ,  { &&sllPLUSsw, NULL }  ,  { &&sllPLUSsw, NULL }  ,  { &&sllPLUSsw, NULL } 
 }; 

struct pointer arraybeqPLUSaddiu[T_SIZE] = {  { &&beqPLUSaddiuPLUSsll, NULL }  ,  { &&beqPLUSaddiu, NULL }  ,  { &&beqPLUSaddiu, NULL }  ,  { &&beqPLUSaddiu, NULL }  ,  { &&beqPLUSaddiu, NULL }  ,  { &&beqPLUSaddiu, NULL }  ,  { &&beqPLUSaddiu, NULL }  ,  { &&beqPLUSaddiu, NULL }  ,  { &&beqPLUSaddiu, NULL }  ,  { &&beqPLUSaddiu, NULL } 
 ,  { &&beqPLUSaddiu, NULL }  ,  { &&beqPLUSaddiu, NULL }  ,  { &&beqPLUSaddiu, NULL }  ,  { &&beqPLUSaddiu, NULL }  ,  { &&beqPLUSaddiu, NULL }  ,  { &&beqPLUSaddiu, NULL }  ,  { &&beqPLUSaddiu, NULL }  ,  { &&beqPLUSaddiu, NULL }  ,  { &&beqPLUSaddiu, NULL }  ,  { &&beqPLUSaddiu, NULL } 
 ,  { &&beqPLUSaddiu, NULL }  ,  { &&beqPLUSaddiu, NULL }  ,  { &&beqPLUSaddiu, NULL }  ,  { &&beqPLUSaddiu, NULL }  ,  { &&beqPLUSaddiu, NULL }  ,  { &&beqPLUSaddiu, NULL }  ,  { &&beqPLUSaddiu, NULL }  ,  { &&beqPLUSaddiu, NULL }  ,  { &&beqPLUSaddiu, NULL }  ,  { &&beqPLUSaddiu, NULL } 
 ,  { &&beqPLUSaddiu, NULL }  ,  { &&beqPLUSaddiu, NULL }  ,  { &&beqPLUSaddiu, NULL }  ,  { &&beqPLUSaddiuPLUSaddu, NULL }  ,  { &&beqPLUSaddiu, NULL }  ,  { &&beqPLUSaddiu, NULL }  ,  { &&beqPLUSaddiu, NULL }  ,  { &&beqPLUSaddiu, NULL }  ,  { &&beqPLUSaddiu, NULL }  ,  { &&beqPLUSaddiu, NULL } 
 ,  { &&beqPLUSaddiu, NULL }  ,  { &&beqPLUSaddiu, NULL }  ,  { &&beqPLUSaddiu, NULL }  ,  { &&beqPLUSaddiuPLUSsltu, NULL }  ,  { &&beqPLUSaddiu, NULL }  ,  { &&beqPLUSaddiu, NULL }  ,  { &&beqPLUSaddiu, NULL }  ,  { &&beqPLUSaddiu, NULL }  ,  { &&beqPLUSaddiu, NULL }  ,  { &&beqPLUSaddiu, NULL } 
 ,  { &&beqPLUSaddiu, NULL }  ,  { &&beqPLUSaddiu, NULL }  ,  { &&beqPLUSaddiuPLUSaddiu, NULL }  ,  { &&beqPLUSaddiu, NULL }  ,  { &&beqPLUSaddiu, NULL }  ,  { &&beqPLUSaddiu, NULL }  ,  { &&beqPLUSaddiu, NULL }  ,  { &&beqPLUSaddiu, NULL }  ,  { &&beqPLUSaddiu, NULL }  ,  { &&beqPLUSaddiu, NULL } 
 ,  { &&beqPLUSaddiu, NULL }  ,  { &&beqPLUSaddiu, NULL }  ,  { &&beqPLUSaddiu, NULL }  ,  { &&beqPLUSaddiu, NULL }  ,  { &&beqPLUSaddiu, NULL }  ,  { &&beqPLUSaddiu, NULL }  ,  { &&beqPLUSaddiu, NULL }  ,  { &&beqPLUSaddiu, NULL }  ,  { &&beqPLUSaddiu, NULL }  ,  { &&beqPLUSaddiu, NULL } 
 ,  { &&beqPLUSaddiu, NULL }  ,  { &&beqPLUSaddiu, NULL }  ,  { &&beqPLUSaddiu, NULL }  ,  { &&beqPLUSaddiu, NULL }  ,  { &&beqPLUSaddiu, NULL }  ,  { &&beqPLUSaddiu, NULL }  ,  { &&beqPLUSaddiu, NULL }  ,  { &&beqPLUSaddiu, NULL }  ,  { &&beqPLUSaddiu, NULL }  ,  { &&beqPLUSaddiu, NULL } 
 ,  { &&beqPLUSaddiu, NULL }  ,  { &&beqPLUSaddiu, NULL }  ,  { &&beqPLUSaddiu, NULL }  ,  { &&beqPLUSaddiu, NULL }  ,  { &&beqPLUSaddiu, NULL }  ,  { &&beqPLUSaddiu, NULL }  ,  { &&beqPLUSaddiu, NULL }  ,  { &&beqPLUSaddiu, NULL }  ,  { &&beqPLUSaddiu, NULL }  ,  { &&beqPLUSaddiu, NULL } 
 ,  { &&beqPLUSaddiu, NULL }  ,  { &&beqPLUSaddiu, NULL }  ,  { &&beqPLUSaddiu, NULL }  ,  { &&beqPLUSaddiu, NULL }  ,  { &&beqPLUSaddiu, NULL }  ,  { &&beqPLUSaddiu, NULL }  ,  { &&beqPLUSaddiu, NULL }  ,  { &&beqPLUSaddiu, NULL }  ,  { &&beqPLUSaddiu, NULL }  ,  { &&beqPLUSaddiu, NULL } 
 ,  { &&beqPLUSaddiu, NULL }  ,  { &&beqPLUSaddiu, NULL }  ,  { &&beqPLUSaddiu, NULL }  ,  { &&beqPLUSaddiu, NULL }  ,  { &&beqPLUSaddiu, NULL }  ,  { &&beqPLUSaddiu, NULL }  ,  { &&beqPLUSaddiu, NULL }  ,  { &&beqPLUSaddiu, NULL }  ,  { &&beqPLUSaddiu, NULL }  ,  { &&beqPLUSaddiu, NULL } 
 }; 

struct pointer arrayandPLUSandi[T_SIZE] = {  { &&andPLUSandi, NULL }  ,  { &&andPLUSandi, NULL }  ,  { &&andPLUSandi, NULL }  ,  { &&andPLUSandi, NULL }  ,  { &&andPLUSandi, NULL }  ,  { &&andPLUSandi, NULL }  ,  { &&andPLUSandi, NULL }  ,  { &&andPLUSandi, NULL }  ,  { &&andPLUSandi, NULL }  ,  { &&andPLUSandi, NULL } 
 ,  { &&andPLUSandi, NULL }  ,  { &&andPLUSandi, NULL }  ,  { &&andPLUSandi, NULL }  ,  { &&andPLUSandi, NULL }  ,  { &&andPLUSandi, NULL }  ,  { &&andPLUSandi, NULL }  ,  { &&andPLUSandi, NULL }  ,  { &&andPLUSandi, NULL }  ,  { &&andPLUSandi, NULL }  ,  { &&andPLUSandi, NULL } 
 ,  { &&andPLUSandi, NULL }  ,  { &&andPLUSandi, NULL }  ,  { &&andPLUSandi, NULL }  ,  { &&andPLUSandi, NULL }  ,  { &&andPLUSandi, NULL }  ,  { &&andPLUSandi, NULL }  ,  { &&andPLUSandi, NULL }  ,  { &&andPLUSandi, NULL }  ,  { &&andPLUSandi, NULL }  ,  { &&andPLUSandi, NULL } 
 ,  { &&andPLUSandi, NULL }  ,  { &&andPLUSandi, NULL }  ,  { &&andPLUSandi, NULL }  ,  { &&andPLUSandi, NULL }  ,  { &&andPLUSandi, NULL }  ,  { &&andPLUSandiPLUSsubu, NULL }  ,  { &&andPLUSandi, NULL }  ,  { &&andPLUSandi, NULL }  ,  { &&andPLUSandi, NULL }  ,  { &&andPLUSandi, NULL } 
 ,  { &&andPLUSandi, NULL }  ,  { &&andPLUSandi, NULL }  ,  { &&andPLUSandi, NULL }  ,  { &&andPLUSandi, NULL }  ,  { &&andPLUSandi, NULL }  ,  { &&andPLUSandi, NULL }  ,  { &&andPLUSandi, NULL }  ,  { &&andPLUSandi, NULL }  ,  { &&andPLUSandi, NULL }  ,  { &&andPLUSandi, NULL } 
 ,  { &&andPLUSandi, NULL }  ,  { &&andPLUSandi, NULL }  ,  { &&andPLUSandi, NULL }  ,  { &&andPLUSandi, NULL }  ,  { &&andPLUSandi, NULL }  ,  { &&andPLUSandi, NULL }  ,  { &&andPLUSandi, NULL }  ,  { &&andPLUSandi, NULL }  ,  { &&andPLUSandi, NULL }  ,  { &&andPLUSandi, NULL } 
 ,  { &&andPLUSandi, NULL }  ,  { &&andPLUSandi, NULL }  ,  { &&andPLUSandi, NULL }  ,  { &&andPLUSandi, NULL }  ,  { &&andPLUSandi, NULL }  ,  { &&andPLUSandi, NULL }  ,  { &&andPLUSandi, NULL }  ,  { &&andPLUSandi, NULL }  ,  { &&andPLUSandi, NULL }  ,  { &&andPLUSandi, NULL } 
 ,  { &&andPLUSandi, NULL }  ,  { &&andPLUSandi, NULL }  ,  { &&andPLUSandi, NULL }  ,  { &&andPLUSandi, NULL }  ,  { &&andPLUSandi, NULL }  ,  { &&andPLUSandi, NULL }  ,  { &&andPLUSandi, NULL }  ,  { &&andPLUSandi, NULL }  ,  { &&andPLUSandi, NULL }  ,  { &&andPLUSandi, NULL } 
 ,  { &&andPLUSandi, NULL }  ,  { &&andPLUSandi, NULL }  ,  { &&andPLUSandi, NULL }  ,  { &&andPLUSandi, NULL }  ,  { &&andPLUSandi, NULL }  ,  { &&andPLUSandi, NULL }  ,  { &&andPLUSandi, NULL }  ,  { &&andPLUSandi, NULL }  ,  { &&andPLUSandi, NULL }  ,  { &&andPLUSandi, NULL } 
 ,  { &&andPLUSandi, NULL }  ,  { &&andPLUSandi, NULL }  ,  { &&andPLUSandi, NULL }  ,  { &&andPLUSandi, NULL }  ,  { &&andPLUSandi, NULL }  ,  { &&andPLUSandi, NULL }  ,  { &&andPLUSandi, NULL }  ,  { &&andPLUSandi, NULL }  ,  { &&andPLUSandi, NULL }  ,  { &&andPLUSandi, NULL } 
 ,  { &&andPLUSandi, NULL }  ,  { &&andPLUSandi, NULL }  ,  { &&andPLUSandi, NULL }  ,  { &&andPLUSandi, NULL }  ,  { &&andPLUSandi, NULL }  ,  { &&andPLUSandi, NULL }  ,  { &&andPLUSandi, NULL }  ,  { &&andPLUSandi, NULL }  ,  { &&andPLUSandi, NULL }  ,  { &&andPLUSandi, NULL } 
 }; 

struct pointer arraysllPLUSsb[T_SIZE] = {  { &&sllPLUSsb, NULL }  ,  { &&sllPLUSsb, NULL }  ,  { &&sllPLUSsb, NULL }  ,  { &&sllPLUSsb, NULL }  ,  { &&sllPLUSsb, NULL }  ,  { &&sllPLUSsb, NULL }  ,  { &&sllPLUSsb, NULL }  ,  { &&sllPLUSsb, NULL }  ,  { &&sllPLUSsb, NULL }  ,  { &&sllPLUSsb, NULL } 
 ,  { &&sllPLUSsb, NULL }  ,  { &&sllPLUSsb, NULL }  ,  { &&sllPLUSsb, NULL }  ,  { &&sllPLUSsb, NULL }  ,  { &&sllPLUSsb, NULL }  ,  { &&sllPLUSsb, NULL }  ,  { &&sllPLUSsb, NULL }  ,  { &&sllPLUSsb, NULL }  ,  { &&sllPLUSsb, NULL }  ,  { &&sllPLUSsb, NULL } 
 ,  { &&sllPLUSsb, NULL }  ,  { &&sllPLUSsb, NULL }  ,  { &&sllPLUSsb, NULL }  ,  { &&sllPLUSsb, NULL }  ,  { &&sllPLUSsb, NULL }  ,  { &&sllPLUSsb, NULL }  ,  { &&sllPLUSsb, NULL }  ,  { &&sllPLUSsb, NULL }  ,  { &&sllPLUSsb, NULL }  ,  { &&sllPLUSsb, NULL } 
 ,  { &&sllPLUSsb, NULL }  ,  { &&sllPLUSsb, NULL }  ,  { &&sllPLUSsb, NULL }  ,  { &&sllPLUSsb, NULL }  ,  { &&sllPLUSsb, NULL }  ,  { &&sllPLUSsb, NULL }  ,  { &&sllPLUSsb, NULL }  ,  { &&sllPLUSsb, NULL }  ,  { &&sllPLUSsb, NULL }  ,  { &&sllPLUSsb, NULL } 
 ,  { &&sllPLUSsb, NULL }  ,  { &&sllPLUSsb, NULL }  ,  { &&sllPLUSsb, NULL }  ,  { &&sllPLUSsb, NULL }  ,  { &&sllPLUSsb, NULL }  ,  { &&sllPLUSsb, NULL }  ,  { &&sllPLUSsb, NULL }  ,  { &&sllPLUSsb, NULL }  ,  { &&sllPLUSsb, NULL }  ,  { &&sllPLUSsb, NULL } 
 ,  { &&sllPLUSsb, NULL }  ,  { &&sllPLUSsb, NULL }  ,  { &&sllPLUSsb, NULL }  ,  { &&sllPLUSsb, NULL }  ,  { &&sllPLUSsb, NULL }  ,  { &&sllPLUSsb, NULL }  ,  { &&sllPLUSsb, NULL }  ,  { &&sllPLUSsb, NULL }  ,  { &&sllPLUSsb, NULL }  ,  { &&sllPLUSsb, NULL } 
 ,  { &&sllPLUSsb, NULL }  ,  { &&sllPLUSsb, NULL }  ,  { &&sllPLUSsb, NULL }  ,  { &&sllPLUSsb, NULL }  ,  { &&sllPLUSsb, NULL }  ,  { &&sllPLUSsb, NULL }  ,  { &&sllPLUSsb, NULL }  ,  { &&sllPLUSsb, NULL }  ,  { &&sllPLUSsb, NULL }  ,  { &&sllPLUSsb, NULL } 
 ,  { &&sllPLUSsb, NULL }  ,  { &&sllPLUSsb, NULL }  ,  { &&sllPLUSsb, NULL }  ,  { &&sllPLUSsb, NULL }  ,  { &&sllPLUSsb, NULL }  ,  { &&sllPLUSsb, NULL }  ,  { &&sllPLUSsb, NULL }  ,  { &&sllPLUSsb, NULL }  ,  { &&sllPLUSsb, NULL }  ,  { &&sllPLUSsb, NULL } 
 ,  { &&sllPLUSsb, NULL }  ,  { &&sllPLUSsb, NULL }  ,  { &&sllPLUSsb, NULL }  ,  { &&sllPLUSsb, NULL }  ,  { &&sllPLUSsbPLUSsh, NULL }  ,  { &&sllPLUSsb, NULL }  ,  { &&sllPLUSsb, NULL }  ,  { &&sllPLUSsb, NULL }  ,  { &&sllPLUSsb, NULL }  ,  { &&sllPLUSsb, NULL } 
 ,  { &&sllPLUSsb, NULL }  ,  { &&sllPLUSsb, NULL }  ,  { &&sllPLUSsb, NULL }  ,  { &&sllPLUSsb, NULL }  ,  { &&sllPLUSsb, NULL }  ,  { &&sllPLUSsb, NULL }  ,  { &&sllPLUSsb, NULL }  ,  { &&sllPLUSsb, NULL }  ,  { &&sllPLUSsb, NULL }  ,  { &&sllPLUSsb, NULL } 
 ,  { &&sllPLUSsb, NULL }  ,  { &&sllPLUSsb, NULL }  ,  { &&sllPLUSsb, NULL }  ,  { &&sllPLUSsb, NULL }  ,  { &&sllPLUSsb, NULL }  ,  { &&sllPLUSsb, NULL }  ,  { &&sllPLUSsb, NULL }  ,  { &&sllPLUSsb, NULL }  ,  { &&sllPLUSsb, NULL }  ,  { &&sllPLUSsb, NULL } 
 }; 

struct pointer arraymfhiPLUSmult[T_SIZE] = {  { &&mfhiPLUSmult, NULL }  ,  { &&mfhiPLUSmult, NULL }  ,  { &&mfhiPLUSmult, NULL }  ,  { &&mfhiPLUSmult, NULL }  ,  { &&mfhiPLUSmult, NULL }  ,  { &&mfhiPLUSmult, NULL }  ,  { &&mfhiPLUSmult, NULL }  ,  { &&mfhiPLUSmult, NULL }  ,  { &&mfhiPLUSmult, NULL }  ,  { &&mfhiPLUSmult, NULL } 
 ,  { &&mfhiPLUSmult, NULL }  ,  { &&mfhiPLUSmult, NULL }  ,  { &&mfhiPLUSmult, NULL }  ,  { &&mfhiPLUSmult, NULL }  ,  { &&mfhiPLUSmult, NULL }  ,  { &&mfhiPLUSmult, NULL }  ,  { &&mfhiPLUSmultPLUSmfhi, NULL }  ,  { &&mfhiPLUSmult, NULL }  ,  { &&mfhiPLUSmult, NULL }  ,  { &&mfhiPLUSmult, NULL } 
 ,  { &&mfhiPLUSmult, NULL }  ,  { &&mfhiPLUSmult, NULL }  ,  { &&mfhiPLUSmult, NULL }  ,  { &&mfhiPLUSmult, NULL }  ,  { &&mfhiPLUSmult, NULL }  ,  { &&mfhiPLUSmult, NULL }  ,  { &&mfhiPLUSmult, NULL }  ,  { &&mfhiPLUSmult, NULL }  ,  { &&mfhiPLUSmult, NULL }  ,  { &&mfhiPLUSmult, NULL } 
 ,  { &&mfhiPLUSmult, NULL }  ,  { &&mfhiPLUSmult, NULL }  ,  { &&mfhiPLUSmult, NULL }  ,  { &&mfhiPLUSmult, NULL }  ,  { &&mfhiPLUSmult, NULL }  ,  { &&mfhiPLUSmult, NULL }  ,  { &&mfhiPLUSmult, NULL }  ,  { &&mfhiPLUSmult, NULL }  ,  { &&mfhiPLUSmult, NULL }  ,  { &&mfhiPLUSmult, NULL } 
 ,  { &&mfhiPLUSmult, NULL }  ,  { &&mfhiPLUSmult, NULL }  ,  { &&mfhiPLUSmult, NULL }  ,  { &&mfhiPLUSmult, NULL }  ,  { &&mfhiPLUSmult, NULL }  ,  { &&mfhiPLUSmult, NULL }  ,  { &&mfhiPLUSmult, NULL }  ,  { &&mfhiPLUSmult, NULL }  ,  { &&mfhiPLUSmult, NULL }  ,  { &&mfhiPLUSmult, NULL } 
 ,  { &&mfhiPLUSmult, NULL }  ,  { &&mfhiPLUSmult, NULL }  ,  { &&mfhiPLUSmult, NULL }  ,  { &&mfhiPLUSmult, NULL }  ,  { &&mfhiPLUSmult, NULL }  ,  { &&mfhiPLUSmult, NULL }  ,  { &&mfhiPLUSmult, NULL }  ,  { &&mfhiPLUSmult, NULL }  ,  { &&mfhiPLUSmult, NULL }  ,  { &&mfhiPLUSmult, NULL } 
 ,  { &&mfhiPLUSmult, NULL }  ,  { &&mfhiPLUSmult, NULL }  ,  { &&mfhiPLUSmult, NULL }  ,  { &&mfhiPLUSmult, NULL }  ,  { &&mfhiPLUSmult, NULL }  ,  { &&mfhiPLUSmult, NULL }  ,  { &&mfhiPLUSmult, NULL }  ,  { &&mfhiPLUSmult, NULL }  ,  { &&mfhiPLUSmult, NULL }  ,  { &&mfhiPLUSmult, NULL } 
 ,  { &&mfhiPLUSmult, NULL }  ,  { &&mfhiPLUSmult, NULL }  ,  { &&mfhiPLUSmult, NULL }  ,  { &&mfhiPLUSmult, NULL }  ,  { &&mfhiPLUSmult, NULL }  ,  { &&mfhiPLUSmult, NULL }  ,  { &&mfhiPLUSmult, NULL }  ,  { &&mfhiPLUSmult, NULL }  ,  { &&mfhiPLUSmult, NULL }  ,  { &&mfhiPLUSmult, NULL } 
 ,  { &&mfhiPLUSmult, NULL }  ,  { &&mfhiPLUSmult, NULL }  ,  { &&mfhiPLUSmult, NULL }  ,  { &&mfhiPLUSmult, NULL }  ,  { &&mfhiPLUSmult, NULL }  ,  { &&mfhiPLUSmult, NULL }  ,  { &&mfhiPLUSmult, NULL }  ,  { &&mfhiPLUSmult, NULL }  ,  { &&mfhiPLUSmult, NULL }  ,  { &&mfhiPLUSmult, NULL } 
 ,  { &&mfhiPLUSmult, NULL }  ,  { &&mfhiPLUSmult, NULL }  ,  { &&mfhiPLUSmult, NULL }  ,  { &&mfhiPLUSmult, NULL }  ,  { &&mfhiPLUSmult, NULL }  ,  { &&mfhiPLUSmult, NULL }  ,  { &&mfhiPLUSmult, NULL }  ,  { &&mfhiPLUSmult, NULL }  ,  { &&mfhiPLUSmult, NULL }  ,  { &&mfhiPLUSmult, NULL } 
 ,  { &&mfhiPLUSmult, NULL }  ,  { &&mfhiPLUSmult, NULL }  ,  { &&mfhiPLUSmult, NULL }  ,  { &&mfhiPLUSmult, NULL }  ,  { &&mfhiPLUSmult, NULL }  ,  { &&mfhiPLUSmult, NULL }  ,  { &&mfhiPLUSmult, NULL }  ,  { &&mfhiPLUSmult, NULL }  ,  { &&mfhiPLUSmult, NULL }  ,  { &&mfhiPLUSmult, NULL } 
 }; 

struct pointer arraynorPLUSsrl[T_SIZE] = {  { &&norPLUSsrl, NULL }  ,  { &&norPLUSsrl, NULL }  ,  { &&norPLUSsrl, NULL }  ,  { &&norPLUSsrl, NULL }  ,  { &&norPLUSsrl, NULL }  ,  { &&norPLUSsrl, NULL }  ,  { &&norPLUSsrl, NULL }  ,  { &&norPLUSsrl, NULL }  ,  { &&norPLUSsrl, NULL }  ,  { &&norPLUSsrl, NULL } 
 ,  { &&norPLUSsrl, NULL }  ,  { &&norPLUSsrl, NULL }  ,  { &&norPLUSsrl, NULL }  ,  { &&norPLUSsrl, NULL }  ,  { &&norPLUSsrl, NULL }  ,  { &&norPLUSsrl, NULL }  ,  { &&norPLUSsrl, NULL }  ,  { &&norPLUSsrl, NULL }  ,  { &&norPLUSsrl, NULL }  ,  { &&norPLUSsrl, NULL } 
 ,  { &&norPLUSsrl, NULL }  ,  { &&norPLUSsrl, NULL }  ,  { &&norPLUSsrl, NULL }  ,  { &&norPLUSsrl, NULL }  ,  { &&norPLUSsrl, NULL }  ,  { &&norPLUSsrl, NULL }  ,  { &&norPLUSsrl, NULL }  ,  { &&norPLUSsrl, NULL }  ,  { &&norPLUSsrl, NULL }  ,  { &&norPLUSsrl, NULL } 
 ,  { &&norPLUSsrl, NULL }  ,  { &&norPLUSsrl, NULL }  ,  { &&norPLUSsrl, NULL }  ,  { &&norPLUSsrl, NULL }  ,  { &&norPLUSsrl, NULL }  ,  { &&norPLUSsrl, NULL }  ,  { &&norPLUSsrl, NULL }  ,  { &&norPLUSsrl, NULL }  ,  { &&norPLUSsrl, NULL }  ,  { &&norPLUSsrl, NULL } 
 ,  { &&norPLUSsrl, NULL }  ,  { &&norPLUSsrl, NULL }  ,  { &&norPLUSsrl, NULL }  ,  { &&norPLUSsrl, NULL }  ,  { &&norPLUSsrl, NULL }  ,  { &&norPLUSsrl, NULL }  ,  { &&norPLUSsrl, NULL }  ,  { &&norPLUSsrl, NULL }  ,  { &&norPLUSsrl, NULL }  ,  { &&norPLUSsrl, NULL } 
 ,  { &&norPLUSsrl, NULL }  ,  { &&norPLUSsrl, NULL }  ,  { &&norPLUSsrl, NULL }  ,  { &&norPLUSsrl, NULL }  ,  { &&norPLUSsrl, NULL }  ,  { &&norPLUSsrl, NULL }  ,  { &&norPLUSsrl, NULL }  ,  { &&norPLUSsrl, NULL }  ,  { &&norPLUSsrlPLUSlui, NULL }  ,  { &&norPLUSsrl, NULL } 
 ,  { &&norPLUSsrl, NULL }  ,  { &&norPLUSsrl, NULL }  ,  { &&norPLUSsrl, NULL }  ,  { &&norPLUSsrl, NULL }  ,  { &&norPLUSsrl, NULL }  ,  { &&norPLUSsrl, NULL }  ,  { &&norPLUSsrl, NULL }  ,  { &&norPLUSsrl, NULL }  ,  { &&norPLUSsrl, NULL }  ,  { &&norPLUSsrl, NULL } 
 ,  { &&norPLUSsrl, NULL }  ,  { &&norPLUSsrl, NULL }  ,  { &&norPLUSsrl, NULL }  ,  { &&norPLUSsrl, NULL }  ,  { &&norPLUSsrl, NULL }  ,  { &&norPLUSsrl, NULL }  ,  { &&norPLUSsrl, NULL }  ,  { &&norPLUSsrl, NULL }  ,  { &&norPLUSsrl, NULL }  ,  { &&norPLUSsrl, NULL } 
 ,  { &&norPLUSsrl, NULL }  ,  { &&norPLUSsrl, NULL }  ,  { &&norPLUSsrl, NULL }  ,  { &&norPLUSsrl, NULL }  ,  { &&norPLUSsrl, NULL }  ,  { &&norPLUSsrl, NULL }  ,  { &&norPLUSsrl, NULL }  ,  { &&norPLUSsrl, NULL }  ,  { &&norPLUSsrl, NULL }  ,  { &&norPLUSsrl, NULL } 
 ,  { &&norPLUSsrl, NULL }  ,  { &&norPLUSsrl, NULL }  ,  { &&norPLUSsrl, NULL }  ,  { &&norPLUSsrl, NULL }  ,  { &&norPLUSsrl, NULL }  ,  { &&norPLUSsrl, NULL }  ,  { &&norPLUSsrl, NULL }  ,  { &&norPLUSsrl, NULL }  ,  { &&norPLUSsrl, NULL }  ,  { &&norPLUSsrl, NULL } 
 ,  { &&norPLUSsrl, NULL }  ,  { &&norPLUSsrl, NULL }  ,  { &&norPLUSsrl, NULL }  ,  { &&norPLUSsrl, NULL }  ,  { &&norPLUSsrl, NULL }  ,  { &&norPLUSsrl, NULL }  ,  { &&norPLUSsrl, NULL }  ,  { &&norPLUSsrl, NULL }  ,  { &&norPLUSsrl, NULL }  ,  { &&norPLUSsrl, NULL } 
 }; 

struct pointer arraylbuPLUSsubu[T_SIZE] = {  { &&lbuPLUSsubu, NULL }  ,  { &&lbuPLUSsubu, NULL }  ,  { &&lbuPLUSsubu, NULL }  ,  { &&lbuPLUSsubu, NULL }  ,  { &&lbuPLUSsubu, NULL }  ,  { &&lbuPLUSsubu, NULL }  ,  { &&lbuPLUSsubu, NULL }  ,  { &&lbuPLUSsubu, NULL }  ,  { &&lbuPLUSsubu, NULL }  ,  { &&lbuPLUSsubu, NULL } 
 ,  { &&lbuPLUSsubu, NULL }  ,  { &&lbuPLUSsubu, NULL }  ,  { &&lbuPLUSsubu, NULL }  ,  { &&lbuPLUSsubu, NULL }  ,  { &&lbuPLUSsubu, NULL }  ,  { &&lbuPLUSsubu, NULL }  ,  { &&lbuPLUSsubu, NULL }  ,  { &&lbuPLUSsubu, NULL }  ,  { &&lbuPLUSsubu, NULL }  ,  { &&lbuPLUSsubu, NULL } 
 ,  { &&lbuPLUSsubu, NULL }  ,  { &&lbuPLUSsubu, NULL }  ,  { &&lbuPLUSsubu, NULL }  ,  { &&lbuPLUSsubu, NULL }  ,  { &&lbuPLUSsubu, NULL }  ,  { &&lbuPLUSsubu, NULL }  ,  { &&lbuPLUSsubu, NULL }  ,  { &&lbuPLUSsubu, NULL }  ,  { &&lbuPLUSsubu, NULL }  ,  { &&lbuPLUSsubu, NULL } 
 ,  { &&lbuPLUSsubu, NULL }  ,  { &&lbuPLUSsubu, NULL }  ,  { &&lbuPLUSsubu, NULL }  ,  { &&lbuPLUSsubu, NULL }  ,  { &&lbuPLUSsubu, NULL }  ,  { &&lbuPLUSsubu, NULL }  ,  { &&lbuPLUSsubuPLUSand, NULL }  ,  { &&lbuPLUSsubu, NULL }  ,  { &&lbuPLUSsubu, NULL }  ,  { &&lbuPLUSsubu, NULL } 
 ,  { &&lbuPLUSsubu, NULL }  ,  { &&lbuPLUSsubu, NULL }  ,  { &&lbuPLUSsubu, NULL }  ,  { &&lbuPLUSsubu, NULL }  ,  { &&lbuPLUSsubu, NULL }  ,  { &&lbuPLUSsubu, NULL }  ,  { &&lbuPLUSsubu, NULL }  ,  { &&lbuPLUSsubu, NULL }  ,  { &&lbuPLUSsubu, NULL }  ,  { &&lbuPLUSsubu, NULL } 
 ,  { &&lbuPLUSsubu, NULL }  ,  { &&lbuPLUSsubu, NULL }  ,  { &&lbuPLUSsubu, NULL }  ,  { &&lbuPLUSsubu, NULL }  ,  { &&lbuPLUSsubu, NULL }  ,  { &&lbuPLUSsubu, NULL }  ,  { &&lbuPLUSsubu, NULL }  ,  { &&lbuPLUSsubu, NULL }  ,  { &&lbuPLUSsubu, NULL }  ,  { &&lbuPLUSsubu, NULL } 
 ,  { &&lbuPLUSsubu, NULL }  ,  { &&lbuPLUSsubu, NULL }  ,  { &&lbuPLUSsubu, NULL }  ,  { &&lbuPLUSsubu, NULL }  ,  { &&lbuPLUSsubu, NULL }  ,  { &&lbuPLUSsubu, NULL }  ,  { &&lbuPLUSsubu, NULL }  ,  { &&lbuPLUSsubu, NULL }  ,  { &&lbuPLUSsubu, NULL }  ,  { &&lbuPLUSsubu, NULL } 
 ,  { &&lbuPLUSsubu, NULL }  ,  { &&lbuPLUSsubu, NULL }  ,  { &&lbuPLUSsubu, NULL }  ,  { &&lbuPLUSsubu, NULL }  ,  { &&lbuPLUSsubu, NULL }  ,  { &&lbuPLUSsubu, NULL }  ,  { &&lbuPLUSsubu, NULL }  ,  { &&lbuPLUSsubu, NULL }  ,  { &&lbuPLUSsubu, NULL }  ,  { &&lbuPLUSsubu, NULL } 
 ,  { &&lbuPLUSsubu, NULL }  ,  { &&lbuPLUSsubu, NULL }  ,  { &&lbuPLUSsubu, NULL }  ,  { &&lbuPLUSsubu, NULL }  ,  { &&lbuPLUSsubu, NULL }  ,  { &&lbuPLUSsubu, NULL }  ,  { &&lbuPLUSsubu, NULL }  ,  { &&lbuPLUSsubu, NULL }  ,  { &&lbuPLUSsubu, NULL }  ,  { &&lbuPLUSsubu, NULL } 
 ,  { &&lbuPLUSsubu, NULL }  ,  { &&lbuPLUSsubu, NULL }  ,  { &&lbuPLUSsubu, NULL }  ,  { &&lbuPLUSsubu, NULL }  ,  { &&lbuPLUSsubu, NULL }  ,  { &&lbuPLUSsubu, NULL }  ,  { &&lbuPLUSsubu, NULL }  ,  { &&lbuPLUSsubu, NULL }  ,  { &&lbuPLUSsubu, NULL }  ,  { &&lbuPLUSsubu, NULL } 
 ,  { &&lbuPLUSsubu, NULL }  ,  { &&lbuPLUSsubu, NULL }  ,  { &&lbuPLUSsubu, NULL }  ,  { &&lbuPLUSsubu, NULL }  ,  { &&lbuPLUSsubu, NULL }  ,  { &&lbuPLUSsubu, NULL }  ,  { &&lbuPLUSsubu, NULL }  ,  { &&lbuPLUSsubu, NULL }  ,  { &&lbuPLUSsubu, NULL }  ,  { &&lbuPLUSsubu, NULL } 
 }; 

struct pointer arraysllPLUSjal[T_SIZE] = {  { &&sllPLUSjal, NULL }  ,  { &&sllPLUSjal, NULL }  ,  { &&sllPLUSjal, NULL }  ,  { &&sllPLUSjal, NULL }  ,  { &&sllPLUSjal, NULL }  ,  { &&sllPLUSjal, NULL }  ,  { &&sllPLUSjal, NULL }  ,  { &&sllPLUSjal, NULL }  ,  { &&sllPLUSjal, NULL }  ,  { &&sllPLUSjal, NULL } 
 ,  { &&sllPLUSjal, NULL }  ,  { &&sllPLUSjal, NULL }  ,  { &&sllPLUSjal, NULL }  ,  { &&sllPLUSjal, NULL }  ,  { &&sllPLUSjal, NULL }  ,  { &&sllPLUSjal, NULL }  ,  { &&sllPLUSjal, NULL }  ,  { &&sllPLUSjal, NULL }  ,  { &&sllPLUSjal, NULL }  ,  { &&sllPLUSjal, NULL } 
 ,  { &&sllPLUSjal, NULL }  ,  { &&sllPLUSjal, NULL }  ,  { &&sllPLUSjal, NULL }  ,  { &&sllPLUSjal, NULL }  ,  { &&sllPLUSjal, NULL }  ,  { &&sllPLUSjal, NULL }  ,  { &&sllPLUSjal, NULL }  ,  { &&sllPLUSjal, NULL }  ,  { &&sllPLUSjal, NULL }  ,  { &&sllPLUSjal, NULL } 
 ,  { &&sllPLUSjal, NULL }  ,  { &&sllPLUSjal, NULL }  ,  { &&sllPLUSjal, NULL }  ,  { &&sllPLUSjalPLUSaddu, NULL }  ,  { &&sllPLUSjal, NULL }  ,  { &&sllPLUSjal, NULL }  ,  { &&sllPLUSjal, NULL }  ,  { &&sllPLUSjal, NULL }  ,  { &&sllPLUSjal, NULL }  ,  { &&sllPLUSjal, NULL } 
 ,  { &&sllPLUSjal, NULL }  ,  { &&sllPLUSjal, NULL }  ,  { &&sllPLUSjal, NULL }  ,  { &&sllPLUSjal, NULL }  ,  { &&sllPLUSjal, NULL }  ,  { &&sllPLUSjal, NULL }  ,  { &&sllPLUSjal, NULL }  ,  { &&sllPLUSjal, NULL }  ,  { &&sllPLUSjal, NULL }  ,  { &&sllPLUSjal, NULL } 
 ,  { &&sllPLUSjal, NULL }  ,  { &&sllPLUSjal, NULL }  ,  { &&sllPLUSjal, NULL }  ,  { &&sllPLUSjal, NULL }  ,  { &&sllPLUSjal, NULL }  ,  { &&sllPLUSjal, NULL }  ,  { &&sllPLUSjal, NULL }  ,  { &&sllPLUSjal, NULL }  ,  { &&sllPLUSjal, NULL }  ,  { &&sllPLUSjal, NULL } 
 ,  { &&sllPLUSjal, NULL }  ,  { &&sllPLUSjal, NULL }  ,  { &&sllPLUSjal, NULL }  ,  { &&sllPLUSjal, NULL }  ,  { &&sllPLUSjal, NULL }  ,  { &&sllPLUSjal, NULL }  ,  { &&sllPLUSjal, NULL }  ,  { &&sllPLUSjal, NULL }  ,  { &&sllPLUSjal, NULL }  ,  { &&sllPLUSjal, NULL } 
 ,  { &&sllPLUSjal, NULL }  ,  { &&sllPLUSjal, NULL }  ,  { &&sllPLUSjal, NULL }  ,  { &&sllPLUSjal, NULL }  ,  { &&sllPLUSjal, NULL }  ,  { &&sllPLUSjal, NULL }  ,  { &&sllPLUSjal, NULL }  ,  { &&sllPLUSjal, NULL }  ,  { &&sllPLUSjal, NULL }  ,  { &&sllPLUSjal, NULL } 
 ,  { &&sllPLUSjal, NULL }  ,  { &&sllPLUSjal, NULL }  ,  { &&sllPLUSjal, NULL }  ,  { &&sllPLUSjal, NULL }  ,  { &&sllPLUSjal, NULL }  ,  { &&sllPLUSjal, NULL }  ,  { &&sllPLUSjal, NULL }  ,  { &&sllPLUSjal, NULL }  ,  { &&sllPLUSjal, NULL }  ,  { &&sllPLUSjal, NULL } 
 ,  { &&sllPLUSjal, NULL }  ,  { &&sllPLUSjal, NULL }  ,  { &&sllPLUSjal, NULL }  ,  { &&sllPLUSjal, NULL }  ,  { &&sllPLUSjal, NULL }  ,  { &&sllPLUSjal, NULL }  ,  { &&sllPLUSjal, NULL }  ,  { &&sllPLUSjal, NULL }  ,  { &&sllPLUSjal, NULL }  ,  { &&sllPLUSjal, NULL } 
 ,  { &&sllPLUSjal, NULL }  ,  { &&sllPLUSjal, NULL }  ,  { &&sllPLUSjal, NULL }  ,  { &&sllPLUSjal, NULL }  ,  { &&sllPLUSjal, NULL }  ,  { &&sllPLUSjal, NULL }  ,  { &&sllPLUSjal, NULL }  ,  { &&sllPLUSjal, NULL }  ,  { &&sllPLUSjal, NULL }  ,  { &&sllPLUSjal, NULL } 
 }; 

struct pointer arrayxorPLUSbne[T_SIZE] = {  { &&xorPLUSbne, NULL }  ,  { &&xorPLUSbne, NULL }  ,  { &&xorPLUSbne, NULL }  ,  { &&xorPLUSbne, NULL }  ,  { &&xorPLUSbne, NULL }  ,  { &&xorPLUSbne, NULL }  ,  { &&xorPLUSbne, NULL }  ,  { &&xorPLUSbne, NULL }  ,  { &&xorPLUSbne, NULL }  ,  { &&xorPLUSbne, NULL } 
 ,  { &&xorPLUSbne, NULL }  ,  { &&xorPLUSbne, NULL }  ,  { &&xorPLUSbne, NULL }  ,  { &&xorPLUSbne, NULL }  ,  { &&xorPLUSbne, NULL }  ,  { &&xorPLUSbne, NULL }  ,  { &&xorPLUSbne, NULL }  ,  { &&xorPLUSbne, NULL }  ,  { &&xorPLUSbne, NULL }  ,  { &&xorPLUSbne, NULL } 
 ,  { &&xorPLUSbne, NULL }  ,  { &&xorPLUSbne, NULL }  ,  { &&xorPLUSbne, NULL }  ,  { &&xorPLUSbne, NULL }  ,  { &&xorPLUSbne, NULL }  ,  { &&xorPLUSbne, NULL }  ,  { &&xorPLUSbne, NULL }  ,  { &&xorPLUSbne, NULL }  ,  { &&xorPLUSbne, NULL }  ,  { &&xorPLUSbne, NULL } 
 ,  { &&xorPLUSbne, NULL }  ,  { &&xorPLUSbne, NULL }  ,  { &&xorPLUSbne, NULL }  ,  { &&xorPLUSbnePLUSaddu, NULL }  ,  { &&xorPLUSbne, NULL }  ,  { &&xorPLUSbne, NULL }  ,  { &&xorPLUSbne, NULL }  ,  { &&xorPLUSbne, NULL }  ,  { &&xorPLUSbne, NULL }  ,  { &&xorPLUSbne, NULL } 
 ,  { &&xorPLUSbne, NULL }  ,  { &&xorPLUSbne, NULL }  ,  { &&xorPLUSbne, NULL }  ,  { &&xorPLUSbne, NULL }  ,  { &&xorPLUSbne, NULL }  ,  { &&xorPLUSbne, NULL }  ,  { &&xorPLUSbne, NULL }  ,  { &&xorPLUSbne, NULL }  ,  { &&xorPLUSbne, NULL }  ,  { &&xorPLUSbne, NULL } 
 ,  { &&xorPLUSbne, NULL }  ,  { &&xorPLUSbne, NULL }  ,  { &&xorPLUSbne, NULL }  ,  { &&xorPLUSbne, NULL }  ,  { &&xorPLUSbne, NULL }  ,  { &&xorPLUSbne, NULL }  ,  { &&xorPLUSbne, NULL }  ,  { &&xorPLUSbne, NULL }  ,  { &&xorPLUSbne, NULL }  ,  { &&xorPLUSbne, NULL } 
 ,  { &&xorPLUSbne, NULL }  ,  { &&xorPLUSbne, NULL }  ,  { &&xorPLUSbne, NULL }  ,  { &&xorPLUSbne, NULL }  ,  { &&xorPLUSbne, NULL }  ,  { &&xorPLUSbne, NULL }  ,  { &&xorPLUSbne, NULL }  ,  { &&xorPLUSbne, NULL }  ,  { &&xorPLUSbne, NULL }  ,  { &&xorPLUSbne, NULL } 
 ,  { &&xorPLUSbne, NULL }  ,  { &&xorPLUSbne, NULL }  ,  { &&xorPLUSbne, NULL }  ,  { &&xorPLUSbne, NULL }  ,  { &&xorPLUSbne, NULL }  ,  { &&xorPLUSbne, NULL }  ,  { &&xorPLUSbne, NULL }  ,  { &&xorPLUSbne, NULL }  ,  { &&xorPLUSbne, NULL }  ,  { &&xorPLUSbne, NULL } 
 ,  { &&xorPLUSbne, NULL }  ,  { &&xorPLUSbne, NULL }  ,  { &&xorPLUSbne, NULL }  ,  { &&xorPLUSbne, NULL }  ,  { &&xorPLUSbne, NULL }  ,  { &&xorPLUSbne, NULL }  ,  { &&xorPLUSbne, NULL }  ,  { &&xorPLUSbne, NULL }  ,  { &&xorPLUSbne, NULL }  ,  { &&xorPLUSbne, NULL } 
 ,  { &&xorPLUSbne, NULL }  ,  { &&xorPLUSbne, NULL }  ,  { &&xorPLUSbne, NULL }  ,  { &&xorPLUSbne, NULL }  ,  { &&xorPLUSbne, NULL }  ,  { &&xorPLUSbne, NULL }  ,  { &&xorPLUSbne, NULL }  ,  { &&xorPLUSbne, NULL }  ,  { &&xorPLUSbne, NULL }  ,  { &&xorPLUSbne, NULL } 
 ,  { &&xorPLUSbne, NULL }  ,  { &&xorPLUSbne, NULL }  ,  { &&xorPLUSbne, NULL }  ,  { &&xorPLUSbne, NULL }  ,  { &&xorPLUSbne, NULL }  ,  { &&xorPLUSbne, NULL }  ,  { &&xorPLUSbne, NULL }  ,  { &&xorPLUSbne, NULL }  ,  { &&xorPLUSbne, NULL }  ,  { &&xorPLUSbne, NULL } 
 }; 

struct pointer arrayaddiuPLUSaddiu[T_SIZE] = {  { &&addiuPLUSaddiu, NULL }  ,  { &&addiuPLUSaddiu, NULL }  ,  { &&addiuPLUSaddiuPLUSsrl, NULL }  ,  { &&addiuPLUSaddiu, NULL }  ,  { &&addiuPLUSaddiu, NULL }  ,  { &&addiuPLUSaddiu, NULL }  ,  { &&addiuPLUSaddiu, NULL }  ,  { &&addiuPLUSaddiu, NULL }  ,  { &&addiuPLUSaddiuPLUSjr, NULL }  ,  { &&addiuPLUSaddiu, NULL } 
 ,  { &&addiuPLUSaddiu, NULL }  ,  { &&addiuPLUSaddiu, NULL }  ,  { &&addiuPLUSaddiuPLUSsysc, NULL }  ,  { &&addiuPLUSaddiu, NULL }  ,  { &&addiuPLUSaddiu, NULL }  ,  { &&addiuPLUSaddiu, NULL }  ,  { &&addiuPLUSaddiu, NULL }  ,  { &&addiuPLUSaddiu, NULL }  ,  { &&addiuPLUSaddiu, NULL }  ,  { &&addiuPLUSaddiu, NULL } 
 ,  { &&addiuPLUSaddiu, NULL }  ,  { &&addiuPLUSaddiu, NULL }  ,  { &&addiuPLUSaddiu, NULL }  ,  { &&addiuPLUSaddiu, NULL }  ,  { &&addiuPLUSaddiu, NULL }  ,  { &&addiuPLUSaddiu, NULL }  ,  { &&addiuPLUSaddiu, NULL }  ,  { &&addiuPLUSaddiu, NULL }  ,  { &&addiuPLUSaddiu, NULL }  ,  { &&addiuPLUSaddiu, NULL } 
 ,  { &&addiuPLUSaddiu, NULL }  ,  { &&addiuPLUSaddiu, NULL }  ,  { &&addiuPLUSaddiu, NULL }  ,  { &&addiuPLUSaddiuPLUSaddu, NULL }  ,  { &&addiuPLUSaddiu, NULL }  ,  { &&addiuPLUSaddiuPLUSsubu, NULL }  ,  { &&addiuPLUSaddiu, NULL }  ,  { &&addiuPLUSaddiu, NULL }  ,  { &&addiuPLUSaddiu, NULL }  ,  { &&addiuPLUSaddiu, NULL } 
 ,  { &&addiuPLUSaddiu, NULL }  ,  { &&addiuPLUSaddiu, NULL }  ,  { &&addiuPLUSaddiuPLUSslt, NULL }  ,  { &&addiuPLUSaddiu, NULL }  ,  { &&addiuPLUSaddiu, NULL }  ,  { &&addiuPLUSaddiuPLUSjump, NULL }  ,  { &&addiuPLUSaddiuPLUSjal, NULL }  ,  { &&addiuPLUSaddiu, NULL }  ,  { &&addiuPLUSaddiuPLUSbne, NULL }  ,  { &&addiuPLUSaddiu, NULL } 
 ,  { &&addiuPLUSaddiu, NULL }  ,  { &&addiuPLUSaddiu, NULL }  ,  { &&addiuPLUSaddiuPLUSaddiu, NULL }  ,  { &&addiuPLUSaddiuPLUSslti, NULL }  ,  { &&addiuPLUSaddiu, NULL }  ,  { &&addiuPLUSaddiuPLUSandi, NULL }  ,  { &&addiuPLUSaddiu, NULL }  ,  { &&addiuPLUSaddiu, NULL }  ,  { &&addiuPLUSaddiuPLUSlui, NULL }  ,  { &&addiuPLUSaddiu, NULL } 
 ,  { &&addiuPLUSaddiu, NULL }  ,  { &&addiuPLUSaddiu, NULL }  ,  { &&addiuPLUSaddiu, NULL }  ,  { &&addiuPLUSaddiu, NULL }  ,  { &&addiuPLUSaddiu, NULL }  ,  { &&addiuPLUSaddiu, NULL }  ,  { &&addiuPLUSaddiu, NULL }  ,  { &&addiuPLUSaddiu, NULL }  ,  { &&addiuPLUSaddiu, NULL }  ,  { &&addiuPLUSaddiu, NULL } 
 ,  { &&addiuPLUSaddiu, NULL }  ,  { &&addiuPLUSaddiu, NULL }  ,  { &&addiuPLUSaddiu, NULL }  ,  { &&addiuPLUSaddiu, NULL }  ,  { &&addiuPLUSaddiu, NULL }  ,  { &&addiuPLUSaddiu, NULL }  ,  { &&addiuPLUSaddiu, NULL }  ,  { &&addiuPLUSaddiu, NULL }  ,  { &&addiuPLUSaddiuPLUSlw, NULL }  ,  { &&addiuPLUSaddiu, NULL } 
 ,  { &&addiuPLUSaddiu, NULL }  ,  { &&addiuPLUSaddiu, NULL }  ,  { &&addiuPLUSaddiu, NULL }  ,  { &&addiuPLUSaddiu, NULL }  ,  { &&addiuPLUSaddiu, NULL }  ,  { &&addiuPLUSaddiu, NULL }  ,  { &&addiuPLUSaddiuPLUSsw, NULL }  ,  { &&addiuPLUSaddiu, NULL }  ,  { &&addiuPLUSaddiu, NULL }  ,  { &&addiuPLUSaddiu, NULL } 
 ,  { &&addiuPLUSaddiu, NULL }  ,  { &&addiuPLUSaddiu, NULL }  ,  { &&addiuPLUSaddiu, NULL }  ,  { &&addiuPLUSaddiu, NULL }  ,  { &&addiuPLUSaddiu, NULL }  ,  { &&addiuPLUSaddiu, NULL }  ,  { &&addiuPLUSaddiu, NULL }  ,  { &&addiuPLUSaddiu, NULL }  ,  { &&addiuPLUSaddiu, NULL }  ,  { &&addiuPLUSaddiu, NULL } 
 ,  { &&addiuPLUSaddiu, NULL }  ,  { &&addiuPLUSaddiu, NULL }  ,  { &&addiuPLUSaddiu, NULL }  ,  { &&addiuPLUSaddiu, NULL }  ,  { &&addiuPLUSaddiu, NULL }  ,  { &&addiuPLUSaddiu, NULL }  ,  { &&addiuPLUSaddiu, NULL }  ,  { &&addiuPLUSaddiu, NULL }  ,  { &&addiuPLUSaddiu, NULL }  ,  { &&addiuPLUSaddiu, NULL } 
 }; 

struct pointer arrayxorPLUSslti[T_SIZE] = {  { &&xorPLUSslti, NULL }  ,  { &&xorPLUSslti, NULL }  ,  { &&xorPLUSslti, NULL }  ,  { &&xorPLUSslti, NULL }  ,  { &&xorPLUSslti, NULL }  ,  { &&xorPLUSslti, NULL }  ,  { &&xorPLUSslti, NULL }  ,  { &&xorPLUSslti, NULL }  ,  { &&xorPLUSslti, NULL }  ,  { &&xorPLUSslti, NULL } 
 ,  { &&xorPLUSslti, NULL }  ,  { &&xorPLUSsltiPLUSmovn, NULL }  ,  { &&xorPLUSslti, NULL }  ,  { &&xorPLUSslti, NULL }  ,  { &&xorPLUSslti, NULL }  ,  { &&xorPLUSslti, NULL }  ,  { &&xorPLUSslti, NULL }  ,  { &&xorPLUSslti, NULL }  ,  { &&xorPLUSslti, NULL }  ,  { &&xorPLUSslti, NULL } 
 ,  { &&xorPLUSslti, NULL }  ,  { &&xorPLUSslti, NULL }  ,  { &&xorPLUSslti, NULL }  ,  { &&xorPLUSslti, NULL }  ,  { &&xorPLUSslti, NULL }  ,  { &&xorPLUSslti, NULL }  ,  { &&xorPLUSslti, NULL }  ,  { &&xorPLUSslti, NULL }  ,  { &&xorPLUSslti, NULL }  ,  { &&xorPLUSslti, NULL } 
 ,  { &&xorPLUSslti, NULL }  ,  { &&xorPLUSslti, NULL }  ,  { &&xorPLUSslti, NULL }  ,  { &&xorPLUSslti, NULL }  ,  { &&xorPLUSslti, NULL }  ,  { &&xorPLUSslti, NULL }  ,  { &&xorPLUSslti, NULL }  ,  { &&xorPLUSslti, NULL }  ,  { &&xorPLUSslti, NULL }  ,  { &&xorPLUSslti, NULL } 
 ,  { &&xorPLUSslti, NULL }  ,  { &&xorPLUSslti, NULL }  ,  { &&xorPLUSslti, NULL }  ,  { &&xorPLUSslti, NULL }  ,  { &&xorPLUSslti, NULL }  ,  { &&xorPLUSslti, NULL }  ,  { &&xorPLUSslti, NULL }  ,  { &&xorPLUSslti, NULL }  ,  { &&xorPLUSslti, NULL }  ,  { &&xorPLUSslti, NULL } 
 ,  { &&xorPLUSslti, NULL }  ,  { &&xorPLUSslti, NULL }  ,  { &&xorPLUSslti, NULL }  ,  { &&xorPLUSslti, NULL }  ,  { &&xorPLUSslti, NULL }  ,  { &&xorPLUSslti, NULL }  ,  { &&xorPLUSslti, NULL }  ,  { &&xorPLUSslti, NULL }  ,  { &&xorPLUSslti, NULL }  ,  { &&xorPLUSslti, NULL } 
 ,  { &&xorPLUSslti, NULL }  ,  { &&xorPLUSslti, NULL }  ,  { &&xorPLUSslti, NULL }  ,  { &&xorPLUSslti, NULL }  ,  { &&xorPLUSslti, NULL }  ,  { &&xorPLUSslti, NULL }  ,  { &&xorPLUSslti, NULL }  ,  { &&xorPLUSslti, NULL }  ,  { &&xorPLUSslti, NULL }  ,  { &&xorPLUSslti, NULL } 
 ,  { &&xorPLUSslti, NULL }  ,  { &&xorPLUSslti, NULL }  ,  { &&xorPLUSslti, NULL }  ,  { &&xorPLUSslti, NULL }  ,  { &&xorPLUSslti, NULL }  ,  { &&xorPLUSslti, NULL }  ,  { &&xorPLUSslti, NULL }  ,  { &&xorPLUSslti, NULL }  ,  { &&xorPLUSslti, NULL }  ,  { &&xorPLUSslti, NULL } 
 ,  { &&xorPLUSslti, NULL }  ,  { &&xorPLUSslti, NULL }  ,  { &&xorPLUSslti, NULL }  ,  { &&xorPLUSslti, NULL }  ,  { &&xorPLUSslti, NULL }  ,  { &&xorPLUSslti, NULL }  ,  { &&xorPLUSslti, NULL }  ,  { &&xorPLUSslti, NULL }  ,  { &&xorPLUSslti, NULL }  ,  { &&xorPLUSslti, NULL } 
 ,  { &&xorPLUSslti, NULL }  ,  { &&xorPLUSslti, NULL }  ,  { &&xorPLUSslti, NULL }  ,  { &&xorPLUSslti, NULL }  ,  { &&xorPLUSslti, NULL }  ,  { &&xorPLUSslti, NULL }  ,  { &&xorPLUSslti, NULL }  ,  { &&xorPLUSslti, NULL }  ,  { &&xorPLUSslti, NULL }  ,  { &&xorPLUSslti, NULL } 
 ,  { &&xorPLUSslti, NULL }  ,  { &&xorPLUSslti, NULL }  ,  { &&xorPLUSslti, NULL }  ,  { &&xorPLUSslti, NULL }  ,  { &&xorPLUSslti, NULL }  ,  { &&xorPLUSslti, NULL }  ,  { &&xorPLUSslti, NULL }  ,  { &&xorPLUSslti, NULL }  ,  { &&xorPLUSslti, NULL }  ,  { &&xorPLUSslti, NULL } 
 }; 

struct pointer arrayorPLUSlui[T_SIZE] = {  { &&orPLUSlui, NULL }  ,  { &&orPLUSlui, NULL }  ,  { &&orPLUSlui, NULL }  ,  { &&orPLUSlui, NULL }  ,  { &&orPLUSlui, NULL }  ,  { &&orPLUSlui, NULL }  ,  { &&orPLUSlui, NULL }  ,  { &&orPLUSlui, NULL }  ,  { &&orPLUSlui, NULL }  ,  { &&orPLUSlui, NULL } 
 ,  { &&orPLUSlui, NULL }  ,  { &&orPLUSlui, NULL }  ,  { &&orPLUSlui, NULL }  ,  { &&orPLUSlui, NULL }  ,  { &&orPLUSlui, NULL }  ,  { &&orPLUSlui, NULL }  ,  { &&orPLUSlui, NULL }  ,  { &&orPLUSlui, NULL }  ,  { &&orPLUSlui, NULL }  ,  { &&orPLUSlui, NULL } 
 ,  { &&orPLUSlui, NULL }  ,  { &&orPLUSlui, NULL }  ,  { &&orPLUSlui, NULL }  ,  { &&orPLUSlui, NULL }  ,  { &&orPLUSlui, NULL }  ,  { &&orPLUSlui, NULL }  ,  { &&orPLUSlui, NULL }  ,  { &&orPLUSlui, NULL }  ,  { &&orPLUSlui, NULL }  ,  { &&orPLUSlui, NULL } 
 ,  { &&orPLUSlui, NULL }  ,  { &&orPLUSlui, NULL }  ,  { &&orPLUSlui, NULL }  ,  { &&orPLUSlui, NULL }  ,  { &&orPLUSlui, NULL }  ,  { &&orPLUSlui, NULL }  ,  { &&orPLUSlui, NULL }  ,  { &&orPLUSlui, NULL }  ,  { &&orPLUSlui, NULL }  ,  { &&orPLUSlui, NULL } 
 ,  { &&orPLUSlui, NULL }  ,  { &&orPLUSlui, NULL }  ,  { &&orPLUSlui, NULL }  ,  { &&orPLUSlui, NULL }  ,  { &&orPLUSlui, NULL }  ,  { &&orPLUSlui, NULL }  ,  { &&orPLUSlui, NULL }  ,  { &&orPLUSlui, NULL }  ,  { &&orPLUSlui, NULL }  ,  { &&orPLUSlui, NULL } 
 ,  { &&orPLUSlui, NULL }  ,  { &&orPLUSlui, NULL }  ,  { &&orPLUSlui, NULL }  ,  { &&orPLUSlui, NULL }  ,  { &&orPLUSlui, NULL }  ,  { &&orPLUSlui, NULL }  ,  { &&orPLUSlui, NULL }  ,  { &&orPLUSlui, NULL }  ,  { &&orPLUSluiPLUSlui, NULL }  ,  { &&orPLUSlui, NULL } 
 ,  { &&orPLUSlui, NULL }  ,  { &&orPLUSlui, NULL }  ,  { &&orPLUSlui, NULL }  ,  { &&orPLUSlui, NULL }  ,  { &&orPLUSlui, NULL }  ,  { &&orPLUSlui, NULL }  ,  { &&orPLUSlui, NULL }  ,  { &&orPLUSlui, NULL }  ,  { &&orPLUSlui, NULL }  ,  { &&orPLUSlui, NULL } 
 ,  { &&orPLUSlui, NULL }  ,  { &&orPLUSlui, NULL }  ,  { &&orPLUSlui, NULL }  ,  { &&orPLUSlui, NULL }  ,  { &&orPLUSlui, NULL }  ,  { &&orPLUSlui, NULL }  ,  { &&orPLUSlui, NULL }  ,  { &&orPLUSlui, NULL }  ,  { &&orPLUSlui, NULL }  ,  { &&orPLUSlui, NULL } 
 ,  { &&orPLUSlui, NULL }  ,  { &&orPLUSlui, NULL }  ,  { &&orPLUSlui, NULL }  ,  { &&orPLUSlui, NULL }  ,  { &&orPLUSlui, NULL }  ,  { &&orPLUSlui, NULL }  ,  { &&orPLUSlui, NULL }  ,  { &&orPLUSlui, NULL }  ,  { &&orPLUSlui, NULL }  ,  { &&orPLUSlui, NULL } 
 ,  { &&orPLUSlui, NULL }  ,  { &&orPLUSlui, NULL }  ,  { &&orPLUSlui, NULL }  ,  { &&orPLUSlui, NULL }  ,  { &&orPLUSlui, NULL }  ,  { &&orPLUSlui, NULL }  ,  { &&orPLUSlui, NULL }  ,  { &&orPLUSlui, NULL }  ,  { &&orPLUSlui, NULL }  ,  { &&orPLUSlui, NULL } 
 ,  { &&orPLUSlui, NULL }  ,  { &&orPLUSlui, NULL }  ,  { &&orPLUSlui, NULL }  ,  { &&orPLUSlui, NULL }  ,  { &&orPLUSlui, NULL }  ,  { &&orPLUSlui, NULL }  ,  { &&orPLUSlui, NULL }  ,  { &&orPLUSlui, NULL }  ,  { &&orPLUSlui, NULL }  ,  { &&orPLUSlui, NULL } 
 }; 

struct pointer arraysrlPLUSlui[T_SIZE] = {  { &&srlPLUSlui, NULL }  ,  { &&srlPLUSlui, NULL }  ,  { &&srlPLUSlui, NULL }  ,  { &&srlPLUSlui, NULL }  ,  { &&srlPLUSlui, NULL }  ,  { &&srlPLUSlui, NULL }  ,  { &&srlPLUSlui, NULL }  ,  { &&srlPLUSlui, NULL }  ,  { &&srlPLUSlui, NULL }  ,  { &&srlPLUSlui, NULL } 
 ,  { &&srlPLUSlui, NULL }  ,  { &&srlPLUSlui, NULL }  ,  { &&srlPLUSlui, NULL }  ,  { &&srlPLUSlui, NULL }  ,  { &&srlPLUSlui, NULL }  ,  { &&srlPLUSlui, NULL }  ,  { &&srlPLUSlui, NULL }  ,  { &&srlPLUSlui, NULL }  ,  { &&srlPLUSlui, NULL }  ,  { &&srlPLUSlui, NULL } 
 ,  { &&srlPLUSlui, NULL }  ,  { &&srlPLUSlui, NULL }  ,  { &&srlPLUSlui, NULL }  ,  { &&srlPLUSlui, NULL }  ,  { &&srlPLUSlui, NULL }  ,  { &&srlPLUSlui, NULL }  ,  { &&srlPLUSlui, NULL }  ,  { &&srlPLUSlui, NULL }  ,  { &&srlPLUSlui, NULL }  ,  { &&srlPLUSlui, NULL } 
 ,  { &&srlPLUSlui, NULL }  ,  { &&srlPLUSlui, NULL }  ,  { &&srlPLUSlui, NULL }  ,  { &&srlPLUSlui, NULL }  ,  { &&srlPLUSlui, NULL }  ,  { &&srlPLUSlui, NULL }  ,  { &&srlPLUSlui, NULL }  ,  { &&srlPLUSlui, NULL }  ,  { &&srlPLUSlui, NULL }  ,  { &&srlPLUSlui, NULL } 
 ,  { &&srlPLUSlui, NULL }  ,  { &&srlPLUSlui, NULL }  ,  { &&srlPLUSlui, NULL }  ,  { &&srlPLUSlui, NULL }  ,  { &&srlPLUSlui, NULL }  ,  { &&srlPLUSlui, NULL }  ,  { &&srlPLUSlui, NULL }  ,  { &&srlPLUSlui, NULL }  ,  { &&srlPLUSlui, NULL }  ,  { &&srlPLUSlui, NULL } 
 ,  { &&srlPLUSlui, NULL }  ,  { &&srlPLUSlui, NULL }  ,  { &&srlPLUSlui, NULL }  ,  { &&srlPLUSlui, NULL }  ,  { &&srlPLUSlui, NULL }  ,  { &&srlPLUSlui, NULL }  ,  { &&srlPLUSluiPLUSori, NULL }  ,  { &&srlPLUSlui, NULL }  ,  { &&srlPLUSlui, NULL }  ,  { &&srlPLUSlui, NULL } 
 ,  { &&srlPLUSlui, NULL }  ,  { &&srlPLUSlui, NULL }  ,  { &&srlPLUSlui, NULL }  ,  { &&srlPLUSlui, NULL }  ,  { &&srlPLUSlui, NULL }  ,  { &&srlPLUSlui, NULL }  ,  { &&srlPLUSlui, NULL }  ,  { &&srlPLUSlui, NULL }  ,  { &&srlPLUSlui, NULL }  ,  { &&srlPLUSlui, NULL } 
 ,  { &&srlPLUSlui, NULL }  ,  { &&srlPLUSlui, NULL }  ,  { &&srlPLUSlui, NULL }  ,  { &&srlPLUSlui, NULL }  ,  { &&srlPLUSlui, NULL }  ,  { &&srlPLUSlui, NULL }  ,  { &&srlPLUSlui, NULL }  ,  { &&srlPLUSlui, NULL }  ,  { &&srlPLUSlui, NULL }  ,  { &&srlPLUSlui, NULL } 
 ,  { &&srlPLUSlui, NULL }  ,  { &&srlPLUSlui, NULL }  ,  { &&srlPLUSlui, NULL }  ,  { &&srlPLUSlui, NULL }  ,  { &&srlPLUSlui, NULL }  ,  { &&srlPLUSlui, NULL }  ,  { &&srlPLUSlui, NULL }  ,  { &&srlPLUSlui, NULL }  ,  { &&srlPLUSlui, NULL }  ,  { &&srlPLUSlui, NULL } 
 ,  { &&srlPLUSlui, NULL }  ,  { &&srlPLUSlui, NULL }  ,  { &&srlPLUSlui, NULL }  ,  { &&srlPLUSlui, NULL }  ,  { &&srlPLUSlui, NULL }  ,  { &&srlPLUSlui, NULL }  ,  { &&srlPLUSlui, NULL }  ,  { &&srlPLUSlui, NULL }  ,  { &&srlPLUSlui, NULL }  ,  { &&srlPLUSlui, NULL } 
 ,  { &&srlPLUSlui, NULL }  ,  { &&srlPLUSlui, NULL }  ,  { &&srlPLUSlui, NULL }  ,  { &&srlPLUSlui, NULL }  ,  { &&srlPLUSlui, NULL }  ,  { &&srlPLUSlui, NULL }  ,  { &&srlPLUSlui, NULL }  ,  { &&srlPLUSlui, NULL }  ,  { &&srlPLUSlui, NULL }  ,  { &&srlPLUSlui, NULL } 
 }; 

struct pointer arraylwPLUSxor[T_SIZE] = {  { &&lwPLUSxor, NULL }  ,  { &&lwPLUSxor, NULL }  ,  { &&lwPLUSxor, NULL }  ,  { &&lwPLUSxor, NULL }  ,  { &&lwPLUSxor, NULL }  ,  { &&lwPLUSxor, NULL }  ,  { &&lwPLUSxor, NULL }  ,  { &&lwPLUSxor, NULL }  ,  { &&lwPLUSxor, NULL }  ,  { &&lwPLUSxor, NULL } 
 ,  { &&lwPLUSxor, NULL }  ,  { &&lwPLUSxor, NULL }  ,  { &&lwPLUSxor, NULL }  ,  { &&lwPLUSxor, NULL }  ,  { &&lwPLUSxor, NULL }  ,  { &&lwPLUSxor, NULL }  ,  { &&lwPLUSxor, NULL }  ,  { &&lwPLUSxor, NULL }  ,  { &&lwPLUSxor, NULL }  ,  { &&lwPLUSxor, NULL } 
 ,  { &&lwPLUSxor, NULL }  ,  { &&lwPLUSxor, NULL }  ,  { &&lwPLUSxor, NULL }  ,  { &&lwPLUSxor, NULL }  ,  { &&lwPLUSxor, NULL }  ,  { &&lwPLUSxor, NULL }  ,  { &&lwPLUSxor, NULL }  ,  { &&lwPLUSxor, NULL }  ,  { &&lwPLUSxor, NULL }  ,  { &&lwPLUSxor, NULL } 
 ,  { &&lwPLUSxor, NULL }  ,  { &&lwPLUSxor, NULL }  ,  { &&lwPLUSxor, NULL }  ,  { &&lwPLUSxor, NULL }  ,  { &&lwPLUSxor, NULL }  ,  { &&lwPLUSxor, NULL }  ,  { &&lwPLUSxor, NULL }  ,  { &&lwPLUSxor, NULL }  ,  { &&lwPLUSxorPLUSxor, NULL }  ,  { &&lwPLUSxor, NULL } 
 ,  { &&lwPLUSxor, NULL }  ,  { &&lwPLUSxor, NULL }  ,  { &&lwPLUSxor, NULL }  ,  { &&lwPLUSxor, NULL }  ,  { &&lwPLUSxor, NULL }  ,  { &&lwPLUSxor, NULL }  ,  { &&lwPLUSxor, NULL }  ,  { &&lwPLUSxor, NULL }  ,  { &&lwPLUSxor, NULL }  ,  { &&lwPLUSxor, NULL } 
 ,  { &&lwPLUSxor, NULL }  ,  { &&lwPLUSxor, NULL }  ,  { &&lwPLUSxor, NULL }  ,  { &&lwPLUSxor, NULL }  ,  { &&lwPLUSxor, NULL }  ,  { &&lwPLUSxor, NULL }  ,  { &&lwPLUSxor, NULL }  ,  { &&lwPLUSxor, NULL }  ,  { &&lwPLUSxor, NULL }  ,  { &&lwPLUSxor, NULL } 
 ,  { &&lwPLUSxor, NULL }  ,  { &&lwPLUSxor, NULL }  ,  { &&lwPLUSxor, NULL }  ,  { &&lwPLUSxor, NULL }  ,  { &&lwPLUSxor, NULL }  ,  { &&lwPLUSxor, NULL }  ,  { &&lwPLUSxor, NULL }  ,  { &&lwPLUSxor, NULL }  ,  { &&lwPLUSxor, NULL }  ,  { &&lwPLUSxor, NULL } 
 ,  { &&lwPLUSxor, NULL }  ,  { &&lwPLUSxor, NULL }  ,  { &&lwPLUSxor, NULL }  ,  { &&lwPLUSxor, NULL }  ,  { &&lwPLUSxor, NULL }  ,  { &&lwPLUSxor, NULL }  ,  { &&lwPLUSxor, NULL }  ,  { &&lwPLUSxor, NULL }  ,  { &&lwPLUSxor, NULL }  ,  { &&lwPLUSxor, NULL } 
 ,  { &&lwPLUSxor, NULL }  ,  { &&lwPLUSxor, NULL }  ,  { &&lwPLUSxor, NULL }  ,  { &&lwPLUSxor, NULL }  ,  { &&lwPLUSxor, NULL }  ,  { &&lwPLUSxor, NULL }  ,  { &&lwPLUSxor, NULL }  ,  { &&lwPLUSxor, NULL }  ,  { &&lwPLUSxor, NULL }  ,  { &&lwPLUSxor, NULL } 
 ,  { &&lwPLUSxor, NULL }  ,  { &&lwPLUSxor, NULL }  ,  { &&lwPLUSxor, NULL }  ,  { &&lwPLUSxor, NULL }  ,  { &&lwPLUSxor, NULL }  ,  { &&lwPLUSxor, NULL }  ,  { &&lwPLUSxor, NULL }  ,  { &&lwPLUSxor, NULL }  ,  { &&lwPLUSxor, NULL }  ,  { &&lwPLUSxor, NULL } 
 ,  { &&lwPLUSxor, NULL }  ,  { &&lwPLUSxor, NULL }  ,  { &&lwPLUSxor, NULL }  ,  { &&lwPLUSxor, NULL }  ,  { &&lwPLUSxor, NULL }  ,  { &&lwPLUSxor, NULL }  ,  { &&lwPLUSxor, NULL }  ,  { &&lwPLUSxor, NULL }  ,  { &&lwPLUSxor, NULL }  ,  { &&lwPLUSxor, NULL } 
 }; 

struct pointer arraysllPLUSori[T_SIZE] = {  { &&sllPLUSori, NULL }  ,  { &&sllPLUSori, NULL }  ,  { &&sllPLUSori, NULL }  ,  { &&sllPLUSori, NULL }  ,  { &&sllPLUSori, NULL }  ,  { &&sllPLUSori, NULL }  ,  { &&sllPLUSori, NULL }  ,  { &&sllPLUSori, NULL }  ,  { &&sllPLUSori, NULL }  ,  { &&sllPLUSori, NULL } 
 ,  { &&sllPLUSori, NULL }  ,  { &&sllPLUSori, NULL }  ,  { &&sllPLUSori, NULL }  ,  { &&sllPLUSori, NULL }  ,  { &&sllPLUSori, NULL }  ,  { &&sllPLUSori, NULL }  ,  { &&sllPLUSori, NULL }  ,  { &&sllPLUSori, NULL }  ,  { &&sllPLUSori, NULL }  ,  { &&sllPLUSori, NULL } 
 ,  { &&sllPLUSori, NULL }  ,  { &&sllPLUSori, NULL }  ,  { &&sllPLUSori, NULL }  ,  { &&sllPLUSori, NULL }  ,  { &&sllPLUSori, NULL }  ,  { &&sllPLUSori, NULL }  ,  { &&sllPLUSori, NULL }  ,  { &&sllPLUSori, NULL }  ,  { &&sllPLUSori, NULL }  ,  { &&sllPLUSori, NULL } 
 ,  { &&sllPLUSori, NULL }  ,  { &&sllPLUSori, NULL }  ,  { &&sllPLUSori, NULL }  ,  { &&sllPLUSori, NULL }  ,  { &&sllPLUSori, NULL }  ,  { &&sllPLUSori, NULL }  ,  { &&sllPLUSoriPLUSand, NULL }  ,  { &&sllPLUSori, NULL }  ,  { &&sllPLUSori, NULL }  ,  { &&sllPLUSori, NULL } 
 ,  { &&sllPLUSori, NULL }  ,  { &&sllPLUSori, NULL }  ,  { &&sllPLUSori, NULL }  ,  { &&sllPLUSori, NULL }  ,  { &&sllPLUSori, NULL }  ,  { &&sllPLUSori, NULL }  ,  { &&sllPLUSori, NULL }  ,  { &&sllPLUSori, NULL }  ,  { &&sllPLUSori, NULL }  ,  { &&sllPLUSori, NULL } 
 ,  { &&sllPLUSori, NULL }  ,  { &&sllPLUSori, NULL }  ,  { &&sllPLUSori, NULL }  ,  { &&sllPLUSori, NULL }  ,  { &&sllPLUSori, NULL }  ,  { &&sllPLUSori, NULL }  ,  { &&sllPLUSori, NULL }  ,  { &&sllPLUSori, NULL }  ,  { &&sllPLUSori, NULL }  ,  { &&sllPLUSori, NULL } 
 ,  { &&sllPLUSori, NULL }  ,  { &&sllPLUSori, NULL }  ,  { &&sllPLUSori, NULL }  ,  { &&sllPLUSori, NULL }  ,  { &&sllPLUSori, NULL }  ,  { &&sllPLUSori, NULL }  ,  { &&sllPLUSori, NULL }  ,  { &&sllPLUSori, NULL }  ,  { &&sllPLUSori, NULL }  ,  { &&sllPLUSori, NULL } 
 ,  { &&sllPLUSori, NULL }  ,  { &&sllPLUSori, NULL }  ,  { &&sllPLUSori, NULL }  ,  { &&sllPLUSori, NULL }  ,  { &&sllPLUSori, NULL }  ,  { &&sllPLUSori, NULL }  ,  { &&sllPLUSori, NULL }  ,  { &&sllPLUSori, NULL }  ,  { &&sllPLUSori, NULL }  ,  { &&sllPLUSori, NULL } 
 ,  { &&sllPLUSori, NULL }  ,  { &&sllPLUSori, NULL }  ,  { &&sllPLUSori, NULL }  ,  { &&sllPLUSori, NULL }  ,  { &&sllPLUSori, NULL }  ,  { &&sllPLUSori, NULL }  ,  { &&sllPLUSori, NULL }  ,  { &&sllPLUSori, NULL }  ,  { &&sllPLUSori, NULL }  ,  { &&sllPLUSori, NULL } 
 ,  { &&sllPLUSori, NULL }  ,  { &&sllPLUSori, NULL }  ,  { &&sllPLUSori, NULL }  ,  { &&sllPLUSori, NULL }  ,  { &&sllPLUSori, NULL }  ,  { &&sllPLUSori, NULL }  ,  { &&sllPLUSori, NULL }  ,  { &&sllPLUSori, NULL }  ,  { &&sllPLUSori, NULL }  ,  { &&sllPLUSori, NULL } 
 ,  { &&sllPLUSori, NULL }  ,  { &&sllPLUSori, NULL }  ,  { &&sllPLUSori, NULL }  ,  { &&sllPLUSori, NULL }  ,  { &&sllPLUSori, NULL }  ,  { &&sllPLUSori, NULL }  ,  { &&sllPLUSori, NULL }  ,  { &&sllPLUSori, NULL }  ,  { &&sllPLUSori, NULL }  ,  { &&sllPLUSori, NULL } 
 }; 

struct pointer arrayadduPLUSsw[T_SIZE] = {  { &&adduPLUSswPLUSsll, NULL }  ,  { &&adduPLUSsw, NULL }  ,  { &&adduPLUSsw, NULL }  ,  { &&adduPLUSsw, NULL }  ,  { &&adduPLUSsw, NULL }  ,  { &&adduPLUSsw, NULL }  ,  { &&adduPLUSsw, NULL }  ,  { &&adduPLUSsw, NULL }  ,  { &&adduPLUSsw, NULL }  ,  { &&adduPLUSsw, NULL } 
 ,  { &&adduPLUSsw, NULL }  ,  { &&adduPLUSsw, NULL }  ,  { &&adduPLUSsw, NULL }  ,  { &&adduPLUSsw, NULL }  ,  { &&adduPLUSsw, NULL }  ,  { &&adduPLUSsw, NULL }  ,  { &&adduPLUSsw, NULL }  ,  { &&adduPLUSsw, NULL }  ,  { &&adduPLUSsw, NULL }  ,  { &&adduPLUSsw, NULL } 
 ,  { &&adduPLUSsw, NULL }  ,  { &&adduPLUSsw, NULL }  ,  { &&adduPLUSsw, NULL }  ,  { &&adduPLUSsw, NULL }  ,  { &&adduPLUSsw, NULL }  ,  { &&adduPLUSsw, NULL }  ,  { &&adduPLUSsw, NULL }  ,  { &&adduPLUSsw, NULL }  ,  { &&adduPLUSsw, NULL }  ,  { &&adduPLUSsw, NULL } 
 ,  { &&adduPLUSsw, NULL }  ,  { &&adduPLUSsw, NULL }  ,  { &&adduPLUSsw, NULL }  ,  { &&adduPLUSswPLUSaddu, NULL }  ,  { &&adduPLUSsw, NULL }  ,  { &&adduPLUSsw, NULL }  ,  { &&adduPLUSsw, NULL }  ,  { &&adduPLUSsw, NULL }  ,  { &&adduPLUSsw, NULL }  ,  { &&adduPLUSsw, NULL } 
 ,  { &&adduPLUSsw, NULL }  ,  { &&adduPLUSsw, NULL }  ,  { &&adduPLUSsw, NULL }  ,  { &&adduPLUSsw, NULL }  ,  { &&adduPLUSsw, NULL }  ,  { &&adduPLUSsw, NULL }  ,  { &&adduPLUSsw, NULL }  ,  { &&adduPLUSsw, NULL }  ,  { &&adduPLUSsw, NULL }  ,  { &&adduPLUSsw, NULL } 
 ,  { &&adduPLUSsw, NULL }  ,  { &&adduPLUSsw, NULL }  ,  { &&adduPLUSswPLUSaddiu, NULL }  ,  { &&adduPLUSswPLUSslti, NULL }  ,  { &&adduPLUSsw, NULL }  ,  { &&adduPLUSsw, NULL }  ,  { &&adduPLUSsw, NULL }  ,  { &&adduPLUSsw, NULL }  ,  { &&adduPLUSsw, NULL }  ,  { &&adduPLUSsw, NULL } 
 ,  { &&adduPLUSsw, NULL }  ,  { &&adduPLUSsw, NULL }  ,  { &&adduPLUSsw, NULL }  ,  { &&adduPLUSsw, NULL }  ,  { &&adduPLUSsw, NULL }  ,  { &&adduPLUSsw, NULL }  ,  { &&adduPLUSsw, NULL }  ,  { &&adduPLUSsw, NULL }  ,  { &&adduPLUSsw, NULL }  ,  { &&adduPLUSsw, NULL } 
 ,  { &&adduPLUSsw, NULL }  ,  { &&adduPLUSsw, NULL }  ,  { &&adduPLUSsw, NULL }  ,  { &&adduPLUSsw, NULL }  ,  { &&adduPLUSsw, NULL }  ,  { &&adduPLUSsw, NULL }  ,  { &&adduPLUSsw, NULL }  ,  { &&adduPLUSsw, NULL }  ,  { &&adduPLUSswPLUSlw, NULL }  ,  { &&adduPLUSsw, NULL } 
 ,  { &&adduPLUSsw, NULL }  ,  { &&adduPLUSsw, NULL }  ,  { &&adduPLUSsw, NULL }  ,  { &&adduPLUSsw, NULL }  ,  { &&adduPLUSsw, NULL }  ,  { &&adduPLUSsw, NULL }  ,  { &&adduPLUSswPLUSsw, NULL }  ,  { &&adduPLUSsw, NULL }  ,  { &&adduPLUSsw, NULL }  ,  { &&adduPLUSsw, NULL } 
 ,  { &&adduPLUSsw, NULL }  ,  { &&adduPLUSsw, NULL }  ,  { &&adduPLUSsw, NULL }  ,  { &&adduPLUSsw, NULL }  ,  { &&adduPLUSsw, NULL }  ,  { &&adduPLUSsw, NULL }  ,  { &&adduPLUSsw, NULL }  ,  { &&adduPLUSsw, NULL }  ,  { &&adduPLUSsw, NULL }  ,  { &&adduPLUSsw, NULL } 
 ,  { &&adduPLUSsw, NULL }  ,  { &&adduPLUSsw, NULL }  ,  { &&adduPLUSsw, NULL }  ,  { &&adduPLUSsw, NULL }  ,  { &&adduPLUSsw, NULL }  ,  { &&adduPLUSsw, NULL }  ,  { &&adduPLUSsw, NULL }  ,  { &&adduPLUSsw, NULL }  ,  { &&adduPLUSsw, NULL }  ,  { &&adduPLUSsw, NULL } 
 }; 

struct pointer arraybnePLUSxor[T_SIZE] = {  { &&bnePLUSxor, NULL }  ,  { &&bnePLUSxor, NULL }  ,  { &&bnePLUSxor, NULL }  ,  { &&bnePLUSxor, NULL }  ,  { &&bnePLUSxor, NULL }  ,  { &&bnePLUSxor, NULL }  ,  { &&bnePLUSxor, NULL }  ,  { &&bnePLUSxor, NULL }  ,  { &&bnePLUSxor, NULL }  ,  { &&bnePLUSxor, NULL } 
 ,  { &&bnePLUSxor, NULL }  ,  { &&bnePLUSxor, NULL }  ,  { &&bnePLUSxor, NULL }  ,  { &&bnePLUSxor, NULL }  ,  { &&bnePLUSxor, NULL }  ,  { &&bnePLUSxor, NULL }  ,  { &&bnePLUSxor, NULL }  ,  { &&bnePLUSxor, NULL }  ,  { &&bnePLUSxor, NULL }  ,  { &&bnePLUSxor, NULL } 
 ,  { &&bnePLUSxor, NULL }  ,  { &&bnePLUSxor, NULL }  ,  { &&bnePLUSxor, NULL }  ,  { &&bnePLUSxor, NULL }  ,  { &&bnePLUSxor, NULL }  ,  { &&bnePLUSxor, NULL }  ,  { &&bnePLUSxor, NULL }  ,  { &&bnePLUSxor, NULL }  ,  { &&bnePLUSxor, NULL }  ,  { &&bnePLUSxor, NULL } 
 ,  { &&bnePLUSxor, NULL }  ,  { &&bnePLUSxor, NULL }  ,  { &&bnePLUSxor, NULL }  ,  { &&bnePLUSxor, NULL }  ,  { &&bnePLUSxor, NULL }  ,  { &&bnePLUSxor, NULL }  ,  { &&bnePLUSxor, NULL }  ,  { &&bnePLUSxor, NULL }  ,  { &&bnePLUSxorPLUSxor, NULL }  ,  { &&bnePLUSxorPLUSnor, NULL } 
 ,  { &&bnePLUSxor, NULL }  ,  { &&bnePLUSxor, NULL }  ,  { &&bnePLUSxor, NULL }  ,  { &&bnePLUSxor, NULL }  ,  { &&bnePLUSxor, NULL }  ,  { &&bnePLUSxor, NULL }  ,  { &&bnePLUSxor, NULL }  ,  { &&bnePLUSxor, NULL }  ,  { &&bnePLUSxor, NULL }  ,  { &&bnePLUSxor, NULL } 
 ,  { &&bnePLUSxor, NULL }  ,  { &&bnePLUSxor, NULL }  ,  { &&bnePLUSxor, NULL }  ,  { &&bnePLUSxor, NULL }  ,  { &&bnePLUSxor, NULL }  ,  { &&bnePLUSxor, NULL }  ,  { &&bnePLUSxor, NULL }  ,  { &&bnePLUSxor, NULL }  ,  { &&bnePLUSxor, NULL }  ,  { &&bnePLUSxor, NULL } 
 ,  { &&bnePLUSxor, NULL }  ,  { &&bnePLUSxor, NULL }  ,  { &&bnePLUSxor, NULL }  ,  { &&bnePLUSxor, NULL }  ,  { &&bnePLUSxor, NULL }  ,  { &&bnePLUSxor, NULL }  ,  { &&bnePLUSxor, NULL }  ,  { &&bnePLUSxor, NULL }  ,  { &&bnePLUSxor, NULL }  ,  { &&bnePLUSxor, NULL } 
 ,  { &&bnePLUSxor, NULL }  ,  { &&bnePLUSxor, NULL }  ,  { &&bnePLUSxor, NULL }  ,  { &&bnePLUSxor, NULL }  ,  { &&bnePLUSxor, NULL }  ,  { &&bnePLUSxor, NULL }  ,  { &&bnePLUSxor, NULL }  ,  { &&bnePLUSxor, NULL }  ,  { &&bnePLUSxor, NULL }  ,  { &&bnePLUSxor, NULL } 
 ,  { &&bnePLUSxor, NULL }  ,  { &&bnePLUSxor, NULL }  ,  { &&bnePLUSxor, NULL }  ,  { &&bnePLUSxor, NULL }  ,  { &&bnePLUSxor, NULL }  ,  { &&bnePLUSxor, NULL }  ,  { &&bnePLUSxor, NULL }  ,  { &&bnePLUSxor, NULL }  ,  { &&bnePLUSxor, NULL }  ,  { &&bnePLUSxor, NULL } 
 ,  { &&bnePLUSxor, NULL }  ,  { &&bnePLUSxor, NULL }  ,  { &&bnePLUSxor, NULL }  ,  { &&bnePLUSxor, NULL }  ,  { &&bnePLUSxor, NULL }  ,  { &&bnePLUSxor, NULL }  ,  { &&bnePLUSxor, NULL }  ,  { &&bnePLUSxor, NULL }  ,  { &&bnePLUSxor, NULL }  ,  { &&bnePLUSxor, NULL } 
 ,  { &&bnePLUSxor, NULL }  ,  { &&bnePLUSxor, NULL }  ,  { &&bnePLUSxor, NULL }  ,  { &&bnePLUSxor, NULL }  ,  { &&bnePLUSxor, NULL }  ,  { &&bnePLUSxor, NULL }  ,  { &&bnePLUSxor, NULL }  ,  { &&bnePLUSxor, NULL }  ,  { &&bnePLUSxor, NULL }  ,  { &&bnePLUSxor, NULL } 
 }; 

struct pointer arraysllPLUSblez[T_SIZE] = {  { &&sllPLUSblezPLUSsll, NULL }  ,  { &&sllPLUSblez, NULL }  ,  { &&sllPLUSblez, NULL }  ,  { &&sllPLUSblez, NULL }  ,  { &&sllPLUSblez, NULL }  ,  { &&sllPLUSblez, NULL }  ,  { &&sllPLUSblez, NULL }  ,  { &&sllPLUSblez, NULL }  ,  { &&sllPLUSblez, NULL }  ,  { &&sllPLUSblez, NULL } 
 ,  { &&sllPLUSblez, NULL }  ,  { &&sllPLUSblez, NULL }  ,  { &&sllPLUSblez, NULL }  ,  { &&sllPLUSblez, NULL }  ,  { &&sllPLUSblez, NULL }  ,  { &&sllPLUSblez, NULL }  ,  { &&sllPLUSblez, NULL }  ,  { &&sllPLUSblez, NULL }  ,  { &&sllPLUSblez, NULL }  ,  { &&sllPLUSblez, NULL } 
 ,  { &&sllPLUSblez, NULL }  ,  { &&sllPLUSblez, NULL }  ,  { &&sllPLUSblez, NULL }  ,  { &&sllPLUSblez, NULL }  ,  { &&sllPLUSblez, NULL }  ,  { &&sllPLUSblez, NULL }  ,  { &&sllPLUSblez, NULL }  ,  { &&sllPLUSblez, NULL }  ,  { &&sllPLUSblez, NULL }  ,  { &&sllPLUSblez, NULL } 
 ,  { &&sllPLUSblez, NULL }  ,  { &&sllPLUSblez, NULL }  ,  { &&sllPLUSblez, NULL }  ,  { &&sllPLUSblez, NULL }  ,  { &&sllPLUSblez, NULL }  ,  { &&sllPLUSblez, NULL }  ,  { &&sllPLUSblez, NULL }  ,  { &&sllPLUSblez, NULL }  ,  { &&sllPLUSblez, NULL }  ,  { &&sllPLUSblez, NULL } 
 ,  { &&sllPLUSblez, NULL }  ,  { &&sllPLUSblez, NULL }  ,  { &&sllPLUSblez, NULL }  ,  { &&sllPLUSblez, NULL }  ,  { &&sllPLUSblez, NULL }  ,  { &&sllPLUSblez, NULL }  ,  { &&sllPLUSblez, NULL }  ,  { &&sllPLUSblez, NULL }  ,  { &&sllPLUSblez, NULL }  ,  { &&sllPLUSblez, NULL } 
 ,  { &&sllPLUSblez, NULL }  ,  { &&sllPLUSblez, NULL }  ,  { &&sllPLUSblezPLUSaddiu, NULL }  ,  { &&sllPLUSblez, NULL }  ,  { &&sllPLUSblez, NULL }  ,  { &&sllPLUSblez, NULL }  ,  { &&sllPLUSblez, NULL }  ,  { &&sllPLUSblez, NULL }  ,  { &&sllPLUSblez, NULL }  ,  { &&sllPLUSblez, NULL } 
 ,  { &&sllPLUSblez, NULL }  ,  { &&sllPLUSblez, NULL }  ,  { &&sllPLUSblez, NULL }  ,  { &&sllPLUSblez, NULL }  ,  { &&sllPLUSblez, NULL }  ,  { &&sllPLUSblez, NULL }  ,  { &&sllPLUSblez, NULL }  ,  { &&sllPLUSblez, NULL }  ,  { &&sllPLUSblez, NULL }  ,  { &&sllPLUSblez, NULL } 
 ,  { &&sllPLUSblez, NULL }  ,  { &&sllPLUSblez, NULL }  ,  { &&sllPLUSblez, NULL }  ,  { &&sllPLUSblez, NULL }  ,  { &&sllPLUSblez, NULL }  ,  { &&sllPLUSblez, NULL }  ,  { &&sllPLUSblez, NULL }  ,  { &&sllPLUSblez, NULL }  ,  { &&sllPLUSblez, NULL }  ,  { &&sllPLUSblez, NULL } 
 ,  { &&sllPLUSblez, NULL }  ,  { &&sllPLUSblez, NULL }  ,  { &&sllPLUSblez, NULL }  ,  { &&sllPLUSblez, NULL }  ,  { &&sllPLUSblez, NULL }  ,  { &&sllPLUSblez, NULL }  ,  { &&sllPLUSblez, NULL }  ,  { &&sllPLUSblez, NULL }  ,  { &&sllPLUSblez, NULL }  ,  { &&sllPLUSblez, NULL } 
 ,  { &&sllPLUSblez, NULL }  ,  { &&sllPLUSblez, NULL }  ,  { &&sllPLUSblez, NULL }  ,  { &&sllPLUSblez, NULL }  ,  { &&sllPLUSblez, NULL }  ,  { &&sllPLUSblez, NULL }  ,  { &&sllPLUSblez, NULL }  ,  { &&sllPLUSblez, NULL }  ,  { &&sllPLUSblez, NULL }  ,  { &&sllPLUSblez, NULL } 
 ,  { &&sllPLUSblez, NULL }  ,  { &&sllPLUSblez, NULL }  ,  { &&sllPLUSblez, NULL }  ,  { &&sllPLUSblez, NULL }  ,  { &&sllPLUSblez, NULL }  ,  { &&sllPLUSblez, NULL }  ,  { &&sllPLUSblez, NULL }  ,  { &&sllPLUSblez, NULL }  ,  { &&sllPLUSblez, NULL }  ,  { &&sllPLUSblez, NULL } 
 }; 

struct pointer arrayaddiuPLUSerror[T_SIZE] = {  { &&addiuPLUSerror, NULL }  ,  { &&addiuPLUSerror, NULL }  ,  { &&addiuPLUSerror, NULL }  ,  { &&addiuPLUSerror, NULL }  ,  { &&addiuPLUSerror, NULL }  ,  { &&addiuPLUSerror, NULL }  ,  { &&addiuPLUSerror, NULL }  ,  { &&addiuPLUSerror, NULL }  ,  { &&addiuPLUSerror, NULL }  ,  { &&addiuPLUSerror, NULL } 
 ,  { &&addiuPLUSerror, NULL }  ,  { &&addiuPLUSerror, NULL }  ,  { &&addiuPLUSerror, NULL }  ,  { &&addiuPLUSerror, NULL }  ,  { &&addiuPLUSerror, NULL }  ,  { &&addiuPLUSerror, NULL }  ,  { &&addiuPLUSerror, NULL }  ,  { &&addiuPLUSerror, NULL }  ,  { &&addiuPLUSerror, NULL }  ,  { &&addiuPLUSerror, NULL } 
 ,  { &&addiuPLUSerror, NULL }  ,  { &&addiuPLUSerror, NULL }  ,  { &&addiuPLUSerror, NULL }  ,  { &&addiuPLUSerror, NULL }  ,  { &&addiuPLUSerror, NULL }  ,  { &&addiuPLUSerror, NULL }  ,  { &&addiuPLUSerror, NULL }  ,  { &&addiuPLUSerror, NULL }  ,  { &&addiuPLUSerror, NULL }  ,  { &&addiuPLUSerror, NULL } 
 ,  { &&addiuPLUSerror, NULL }  ,  { &&addiuPLUSerror, NULL }  ,  { &&addiuPLUSerror, NULL }  ,  { &&addiuPLUSerror, NULL }  ,  { &&addiuPLUSerror, NULL }  ,  { &&addiuPLUSerrorPLUSsubu, NULL }  ,  { &&addiuPLUSerror, NULL }  ,  { &&addiuPLUSerror, NULL }  ,  { &&addiuPLUSerror, NULL }  ,  { &&addiuPLUSerror, NULL } 
 ,  { &&addiuPLUSerror, NULL }  ,  { &&addiuPLUSerror, NULL }  ,  { &&addiuPLUSerror, NULL }  ,  { &&addiuPLUSerror, NULL }  ,  { &&addiuPLUSerror, NULL }  ,  { &&addiuPLUSerror, NULL }  ,  { &&addiuPLUSerror, NULL }  ,  { &&addiuPLUSerror, NULL }  ,  { &&addiuPLUSerror, NULL }  ,  { &&addiuPLUSerror, NULL } 
 ,  { &&addiuPLUSerror, NULL }  ,  { &&addiuPLUSerror, NULL }  ,  { &&addiuPLUSerror, NULL }  ,  { &&addiuPLUSerror, NULL }  ,  { &&addiuPLUSerror, NULL }  ,  { &&addiuPLUSerror, NULL }  ,  { &&addiuPLUSerror, NULL }  ,  { &&addiuPLUSerror, NULL }  ,  { &&addiuPLUSerror, NULL }  ,  { &&addiuPLUSerror, NULL } 
 ,  { &&addiuPLUSerror, NULL }  ,  { &&addiuPLUSerror, NULL }  ,  { &&addiuPLUSerror, NULL }  ,  { &&addiuPLUSerror, NULL }  ,  { &&addiuPLUSerror, NULL }  ,  { &&addiuPLUSerror, NULL }  ,  { &&addiuPLUSerror, NULL }  ,  { &&addiuPLUSerror, NULL }  ,  { &&addiuPLUSerror, NULL }  ,  { &&addiuPLUSerror, NULL } 
 ,  { &&addiuPLUSerror, NULL }  ,  { &&addiuPLUSerror, NULL }  ,  { &&addiuPLUSerror, NULL }  ,  { &&addiuPLUSerror, NULL }  ,  { &&addiuPLUSerror, NULL }  ,  { &&addiuPLUSerror, NULL }  ,  { &&addiuPLUSerror, NULL }  ,  { &&addiuPLUSerror, NULL }  ,  { &&addiuPLUSerror, NULL }  ,  { &&addiuPLUSerror, NULL } 
 ,  { &&addiuPLUSerror, NULL }  ,  { &&addiuPLUSerror, NULL }  ,  { &&addiuPLUSerror, NULL }  ,  { &&addiuPLUSerror, NULL }  ,  { &&addiuPLUSerror, NULL }  ,  { &&addiuPLUSerror, NULL }  ,  { &&addiuPLUSerror, NULL }  ,  { &&addiuPLUSerror, NULL }  ,  { &&addiuPLUSerror, NULL }  ,  { &&addiuPLUSerror, NULL } 
 ,  { &&addiuPLUSerror, NULL }  ,  { &&addiuPLUSerror, NULL }  ,  { &&addiuPLUSerror, NULL }  ,  { &&addiuPLUSerror, NULL }  ,  { &&addiuPLUSerror, NULL }  ,  { &&addiuPLUSerror, NULL }  ,  { &&addiuPLUSerror, NULL }  ,  { &&addiuPLUSerror, NULL }  ,  { &&addiuPLUSerror, NULL }  ,  { &&addiuPLUSerror, NULL } 
 ,  { &&addiuPLUSerror, NULL }  ,  { &&addiuPLUSerror, NULL }  ,  { &&addiuPLUSerror, NULL }  ,  { &&addiuPLUSerror, NULL }  ,  { &&addiuPLUSerror, NULL }  ,  { &&addiuPLUSerror, NULL }  ,  { &&addiuPLUSerror, NULL }  ,  { &&addiuPLUSerror, NULL }  ,  { &&addiuPLUSerror, NULL }  ,  { &&addiuPLUSerror, NULL } 
 }; 

struct pointer arraysubuPLUSaddiu[T_SIZE] = {  { &&subuPLUSaddiu, NULL }  ,  { &&subuPLUSaddiu, NULL }  ,  { &&subuPLUSaddiu, NULL }  ,  { &&subuPLUSaddiu, NULL }  ,  { &&subuPLUSaddiu, NULL }  ,  { &&subuPLUSaddiu, NULL }  ,  { &&subuPLUSaddiu, NULL }  ,  { &&subuPLUSaddiu, NULL }  ,  { &&subuPLUSaddiu, NULL }  ,  { &&subuPLUSaddiu, NULL } 
 ,  { &&subuPLUSaddiu, NULL }  ,  { &&subuPLUSaddiu, NULL }  ,  { &&subuPLUSaddiu, NULL }  ,  { &&subuPLUSaddiu, NULL }  ,  { &&subuPLUSaddiu, NULL }  ,  { &&subuPLUSaddiu, NULL }  ,  { &&subuPLUSaddiu, NULL }  ,  { &&subuPLUSaddiu, NULL }  ,  { &&subuPLUSaddiu, NULL }  ,  { &&subuPLUSaddiu, NULL } 
 ,  { &&subuPLUSaddiu, NULL }  ,  { &&subuPLUSaddiu, NULL }  ,  { &&subuPLUSaddiu, NULL }  ,  { &&subuPLUSaddiu, NULL }  ,  { &&subuPLUSaddiu, NULL }  ,  { &&subuPLUSaddiu, NULL }  ,  { &&subuPLUSaddiu, NULL }  ,  { &&subuPLUSaddiu, NULL }  ,  { &&subuPLUSaddiu, NULL }  ,  { &&subuPLUSaddiu, NULL } 
 ,  { &&subuPLUSaddiu, NULL }  ,  { &&subuPLUSaddiu, NULL }  ,  { &&subuPLUSaddiu, NULL }  ,  { &&subuPLUSaddiu, NULL }  ,  { &&subuPLUSaddiu, NULL }  ,  { &&subuPLUSaddiu, NULL }  ,  { &&subuPLUSaddiu, NULL }  ,  { &&subuPLUSaddiu, NULL }  ,  { &&subuPLUSaddiu, NULL }  ,  { &&subuPLUSaddiu, NULL } 
 ,  { &&subuPLUSaddiu, NULL }  ,  { &&subuPLUSaddiu, NULL }  ,  { &&subuPLUSaddiu, NULL }  ,  { &&subuPLUSaddiu, NULL }  ,  { &&subuPLUSaddiu, NULL }  ,  { &&subuPLUSaddiuPLUSjump, NULL }  ,  { &&subuPLUSaddiu, NULL }  ,  { &&subuPLUSaddiu, NULL }  ,  { &&subuPLUSaddiu, NULL }  ,  { &&subuPLUSaddiu, NULL } 
 ,  { &&subuPLUSaddiu, NULL }  ,  { &&subuPLUSaddiu, NULL }  ,  { &&subuPLUSaddiu, NULL }  ,  { &&subuPLUSaddiu, NULL }  ,  { &&subuPLUSaddiu, NULL }  ,  { &&subuPLUSaddiu, NULL }  ,  { &&subuPLUSaddiu, NULL }  ,  { &&subuPLUSaddiu, NULL }  ,  { &&subuPLUSaddiu, NULL }  ,  { &&subuPLUSaddiu, NULL } 
 ,  { &&subuPLUSaddiu, NULL }  ,  { &&subuPLUSaddiu, NULL }  ,  { &&subuPLUSaddiu, NULL }  ,  { &&subuPLUSaddiu, NULL }  ,  { &&subuPLUSaddiu, NULL }  ,  { &&subuPLUSaddiu, NULL }  ,  { &&subuPLUSaddiu, NULL }  ,  { &&subuPLUSaddiu, NULL }  ,  { &&subuPLUSaddiu, NULL }  ,  { &&subuPLUSaddiu, NULL } 
 ,  { &&subuPLUSaddiu, NULL }  ,  { &&subuPLUSaddiu, NULL }  ,  { &&subuPLUSaddiu, NULL }  ,  { &&subuPLUSaddiu, NULL }  ,  { &&subuPLUSaddiu, NULL }  ,  { &&subuPLUSaddiu, NULL }  ,  { &&subuPLUSaddiu, NULL }  ,  { &&subuPLUSaddiu, NULL }  ,  { &&subuPLUSaddiu, NULL }  ,  { &&subuPLUSaddiu, NULL } 
 ,  { &&subuPLUSaddiu, NULL }  ,  { &&subuPLUSaddiu, NULL }  ,  { &&subuPLUSaddiu, NULL }  ,  { &&subuPLUSaddiu, NULL }  ,  { &&subuPLUSaddiu, NULL }  ,  { &&subuPLUSaddiu, NULL }  ,  { &&subuPLUSaddiu, NULL }  ,  { &&subuPLUSaddiu, NULL }  ,  { &&subuPLUSaddiu, NULL }  ,  { &&subuPLUSaddiu, NULL } 
 ,  { &&subuPLUSaddiu, NULL }  ,  { &&subuPLUSaddiu, NULL }  ,  { &&subuPLUSaddiu, NULL }  ,  { &&subuPLUSaddiu, NULL }  ,  { &&subuPLUSaddiu, NULL }  ,  { &&subuPLUSaddiu, NULL }  ,  { &&subuPLUSaddiu, NULL }  ,  { &&subuPLUSaddiu, NULL }  ,  { &&subuPLUSaddiu, NULL }  ,  { &&subuPLUSaddiu, NULL } 
 ,  { &&subuPLUSaddiu, NULL }  ,  { &&subuPLUSaddiu, NULL }  ,  { &&subuPLUSaddiu, NULL }  ,  { &&subuPLUSaddiu, NULL }  ,  { &&subuPLUSaddiu, NULL }  ,  { &&subuPLUSaddiu, NULL }  ,  { &&subuPLUSaddiu, NULL }  ,  { &&subuPLUSaddiu, NULL }  ,  { &&subuPLUSaddiu, NULL }  ,  { &&subuPLUSaddiu, NULL } 
 }; 

struct pointer arrayandiPLUSjr[T_SIZE] = {  { &&andiPLUSjr, NULL }  ,  { &&andiPLUSjr, NULL }  ,  { &&andiPLUSjr, NULL }  ,  { &&andiPLUSjr, NULL }  ,  { &&andiPLUSjr, NULL }  ,  { &&andiPLUSjr, NULL }  ,  { &&andiPLUSjr, NULL }  ,  { &&andiPLUSjr, NULL }  ,  { &&andiPLUSjr, NULL }  ,  { &&andiPLUSjr, NULL } 
 ,  { &&andiPLUSjr, NULL }  ,  { &&andiPLUSjr, NULL }  ,  { &&andiPLUSjr, NULL }  ,  { &&andiPLUSjr, NULL }  ,  { &&andiPLUSjr, NULL }  ,  { &&andiPLUSjr, NULL }  ,  { &&andiPLUSjr, NULL }  ,  { &&andiPLUSjr, NULL }  ,  { &&andiPLUSjr, NULL }  ,  { &&andiPLUSjr, NULL } 
 ,  { &&andiPLUSjr, NULL }  ,  { &&andiPLUSjr, NULL }  ,  { &&andiPLUSjr, NULL }  ,  { &&andiPLUSjr, NULL }  ,  { &&andiPLUSjr, NULL }  ,  { &&andiPLUSjr, NULL }  ,  { &&andiPLUSjr, NULL }  ,  { &&andiPLUSjr, NULL }  ,  { &&andiPLUSjr, NULL }  ,  { &&andiPLUSjr, NULL } 
 ,  { &&andiPLUSjr, NULL }  ,  { &&andiPLUSjr, NULL }  ,  { &&andiPLUSjr, NULL }  ,  { &&andiPLUSjr, NULL }  ,  { &&andiPLUSjr, NULL }  ,  { &&andiPLUSjr, NULL }  ,  { &&andiPLUSjr, NULL }  ,  { &&andiPLUSjrPLUSor, NULL }  ,  { &&andiPLUSjr, NULL }  ,  { &&andiPLUSjr, NULL } 
 ,  { &&andiPLUSjr, NULL }  ,  { &&andiPLUSjr, NULL }  ,  { &&andiPLUSjr, NULL }  ,  { &&andiPLUSjr, NULL }  ,  { &&andiPLUSjr, NULL }  ,  { &&andiPLUSjr, NULL }  ,  { &&andiPLUSjr, NULL }  ,  { &&andiPLUSjr, NULL }  ,  { &&andiPLUSjr, NULL }  ,  { &&andiPLUSjr, NULL } 
 ,  { &&andiPLUSjr, NULL }  ,  { &&andiPLUSjr, NULL }  ,  { &&andiPLUSjr, NULL }  ,  { &&andiPLUSjr, NULL }  ,  { &&andiPLUSjr, NULL }  ,  { &&andiPLUSjr, NULL }  ,  { &&andiPLUSjr, NULL }  ,  { &&andiPLUSjr, NULL }  ,  { &&andiPLUSjr, NULL }  ,  { &&andiPLUSjr, NULL } 
 ,  { &&andiPLUSjr, NULL }  ,  { &&andiPLUSjr, NULL }  ,  { &&andiPLUSjr, NULL }  ,  { &&andiPLUSjr, NULL }  ,  { &&andiPLUSjr, NULL }  ,  { &&andiPLUSjr, NULL }  ,  { &&andiPLUSjr, NULL }  ,  { &&andiPLUSjr, NULL }  ,  { &&andiPLUSjr, NULL }  ,  { &&andiPLUSjr, NULL } 
 ,  { &&andiPLUSjr, NULL }  ,  { &&andiPLUSjr, NULL }  ,  { &&andiPLUSjr, NULL }  ,  { &&andiPLUSjr, NULL }  ,  { &&andiPLUSjr, NULL }  ,  { &&andiPLUSjr, NULL }  ,  { &&andiPLUSjr, NULL }  ,  { &&andiPLUSjr, NULL }  ,  { &&andiPLUSjr, NULL }  ,  { &&andiPLUSjr, NULL } 
 ,  { &&andiPLUSjr, NULL }  ,  { &&andiPLUSjr, NULL }  ,  { &&andiPLUSjr, NULL }  ,  { &&andiPLUSjr, NULL }  ,  { &&andiPLUSjr, NULL }  ,  { &&andiPLUSjr, NULL }  ,  { &&andiPLUSjr, NULL }  ,  { &&andiPLUSjr, NULL }  ,  { &&andiPLUSjr, NULL }  ,  { &&andiPLUSjr, NULL } 
 ,  { &&andiPLUSjr, NULL }  ,  { &&andiPLUSjr, NULL }  ,  { &&andiPLUSjr, NULL }  ,  { &&andiPLUSjr, NULL }  ,  { &&andiPLUSjr, NULL }  ,  { &&andiPLUSjr, NULL }  ,  { &&andiPLUSjr, NULL }  ,  { &&andiPLUSjr, NULL }  ,  { &&andiPLUSjr, NULL }  ,  { &&andiPLUSjr, NULL } 
 ,  { &&andiPLUSjr, NULL }  ,  { &&andiPLUSjr, NULL }  ,  { &&andiPLUSjr, NULL }  ,  { &&andiPLUSjr, NULL }  ,  { &&andiPLUSjr, NULL }  ,  { &&andiPLUSjr, NULL }  ,  { &&andiPLUSjr, NULL }  ,  { &&andiPLUSjr, NULL }  ,  { &&andiPLUSjr, NULL }  ,  { &&andiPLUSjr, NULL } 
 }; 

struct pointer arraylwPLUSjal[T_SIZE] = {  { &&lwPLUSjalPLUSsll, NULL }  ,  { &&lwPLUSjal, NULL }  ,  { &&lwPLUSjal, NULL }  ,  { &&lwPLUSjal, NULL }  ,  { &&lwPLUSjal, NULL }  ,  { &&lwPLUSjal, NULL }  ,  { &&lwPLUSjal, NULL }  ,  { &&lwPLUSjal, NULL }  ,  { &&lwPLUSjal, NULL }  ,  { &&lwPLUSjal, NULL } 
 ,  { &&lwPLUSjal, NULL }  ,  { &&lwPLUSjal, NULL }  ,  { &&lwPLUSjal, NULL }  ,  { &&lwPLUSjal, NULL }  ,  { &&lwPLUSjal, NULL }  ,  { &&lwPLUSjal, NULL }  ,  { &&lwPLUSjal, NULL }  ,  { &&lwPLUSjal, NULL }  ,  { &&lwPLUSjal, NULL }  ,  { &&lwPLUSjal, NULL } 
 ,  { &&lwPLUSjal, NULL }  ,  { &&lwPLUSjal, NULL }  ,  { &&lwPLUSjal, NULL }  ,  { &&lwPLUSjal, NULL }  ,  { &&lwPLUSjal, NULL }  ,  { &&lwPLUSjal, NULL }  ,  { &&lwPLUSjal, NULL }  ,  { &&lwPLUSjal, NULL }  ,  { &&lwPLUSjal, NULL }  ,  { &&lwPLUSjal, NULL } 
 ,  { &&lwPLUSjal, NULL }  ,  { &&lwPLUSjal, NULL }  ,  { &&lwPLUSjal, NULL }  ,  { &&lwPLUSjalPLUSaddu, NULL }  ,  { &&lwPLUSjal, NULL }  ,  { &&lwPLUSjal, NULL }  ,  { &&lwPLUSjal, NULL }  ,  { &&lwPLUSjal, NULL }  ,  { &&lwPLUSjal, NULL }  ,  { &&lwPLUSjal, NULL } 
 ,  { &&lwPLUSjal, NULL }  ,  { &&lwPLUSjal, NULL }  ,  { &&lwPLUSjal, NULL }  ,  { &&lwPLUSjal, NULL }  ,  { &&lwPLUSjal, NULL }  ,  { &&lwPLUSjal, NULL }  ,  { &&lwPLUSjal, NULL }  ,  { &&lwPLUSjal, NULL }  ,  { &&lwPLUSjal, NULL }  ,  { &&lwPLUSjal, NULL } 
 ,  { &&lwPLUSjal, NULL }  ,  { &&lwPLUSjal, NULL }  ,  { &&lwPLUSjalPLUSaddiu, NULL }  ,  { &&lwPLUSjal, NULL }  ,  { &&lwPLUSjal, NULL }  ,  { &&lwPLUSjal, NULL }  ,  { &&lwPLUSjal, NULL }  ,  { &&lwPLUSjal, NULL }  ,  { &&lwPLUSjal, NULL }  ,  { &&lwPLUSjal, NULL } 
 ,  { &&lwPLUSjal, NULL }  ,  { &&lwPLUSjal, NULL }  ,  { &&lwPLUSjal, NULL }  ,  { &&lwPLUSjal, NULL }  ,  { &&lwPLUSjal, NULL }  ,  { &&lwPLUSjal, NULL }  ,  { &&lwPLUSjal, NULL }  ,  { &&lwPLUSjal, NULL }  ,  { &&lwPLUSjal, NULL }  ,  { &&lwPLUSjal, NULL } 
 ,  { &&lwPLUSjal, NULL }  ,  { &&lwPLUSjal, NULL }  ,  { &&lwPLUSjal, NULL }  ,  { &&lwPLUSjal, NULL }  ,  { &&lwPLUSjal, NULL }  ,  { &&lwPLUSjal, NULL }  ,  { &&lwPLUSjal, NULL }  ,  { &&lwPLUSjal, NULL }  ,  { &&lwPLUSjal, NULL }  ,  { &&lwPLUSjal, NULL } 
 ,  { &&lwPLUSjal, NULL }  ,  { &&lwPLUSjal, NULL }  ,  { &&lwPLUSjal, NULL }  ,  { &&lwPLUSjal, NULL }  ,  { &&lwPLUSjal, NULL }  ,  { &&lwPLUSjal, NULL }  ,  { &&lwPLUSjal, NULL }  ,  { &&lwPLUSjal, NULL }  ,  { &&lwPLUSjal, NULL }  ,  { &&lwPLUSjal, NULL } 
 ,  { &&lwPLUSjal, NULL }  ,  { &&lwPLUSjal, NULL }  ,  { &&lwPLUSjal, NULL }  ,  { &&lwPLUSjal, NULL }  ,  { &&lwPLUSjal, NULL }  ,  { &&lwPLUSjal, NULL }  ,  { &&lwPLUSjal, NULL }  ,  { &&lwPLUSjal, NULL }  ,  { &&lwPLUSjal, NULL }  ,  { &&lwPLUSjal, NULL } 
 ,  { &&lwPLUSjal, NULL }  ,  { &&lwPLUSjal, NULL }  ,  { &&lwPLUSjal, NULL }  ,  { &&lwPLUSjal, NULL }  ,  { &&lwPLUSjal, NULL }  ,  { &&lwPLUSjal, NULL }  ,  { &&lwPLUSjal, NULL }  ,  { &&lwPLUSjal, NULL }  ,  { &&lwPLUSjal, NULL }  ,  { &&lwPLUSjal, NULL } 
 }; 

struct pointer arrayjumpPLUSsw[T_SIZE] = {  { &&jumpPLUSsw, NULL }  ,  { &&jumpPLUSsw, NULL }  ,  { &&jumpPLUSsw, NULL }  ,  { &&jumpPLUSsw, NULL }  ,  { &&jumpPLUSsw, NULL }  ,  { &&jumpPLUSsw, NULL }  ,  { &&jumpPLUSsw, NULL }  ,  { &&jumpPLUSsw, NULL }  ,  { &&jumpPLUSsw, NULL }  ,  { &&jumpPLUSsw, NULL } 
 ,  { &&jumpPLUSsw, NULL }  ,  { &&jumpPLUSsw, NULL }  ,  { &&jumpPLUSsw, NULL }  ,  { &&jumpPLUSsw, NULL }  ,  { &&jumpPLUSsw, NULL }  ,  { &&jumpPLUSsw, NULL }  ,  { &&jumpPLUSsw, NULL }  ,  { &&jumpPLUSsw, NULL }  ,  { &&jumpPLUSsw, NULL }  ,  { &&jumpPLUSsw, NULL } 
 ,  { &&jumpPLUSsw, NULL }  ,  { &&jumpPLUSsw, NULL }  ,  { &&jumpPLUSsw, NULL }  ,  { &&jumpPLUSsw, NULL }  ,  { &&jumpPLUSsw, NULL }  ,  { &&jumpPLUSsw, NULL }  ,  { &&jumpPLUSsw, NULL }  ,  { &&jumpPLUSsw, NULL }  ,  { &&jumpPLUSsw, NULL }  ,  { &&jumpPLUSsw, NULL } 
 ,  { &&jumpPLUSsw, NULL }  ,  { &&jumpPLUSsw, NULL }  ,  { &&jumpPLUSsw, NULL }  ,  { &&jumpPLUSsw, NULL }  ,  { &&jumpPLUSsw, NULL }  ,  { &&jumpPLUSsw, NULL }  ,  { &&jumpPLUSsw, NULL }  ,  { &&jumpPLUSsw, NULL }  ,  { &&jumpPLUSsw, NULL }  ,  { &&jumpPLUSsw, NULL } 
 ,  { &&jumpPLUSsw, NULL }  ,  { &&jumpPLUSsw, NULL }  ,  { &&jumpPLUSsw, NULL }  ,  { &&jumpPLUSsw, NULL }  ,  { &&jumpPLUSsw, NULL }  ,  { &&jumpPLUSsw, NULL }  ,  { &&jumpPLUSsw, NULL }  ,  { &&jumpPLUSsw, NULL }  ,  { &&jumpPLUSsw, NULL }  ,  { &&jumpPLUSsw, NULL } 
 ,  { &&jumpPLUSsw, NULL }  ,  { &&jumpPLUSsw, NULL }  ,  { &&jumpPLUSsw, NULL }  ,  { &&jumpPLUSswPLUSslti, NULL }  ,  { &&jumpPLUSsw, NULL }  ,  { &&jumpPLUSsw, NULL }  ,  { &&jumpPLUSsw, NULL }  ,  { &&jumpPLUSsw, NULL }  ,  { &&jumpPLUSsw, NULL }  ,  { &&jumpPLUSsw, NULL } 
 ,  { &&jumpPLUSsw, NULL }  ,  { &&jumpPLUSsw, NULL }  ,  { &&jumpPLUSsw, NULL }  ,  { &&jumpPLUSsw, NULL }  ,  { &&jumpPLUSsw, NULL }  ,  { &&jumpPLUSsw, NULL }  ,  { &&jumpPLUSsw, NULL }  ,  { &&jumpPLUSsw, NULL }  ,  { &&jumpPLUSsw, NULL }  ,  { &&jumpPLUSsw, NULL } 
 ,  { &&jumpPLUSsw, NULL }  ,  { &&jumpPLUSsw, NULL }  ,  { &&jumpPLUSsw, NULL }  ,  { &&jumpPLUSsw, NULL }  ,  { &&jumpPLUSsw, NULL }  ,  { &&jumpPLUSsw, NULL }  ,  { &&jumpPLUSsw, NULL }  ,  { &&jumpPLUSsw, NULL }  ,  { &&jumpPLUSsw, NULL }  ,  { &&jumpPLUSsw, NULL } 
 ,  { &&jumpPLUSsw, NULL }  ,  { &&jumpPLUSsw, NULL }  ,  { &&jumpPLUSsw, NULL }  ,  { &&jumpPLUSsw, NULL }  ,  { &&jumpPLUSsw, NULL }  ,  { &&jumpPLUSsw, NULL }  ,  { &&jumpPLUSsw, NULL }  ,  { &&jumpPLUSsw, NULL }  ,  { &&jumpPLUSsw, NULL }  ,  { &&jumpPLUSsw, NULL } 
 ,  { &&jumpPLUSsw, NULL }  ,  { &&jumpPLUSsw, NULL }  ,  { &&jumpPLUSsw, NULL }  ,  { &&jumpPLUSsw, NULL }  ,  { &&jumpPLUSsw, NULL }  ,  { &&jumpPLUSsw, NULL }  ,  { &&jumpPLUSsw, NULL }  ,  { &&jumpPLUSsw, NULL }  ,  { &&jumpPLUSsw, NULL }  ,  { &&jumpPLUSsw, NULL } 
 ,  { &&jumpPLUSsw, NULL }  ,  { &&jumpPLUSsw, NULL }  ,  { &&jumpPLUSsw, NULL }  ,  { &&jumpPLUSsw, NULL }  ,  { &&jumpPLUSsw, NULL }  ,  { &&jumpPLUSsw, NULL }  ,  { &&jumpPLUSsw, NULL }  ,  { &&jumpPLUSsw, NULL }  ,  { &&jumpPLUSsw, NULL }  ,  { &&jumpPLUSsw, NULL } 
 }; 

struct pointer arrayjrPLUSsll[T_SIZE] = {  { &&jrPLUSsll, NULL }  ,  { &&jrPLUSsll, NULL }  ,  { &&jrPLUSsll, NULL }  ,  { &&jrPLUSsll, NULL }  ,  { &&jrPLUSsll, NULL }  ,  { &&jrPLUSsll, NULL }  ,  { &&jrPLUSsll, NULL }  ,  { &&jrPLUSsll, NULL }  ,  { &&jrPLUSsll, NULL }  ,  { &&jrPLUSsll, NULL } 
 ,  { &&jrPLUSsll, NULL }  ,  { &&jrPLUSsll, NULL }  ,  { &&jrPLUSsll, NULL }  ,  { &&jrPLUSsll, NULL }  ,  { &&jrPLUSsll, NULL }  ,  { &&jrPLUSsll, NULL }  ,  { &&jrPLUSsll, NULL }  ,  { &&jrPLUSsll, NULL }  ,  { &&jrPLUSsll, NULL }  ,  { &&jrPLUSsll, NULL } 
 ,  { &&jrPLUSsll, NULL }  ,  { &&jrPLUSsll, NULL }  ,  { &&jrPLUSsll, NULL }  ,  { &&jrPLUSsll, NULL }  ,  { &&jrPLUSsll, NULL }  ,  { &&jrPLUSsll, NULL }  ,  { &&jrPLUSsll, NULL }  ,  { &&jrPLUSsll, NULL }  ,  { &&jrPLUSsll, NULL }  ,  { &&jrPLUSsll, NULL } 
 ,  { &&jrPLUSsll, NULL }  ,  { &&jrPLUSsll, NULL }  ,  { &&jrPLUSsll, NULL }  ,  { &&jrPLUSsllPLUSaddu, NULL }  ,  { &&jrPLUSsll, NULL }  ,  { &&jrPLUSsll, NULL }  ,  { &&jrPLUSsll, NULL }  ,  { &&jrPLUSsll, NULL }  ,  { &&jrPLUSsll, NULL }  ,  { &&jrPLUSsll, NULL } 
 ,  { &&jrPLUSsll, NULL }  ,  { &&jrPLUSsll, NULL }  ,  { &&jrPLUSsll, NULL }  ,  { &&jrPLUSsll, NULL }  ,  { &&jrPLUSsll, NULL }  ,  { &&jrPLUSsll, NULL }  ,  { &&jrPLUSsllPLUSjal, NULL }  ,  { &&jrPLUSsll, NULL }  ,  { &&jrPLUSsll, NULL }  ,  { &&jrPLUSsll, NULL } 
 ,  { &&jrPLUSsll, NULL }  ,  { &&jrPLUSsll, NULL }  ,  { &&jrPLUSsllPLUSaddiu, NULL }  ,  { &&jrPLUSsll, NULL }  ,  { &&jrPLUSsll, NULL }  ,  { &&jrPLUSsll, NULL }  ,  { &&jrPLUSsll, NULL }  ,  { &&jrPLUSsll, NULL }  ,  { &&jrPLUSsllPLUSlui, NULL }  ,  { &&jrPLUSsll, NULL } 
 ,  { &&jrPLUSsll, NULL }  ,  { &&jrPLUSsll, NULL }  ,  { &&jrPLUSsll, NULL }  ,  { &&jrPLUSsll, NULL }  ,  { &&jrPLUSsll, NULL }  ,  { &&jrPLUSsll, NULL }  ,  { &&jrPLUSsll, NULL }  ,  { &&jrPLUSsll, NULL }  ,  { &&jrPLUSsll, NULL }  ,  { &&jrPLUSsll, NULL } 
 ,  { &&jrPLUSsll, NULL }  ,  { &&jrPLUSsll, NULL }  ,  { &&jrPLUSsll, NULL }  ,  { &&jrPLUSsll, NULL }  ,  { &&jrPLUSsll, NULL }  ,  { &&jrPLUSsll, NULL }  ,  { &&jrPLUSsll, NULL }  ,  { &&jrPLUSsll, NULL }  ,  { &&jrPLUSsllPLUSlw, NULL }  ,  { &&jrPLUSsll, NULL } 
 ,  { &&jrPLUSsll, NULL }  ,  { &&jrPLUSsll, NULL }  ,  { &&jrPLUSsll, NULL }  ,  { &&jrPLUSsll, NULL }  ,  { &&jrPLUSsll, NULL }  ,  { &&jrPLUSsll, NULL }  ,  { &&jrPLUSsll, NULL }  ,  { &&jrPLUSsll, NULL }  ,  { &&jrPLUSsll, NULL }  ,  { &&jrPLUSsll, NULL } 
 ,  { &&jrPLUSsll, NULL }  ,  { &&jrPLUSsll, NULL }  ,  { &&jrPLUSsll, NULL }  ,  { &&jrPLUSsll, NULL }  ,  { &&jrPLUSsll, NULL }  ,  { &&jrPLUSsll, NULL }  ,  { &&jrPLUSsll, NULL }  ,  { &&jrPLUSsll, NULL }  ,  { &&jrPLUSsll, NULL }  ,  { &&jrPLUSsll, NULL } 
 ,  { &&jrPLUSsll, NULL }  ,  { &&jrPLUSsll, NULL }  ,  { &&jrPLUSsll, NULL }  ,  { &&jrPLUSsll, NULL }  ,  { &&jrPLUSsll, NULL }  ,  { &&jrPLUSsll, NULL }  ,  { &&jrPLUSsll, NULL }  ,  { &&jrPLUSsll, NULL }  ,  { &&jrPLUSsll, NULL }  ,  { &&jrPLUSsll, NULL } 
 }; 

struct pointer arrayoriPLUSmult[T_SIZE] = {  { &&oriPLUSmult, NULL }  ,  { &&oriPLUSmult, NULL }  ,  { &&oriPLUSmult, NULL }  ,  { &&oriPLUSmult, NULL }  ,  { &&oriPLUSmult, NULL }  ,  { &&oriPLUSmult, NULL }  ,  { &&oriPLUSmult, NULL }  ,  { &&oriPLUSmult, NULL }  ,  { &&oriPLUSmult, NULL }  ,  { &&oriPLUSmult, NULL } 
 ,  { &&oriPLUSmult, NULL }  ,  { &&oriPLUSmult, NULL }  ,  { &&oriPLUSmult, NULL }  ,  { &&oriPLUSmult, NULL }  ,  { &&oriPLUSmult, NULL }  ,  { &&oriPLUSmult, NULL }  ,  { &&oriPLUSmultPLUSmfhi, NULL }  ,  { &&oriPLUSmult, NULL }  ,  { &&oriPLUSmult, NULL }  ,  { &&oriPLUSmult, NULL } 
 ,  { &&oriPLUSmult, NULL }  ,  { &&oriPLUSmult, NULL }  ,  { &&oriPLUSmult, NULL }  ,  { &&oriPLUSmult, NULL }  ,  { &&oriPLUSmult, NULL }  ,  { &&oriPLUSmult, NULL }  ,  { &&oriPLUSmult, NULL }  ,  { &&oriPLUSmult, NULL }  ,  { &&oriPLUSmult, NULL }  ,  { &&oriPLUSmult, NULL } 
 ,  { &&oriPLUSmult, NULL }  ,  { &&oriPLUSmult, NULL }  ,  { &&oriPLUSmult, NULL }  ,  { &&oriPLUSmult, NULL }  ,  { &&oriPLUSmult, NULL }  ,  { &&oriPLUSmult, NULL }  ,  { &&oriPLUSmult, NULL }  ,  { &&oriPLUSmult, NULL }  ,  { &&oriPLUSmult, NULL }  ,  { &&oriPLUSmult, NULL } 
 ,  { &&oriPLUSmult, NULL }  ,  { &&oriPLUSmult, NULL }  ,  { &&oriPLUSmult, NULL }  ,  { &&oriPLUSmult, NULL }  ,  { &&oriPLUSmult, NULL }  ,  { &&oriPLUSmult, NULL }  ,  { &&oriPLUSmult, NULL }  ,  { &&oriPLUSmult, NULL }  ,  { &&oriPLUSmult, NULL }  ,  { &&oriPLUSmult, NULL } 
 ,  { &&oriPLUSmult, NULL }  ,  { &&oriPLUSmult, NULL }  ,  { &&oriPLUSmult, NULL }  ,  { &&oriPLUSmult, NULL }  ,  { &&oriPLUSmult, NULL }  ,  { &&oriPLUSmult, NULL }  ,  { &&oriPLUSmult, NULL }  ,  { &&oriPLUSmult, NULL }  ,  { &&oriPLUSmult, NULL }  ,  { &&oriPLUSmult, NULL } 
 ,  { &&oriPLUSmult, NULL }  ,  { &&oriPLUSmult, NULL }  ,  { &&oriPLUSmult, NULL }  ,  { &&oriPLUSmult, NULL }  ,  { &&oriPLUSmult, NULL }  ,  { &&oriPLUSmult, NULL }  ,  { &&oriPLUSmult, NULL }  ,  { &&oriPLUSmult, NULL }  ,  { &&oriPLUSmult, NULL }  ,  { &&oriPLUSmult, NULL } 
 ,  { &&oriPLUSmult, NULL }  ,  { &&oriPLUSmult, NULL }  ,  { &&oriPLUSmult, NULL }  ,  { &&oriPLUSmult, NULL }  ,  { &&oriPLUSmult, NULL }  ,  { &&oriPLUSmult, NULL }  ,  { &&oriPLUSmult, NULL }  ,  { &&oriPLUSmult, NULL }  ,  { &&oriPLUSmult, NULL }  ,  { &&oriPLUSmult, NULL } 
 ,  { &&oriPLUSmult, NULL }  ,  { &&oriPLUSmult, NULL }  ,  { &&oriPLUSmult, NULL }  ,  { &&oriPLUSmult, NULL }  ,  { &&oriPLUSmult, NULL }  ,  { &&oriPLUSmult, NULL }  ,  { &&oriPLUSmult, NULL }  ,  { &&oriPLUSmult, NULL }  ,  { &&oriPLUSmult, NULL }  ,  { &&oriPLUSmult, NULL } 
 ,  { &&oriPLUSmult, NULL }  ,  { &&oriPLUSmult, NULL }  ,  { &&oriPLUSmult, NULL }  ,  { &&oriPLUSmult, NULL }  ,  { &&oriPLUSmult, NULL }  ,  { &&oriPLUSmult, NULL }  ,  { &&oriPLUSmult, NULL }  ,  { &&oriPLUSmult, NULL }  ,  { &&oriPLUSmult, NULL }  ,  { &&oriPLUSmult, NULL } 
 ,  { &&oriPLUSmult, NULL }  ,  { &&oriPLUSmult, NULL }  ,  { &&oriPLUSmult, NULL }  ,  { &&oriPLUSmult, NULL }  ,  { &&oriPLUSmult, NULL }  ,  { &&oriPLUSmult, NULL }  ,  { &&oriPLUSmult, NULL }  ,  { &&oriPLUSmult, NULL }  ,  { &&oriPLUSmult, NULL }  ,  { &&oriPLUSmult, NULL } 
 }; 

struct pointer arraysyscPLUSjal[T_SIZE] = {  { &&syscPLUSjalPLUSsll, NULL }  ,  { &&syscPLUSjal, NULL }  ,  { &&syscPLUSjal, NULL }  ,  { &&syscPLUSjal, NULL }  ,  { &&syscPLUSjal, NULL }  ,  { &&syscPLUSjal, NULL }  ,  { &&syscPLUSjal, NULL }  ,  { &&syscPLUSjal, NULL }  ,  { &&syscPLUSjal, NULL }  ,  { &&syscPLUSjal, NULL } 
 ,  { &&syscPLUSjal, NULL }  ,  { &&syscPLUSjal, NULL }  ,  { &&syscPLUSjal, NULL }  ,  { &&syscPLUSjal, NULL }  ,  { &&syscPLUSjal, NULL }  ,  { &&syscPLUSjal, NULL }  ,  { &&syscPLUSjal, NULL }  ,  { &&syscPLUSjal, NULL }  ,  { &&syscPLUSjal, NULL }  ,  { &&syscPLUSjal, NULL } 
 ,  { &&syscPLUSjal, NULL }  ,  { &&syscPLUSjal, NULL }  ,  { &&syscPLUSjal, NULL }  ,  { &&syscPLUSjal, NULL }  ,  { &&syscPLUSjal, NULL }  ,  { &&syscPLUSjal, NULL }  ,  { &&syscPLUSjal, NULL }  ,  { &&syscPLUSjal, NULL }  ,  { &&syscPLUSjal, NULL }  ,  { &&syscPLUSjal, NULL } 
 ,  { &&syscPLUSjal, NULL }  ,  { &&syscPLUSjal, NULL }  ,  { &&syscPLUSjal, NULL }  ,  { &&syscPLUSjal, NULL }  ,  { &&syscPLUSjal, NULL }  ,  { &&syscPLUSjal, NULL }  ,  { &&syscPLUSjal, NULL }  ,  { &&syscPLUSjal, NULL }  ,  { &&syscPLUSjal, NULL }  ,  { &&syscPLUSjal, NULL } 
 ,  { &&syscPLUSjal, NULL }  ,  { &&syscPLUSjal, NULL }  ,  { &&syscPLUSjal, NULL }  ,  { &&syscPLUSjal, NULL }  ,  { &&syscPLUSjal, NULL }  ,  { &&syscPLUSjal, NULL }  ,  { &&syscPLUSjal, NULL }  ,  { &&syscPLUSjal, NULL }  ,  { &&syscPLUSjal, NULL }  ,  { &&syscPLUSjal, NULL } 
 ,  { &&syscPLUSjal, NULL }  ,  { &&syscPLUSjal, NULL }  ,  { &&syscPLUSjal, NULL }  ,  { &&syscPLUSjal, NULL }  ,  { &&syscPLUSjal, NULL }  ,  { &&syscPLUSjal, NULL }  ,  { &&syscPLUSjal, NULL }  ,  { &&syscPLUSjal, NULL }  ,  { &&syscPLUSjal, NULL }  ,  { &&syscPLUSjal, NULL } 
 ,  { &&syscPLUSjal, NULL }  ,  { &&syscPLUSjal, NULL }  ,  { &&syscPLUSjal, NULL }  ,  { &&syscPLUSjal, NULL }  ,  { &&syscPLUSjal, NULL }  ,  { &&syscPLUSjal, NULL }  ,  { &&syscPLUSjal, NULL }  ,  { &&syscPLUSjal, NULL }  ,  { &&syscPLUSjal, NULL }  ,  { &&syscPLUSjal, NULL } 
 ,  { &&syscPLUSjal, NULL }  ,  { &&syscPLUSjal, NULL }  ,  { &&syscPLUSjal, NULL }  ,  { &&syscPLUSjal, NULL }  ,  { &&syscPLUSjal, NULL }  ,  { &&syscPLUSjal, NULL }  ,  { &&syscPLUSjal, NULL }  ,  { &&syscPLUSjal, NULL }  ,  { &&syscPLUSjal, NULL }  ,  { &&syscPLUSjal, NULL } 
 ,  { &&syscPLUSjal, NULL }  ,  { &&syscPLUSjal, NULL }  ,  { &&syscPLUSjal, NULL }  ,  { &&syscPLUSjal, NULL }  ,  { &&syscPLUSjal, NULL }  ,  { &&syscPLUSjal, NULL }  ,  { &&syscPLUSjal, NULL }  ,  { &&syscPLUSjal, NULL }  ,  { &&syscPLUSjal, NULL }  ,  { &&syscPLUSjal, NULL } 
 ,  { &&syscPLUSjal, NULL }  ,  { &&syscPLUSjal, NULL }  ,  { &&syscPLUSjal, NULL }  ,  { &&syscPLUSjal, NULL }  ,  { &&syscPLUSjal, NULL }  ,  { &&syscPLUSjal, NULL }  ,  { &&syscPLUSjal, NULL }  ,  { &&syscPLUSjal, NULL }  ,  { &&syscPLUSjal, NULL }  ,  { &&syscPLUSjal, NULL } 
 ,  { &&syscPLUSjal, NULL }  ,  { &&syscPLUSjal, NULL }  ,  { &&syscPLUSjal, NULL }  ,  { &&syscPLUSjal, NULL }  ,  { &&syscPLUSjal, NULL }  ,  { &&syscPLUSjal, NULL }  ,  { &&syscPLUSjal, NULL }  ,  { &&syscPLUSjal, NULL }  ,  { &&syscPLUSjal, NULL }  ,  { &&syscPLUSjal, NULL } 
 }; 

struct pointer arrayadduPLUSlbu[T_SIZE] = {  { &&adduPLUSlbu, NULL }  ,  { &&adduPLUSlbu, NULL }  ,  { &&adduPLUSlbu, NULL }  ,  { &&adduPLUSlbu, NULL }  ,  { &&adduPLUSlbu, NULL }  ,  { &&adduPLUSlbu, NULL }  ,  { &&adduPLUSlbu, NULL }  ,  { &&adduPLUSlbu, NULL }  ,  { &&adduPLUSlbu, NULL }  ,  { &&adduPLUSlbu, NULL } 
 ,  { &&adduPLUSlbu, NULL }  ,  { &&adduPLUSlbu, NULL }  ,  { &&adduPLUSlbu, NULL }  ,  { &&adduPLUSlbu, NULL }  ,  { &&adduPLUSlbu, NULL }  ,  { &&adduPLUSlbu, NULL }  ,  { &&adduPLUSlbu, NULL }  ,  { &&adduPLUSlbu, NULL }  ,  { &&adduPLUSlbu, NULL }  ,  { &&adduPLUSlbu, NULL } 
 ,  { &&adduPLUSlbu, NULL }  ,  { &&adduPLUSlbu, NULL }  ,  { &&adduPLUSlbu, NULL }  ,  { &&adduPLUSlbu, NULL }  ,  { &&adduPLUSlbu, NULL }  ,  { &&adduPLUSlbu, NULL }  ,  { &&adduPLUSlbu, NULL }  ,  { &&adduPLUSlbu, NULL }  ,  { &&adduPLUSlbu, NULL }  ,  { &&adduPLUSlbu, NULL } 
 ,  { &&adduPLUSlbu, NULL }  ,  { &&adduPLUSlbu, NULL }  ,  { &&adduPLUSlbu, NULL }  ,  { &&adduPLUSlbu, NULL }  ,  { &&adduPLUSlbu, NULL }  ,  { &&adduPLUSlbu, NULL }  ,  { &&adduPLUSlbu, NULL }  ,  { &&adduPLUSlbu, NULL }  ,  { &&adduPLUSlbu, NULL }  ,  { &&adduPLUSlbu, NULL } 
 ,  { &&adduPLUSlbu, NULL }  ,  { &&adduPLUSlbu, NULL }  ,  { &&adduPLUSlbu, NULL }  ,  { &&adduPLUSlbu, NULL }  ,  { &&adduPLUSlbu, NULL }  ,  { &&adduPLUSlbu, NULL }  ,  { &&adduPLUSlbu, NULL }  ,  { &&adduPLUSlbuPLUSbeq, NULL }  ,  { &&adduPLUSlbu, NULL }  ,  { &&adduPLUSlbu, NULL } 
 ,  { &&adduPLUSlbu, NULL }  ,  { &&adduPLUSlbu, NULL }  ,  { &&adduPLUSlbu, NULL }  ,  { &&adduPLUSlbu, NULL }  ,  { &&adduPLUSlbu, NULL }  ,  { &&adduPLUSlbu, NULL }  ,  { &&adduPLUSlbu, NULL }  ,  { &&adduPLUSlbu, NULL }  ,  { &&adduPLUSlbu, NULL }  ,  { &&adduPLUSlbu, NULL } 
 ,  { &&adduPLUSlbu, NULL }  ,  { &&adduPLUSlbu, NULL }  ,  { &&adduPLUSlbu, NULL }  ,  { &&adduPLUSlbu, NULL }  ,  { &&adduPLUSlbu, NULL }  ,  { &&adduPLUSlbu, NULL }  ,  { &&adduPLUSlbu, NULL }  ,  { &&adduPLUSlbu, NULL }  ,  { &&adduPLUSlbu, NULL }  ,  { &&adduPLUSlbu, NULL } 
 ,  { &&adduPLUSlbu, NULL }  ,  { &&adduPLUSlbu, NULL }  ,  { &&adduPLUSlbu, NULL }  ,  { &&adduPLUSlbu, NULL }  ,  { &&adduPLUSlbu, NULL }  ,  { &&adduPLUSlbu, NULL }  ,  { &&adduPLUSlbu, NULL }  ,  { &&adduPLUSlbu, NULL }  ,  { &&adduPLUSlbu, NULL }  ,  { &&adduPLUSlbu, NULL } 
 ,  { &&adduPLUSlbu, NULL }  ,  { &&adduPLUSlbu, NULL }  ,  { &&adduPLUSlbu, NULL }  ,  { &&adduPLUSlbu, NULL }  ,  { &&adduPLUSlbu, NULL }  ,  { &&adduPLUSlbu, NULL }  ,  { &&adduPLUSlbu, NULL }  ,  { &&adduPLUSlbu, NULL }  ,  { &&adduPLUSlbu, NULL }  ,  { &&adduPLUSlbu, NULL } 
 ,  { &&adduPLUSlbu, NULL }  ,  { &&adduPLUSlbu, NULL }  ,  { &&adduPLUSlbu, NULL }  ,  { &&adduPLUSlbu, NULL }  ,  { &&adduPLUSlbu, NULL }  ,  { &&adduPLUSlbu, NULL }  ,  { &&adduPLUSlbu, NULL }  ,  { &&adduPLUSlbu, NULL }  ,  { &&adduPLUSlbu, NULL }  ,  { &&adduPLUSlbu, NULL } 
 ,  { &&adduPLUSlbu, NULL }  ,  { &&adduPLUSlbu, NULL }  ,  { &&adduPLUSlbu, NULL }  ,  { &&adduPLUSlbu, NULL }  ,  { &&adduPLUSlbu, NULL }  ,  { &&adduPLUSlbu, NULL }  ,  { &&adduPLUSlbu, NULL }  ,  { &&adduPLUSlbu, NULL }  ,  { &&adduPLUSlbu, NULL }  ,  { &&adduPLUSlbu, NULL } 
 }; 

struct pointer arrayswPLUSlui[T_SIZE] = {  { &&swPLUSlui, NULL }  ,  { &&swPLUSlui, NULL }  ,  { &&swPLUSlui, NULL }  ,  { &&swPLUSlui, NULL }  ,  { &&swPLUSlui, NULL }  ,  { &&swPLUSlui, NULL }  ,  { &&swPLUSlui, NULL }  ,  { &&swPLUSlui, NULL }  ,  { &&swPLUSlui, NULL }  ,  { &&swPLUSlui, NULL } 
 ,  { &&swPLUSlui, NULL }  ,  { &&swPLUSlui, NULL }  ,  { &&swPLUSlui, NULL }  ,  { &&swPLUSlui, NULL }  ,  { &&swPLUSlui, NULL }  ,  { &&swPLUSlui, NULL }  ,  { &&swPLUSlui, NULL }  ,  { &&swPLUSlui, NULL }  ,  { &&swPLUSlui, NULL }  ,  { &&swPLUSlui, NULL } 
 ,  { &&swPLUSlui, NULL }  ,  { &&swPLUSlui, NULL }  ,  { &&swPLUSlui, NULL }  ,  { &&swPLUSlui, NULL }  ,  { &&swPLUSlui, NULL }  ,  { &&swPLUSlui, NULL }  ,  { &&swPLUSlui, NULL }  ,  { &&swPLUSlui, NULL }  ,  { &&swPLUSlui, NULL }  ,  { &&swPLUSlui, NULL } 
 ,  { &&swPLUSlui, NULL }  ,  { &&swPLUSlui, NULL }  ,  { &&swPLUSlui, NULL }  ,  { &&swPLUSlui, NULL }  ,  { &&swPLUSlui, NULL }  ,  { &&swPLUSlui, NULL }  ,  { &&swPLUSlui, NULL }  ,  { &&swPLUSlui, NULL }  ,  { &&swPLUSlui, NULL }  ,  { &&swPLUSlui, NULL } 
 ,  { &&swPLUSlui, NULL }  ,  { &&swPLUSlui, NULL }  ,  { &&swPLUSlui, NULL }  ,  { &&swPLUSlui, NULL }  ,  { &&swPLUSlui, NULL }  ,  { &&swPLUSlui, NULL }  ,  { &&swPLUSlui, NULL }  ,  { &&swPLUSlui, NULL }  ,  { &&swPLUSlui, NULL }  ,  { &&swPLUSlui, NULL } 
 ,  { &&swPLUSlui, NULL }  ,  { &&swPLUSlui, NULL }  ,  { &&swPLUSluiPLUSaddiu, NULL }  ,  { &&swPLUSlui, NULL }  ,  { &&swPLUSlui, NULL }  ,  { &&swPLUSlui, NULL }  ,  { &&swPLUSlui, NULL }  ,  { &&swPLUSlui, NULL }  ,  { &&swPLUSlui, NULL }  ,  { &&swPLUSlui, NULL } 
 ,  { &&swPLUSlui, NULL }  ,  { &&swPLUSlui, NULL }  ,  { &&swPLUSlui, NULL }  ,  { &&swPLUSlui, NULL }  ,  { &&swPLUSlui, NULL }  ,  { &&swPLUSlui, NULL }  ,  { &&swPLUSlui, NULL }  ,  { &&swPLUSlui, NULL }  ,  { &&swPLUSlui, NULL }  ,  { &&swPLUSlui, NULL } 
 ,  { &&swPLUSlui, NULL }  ,  { &&swPLUSlui, NULL }  ,  { &&swPLUSlui, NULL }  ,  { &&swPLUSlui, NULL }  ,  { &&swPLUSlui, NULL }  ,  { &&swPLUSlui, NULL }  ,  { &&swPLUSlui, NULL }  ,  { &&swPLUSlui, NULL }  ,  { &&swPLUSluiPLUSlw, NULL }  ,  { &&swPLUSlui, NULL } 
 ,  { &&swPLUSlui, NULL }  ,  { &&swPLUSlui, NULL }  ,  { &&swPLUSlui, NULL }  ,  { &&swPLUSlui, NULL }  ,  { &&swPLUSlui, NULL }  ,  { &&swPLUSlui, NULL }  ,  { &&swPLUSlui, NULL }  ,  { &&swPLUSlui, NULL }  ,  { &&swPLUSlui, NULL }  ,  { &&swPLUSlui, NULL } 
 ,  { &&swPLUSlui, NULL }  ,  { &&swPLUSlui, NULL }  ,  { &&swPLUSlui, NULL }  ,  { &&swPLUSlui, NULL }  ,  { &&swPLUSlui, NULL }  ,  { &&swPLUSlui, NULL }  ,  { &&swPLUSlui, NULL }  ,  { &&swPLUSlui, NULL }  ,  { &&swPLUSlui, NULL }  ,  { &&swPLUSlui, NULL } 
 ,  { &&swPLUSlui, NULL }  ,  { &&swPLUSlui, NULL }  ,  { &&swPLUSlui, NULL }  ,  { &&swPLUSlui, NULL }  ,  { &&swPLUSlui, NULL }  ,  { &&swPLUSlui, NULL }  ,  { &&swPLUSlui, NULL }  ,  { &&swPLUSlui, NULL }  ,  { &&swPLUSlui, NULL }  ,  { &&swPLUSlui, NULL } 
 }; 

struct pointer arraysllPLUSor[T_SIZE] = {  { &&sllPLUSorPLUSsll, NULL }  ,  { &&sllPLUSor, NULL }  ,  { &&sllPLUSor, NULL }  ,  { &&sllPLUSor, NULL }  ,  { &&sllPLUSor, NULL }  ,  { &&sllPLUSor, NULL }  ,  { &&sllPLUSor, NULL }  ,  { &&sllPLUSor, NULL }  ,  { &&sllPLUSor, NULL }  ,  { &&sllPLUSor, NULL } 
 ,  { &&sllPLUSor, NULL }  ,  { &&sllPLUSor, NULL }  ,  { &&sllPLUSor, NULL }  ,  { &&sllPLUSor, NULL }  ,  { &&sllPLUSor, NULL }  ,  { &&sllPLUSor, NULL }  ,  { &&sllPLUSor, NULL }  ,  { &&sllPLUSor, NULL }  ,  { &&sllPLUSor, NULL }  ,  { &&sllPLUSor, NULL } 
 ,  { &&sllPLUSor, NULL }  ,  { &&sllPLUSor, NULL }  ,  { &&sllPLUSor, NULL }  ,  { &&sllPLUSor, NULL }  ,  { &&sllPLUSor, NULL }  ,  { &&sllPLUSor, NULL }  ,  { &&sllPLUSor, NULL }  ,  { &&sllPLUSor, NULL }  ,  { &&sllPLUSor, NULL }  ,  { &&sllPLUSor, NULL } 
 ,  { &&sllPLUSor, NULL }  ,  { &&sllPLUSor, NULL }  ,  { &&sllPLUSor, NULL }  ,  { &&sllPLUSor, NULL }  ,  { &&sllPLUSor, NULL }  ,  { &&sllPLUSor, NULL }  ,  { &&sllPLUSor, NULL }  ,  { &&sllPLUSorPLUSor, NULL }  ,  { &&sllPLUSor, NULL }  ,  { &&sllPLUSor, NULL } 
 ,  { &&sllPLUSor, NULL }  ,  { &&sllPLUSor, NULL }  ,  { &&sllPLUSor, NULL }  ,  { &&sllPLUSor, NULL }  ,  { &&sllPLUSor, NULL }  ,  { &&sllPLUSor, NULL }  ,  { &&sllPLUSor, NULL }  ,  { &&sllPLUSor, NULL }  ,  { &&sllPLUSor, NULL }  ,  { &&sllPLUSor, NULL } 
 ,  { &&sllPLUSor, NULL }  ,  { &&sllPLUSor, NULL }  ,  { &&sllPLUSor, NULL }  ,  { &&sllPLUSor, NULL }  ,  { &&sllPLUSor, NULL }  ,  { &&sllPLUSor, NULL }  ,  { &&sllPLUSor, NULL }  ,  { &&sllPLUSor, NULL }  ,  { &&sllPLUSor, NULL }  ,  { &&sllPLUSor, NULL } 
 ,  { &&sllPLUSor, NULL }  ,  { &&sllPLUSor, NULL }  ,  { &&sllPLUSor, NULL }  ,  { &&sllPLUSor, NULL }  ,  { &&sllPLUSor, NULL }  ,  { &&sllPLUSor, NULL }  ,  { &&sllPLUSor, NULL }  ,  { &&sllPLUSor, NULL }  ,  { &&sllPLUSor, NULL }  ,  { &&sllPLUSor, NULL } 
 ,  { &&sllPLUSor, NULL }  ,  { &&sllPLUSor, NULL }  ,  { &&sllPLUSor, NULL }  ,  { &&sllPLUSor, NULL }  ,  { &&sllPLUSor, NULL }  ,  { &&sllPLUSor, NULL }  ,  { &&sllPLUSor, NULL }  ,  { &&sllPLUSor, NULL }  ,  { &&sllPLUSor, NULL }  ,  { &&sllPLUSor, NULL } 
 ,  { &&sllPLUSor, NULL }  ,  { &&sllPLUSor, NULL }  ,  { &&sllPLUSor, NULL }  ,  { &&sllPLUSor, NULL }  ,  { &&sllPLUSor, NULL }  ,  { &&sllPLUSor, NULL }  ,  { &&sllPLUSorPLUSsw, NULL }  ,  { &&sllPLUSor, NULL }  ,  { &&sllPLUSor, NULL }  ,  { &&sllPLUSor, NULL } 
 ,  { &&sllPLUSor, NULL }  ,  { &&sllPLUSor, NULL }  ,  { &&sllPLUSor, NULL }  ,  { &&sllPLUSor, NULL }  ,  { &&sllPLUSor, NULL }  ,  { &&sllPLUSor, NULL }  ,  { &&sllPLUSor, NULL }  ,  { &&sllPLUSor, NULL }  ,  { &&sllPLUSor, NULL }  ,  { &&sllPLUSor, NULL } 
 ,  { &&sllPLUSor, NULL }  ,  { &&sllPLUSor, NULL }  ,  { &&sllPLUSor, NULL }  ,  { &&sllPLUSor, NULL }  ,  { &&sllPLUSor, NULL }  ,  { &&sllPLUSor, NULL }  ,  { &&sllPLUSor, NULL }  ,  { &&sllPLUSor, NULL }  ,  { &&sllPLUSor, NULL }  ,  { &&sllPLUSor, NULL } 
 }; 

struct pointer arrayerrorPLUSlw[T_SIZE] = {  { &&errorPLUSlw, NULL }  ,  { &&errorPLUSlw, NULL }  ,  { &&errorPLUSlw, NULL }  ,  { &&errorPLUSlw, NULL }  ,  { &&errorPLUSlw, NULL }  ,  { &&errorPLUSlw, NULL }  ,  { &&errorPLUSlw, NULL }  ,  { &&errorPLUSlw, NULL }  ,  { &&errorPLUSlw, NULL }  ,  { &&errorPLUSlw, NULL } 
 ,  { &&errorPLUSlw, NULL }  ,  { &&errorPLUSlw, NULL }  ,  { &&errorPLUSlw, NULL }  ,  { &&errorPLUSlw, NULL }  ,  { &&errorPLUSlw, NULL }  ,  { &&errorPLUSlw, NULL }  ,  { &&errorPLUSlw, NULL }  ,  { &&errorPLUSlw, NULL }  ,  { &&errorPLUSlw, NULL }  ,  { &&errorPLUSlw, NULL } 
 ,  { &&errorPLUSlw, NULL }  ,  { &&errorPLUSlw, NULL }  ,  { &&errorPLUSlw, NULL }  ,  { &&errorPLUSlw, NULL }  ,  { &&errorPLUSlw, NULL }  ,  { &&errorPLUSlw, NULL }  ,  { &&errorPLUSlw, NULL }  ,  { &&errorPLUSlw, NULL }  ,  { &&errorPLUSlw, NULL }  ,  { &&errorPLUSlw, NULL } 
 ,  { &&errorPLUSlw, NULL }  ,  { &&errorPLUSlw, NULL }  ,  { &&errorPLUSlw, NULL }  ,  { &&errorPLUSlwPLUSaddu, NULL }  ,  { &&errorPLUSlw, NULL }  ,  { &&errorPLUSlw, NULL }  ,  { &&errorPLUSlw, NULL }  ,  { &&errorPLUSlw, NULL }  ,  { &&errorPLUSlw, NULL }  ,  { &&errorPLUSlw, NULL } 
 ,  { &&errorPLUSlw, NULL }  ,  { &&errorPLUSlw, NULL }  ,  { &&errorPLUSlw, NULL }  ,  { &&errorPLUSlw, NULL }  ,  { &&errorPLUSlw, NULL }  ,  { &&errorPLUSlw, NULL }  ,  { &&errorPLUSlw, NULL }  ,  { &&errorPLUSlw, NULL }  ,  { &&errorPLUSlw, NULL }  ,  { &&errorPLUSlw, NULL } 
 ,  { &&errorPLUSlw, NULL }  ,  { &&errorPLUSlw, NULL }  ,  { &&errorPLUSlw, NULL }  ,  { &&errorPLUSlw, NULL }  ,  { &&errorPLUSlw, NULL }  ,  { &&errorPLUSlw, NULL }  ,  { &&errorPLUSlw, NULL }  ,  { &&errorPLUSlw, NULL }  ,  { &&errorPLUSlw, NULL }  ,  { &&errorPLUSlw, NULL } 
 ,  { &&errorPLUSlw, NULL }  ,  { &&errorPLUSlw, NULL }  ,  { &&errorPLUSlw, NULL }  ,  { &&errorPLUSlw, NULL }  ,  { &&errorPLUSlw, NULL }  ,  { &&errorPLUSlw, NULL }  ,  { &&errorPLUSlw, NULL }  ,  { &&errorPLUSlw, NULL }  ,  { &&errorPLUSlw, NULL }  ,  { &&errorPLUSlw, NULL } 
 ,  { &&errorPLUSlw, NULL }  ,  { &&errorPLUSlw, NULL }  ,  { &&errorPLUSlw, NULL }  ,  { &&errorPLUSlw, NULL }  ,  { &&errorPLUSlw, NULL }  ,  { &&errorPLUSlw, NULL }  ,  { &&errorPLUSlw, NULL }  ,  { &&errorPLUSlw, NULL }  ,  { &&errorPLUSlwPLUSlw, NULL }  ,  { &&errorPLUSlw, NULL } 
 ,  { &&errorPLUSlw, NULL }  ,  { &&errorPLUSlw, NULL }  ,  { &&errorPLUSlw, NULL }  ,  { &&errorPLUSlw, NULL }  ,  { &&errorPLUSlw, NULL }  ,  { &&errorPLUSlw, NULL }  ,  { &&errorPLUSlw, NULL }  ,  { &&errorPLUSlw, NULL }  ,  { &&errorPLUSlw, NULL }  ,  { &&errorPLUSlw, NULL } 
 ,  { &&errorPLUSlw, NULL }  ,  { &&errorPLUSlw, NULL }  ,  { &&errorPLUSlw, NULL }  ,  { &&errorPLUSlw, NULL }  ,  { &&errorPLUSlw, NULL }  ,  { &&errorPLUSlw, NULL }  ,  { &&errorPLUSlw, NULL }  ,  { &&errorPLUSlw, NULL }  ,  { &&errorPLUSlw, NULL }  ,  { &&errorPLUSlw, NULL } 
 ,  { &&errorPLUSlw, NULL }  ,  { &&errorPLUSlw, NULL }  ,  { &&errorPLUSlw, NULL }  ,  { &&errorPLUSlw, NULL }  ,  { &&errorPLUSlw, NULL }  ,  { &&errorPLUSlw, NULL }  ,  { &&errorPLUSlw, NULL }  ,  { &&errorPLUSlw, NULL }  ,  { &&errorPLUSlw, NULL }  ,  { &&errorPLUSlw, NULL } 
 }; 

struct pointer arraynorPLUSjr[T_SIZE] = {  { &&norPLUSjrPLUSsll, NULL }  ,  { &&norPLUSjr, NULL }  ,  { &&norPLUSjr, NULL }  ,  { &&norPLUSjr, NULL }  ,  { &&norPLUSjr, NULL }  ,  { &&norPLUSjr, NULL }  ,  { &&norPLUSjr, NULL }  ,  { &&norPLUSjr, NULL }  ,  { &&norPLUSjr, NULL }  ,  { &&norPLUSjr, NULL } 
 ,  { &&norPLUSjr, NULL }  ,  { &&norPLUSjr, NULL }  ,  { &&norPLUSjr, NULL }  ,  { &&norPLUSjr, NULL }  ,  { &&norPLUSjr, NULL }  ,  { &&norPLUSjr, NULL }  ,  { &&norPLUSjr, NULL }  ,  { &&norPLUSjr, NULL }  ,  { &&norPLUSjr, NULL }  ,  { &&norPLUSjr, NULL } 
 ,  { &&norPLUSjr, NULL }  ,  { &&norPLUSjr, NULL }  ,  { &&norPLUSjr, NULL }  ,  { &&norPLUSjr, NULL }  ,  { &&norPLUSjr, NULL }  ,  { &&norPLUSjr, NULL }  ,  { &&norPLUSjr, NULL }  ,  { &&norPLUSjr, NULL }  ,  { &&norPLUSjr, NULL }  ,  { &&norPLUSjr, NULL } 
 ,  { &&norPLUSjr, NULL }  ,  { &&norPLUSjr, NULL }  ,  { &&norPLUSjr, NULL }  ,  { &&norPLUSjr, NULL }  ,  { &&norPLUSjr, NULL }  ,  { &&norPLUSjr, NULL }  ,  { &&norPLUSjr, NULL }  ,  { &&norPLUSjr, NULL }  ,  { &&norPLUSjr, NULL }  ,  { &&norPLUSjr, NULL } 
 ,  { &&norPLUSjr, NULL }  ,  { &&norPLUSjr, NULL }  ,  { &&norPLUSjr, NULL }  ,  { &&norPLUSjr, NULL }  ,  { &&norPLUSjr, NULL }  ,  { &&norPLUSjr, NULL }  ,  { &&norPLUSjr, NULL }  ,  { &&norPLUSjr, NULL }  ,  { &&norPLUSjr, NULL }  ,  { &&norPLUSjr, NULL } 
 ,  { &&norPLUSjr, NULL }  ,  { &&norPLUSjr, NULL }  ,  { &&norPLUSjr, NULL }  ,  { &&norPLUSjr, NULL }  ,  { &&norPLUSjr, NULL }  ,  { &&norPLUSjr, NULL }  ,  { &&norPLUSjr, NULL }  ,  { &&norPLUSjr, NULL }  ,  { &&norPLUSjr, NULL }  ,  { &&norPLUSjr, NULL } 
 ,  { &&norPLUSjr, NULL }  ,  { &&norPLUSjr, NULL }  ,  { &&norPLUSjr, NULL }  ,  { &&norPLUSjr, NULL }  ,  { &&norPLUSjr, NULL }  ,  { &&norPLUSjr, NULL }  ,  { &&norPLUSjr, NULL }  ,  { &&norPLUSjr, NULL }  ,  { &&norPLUSjr, NULL }  ,  { &&norPLUSjr, NULL } 
 ,  { &&norPLUSjr, NULL }  ,  { &&norPLUSjr, NULL }  ,  { &&norPLUSjr, NULL }  ,  { &&norPLUSjr, NULL }  ,  { &&norPLUSjr, NULL }  ,  { &&norPLUSjr, NULL }  ,  { &&norPLUSjr, NULL }  ,  { &&norPLUSjr, NULL }  ,  { &&norPLUSjr, NULL }  ,  { &&norPLUSjr, NULL } 
 ,  { &&norPLUSjr, NULL }  ,  { &&norPLUSjr, NULL }  ,  { &&norPLUSjr, NULL }  ,  { &&norPLUSjr, NULL }  ,  { &&norPLUSjr, NULL }  ,  { &&norPLUSjr, NULL }  ,  { &&norPLUSjr, NULL }  ,  { &&norPLUSjr, NULL }  ,  { &&norPLUSjr, NULL }  ,  { &&norPLUSjr, NULL } 
 ,  { &&norPLUSjr, NULL }  ,  { &&norPLUSjr, NULL }  ,  { &&norPLUSjr, NULL }  ,  { &&norPLUSjr, NULL }  ,  { &&norPLUSjr, NULL }  ,  { &&norPLUSjr, NULL }  ,  { &&norPLUSjr, NULL }  ,  { &&norPLUSjr, NULL }  ,  { &&norPLUSjr, NULL }  ,  { &&norPLUSjr, NULL } 
 ,  { &&norPLUSjr, NULL }  ,  { &&norPLUSjr, NULL }  ,  { &&norPLUSjr, NULL }  ,  { &&norPLUSjr, NULL }  ,  { &&norPLUSjr, NULL }  ,  { &&norPLUSjr, NULL }  ,  { &&norPLUSjr, NULL }  ,  { &&norPLUSjr, NULL }  ,  { &&norPLUSjr, NULL }  ,  { &&norPLUSjr, NULL } 
 }; 

struct pointer arrayorPLUSsltu[T_SIZE] = {  { &&orPLUSsltu, NULL }  ,  { &&orPLUSsltu, NULL }  ,  { &&orPLUSsltu, NULL }  ,  { &&orPLUSsltu, NULL }  ,  { &&orPLUSsltu, NULL }  ,  { &&orPLUSsltu, NULL }  ,  { &&orPLUSsltu, NULL }  ,  { &&orPLUSsltu, NULL }  ,  { &&orPLUSsltu, NULL }  ,  { &&orPLUSsltu, NULL } 
 ,  { &&orPLUSsltu, NULL }  ,  { &&orPLUSsltu, NULL }  ,  { &&orPLUSsltu, NULL }  ,  { &&orPLUSsltu, NULL }  ,  { &&orPLUSsltu, NULL }  ,  { &&orPLUSsltu, NULL }  ,  { &&orPLUSsltu, NULL }  ,  { &&orPLUSsltu, NULL }  ,  { &&orPLUSsltu, NULL }  ,  { &&orPLUSsltu, NULL } 
 ,  { &&orPLUSsltu, NULL }  ,  { &&orPLUSsltu, NULL }  ,  { &&orPLUSsltu, NULL }  ,  { &&orPLUSsltu, NULL }  ,  { &&orPLUSsltu, NULL }  ,  { &&orPLUSsltu, NULL }  ,  { &&orPLUSsltu, NULL }  ,  { &&orPLUSsltu, NULL }  ,  { &&orPLUSsltu, NULL }  ,  { &&orPLUSsltu, NULL } 
 ,  { &&orPLUSsltu, NULL }  ,  { &&orPLUSsltu, NULL }  ,  { &&orPLUSsltu, NULL }  ,  { &&orPLUSsltu, NULL }  ,  { &&orPLUSsltu, NULL }  ,  { &&orPLUSsltu, NULL }  ,  { &&orPLUSsltu, NULL }  ,  { &&orPLUSsltu, NULL }  ,  { &&orPLUSsltu, NULL }  ,  { &&orPLUSsltu, NULL } 
 ,  { &&orPLUSsltu, NULL }  ,  { &&orPLUSsltu, NULL }  ,  { &&orPLUSsltu, NULL }  ,  { &&orPLUSsltu, NULL }  ,  { &&orPLUSsltu, NULL }  ,  { &&orPLUSsltu, NULL }  ,  { &&orPLUSsltu, NULL }  ,  { &&orPLUSsltu, NULL }  ,  { &&orPLUSsltu, NULL }  ,  { &&orPLUSsltu, NULL } 
 ,  { &&orPLUSsltu, NULL }  ,  { &&orPLUSsltu, NULL }  ,  { &&orPLUSsltu, NULL }  ,  { &&orPLUSsltu, NULL }  ,  { &&orPLUSsltu, NULL }  ,  { &&orPLUSsltu, NULL }  ,  { &&orPLUSsltu, NULL }  ,  { &&orPLUSsltu, NULL }  ,  { &&orPLUSsltu, NULL }  ,  { &&orPLUSsltu, NULL } 
 ,  { &&orPLUSsltu, NULL }  ,  { &&orPLUSsltu, NULL }  ,  { &&orPLUSsltu, NULL }  ,  { &&orPLUSsltu, NULL }  ,  { &&orPLUSsltu, NULL }  ,  { &&orPLUSsltu, NULL }  ,  { &&orPLUSsltu, NULL }  ,  { &&orPLUSsltu, NULL }  ,  { &&orPLUSsltu, NULL }  ,  { &&orPLUSsltu, NULL } 
 ,  { &&orPLUSsltu, NULL }  ,  { &&orPLUSsltu, NULL }  ,  { &&orPLUSsltu, NULL }  ,  { &&orPLUSsltu, NULL }  ,  { &&orPLUSsltu, NULL }  ,  { &&orPLUSsltu, NULL }  ,  { &&orPLUSsltu, NULL }  ,  { &&orPLUSsltu, NULL }  ,  { &&orPLUSsltuPLUSlw, NULL }  ,  { &&orPLUSsltu, NULL } 
 ,  { &&orPLUSsltu, NULL }  ,  { &&orPLUSsltu, NULL }  ,  { &&orPLUSsltu, NULL }  ,  { &&orPLUSsltu, NULL }  ,  { &&orPLUSsltu, NULL }  ,  { &&orPLUSsltu, NULL }  ,  { &&orPLUSsltu, NULL }  ,  { &&orPLUSsltu, NULL }  ,  { &&orPLUSsltu, NULL }  ,  { &&orPLUSsltu, NULL } 
 ,  { &&orPLUSsltu, NULL }  ,  { &&orPLUSsltu, NULL }  ,  { &&orPLUSsltu, NULL }  ,  { &&orPLUSsltu, NULL }  ,  { &&orPLUSsltu, NULL }  ,  { &&orPLUSsltu, NULL }  ,  { &&orPLUSsltu, NULL }  ,  { &&orPLUSsltu, NULL }  ,  { &&orPLUSsltu, NULL }  ,  { &&orPLUSsltu, NULL } 
 ,  { &&orPLUSsltu, NULL }  ,  { &&orPLUSsltu, NULL }  ,  { &&orPLUSsltu, NULL }  ,  { &&orPLUSsltu, NULL }  ,  { &&orPLUSsltu, NULL }  ,  { &&orPLUSsltu, NULL }  ,  { &&orPLUSsltu, NULL }  ,  { &&orPLUSsltu, NULL }  ,  { &&orPLUSsltu, NULL }  ,  { &&orPLUSsltu, NULL } 
 }; 

struct pointer arrayluiPLUSaddiu[T_SIZE] = {  { &&luiPLUSaddiu, NULL }  ,  { &&luiPLUSaddiu, NULL }  ,  { &&luiPLUSaddiu, NULL }  ,  { &&luiPLUSaddiu, NULL }  ,  { &&luiPLUSaddiu, NULL }  ,  { &&luiPLUSaddiu, NULL }  ,  { &&luiPLUSaddiu, NULL }  ,  { &&luiPLUSaddiu, NULL }  ,  { &&luiPLUSaddiu, NULL }  ,  { &&luiPLUSaddiu, NULL } 
 ,  { &&luiPLUSaddiu, NULL }  ,  { &&luiPLUSaddiu, NULL }  ,  { &&luiPLUSaddiuPLUSsysc, NULL }  ,  { &&luiPLUSaddiu, NULL }  ,  { &&luiPLUSaddiu, NULL }  ,  { &&luiPLUSaddiu, NULL }  ,  { &&luiPLUSaddiu, NULL }  ,  { &&luiPLUSaddiu, NULL }  ,  { &&luiPLUSaddiu, NULL }  ,  { &&luiPLUSaddiu, NULL } 
 ,  { &&luiPLUSaddiu, NULL }  ,  { &&luiPLUSaddiu, NULL }  ,  { &&luiPLUSaddiu, NULL }  ,  { &&luiPLUSaddiu, NULL }  ,  { &&luiPLUSaddiu, NULL }  ,  { &&luiPLUSaddiu, NULL }  ,  { &&luiPLUSaddiu, NULL }  ,  { &&luiPLUSaddiu, NULL }  ,  { &&luiPLUSaddiu, NULL }  ,  { &&luiPLUSaddiu, NULL } 
 ,  { &&luiPLUSaddiu, NULL }  ,  { &&luiPLUSaddiu, NULL }  ,  { &&luiPLUSaddiu, NULL }  ,  { &&luiPLUSaddiuPLUSaddu, NULL }  ,  { &&luiPLUSaddiu, NULL }  ,  { &&luiPLUSaddiu, NULL }  ,  { &&luiPLUSaddiu, NULL }  ,  { &&luiPLUSaddiu, NULL }  ,  { &&luiPLUSaddiuPLUSxor, NULL }  ,  { &&luiPLUSaddiu, NULL } 
 ,  { &&luiPLUSaddiu, NULL }  ,  { &&luiPLUSaddiu, NULL }  ,  { &&luiPLUSaddiu, NULL }  ,  { &&luiPLUSaddiu, NULL }  ,  { &&luiPLUSaddiu, NULL }  ,  { &&luiPLUSaddiu, NULL }  ,  { &&luiPLUSaddiuPLUSjal, NULL }  ,  { &&luiPLUSaddiu, NULL }  ,  { &&luiPLUSaddiu, NULL }  ,  { &&luiPLUSaddiu, NULL } 
 ,  { &&luiPLUSaddiu, NULL }  ,  { &&luiPLUSaddiu, NULL }  ,  { &&luiPLUSaddiuPLUSaddiu, NULL }  ,  { &&luiPLUSaddiu, NULL }  ,  { &&luiPLUSaddiu, NULL }  ,  { &&luiPLUSaddiu, NULL }  ,  { &&luiPLUSaddiu, NULL }  ,  { &&luiPLUSaddiu, NULL }  ,  { &&luiPLUSaddiu, NULL }  ,  { &&luiPLUSaddiu, NULL } 
 ,  { &&luiPLUSaddiu, NULL }  ,  { &&luiPLUSaddiu, NULL }  ,  { &&luiPLUSaddiu, NULL }  ,  { &&luiPLUSaddiu, NULL }  ,  { &&luiPLUSaddiu, NULL }  ,  { &&luiPLUSaddiu, NULL }  ,  { &&luiPLUSaddiu, NULL }  ,  { &&luiPLUSaddiu, NULL }  ,  { &&luiPLUSaddiu, NULL }  ,  { &&luiPLUSaddiu, NULL } 
 ,  { &&luiPLUSaddiu, NULL }  ,  { &&luiPLUSaddiu, NULL }  ,  { &&luiPLUSaddiu, NULL }  ,  { &&luiPLUSaddiu, NULL }  ,  { &&luiPLUSaddiu, NULL }  ,  { &&luiPLUSaddiu, NULL }  ,  { &&luiPLUSaddiu, NULL }  ,  { &&luiPLUSaddiu, NULL }  ,  { &&luiPLUSaddiuPLUSlw, NULL }  ,  { &&luiPLUSaddiu, NULL } 
 ,  { &&luiPLUSaddiu, NULL }  ,  { &&luiPLUSaddiu, NULL }  ,  { &&luiPLUSaddiu, NULL }  ,  { &&luiPLUSaddiu, NULL }  ,  { &&luiPLUSaddiu, NULL }  ,  { &&luiPLUSaddiu, NULL }  ,  { &&luiPLUSaddiu, NULL }  ,  { &&luiPLUSaddiu, NULL }  ,  { &&luiPLUSaddiu, NULL }  ,  { &&luiPLUSaddiu, NULL } 
 ,  { &&luiPLUSaddiu, NULL }  ,  { &&luiPLUSaddiu, NULL }  ,  { &&luiPLUSaddiu, NULL }  ,  { &&luiPLUSaddiu, NULL }  ,  { &&luiPLUSaddiu, NULL }  ,  { &&luiPLUSaddiu, NULL }  ,  { &&luiPLUSaddiu, NULL }  ,  { &&luiPLUSaddiu, NULL }  ,  { &&luiPLUSaddiu, NULL }  ,  { &&luiPLUSaddiu, NULL } 
 ,  { &&luiPLUSaddiu, NULL }  ,  { &&luiPLUSaddiu, NULL }  ,  { &&luiPLUSaddiu, NULL }  ,  { &&luiPLUSaddiu, NULL }  ,  { &&luiPLUSaddiu, NULL }  ,  { &&luiPLUSaddiu, NULL }  ,  { &&luiPLUSaddiu, NULL }  ,  { &&luiPLUSaddiu, NULL }  ,  { &&luiPLUSaddiu, NULL }  ,  { &&luiPLUSaddiu, NULL } 
 }; 

struct pointer arrayxorPLUSsw[T_SIZE] = {  { &&xorPLUSsw, NULL }  ,  { &&xorPLUSsw, NULL }  ,  { &&xorPLUSsw, NULL }  ,  { &&xorPLUSsw, NULL }  ,  { &&xorPLUSsw, NULL }  ,  { &&xorPLUSsw, NULL }  ,  { &&xorPLUSsw, NULL }  ,  { &&xorPLUSsw, NULL }  ,  { &&xorPLUSsw, NULL }  ,  { &&xorPLUSsw, NULL } 
 ,  { &&xorPLUSsw, NULL }  ,  { &&xorPLUSsw, NULL }  ,  { &&xorPLUSsw, NULL }  ,  { &&xorPLUSsw, NULL }  ,  { &&xorPLUSsw, NULL }  ,  { &&xorPLUSsw, NULL }  ,  { &&xorPLUSsw, NULL }  ,  { &&xorPLUSsw, NULL }  ,  { &&xorPLUSsw, NULL }  ,  { &&xorPLUSsw, NULL } 
 ,  { &&xorPLUSsw, NULL }  ,  { &&xorPLUSsw, NULL }  ,  { &&xorPLUSsw, NULL }  ,  { &&xorPLUSsw, NULL }  ,  { &&xorPLUSsw, NULL }  ,  { &&xorPLUSsw, NULL }  ,  { &&xorPLUSsw, NULL }  ,  { &&xorPLUSsw, NULL }  ,  { &&xorPLUSsw, NULL }  ,  { &&xorPLUSsw, NULL } 
 ,  { &&xorPLUSsw, NULL }  ,  { &&xorPLUSsw, NULL }  ,  { &&xorPLUSsw, NULL }  ,  { &&xorPLUSsw, NULL }  ,  { &&xorPLUSsw, NULL }  ,  { &&xorPLUSsw, NULL }  ,  { &&xorPLUSsw, NULL }  ,  { &&xorPLUSsw, NULL }  ,  { &&xorPLUSsw, NULL }  ,  { &&xorPLUSsw, NULL } 
 ,  { &&xorPLUSsw, NULL }  ,  { &&xorPLUSsw, NULL }  ,  { &&xorPLUSsw, NULL }  ,  { &&xorPLUSsw, NULL }  ,  { &&xorPLUSsw, NULL }  ,  { &&xorPLUSsw, NULL }  ,  { &&xorPLUSsw, NULL }  ,  { &&xorPLUSsw, NULL }  ,  { &&xorPLUSswPLUSbne, NULL }  ,  { &&xorPLUSsw, NULL } 
 ,  { &&xorPLUSsw, NULL }  ,  { &&xorPLUSsw, NULL }  ,  { &&xorPLUSsw, NULL }  ,  { &&xorPLUSsw, NULL }  ,  { &&xorPLUSsw, NULL }  ,  { &&xorPLUSsw, NULL }  ,  { &&xorPLUSsw, NULL }  ,  { &&xorPLUSsw, NULL }  ,  { &&xorPLUSsw, NULL }  ,  { &&xorPLUSsw, NULL } 
 ,  { &&xorPLUSsw, NULL }  ,  { &&xorPLUSsw, NULL }  ,  { &&xorPLUSsw, NULL }  ,  { &&xorPLUSsw, NULL }  ,  { &&xorPLUSsw, NULL }  ,  { &&xorPLUSsw, NULL }  ,  { &&xorPLUSsw, NULL }  ,  { &&xorPLUSsw, NULL }  ,  { &&xorPLUSsw, NULL }  ,  { &&xorPLUSsw, NULL } 
 ,  { &&xorPLUSsw, NULL }  ,  { &&xorPLUSsw, NULL }  ,  { &&xorPLUSsw, NULL }  ,  { &&xorPLUSsw, NULL }  ,  { &&xorPLUSsw, NULL }  ,  { &&xorPLUSsw, NULL }  ,  { &&xorPLUSsw, NULL }  ,  { &&xorPLUSsw, NULL }  ,  { &&xorPLUSsw, NULL }  ,  { &&xorPLUSsw, NULL } 
 ,  { &&xorPLUSsw, NULL }  ,  { &&xorPLUSsw, NULL }  ,  { &&xorPLUSsw, NULL }  ,  { &&xorPLUSsw, NULL }  ,  { &&xorPLUSsw, NULL }  ,  { &&xorPLUSsw, NULL }  ,  { &&xorPLUSsw, NULL }  ,  { &&xorPLUSsw, NULL }  ,  { &&xorPLUSsw, NULL }  ,  { &&xorPLUSsw, NULL } 
 ,  { &&xorPLUSsw, NULL }  ,  { &&xorPLUSsw, NULL }  ,  { &&xorPLUSsw, NULL }  ,  { &&xorPLUSsw, NULL }  ,  { &&xorPLUSsw, NULL }  ,  { &&xorPLUSsw, NULL }  ,  { &&xorPLUSsw, NULL }  ,  { &&xorPLUSsw, NULL }  ,  { &&xorPLUSsw, NULL }  ,  { &&xorPLUSsw, NULL } 
 ,  { &&xorPLUSsw, NULL }  ,  { &&xorPLUSsw, NULL }  ,  { &&xorPLUSsw, NULL }  ,  { &&xorPLUSsw, NULL }  ,  { &&xorPLUSsw, NULL }  ,  { &&xorPLUSsw, NULL }  ,  { &&xorPLUSsw, NULL }  ,  { &&xorPLUSsw, NULL }  ,  { &&xorPLUSsw, NULL }  ,  { &&xorPLUSsw, NULL } 
 }; 

struct pointer arraybeqPLUSsll[T_SIZE] = {  { &&beqPLUSsllPLUSsll, NULL }  ,  { &&beqPLUSsll, NULL }  ,  { &&beqPLUSsll, NULL }  ,  { &&beqPLUSsll, NULL }  ,  { &&beqPLUSsll, NULL }  ,  { &&beqPLUSsll, NULL }  ,  { &&beqPLUSsll, NULL }  ,  { &&beqPLUSsll, NULL }  ,  { &&beqPLUSsll, NULL }  ,  { &&beqPLUSsll, NULL } 
 ,  { &&beqPLUSsll, NULL }  ,  { &&beqPLUSsll, NULL }  ,  { &&beqPLUSsll, NULL }  ,  { &&beqPLUSsll, NULL }  ,  { &&beqPLUSsll, NULL }  ,  { &&beqPLUSsll, NULL }  ,  { &&beqPLUSsll, NULL }  ,  { &&beqPLUSsll, NULL }  ,  { &&beqPLUSsll, NULL }  ,  { &&beqPLUSsll, NULL } 
 ,  { &&beqPLUSsll, NULL }  ,  { &&beqPLUSsll, NULL }  ,  { &&beqPLUSsll, NULL }  ,  { &&beqPLUSsll, NULL }  ,  { &&beqPLUSsllPLUSmult, NULL }  ,  { &&beqPLUSsll, NULL }  ,  { &&beqPLUSsll, NULL }  ,  { &&beqPLUSsll, NULL }  ,  { &&beqPLUSsll, NULL }  ,  { &&beqPLUSsll, NULL } 
 ,  { &&beqPLUSsll, NULL }  ,  { &&beqPLUSsll, NULL }  ,  { &&beqPLUSsll, NULL }  ,  { &&beqPLUSsllPLUSaddu, NULL }  ,  { &&beqPLUSsll, NULL }  ,  { &&beqPLUSsll, NULL }  ,  { &&beqPLUSsll, NULL }  ,  { &&beqPLUSsll, NULL }  ,  { &&beqPLUSsll, NULL }  ,  { &&beqPLUSsll, NULL } 
 ,  { &&beqPLUSsll, NULL }  ,  { &&beqPLUSsll, NULL }  ,  { &&beqPLUSsll, NULL }  ,  { &&beqPLUSsll, NULL }  ,  { &&beqPLUSsll, NULL }  ,  { &&beqPLUSsllPLUSjump, NULL }  ,  { &&beqPLUSsll, NULL }  ,  { &&beqPLUSsll, NULL }  ,  { &&beqPLUSsllPLUSbne, NULL }  ,  { &&beqPLUSsll, NULL } 
 ,  { &&beqPLUSsll, NULL }  ,  { &&beqPLUSsll, NULL }  ,  { &&beqPLUSsllPLUSaddiu, NULL }  ,  { &&beqPLUSsllPLUSslti, NULL }  ,  { &&beqPLUSsll, NULL }  ,  { &&beqPLUSsll, NULL }  ,  { &&beqPLUSsll, NULL }  ,  { &&beqPLUSsll, NULL }  ,  { &&beqPLUSsllPLUSlui, NULL }  ,  { &&beqPLUSsll, NULL } 
 ,  { &&beqPLUSsll, NULL }  ,  { &&beqPLUSsll, NULL }  ,  { &&beqPLUSsll, NULL }  ,  { &&beqPLUSsll, NULL }  ,  { &&beqPLUSsll, NULL }  ,  { &&beqPLUSsll, NULL }  ,  { &&beqPLUSsll, NULL }  ,  { &&beqPLUSsll, NULL }  ,  { &&beqPLUSsll, NULL }  ,  { &&beqPLUSsll, NULL } 
 ,  { &&beqPLUSsll, NULL }  ,  { &&beqPLUSsll, NULL }  ,  { &&beqPLUSsll, NULL }  ,  { &&beqPLUSsll, NULL }  ,  { &&beqPLUSsll, NULL }  ,  { &&beqPLUSsll, NULL }  ,  { &&beqPLUSsll, NULL }  ,  { &&beqPLUSsll, NULL }  ,  { &&beqPLUSsllPLUSlw, NULL }  ,  { &&beqPLUSsll, NULL } 
 ,  { &&beqPLUSsll, NULL }  ,  { &&beqPLUSsll, NULL }  ,  { &&beqPLUSsll, NULL }  ,  { &&beqPLUSsll, NULL }  ,  { &&beqPLUSsll, NULL }  ,  { &&beqPLUSsll, NULL }  ,  { &&beqPLUSsllPLUSsw, NULL }  ,  { &&beqPLUSsll, NULL }  ,  { &&beqPLUSsll, NULL }  ,  { &&beqPLUSsll, NULL } 
 ,  { &&beqPLUSsll, NULL }  ,  { &&beqPLUSsll, NULL }  ,  { &&beqPLUSsll, NULL }  ,  { &&beqPLUSsll, NULL }  ,  { &&beqPLUSsll, NULL }  ,  { &&beqPLUSsll, NULL }  ,  { &&beqPLUSsll, NULL }  ,  { &&beqPLUSsll, NULL }  ,  { &&beqPLUSsll, NULL }  ,  { &&beqPLUSsll, NULL } 
 ,  { &&beqPLUSsll, NULL }  ,  { &&beqPLUSsll, NULL }  ,  { &&beqPLUSsll, NULL }  ,  { &&beqPLUSsll, NULL }  ,  { &&beqPLUSsll, NULL }  ,  { &&beqPLUSsll, NULL }  ,  { &&beqPLUSsll, NULL }  ,  { &&beqPLUSsll, NULL }  ,  { &&beqPLUSsll, NULL }  ,  { &&beqPLUSsll, NULL } 
 }; 

struct pointer arraysubuPLUSaddu[T_SIZE] = {  { &&subuPLUSadduPLUSsll, NULL }  ,  { &&subuPLUSaddu, NULL }  ,  { &&subuPLUSaddu, NULL }  ,  { &&subuPLUSaddu, NULL }  ,  { &&subuPLUSaddu, NULL }  ,  { &&subuPLUSaddu, NULL }  ,  { &&subuPLUSaddu, NULL }  ,  { &&subuPLUSaddu, NULL }  ,  { &&subuPLUSaddu, NULL }  ,  { &&subuPLUSaddu, NULL } 
 ,  { &&subuPLUSaddu, NULL }  ,  { &&subuPLUSaddu, NULL }  ,  { &&subuPLUSaddu, NULL }  ,  { &&subuPLUSaddu, NULL }  ,  { &&subuPLUSaddu, NULL }  ,  { &&subuPLUSaddu, NULL }  ,  { &&subuPLUSaddu, NULL }  ,  { &&subuPLUSaddu, NULL }  ,  { &&subuPLUSaddu, NULL }  ,  { &&subuPLUSaddu, NULL } 
 ,  { &&subuPLUSaddu, NULL }  ,  { &&subuPLUSaddu, NULL }  ,  { &&subuPLUSaddu, NULL }  ,  { &&subuPLUSaddu, NULL }  ,  { &&subuPLUSaddu, NULL }  ,  { &&subuPLUSaddu, NULL }  ,  { &&subuPLUSaddu, NULL }  ,  { &&subuPLUSaddu, NULL }  ,  { &&subuPLUSaddu, NULL }  ,  { &&subuPLUSaddu, NULL } 
 ,  { &&subuPLUSaddu, NULL }  ,  { &&subuPLUSaddu, NULL }  ,  { &&subuPLUSaddu, NULL }  ,  { &&subuPLUSaddu, NULL }  ,  { &&subuPLUSaddu, NULL }  ,  { &&subuPLUSaddu, NULL }  ,  { &&subuPLUSaddu, NULL }  ,  { &&subuPLUSaddu, NULL }  ,  { &&subuPLUSaddu, NULL }  ,  { &&subuPLUSaddu, NULL } 
 ,  { &&subuPLUSaddu, NULL }  ,  { &&subuPLUSaddu, NULL }  ,  { &&subuPLUSaddu, NULL }  ,  { &&subuPLUSaddu, NULL }  ,  { &&subuPLUSaddu, NULL }  ,  { &&subuPLUSaddu, NULL }  ,  { &&subuPLUSaddu, NULL }  ,  { &&subuPLUSaddu, NULL }  ,  { &&subuPLUSaddu, NULL }  ,  { &&subuPLUSaddu, NULL } 
 ,  { &&subuPLUSaddu, NULL }  ,  { &&subuPLUSaddu, NULL }  ,  { &&subuPLUSaddu, NULL }  ,  { &&subuPLUSaddu, NULL }  ,  { &&subuPLUSaddu, NULL }  ,  { &&subuPLUSaddu, NULL }  ,  { &&subuPLUSaddu, NULL }  ,  { &&subuPLUSaddu, NULL }  ,  { &&subuPLUSaddu, NULL }  ,  { &&subuPLUSaddu, NULL } 
 ,  { &&subuPLUSaddu, NULL }  ,  { &&subuPLUSaddu, NULL }  ,  { &&subuPLUSaddu, NULL }  ,  { &&subuPLUSaddu, NULL }  ,  { &&subuPLUSaddu, NULL }  ,  { &&subuPLUSaddu, NULL }  ,  { &&subuPLUSaddu, NULL }  ,  { &&subuPLUSaddu, NULL }  ,  { &&subuPLUSaddu, NULL }  ,  { &&subuPLUSaddu, NULL } 
 ,  { &&subuPLUSaddu, NULL }  ,  { &&subuPLUSaddu, NULL }  ,  { &&subuPLUSaddu, NULL }  ,  { &&subuPLUSaddu, NULL }  ,  { &&subuPLUSaddu, NULL }  ,  { &&subuPLUSaddu, NULL }  ,  { &&subuPLUSaddu, NULL }  ,  { &&subuPLUSaddu, NULL }  ,  { &&subuPLUSaddu, NULL }  ,  { &&subuPLUSaddu, NULL } 
 ,  { &&subuPLUSaddu, NULL }  ,  { &&subuPLUSaddu, NULL }  ,  { &&subuPLUSaddu, NULL }  ,  { &&subuPLUSaddu, NULL }  ,  { &&subuPLUSaddu, NULL }  ,  { &&subuPLUSaddu, NULL }  ,  { &&subuPLUSaddu, NULL }  ,  { &&subuPLUSaddu, NULL }  ,  { &&subuPLUSaddu, NULL }  ,  { &&subuPLUSaddu, NULL } 
 ,  { &&subuPLUSaddu, NULL }  ,  { &&subuPLUSaddu, NULL }  ,  { &&subuPLUSaddu, NULL }  ,  { &&subuPLUSaddu, NULL }  ,  { &&subuPLUSaddu, NULL }  ,  { &&subuPLUSaddu, NULL }  ,  { &&subuPLUSaddu, NULL }  ,  { &&subuPLUSaddu, NULL }  ,  { &&subuPLUSaddu, NULL }  ,  { &&subuPLUSaddu, NULL } 
 ,  { &&subuPLUSaddu, NULL }  ,  { &&subuPLUSaddu, NULL }  ,  { &&subuPLUSaddu, NULL }  ,  { &&subuPLUSaddu, NULL }  ,  { &&subuPLUSaddu, NULL }  ,  { &&subuPLUSaddu, NULL }  ,  { &&subuPLUSaddu, NULL }  ,  { &&subuPLUSaddu, NULL }  ,  { &&subuPLUSaddu, NULL }  ,  { &&subuPLUSaddu, NULL } 
 }; 

struct pointer arrayjump[T_SIZE] = {  { NULL, arrayjumpPLUSsll }  ,  { &&jump, NULL }  ,  { &&jump, NULL }  ,  { &&jump, NULL }  ,  { &&jump, NULL }  ,  { &&jump, NULL }  ,  { &&jump, NULL }  ,  { &&jump, NULL }  ,  { &&jump, NULL }  ,  { &&jump, NULL } 
 ,  { &&jump, NULL }  ,  { &&jump, NULL }  ,  { &&jump, NULL }  ,  { &&jump, NULL }  ,  { &&jump, NULL }  ,  { &&jump, NULL }  ,  { &&jump, NULL }  ,  { &&jump, NULL }  ,  { &&jump, NULL }  ,  { &&jump, NULL } 
 ,  { &&jump, NULL }  ,  { &&jump, NULL }  ,  { &&jump, NULL }  ,  { &&jump, NULL }  ,  { &&jump, NULL }  ,  { &&jump, NULL }  ,  { &&jump, NULL }  ,  { &&jump, NULL }  ,  { &&jump, NULL }  ,  { &&jump, NULL } 
 ,  { &&jump, NULL }  ,  { &&jump, NULL }  ,  { &&jump, NULL }  ,  { NULL, arrayjumpPLUSaddu }  ,  { &&jump, NULL }  ,  { &&jump, NULL }  ,  { &&jump, NULL }  ,  { &&jump, NULL }  ,  { &&jump, NULL }  ,  { &&jump, NULL } 
 ,  { &&jump, NULL }  ,  { &&jump, NULL }  ,  { &&jump, NULL }  ,  { &&jump, NULL }  ,  { &&jump, NULL }  ,  { &&jump, NULL }  ,  { &&jump, NULL }  ,  { &&jump, NULL }  ,  { &&jump, NULL }  ,  { &&jump, NULL } 
 ,  { &&jump, NULL }  ,  { &&jump, NULL }  ,  { NULL, arrayjumpPLUSaddiu }  ,  { &&jump, NULL }  ,  { &&jump, NULL }  ,  { &&jump, NULL }  ,  { &&jump, NULL }  ,  { &&jump, NULL }  ,  { &&jump, NULL }  ,  { &&jump, NULL } 
 ,  { &&jump, NULL }  ,  { &&jump, NULL }  ,  { &&jump, NULL }  ,  { &&jump, NULL }  ,  { &&jump, NULL }  ,  { &&jump, NULL }  ,  { &&jump, NULL }  ,  { &&jump, NULL }  ,  { &&jump, NULL }  ,  { &&jump, NULL } 
 ,  { &&jump, NULL }  ,  { &&jump, NULL }  ,  { &&jump, NULL }  ,  { &&jump, NULL }  ,  { &&jump, NULL }  ,  { &&jump, NULL }  ,  { &&jump, NULL }  ,  { &&jump, NULL }  ,  { &&jump, NULL }  ,  { &&jump, NULL } 
 ,  { &&jump, NULL }  ,  { &&jump, NULL }  ,  { &&jump, NULL }  ,  { &&jump, NULL }  ,  { &&jump, NULL }  ,  { &&jump, NULL }  ,  { NULL, arrayjumpPLUSsw }  ,  { &&jump, NULL }  ,  { &&jump, NULL }  ,  { &&jump, NULL } 
 ,  { &&jump, NULL }  ,  { &&jump, NULL }  ,  { &&jump, NULL }  ,  { &&jump, NULL }  ,  { &&jump, NULL }  ,  { &&jump, NULL }  ,  { &&jump, NULL }  ,  { &&jump, NULL }  ,  { &&jump, NULL }  ,  { &&jump, NULL } 
 ,  { &&jump, NULL }  ,  { &&jump, NULL }  ,  { &&jump, NULL }  ,  { &&jump, NULL }  ,  { &&jump, NULL }  ,  { &&jump, NULL }  ,  { &&jump, NULL }  ,  { &&jump, NULL }  ,  { &&jump, NULL }  ,  { &&jump, NULL } 
 }; 

struct pointer arraysll[T_SIZE] = {  { NULL, arraysllPLUSsll }  ,  { &&sll, NULL }  ,  { NULL, arraysllPLUSsrl }  ,  { &&sll, NULL }  ,  { &&sll, NULL }  ,  { &&sll, NULL }  ,  { &&sll, NULL }  ,  { &&sll, NULL }  ,  { &&sll, NULL }  ,  { &&sll, NULL } 
 ,  { &&sll, NULL }  ,  { &&sll, NULL }  ,  { &&sll, NULL }  ,  { &&sll, NULL }  ,  { &&sll, NULL }  ,  { &&sll, NULL }  ,  { &&sll, NULL }  ,  { &&sll, NULL }  ,  { &&sll, NULL }  ,  { &&sll, NULL } 
 ,  { &&sll, NULL }  ,  { &&sll, NULL }  ,  { &&sll, NULL }  ,  { &&sll, NULL }  ,  { NULL, arraysllPLUSmult }  ,  { &&sll, NULL }  ,  { &&sll, NULL }  ,  { &&sll, NULL }  ,  { &&sll, NULL }  ,  { &&sll, NULL } 
 ,  { &&sll, NULL }  ,  { &&sll, NULL }  ,  { &&sll, NULL }  ,  { NULL, arraysllPLUSaddu }  ,  { &&sll, NULL }  ,  { &&sll, NULL }  ,  { NULL, arraysllPLUSand }  ,  { NULL, arraysllPLUSor }  ,  { NULL, arraysllPLUSxor }  ,  { &&sll, NULL } 
 ,  { &&sll, NULL }  ,  { &&sll, NULL }  ,  { NULL, arraysllPLUSslt }  ,  { &&sll, NULL }  ,  { &&sll, NULL }  ,  { NULL, arraysllPLUSjump }  ,  { NULL, arraysllPLUSjal }  ,  { &&sll, NULL }  ,  { NULL, arraysllPLUSbne }  ,  { NULL, arraysllPLUSblez } 
 ,  { &&sll, NULL }  ,  { &&sll, NULL }  ,  { NULL, arraysllPLUSaddiu }  ,  { NULL, arraysllPLUSslti }  ,  { &&sll, NULL }  ,  { NULL, arraysllPLUSandi }  ,  { NULL, arraysllPLUSori }  ,  { &&sll, NULL }  ,  { NULL, arraysllPLUSlui }  ,  { &&sll, NULL } 
 ,  { &&sll, NULL }  ,  { &&sll, NULL }  ,  { &&sll, NULL }  ,  { &&sll, NULL }  ,  { &&sll, NULL }  ,  { &&sll, NULL }  ,  { &&sll, NULL }  ,  { &&sll, NULL }  ,  { &&sll, NULL }  ,  { &&sll, NULL } 
 ,  { &&sll, NULL }  ,  { &&sll, NULL }  ,  { &&sll, NULL }  ,  { &&sll, NULL }  ,  { &&sll, NULL }  ,  { &&sll, NULL }  ,  { &&sll, NULL }  ,  { &&sll, NULL }  ,  { NULL, arraysllPLUSlw }  ,  { NULL, arraysllPLUSlbu } 
 ,  { &&sll, NULL }  ,  { &&sll, NULL }  ,  { &&sll, NULL }  ,  { NULL, arraysllPLUSsb }  ,  { &&sll, NULL }  ,  { &&sll, NULL }  ,  { NULL, arraysllPLUSsw }  ,  { &&sll, NULL }  ,  { &&sll, NULL }  ,  { &&sll, NULL } 
 ,  { &&sll, NULL }  ,  { &&sll, NULL }  ,  { &&sll, NULL }  ,  { &&sll, NULL }  ,  { &&sll, NULL }  ,  { &&sll, NULL }  ,  { &&sll, NULL }  ,  { &&sll, NULL }  ,  { &&sll, NULL }  ,  { &&sll, NULL } 
 ,  { &&sll, NULL }  ,  { &&sll, NULL }  ,  { &&sll, NULL }  ,  { &&sll, NULL }  ,  { &&sll, NULL }  ,  { &&sll, NULL }  ,  { &&sll, NULL }  ,  { &&sll, NULL }  ,  { &&sll, NULL }  ,  { &&sll, NULL } 
 }; 

struct pointer arrayaddu[T_SIZE] = {  { NULL, arrayadduPLUSsll }  ,  { NULL, arrayadduPLUSerror }  ,  { NULL, arrayadduPLUSsrl }  ,  { &&addu, NULL }  ,  { &&addu, NULL }  ,  { NULL, arrayadduPLUSerror }  ,  { &&addu, NULL }  ,  { &&addu, NULL }  ,  { &&addu, NULL }  ,  { &&addu, NULL } 
 ,  { &&addu, NULL }  ,  { &&addu, NULL }  ,  { &&addu, NULL }  ,  { NULL, arrayadduPLUSerror }  ,  { NULL, arrayadduPLUSerror }  ,  { NULL, arrayadduPLUSerror }  ,  { &&addu, NULL }  ,  { &&addu, NULL }  ,  { &&addu, NULL }  ,  { &&addu, NULL } 
 ,  { NULL, arrayadduPLUSerror }  ,  { NULL, arrayadduPLUSerror }  ,  { NULL, arrayadduPLUSerror }  ,  { NULL, arrayadduPLUSerror }  ,  { NULL, arrayadduPLUSmult }  ,  { &&addu, NULL }  ,  { &&addu, NULL }  ,  { &&addu, NULL }  ,  { NULL, arrayadduPLUSerror }  ,  { NULL, arrayadduPLUSerror } 
 ,  { NULL, arrayadduPLUSerror }  ,  { NULL, arrayadduPLUSerror }  ,  { &&addu, NULL }  ,  { NULL, arrayadduPLUSaddu }  ,  { &&addu, NULL }  ,  { NULL, arrayadduPLUSsubu }  ,  { &&addu, NULL }  ,  { &&addu, NULL }  ,  { &&addu, NULL }  ,  { NULL, arrayadduPLUSnor } 
 ,  { NULL, arrayadduPLUSerror }  ,  { NULL, arrayadduPLUSerror }  ,  { NULL, arrayadduPLUSslt }  ,  { &&addu, NULL }  ,  { &&addu, NULL }  ,  { NULL, arrayadduPLUSjump }  ,  { NULL, arrayadduPLUSjal }  ,  { &&addu, NULL }  ,  { NULL, arrayadduPLUSbne }  ,  { &&addu, NULL } 
 ,  { &&addu, NULL }  ,  { &&addu, NULL }  ,  { NULL, arrayadduPLUSaddiu }  ,  { NULL, arrayadduPLUSslti }  ,  { &&addu, NULL }  ,  { NULL, arrayadduPLUSandi }  ,  { &&addu, NULL }  ,  { &&addu, NULL }  ,  { NULL, arrayadduPLUSlui }  ,  { NULL, arrayadduPLUSerror } 
 ,  { NULL, arrayadduPLUSerror }  ,  { NULL, arrayadduPLUSerror }  ,  { NULL, arrayadduPLUSerror }  ,  { NULL, arrayadduPLUSerror }  ,  { NULL, arrayadduPLUSerror }  ,  { NULL, arrayadduPLUSerror }  ,  { NULL, arrayadduPLUSerror }  ,  { &&addu, NULL }  ,  { &&addu, NULL }  ,  { &&addu, NULL } 
 ,  { NULL, arrayadduPLUSerror }  ,  { NULL, arrayadduPLUSerror }  ,  { NULL, arrayadduPLUSerror }  ,  { NULL, arrayadduPLUSerror }  ,  { NULL, arrayadduPLUSerror }  ,  { &&addu, NULL }  ,  { &&addu, NULL }  ,  { &&addu, NULL }  ,  { NULL, arrayadduPLUSlw }  ,  { NULL, arrayadduPLUSlbu } 
 ,  { &&addu, NULL }  ,  { &&addu, NULL }  ,  { NULL, arrayadduPLUSerror }  ,  { &&addu, NULL }  ,  { &&addu, NULL }  ,  { &&addu, NULL }  ,  { NULL, arrayadduPLUSsw }  ,  { NULL, arrayadduPLUSerror }  ,  { NULL, arrayadduPLUSerror }  ,  { &&addu, NULL } 
 ,  { NULL, arrayadduPLUSerror }  ,  { NULL, arrayadduPLUSerror }  ,  { NULL, arrayadduPLUSerror }  ,  { NULL, arrayadduPLUSerror }  ,  { NULL, arrayadduPLUSerror }  ,  { NULL, arrayadduPLUSerror }  ,  { NULL, arrayadduPLUSerror }  ,  { NULL, arrayadduPLUSerror }  ,  { NULL, arrayadduPLUSerror }  ,  { NULL, arrayadduPLUSerror } 
 ,  { NULL, arrayadduPLUSerror }  ,  { NULL, arrayadduPLUSerror }  ,  { NULL, arrayadduPLUSerror }  ,  { NULL, arrayadduPLUSerror }  ,  { NULL, arrayadduPLUSerror }  ,  { NULL, arrayadduPLUSerror }  ,  { NULL, arrayadduPLUSerror }  ,  { NULL, arrayadduPLUSerror }  ,  { NULL, arrayadduPLUSerror }  ,  { NULL, arrayadduPLUSerror } 
 }; 

struct pointer arrayxor[T_SIZE] = {  { NULL, arrayxorPLUSsll }  ,  { NULL, arrayxorPLUSerror }  ,  { NULL, arrayxorPLUSsrl }  ,  { &&xor, NULL }  ,  { &&xor, NULL }  ,  { NULL, arrayxorPLUSerror }  ,  { &&xor, NULL }  ,  { &&xor, NULL }  ,  { &&xor, NULL }  ,  { &&xor, NULL } 
 ,  { &&xor, NULL }  ,  { &&xor, NULL }  ,  { &&xor, NULL }  ,  { NULL, arrayxorPLUSerror }  ,  { NULL, arrayxorPLUSerror }  ,  { NULL, arrayxorPLUSerror }  ,  { &&xor, NULL }  ,  { &&xor, NULL }  ,  { &&xor, NULL }  ,  { &&xor, NULL } 
 ,  { NULL, arrayxorPLUSerror }  ,  { NULL, arrayxorPLUSerror }  ,  { NULL, arrayxorPLUSerror }  ,  { NULL, arrayxorPLUSerror }  ,  { &&xor, NULL }  ,  { &&xor, NULL }  ,  { &&xor, NULL }  ,  { &&xor, NULL }  ,  { NULL, arrayxorPLUSerror }  ,  { NULL, arrayxorPLUSerror } 
 ,  { NULL, arrayxorPLUSerror }  ,  { NULL, arrayxorPLUSerror }  ,  { &&xor, NULL }  ,  { &&xor, NULL }  ,  { &&xor, NULL }  ,  { &&xor, NULL }  ,  { &&xor, NULL }  ,  { &&xor, NULL }  ,  { NULL, arrayxorPLUSxor }  ,  { NULL, arrayxorPLUSnor } 
 ,  { NULL, arrayxorPLUSerror }  ,  { NULL, arrayxorPLUSerror }  ,  { &&xor, NULL }  ,  { &&xor, NULL }  ,  { &&xor, NULL }  ,  { &&xor, NULL }  ,  { &&xor, NULL }  ,  { &&xor, NULL }  ,  { NULL, arrayxorPLUSbne }  ,  { &&xor, NULL } 
 ,  { &&xor, NULL }  ,  { &&xor, NULL }  ,  { NULL, arrayxorPLUSaddiu }  ,  { NULL, arrayxorPLUSslti }  ,  { &&xor, NULL }  ,  { NULL, arrayxorPLUSandi }  ,  { &&xor, NULL }  ,  { &&xor, NULL }  ,  { &&xor, NULL }  ,  { NULL, arrayxorPLUSerror } 
 ,  { NULL, arrayxorPLUSerror }  ,  { NULL, arrayxorPLUSerror }  ,  { NULL, arrayxorPLUSerror }  ,  { NULL, arrayxorPLUSerror }  ,  { NULL, arrayxorPLUSerror }  ,  { NULL, arrayxorPLUSerror }  ,  { NULL, arrayxorPLUSerror }  ,  { &&xor, NULL }  ,  { &&xor, NULL }  ,  { &&xor, NULL } 
 ,  { NULL, arrayxorPLUSerror }  ,  { NULL, arrayxorPLUSerror }  ,  { NULL, arrayxorPLUSerror }  ,  { NULL, arrayxorPLUSerror }  ,  { NULL, arrayxorPLUSerror }  ,  { &&xor, NULL }  ,  { &&xor, NULL }  ,  { &&xor, NULL }  ,  { &&xor, NULL }  ,  { &&xor, NULL } 
 ,  { &&xor, NULL }  ,  { &&xor, NULL }  ,  { NULL, arrayxorPLUSerror }  ,  { &&xor, NULL }  ,  { &&xor, NULL }  ,  { &&xor, NULL }  ,  { NULL, arrayxorPLUSsw }  ,  { NULL, arrayxorPLUSerror }  ,  { NULL, arrayxorPLUSerror }  ,  { &&xor, NULL } 
 ,  { NULL, arrayxorPLUSerror }  ,  { NULL, arrayxorPLUSerror }  ,  { NULL, arrayxorPLUSerror }  ,  { NULL, arrayxorPLUSerror }  ,  { NULL, arrayxorPLUSerror }  ,  { NULL, arrayxorPLUSerror }  ,  { NULL, arrayxorPLUSerror }  ,  { NULL, arrayxorPLUSerror }  ,  { NULL, arrayxorPLUSerror }  ,  { NULL, arrayxorPLUSerror } 
 ,  { NULL, arrayxorPLUSerror }  ,  { NULL, arrayxorPLUSerror }  ,  { NULL, arrayxorPLUSerror }  ,  { NULL, arrayxorPLUSerror }  ,  { NULL, arrayxorPLUSerror }  ,  { NULL, arrayxorPLUSerror }  ,  { NULL, arrayxorPLUSerror }  ,  { NULL, arrayxorPLUSerror }  ,  { NULL, arrayxorPLUSerror }  ,  { NULL, arrayxorPLUSerror } 
 }; 

struct pointer arraymult[T_SIZE] = {  { &&mult, NULL }  ,  { &&mult, NULL }  ,  { &&mult, NULL }  ,  { &&mult, NULL }  ,  { &&mult, NULL }  ,  { &&mult, NULL }  ,  { &&mult, NULL }  ,  { &&mult, NULL }  ,  { &&mult, NULL }  ,  { &&mult, NULL } 
 ,  { &&mult, NULL }  ,  { &&mult, NULL }  ,  { &&mult, NULL }  ,  { &&mult, NULL }  ,  { &&mult, NULL }  ,  { &&mult, NULL }  ,  { NULL, arraymultPLUSmfhi }  ,  { &&mult, NULL }  ,  { &&mult, NULL }  ,  { &&mult, NULL } 
 ,  { &&mult, NULL }  ,  { &&mult, NULL }  ,  { &&mult, NULL }  ,  { &&mult, NULL }  ,  { &&mult, NULL }  ,  { &&mult, NULL }  ,  { &&mult, NULL }  ,  { &&mult, NULL }  ,  { &&mult, NULL }  ,  { &&mult, NULL } 
 ,  { &&mult, NULL }  ,  { &&mult, NULL }  ,  { &&mult, NULL }  ,  { &&mult, NULL }  ,  { &&mult, NULL }  ,  { &&mult, NULL }  ,  { &&mult, NULL }  ,  { &&mult, NULL }  ,  { &&mult, NULL }  ,  { &&mult, NULL } 
 ,  { &&mult, NULL }  ,  { &&mult, NULL }  ,  { &&mult, NULL }  ,  { &&mult, NULL }  ,  { &&mult, NULL }  ,  { &&mult, NULL }  ,  { &&mult, NULL }  ,  { &&mult, NULL }  ,  { &&mult, NULL }  ,  { &&mult, NULL } 
 ,  { &&mult, NULL }  ,  { &&mult, NULL }  ,  { &&mult, NULL }  ,  { &&mult, NULL }  ,  { &&mult, NULL }  ,  { &&mult, NULL }  ,  { &&mult, NULL }  ,  { &&mult, NULL }  ,  { &&mult, NULL }  ,  { &&mult, NULL } 
 ,  { &&mult, NULL }  ,  { &&mult, NULL }  ,  { &&mult, NULL }  ,  { &&mult, NULL }  ,  { &&mult, NULL }  ,  { &&mult, NULL }  ,  { &&mult, NULL }  ,  { &&mult, NULL }  ,  { &&mult, NULL }  ,  { &&mult, NULL } 
 ,  { &&mult, NULL }  ,  { &&mult, NULL }  ,  { &&mult, NULL }  ,  { &&mult, NULL }  ,  { &&mult, NULL }  ,  { &&mult, NULL }  ,  { &&mult, NULL }  ,  { &&mult, NULL }  ,  { &&mult, NULL }  ,  { &&mult, NULL } 
 ,  { &&mult, NULL }  ,  { &&mult, NULL }  ,  { &&mult, NULL }  ,  { &&mult, NULL }  ,  { &&mult, NULL }  ,  { &&mult, NULL }  ,  { &&mult, NULL }  ,  { &&mult, NULL }  ,  { &&mult, NULL }  ,  { &&mult, NULL } 
 ,  { &&mult, NULL }  ,  { &&mult, NULL }  ,  { &&mult, NULL }  ,  { &&mult, NULL }  ,  { &&mult, NULL }  ,  { &&mult, NULL }  ,  { &&mult, NULL }  ,  { &&mult, NULL }  ,  { &&mult, NULL }  ,  { &&mult, NULL } 
 ,  { &&mult, NULL }  ,  { &&mult, NULL }  ,  { &&mult, NULL }  ,  { &&mult, NULL }  ,  { &&mult, NULL }  ,  { &&mult, NULL }  ,  { &&mult, NULL }  ,  { &&mult, NULL }  ,  { &&mult, NULL }  ,  { &&mult, NULL } 
 }; 

struct pointer arrayandi[T_SIZE] = {  { NULL, arrayandiPLUSsll }  ,  { &&andi, NULL }  ,  { &&andi, NULL }  ,  { &&andi, NULL }  ,  { &&andi, NULL }  ,  { &&andi, NULL }  ,  { &&andi, NULL }  ,  { &&andi, NULL }  ,  { NULL, arrayandiPLUSjr }  ,  { &&andi, NULL } 
 ,  { &&andi, NULL }  ,  { &&andi, NULL }  ,  { &&andi, NULL }  ,  { &&andi, NULL }  ,  { &&andi, NULL }  ,  { &&andi, NULL }  ,  { &&andi, NULL }  ,  { &&andi, NULL }  ,  { &&andi, NULL }  ,  { &&andi, NULL } 
 ,  { &&andi, NULL }  ,  { &&andi, NULL }  ,  { &&andi, NULL }  ,  { &&andi, NULL }  ,  { &&andi, NULL }  ,  { &&andi, NULL }  ,  { &&andi, NULL }  ,  { &&andi, NULL }  ,  { &&andi, NULL }  ,  { &&andi, NULL } 
 ,  { &&andi, NULL }  ,  { &&andi, NULL }  ,  { &&andi, NULL }  ,  { &&andi, NULL }  ,  { &&andi, NULL }  ,  { NULL, arrayandiPLUSsubu }  ,  { &&andi, NULL }  ,  { NULL, arrayandiPLUSor }  ,  { NULL, arrayandiPLUSxor }  ,  { &&andi, NULL } 
 ,  { &&andi, NULL }  ,  { &&andi, NULL }  ,  { &&andi, NULL }  ,  { &&andi, NULL }  ,  { &&andi, NULL }  ,  { &&andi, NULL }  ,  { &&andi, NULL }  ,  { &&andi, NULL }  ,  { &&andi, NULL }  ,  { &&andi, NULL } 
 ,  { &&andi, NULL }  ,  { &&andi, NULL }  ,  { &&andi, NULL }  ,  { &&andi, NULL }  ,  { &&andi, NULL }  ,  { &&andi, NULL }  ,  { &&andi, NULL }  ,  { &&andi, NULL }  ,  { &&andi, NULL }  ,  { &&andi, NULL } 
 ,  { &&andi, NULL }  ,  { &&andi, NULL }  ,  { &&andi, NULL }  ,  { &&andi, NULL }  ,  { &&andi, NULL }  ,  { &&andi, NULL }  ,  { &&andi, NULL }  ,  { &&andi, NULL }  ,  { &&andi, NULL }  ,  { &&andi, NULL } 
 ,  { &&andi, NULL }  ,  { &&andi, NULL }  ,  { &&andi, NULL }  ,  { &&andi, NULL }  ,  { &&andi, NULL }  ,  { &&andi, NULL }  ,  { &&andi, NULL }  ,  { &&andi, NULL }  ,  { &&andi, NULL }  ,  { &&andi, NULL } 
 ,  { &&andi, NULL }  ,  { &&andi, NULL }  ,  { &&andi, NULL }  ,  { &&andi, NULL }  ,  { &&andi, NULL }  ,  { &&andi, NULL }  ,  { &&andi, NULL }  ,  { &&andi, NULL }  ,  { &&andi, NULL }  ,  { &&andi, NULL } 
 ,  { &&andi, NULL }  ,  { &&andi, NULL }  ,  { &&andi, NULL }  ,  { &&andi, NULL }  ,  { &&andi, NULL }  ,  { &&andi, NULL }  ,  { &&andi, NULL }  ,  { &&andi, NULL }  ,  { &&andi, NULL }  ,  { &&andi, NULL } 
 ,  { &&andi, NULL }  ,  { &&andi, NULL }  ,  { &&andi, NULL }  ,  { &&andi, NULL }  ,  { &&andi, NULL }  ,  { &&andi, NULL }  ,  { &&andi, NULL }  ,  { &&andi, NULL }  ,  { &&andi, NULL }  ,  { &&andi, NULL } 
 }; 

struct pointer arrayslti[T_SIZE] = {  { &&slti, NULL }  ,  { &&slti, NULL }  ,  { &&slti, NULL }  ,  { &&slti, NULL }  ,  { &&slti, NULL }  ,  { &&slti, NULL }  ,  { &&slti, NULL }  ,  { &&slti, NULL }  ,  { &&slti, NULL }  ,  { &&slti, NULL } 
 ,  { &&slti, NULL }  ,  { NULL, arraysltiPLUSmovn }  ,  { &&slti, NULL }  ,  { &&slti, NULL }  ,  { &&slti, NULL }  ,  { &&slti, NULL }  ,  { &&slti, NULL }  ,  { &&slti, NULL }  ,  { &&slti, NULL }  ,  { &&slti, NULL } 
 ,  { &&slti, NULL }  ,  { &&slti, NULL }  ,  { &&slti, NULL }  ,  { &&slti, NULL }  ,  { &&slti, NULL }  ,  { &&slti, NULL }  ,  { &&slti, NULL }  ,  { &&slti, NULL }  ,  { &&slti, NULL }  ,  { &&slti, NULL } 
 ,  { &&slti, NULL }  ,  { &&slti, NULL }  ,  { &&slti, NULL }  ,  { &&slti, NULL }  ,  { &&slti, NULL }  ,  { &&slti, NULL }  ,  { &&slti, NULL }  ,  { &&slti, NULL }  ,  { &&slti, NULL }  ,  { &&slti, NULL } 
 ,  { &&slti, NULL }  ,  { &&slti, NULL }  ,  { &&slti, NULL }  ,  { &&slti, NULL }  ,  { &&slti, NULL }  ,  { &&slti, NULL }  ,  { &&slti, NULL }  ,  { NULL, arraysltiPLUSbeq }  ,  { NULL, arraysltiPLUSbne }  ,  { &&slti, NULL } 
 ,  { &&slti, NULL }  ,  { &&slti, NULL }  ,  { &&slti, NULL }  ,  { &&slti, NULL }  ,  { &&slti, NULL }  ,  { &&slti, NULL }  ,  { &&slti, NULL }  ,  { &&slti, NULL }  ,  { &&slti, NULL }  ,  { &&slti, NULL } 
 ,  { &&slti, NULL }  ,  { &&slti, NULL }  ,  { &&slti, NULL }  ,  { &&slti, NULL }  ,  { &&slti, NULL }  ,  { &&slti, NULL }  ,  { &&slti, NULL }  ,  { &&slti, NULL }  ,  { &&slti, NULL }  ,  { &&slti, NULL } 
 ,  { &&slti, NULL }  ,  { &&slti, NULL }  ,  { &&slti, NULL }  ,  { &&slti, NULL }  ,  { &&slti, NULL }  ,  { &&slti, NULL }  ,  { &&slti, NULL }  ,  { &&slti, NULL }  ,  { &&slti, NULL }  ,  { &&slti, NULL } 
 ,  { &&slti, NULL }  ,  { &&slti, NULL }  ,  { &&slti, NULL }  ,  { &&slti, NULL }  ,  { &&slti, NULL }  ,  { &&slti, NULL }  ,  { NULL, arraysltiPLUSsw }  ,  { &&slti, NULL }  ,  { &&slti, NULL }  ,  { &&slti, NULL } 
 ,  { &&slti, NULL }  ,  { &&slti, NULL }  ,  { &&slti, NULL }  ,  { &&slti, NULL }  ,  { &&slti, NULL }  ,  { &&slti, NULL }  ,  { &&slti, NULL }  ,  { &&slti, NULL }  ,  { &&slti, NULL }  ,  { &&slti, NULL } 
 ,  { &&slti, NULL }  ,  { &&slti, NULL }  ,  { &&slti, NULL }  ,  { &&slti, NULL }  ,  { &&slti, NULL }  ,  { &&slti, NULL }  ,  { &&slti, NULL }  ,  { &&slti, NULL }  ,  { &&slti, NULL }  ,  { &&slti, NULL } 
 }; 

struct pointer arraysltu[T_SIZE] = {  { &&sltu, NULL }  ,  { &&sltu, NULL }  ,  { &&sltu, NULL }  ,  { &&sltu, NULL }  ,  { &&sltu, NULL }  ,  { &&sltu, NULL }  ,  { &&sltu, NULL }  ,  { &&sltu, NULL }  ,  { &&sltu, NULL }  ,  { &&sltu, NULL } 
 ,  { &&sltu, NULL }  ,  { NULL, arraysltuPLUSmovn }  ,  { &&sltu, NULL }  ,  { &&sltu, NULL }  ,  { &&sltu, NULL }  ,  { &&sltu, NULL }  ,  { &&sltu, NULL }  ,  { &&sltu, NULL }  ,  { &&sltu, NULL }  ,  { &&sltu, NULL } 
 ,  { &&sltu, NULL }  ,  { &&sltu, NULL }  ,  { &&sltu, NULL }  ,  { &&sltu, NULL }  ,  { &&sltu, NULL }  ,  { &&sltu, NULL }  ,  { &&sltu, NULL }  ,  { &&sltu, NULL }  ,  { &&sltu, NULL }  ,  { &&sltu, NULL } 
 ,  { &&sltu, NULL }  ,  { &&sltu, NULL }  ,  { &&sltu, NULL }  ,  { &&sltu, NULL }  ,  { &&sltu, NULL }  ,  { &&sltu, NULL }  ,  { &&sltu, NULL }  ,  { &&sltu, NULL }  ,  { &&sltu, NULL }  ,  { &&sltu, NULL } 
 ,  { &&sltu, NULL }  ,  { &&sltu, NULL }  ,  { &&sltu, NULL }  ,  { &&sltu, NULL }  ,  { &&sltu, NULL }  ,  { &&sltu, NULL }  ,  { &&sltu, NULL }  ,  { NULL, arraysltuPLUSbeq }  ,  { &&sltu, NULL }  ,  { &&sltu, NULL } 
 ,  { &&sltu, NULL }  ,  { &&sltu, NULL }  ,  { NULL, arraysltuPLUSaddiu }  ,  { &&sltu, NULL }  ,  { &&sltu, NULL }  ,  { &&sltu, NULL }  ,  { &&sltu, NULL }  ,  { &&sltu, NULL }  ,  { &&sltu, NULL }  ,  { &&sltu, NULL } 
 ,  { &&sltu, NULL }  ,  { &&sltu, NULL }  ,  { &&sltu, NULL }  ,  { &&sltu, NULL }  ,  { &&sltu, NULL }  ,  { &&sltu, NULL }  ,  { &&sltu, NULL }  ,  { &&sltu, NULL }  ,  { &&sltu, NULL }  ,  { &&sltu, NULL } 
 ,  { &&sltu, NULL }  ,  { &&sltu, NULL }  ,  { &&sltu, NULL }  ,  { &&sltu, NULL }  ,  { &&sltu, NULL }  ,  { &&sltu, NULL }  ,  { &&sltu, NULL }  ,  { &&sltu, NULL }  ,  { NULL, arraysltuPLUSlw }  ,  { &&sltu, NULL } 
 ,  { &&sltu, NULL }  ,  { &&sltu, NULL }  ,  { &&sltu, NULL }  ,  { &&sltu, NULL }  ,  { &&sltu, NULL }  ,  { &&sltu, NULL }  ,  { &&sltu, NULL }  ,  { &&sltu, NULL }  ,  { &&sltu, NULL }  ,  { &&sltu, NULL } 
 ,  { &&sltu, NULL }  ,  { &&sltu, NULL }  ,  { &&sltu, NULL }  ,  { &&sltu, NULL }  ,  { &&sltu, NULL }  ,  { &&sltu, NULL }  ,  { &&sltu, NULL }  ,  { &&sltu, NULL }  ,  { &&sltu, NULL }  ,  { &&sltu, NULL } 
 ,  { &&sltu, NULL }  ,  { &&sltu, NULL }  ,  { &&sltu, NULL }  ,  { &&sltu, NULL }  ,  { &&sltu, NULL }  ,  { &&sltu, NULL }  ,  { &&sltu, NULL }  ,  { &&sltu, NULL }  ,  { &&sltu, NULL }  ,  { &&sltu, NULL } 
 }; 

struct pointer arraysw[T_SIZE] = {  { NULL, arrayswPLUSsll }  ,  { &&sw, NULL }  ,  { &&sw, NULL }  ,  { &&sw, NULL }  ,  { &&sw, NULL }  ,  { &&sw, NULL }  ,  { &&sw, NULL }  ,  { &&sw, NULL }  ,  { &&sw, NULL }  ,  { &&sw, NULL } 
 ,  { &&sw, NULL }  ,  { &&sw, NULL }  ,  { &&sw, NULL }  ,  { &&sw, NULL }  ,  { &&sw, NULL }  ,  { &&sw, NULL }  ,  { &&sw, NULL }  ,  { &&sw, NULL }  ,  { &&sw, NULL }  ,  { &&sw, NULL } 
 ,  { &&sw, NULL }  ,  { &&sw, NULL }  ,  { &&sw, NULL }  ,  { &&sw, NULL }  ,  { &&sw, NULL }  ,  { &&sw, NULL }  ,  { &&sw, NULL }  ,  { &&sw, NULL }  ,  { &&sw, NULL }  ,  { &&sw, NULL } 
 ,  { &&sw, NULL }  ,  { &&sw, NULL }  ,  { &&sw, NULL }  ,  { NULL, arrayswPLUSaddu }  ,  { &&sw, NULL }  ,  { &&sw, NULL }  ,  { &&sw, NULL }  ,  { &&sw, NULL }  ,  { &&sw, NULL }  ,  { &&sw, NULL } 
 ,  { &&sw, NULL }  ,  { &&sw, NULL }  ,  { &&sw, NULL }  ,  { &&sw, NULL }  ,  { &&sw, NULL }  ,  { NULL, arrayswPLUSjump }  ,  { NULL, arrayswPLUSjal }  ,  { &&sw, NULL }  ,  { NULL, arrayswPLUSbne }  ,  { &&sw, NULL } 
 ,  { &&sw, NULL }  ,  { &&sw, NULL }  ,  { NULL, arrayswPLUSaddiu }  ,  { NULL, arrayswPLUSslti }  ,  { &&sw, NULL }  ,  { &&sw, NULL }  ,  { &&sw, NULL }  ,  { &&sw, NULL }  ,  { NULL, arrayswPLUSlui }  ,  { &&sw, NULL } 
 ,  { &&sw, NULL }  ,  { &&sw, NULL }  ,  { &&sw, NULL }  ,  { &&sw, NULL }  ,  { &&sw, NULL }  ,  { &&sw, NULL }  ,  { &&sw, NULL }  ,  { &&sw, NULL }  ,  { &&sw, NULL }  ,  { &&sw, NULL } 
 ,  { &&sw, NULL }  ,  { &&sw, NULL }  ,  { &&sw, NULL }  ,  { &&sw, NULL }  ,  { &&sw, NULL }  ,  { &&sw, NULL }  ,  { &&sw, NULL }  ,  { &&sw, NULL }  ,  { NULL, arrayswPLUSlw }  ,  { &&sw, NULL } 
 ,  { &&sw, NULL }  ,  { &&sw, NULL }  ,  { &&sw, NULL }  ,  { NULL, arrayswPLUSsb }  ,  { &&sw, NULL }  ,  { &&sw, NULL }  ,  { NULL, arrayswPLUSsw }  ,  { &&sw, NULL }  ,  { &&sw, NULL }  ,  { &&sw, NULL } 
 ,  { &&sw, NULL }  ,  { &&sw, NULL }  ,  { &&sw, NULL }  ,  { &&sw, NULL }  ,  { &&sw, NULL }  ,  { &&sw, NULL }  ,  { &&sw, NULL }  ,  { &&sw, NULL }  ,  { &&sw, NULL }  ,  { &&sw, NULL } 
 ,  { &&sw, NULL }  ,  { &&sw, NULL }  ,  { &&sw, NULL }  ,  { &&sw, NULL }  ,  { &&sw, NULL }  ,  { &&sw, NULL }  ,  { &&sw, NULL }  ,  { &&sw, NULL }  ,  { &&sw, NULL }  ,  { &&sw, NULL } 
 }; 

struct pointer arraymovn[T_SIZE] = {  { NULL, arraymovnPLUSsll }  ,  { &&movn, NULL }  ,  { &&movn, NULL }  ,  { &&movn, NULL }  ,  { &&movn, NULL }  ,  { &&movn, NULL }  ,  { &&movn, NULL }  ,  { &&movn, NULL }  ,  { &&movn, NULL }  ,  { &&movn, NULL } 
 ,  { &&movn, NULL }  ,  { &&movn, NULL }  ,  { &&movn, NULL }  ,  { &&movn, NULL }  ,  { &&movn, NULL }  ,  { &&movn, NULL }  ,  { &&movn, NULL }  ,  { &&movn, NULL }  ,  { &&movn, NULL }  ,  { &&movn, NULL } 
 ,  { &&movn, NULL }  ,  { &&movn, NULL }  ,  { &&movn, NULL }  ,  { &&movn, NULL }  ,  { &&movn, NULL }  ,  { &&movn, NULL }  ,  { &&movn, NULL }  ,  { &&movn, NULL }  ,  { &&movn, NULL }  ,  { &&movn, NULL } 
 ,  { &&movn, NULL }  ,  { &&movn, NULL }  ,  { &&movn, NULL }  ,  { &&movn, NULL }  ,  { &&movn, NULL }  ,  { &&movn, NULL }  ,  { &&movn, NULL }  ,  { &&movn, NULL }  ,  { &&movn, NULL }  ,  { &&movn, NULL } 
 ,  { &&movn, NULL }  ,  { &&movn, NULL }  ,  { &&movn, NULL }  ,  { &&movn, NULL }  ,  { &&movn, NULL }  ,  { NULL, arraymovnPLUSjump }  ,  { &&movn, NULL }  ,  { &&movn, NULL }  ,  { NULL, arraymovnPLUSbne }  ,  { &&movn, NULL } 
 ,  { &&movn, NULL }  ,  { &&movn, NULL }  ,  { NULL, arraymovnPLUSaddiu }  ,  { &&movn, NULL }  ,  { &&movn, NULL }  ,  { NULL, arraymovnPLUSandi }  ,  { &&movn, NULL }  ,  { &&movn, NULL }  ,  { &&movn, NULL }  ,  { &&movn, NULL } 
 ,  { &&movn, NULL }  ,  { &&movn, NULL }  ,  { &&movn, NULL }  ,  { &&movn, NULL }  ,  { &&movn, NULL }  ,  { &&movn, NULL }  ,  { &&movn, NULL }  ,  { &&movn, NULL }  ,  { &&movn, NULL }  ,  { &&movn, NULL } 
 ,  { &&movn, NULL }  ,  { &&movn, NULL }  ,  { &&movn, NULL }  ,  { &&movn, NULL }  ,  { &&movn, NULL }  ,  { &&movn, NULL }  ,  { &&movn, NULL }  ,  { &&movn, NULL }  ,  { &&movn, NULL }  ,  { &&movn, NULL } 
 ,  { &&movn, NULL }  ,  { &&movn, NULL }  ,  { &&movn, NULL }  ,  { &&movn, NULL }  ,  { &&movn, NULL }  ,  { &&movn, NULL }  ,  { &&movn, NULL }  ,  { &&movn, NULL }  ,  { &&movn, NULL }  ,  { &&movn, NULL } 
 ,  { &&movn, NULL }  ,  { &&movn, NULL }  ,  { &&movn, NULL }  ,  { &&movn, NULL }  ,  { &&movn, NULL }  ,  { &&movn, NULL }  ,  { &&movn, NULL }  ,  { &&movn, NULL }  ,  { &&movn, NULL }  ,  { &&movn, NULL } 
 ,  { &&movn, NULL }  ,  { &&movn, NULL }  ,  { &&movn, NULL }  ,  { &&movn, NULL }  ,  { &&movn, NULL }  ,  { &&movn, NULL }  ,  { &&movn, NULL }  ,  { &&movn, NULL }  ,  { &&movn, NULL }  ,  { &&movn, NULL } 
 }; 

struct pointer arraylw[T_SIZE] = {  { NULL, arraylwPLUSsll }  ,  { NULL, arraylwPLUSerror }  ,  { &&lw, NULL }  ,  { &&lw, NULL }  ,  { &&lw, NULL }  ,  { NULL, arraylwPLUSerror }  ,  { &&lw, NULL }  ,  { &&lw, NULL }  ,  { NULL, arraylwPLUSjr }  ,  { &&lw, NULL } 
 ,  { &&lw, NULL }  ,  { &&lw, NULL }  ,  { &&lw, NULL }  ,  { NULL, arraylwPLUSerror }  ,  { NULL, arraylwPLUSerror }  ,  { NULL, arraylwPLUSerror }  ,  { &&lw, NULL }  ,  { &&lw, NULL }  ,  { &&lw, NULL }  ,  { &&lw, NULL } 
 ,  { NULL, arraylwPLUSerror }  ,  { NULL, arraylwPLUSerror }  ,  { NULL, arraylwPLUSerror }  ,  { NULL, arraylwPLUSerror }  ,  { &&lw, NULL }  ,  { &&lw, NULL }  ,  { &&lw, NULL }  ,  { &&lw, NULL }  ,  { NULL, arraylwPLUSerror }  ,  { NULL, arraylwPLUSerror } 
 ,  { NULL, arraylwPLUSerror }  ,  { NULL, arraylwPLUSerror }  ,  { &&lw, NULL }  ,  { NULL, arraylwPLUSaddu }  ,  { &&lw, NULL }  ,  { &&lw, NULL }  ,  { &&lw, NULL }  ,  { &&lw, NULL }  ,  { NULL, arraylwPLUSxor }  ,  { &&lw, NULL } 
 ,  { NULL, arraylwPLUSerror }  ,  { NULL, arraylwPLUSerror }  ,  { NULL, arraylwPLUSslt }  ,  { NULL, arraylwPLUSsltu }  ,  { &&lw, NULL }  ,  { NULL, arraylwPLUSjump }  ,  { NULL, arraylwPLUSjal }  ,  { NULL, arraylwPLUSbeq }  ,  { NULL, arraylwPLUSbne }  ,  { NULL, arraylwPLUSblez } 
 ,  { NULL, arraylwPLUSbgtz }  ,  { &&lw, NULL }  ,  { NULL, arraylwPLUSaddiu }  ,  { NULL, arraylwPLUSslti }  ,  { &&lw, NULL }  ,  { &&lw, NULL }  ,  { NULL, arraylwPLUSori }  ,  { &&lw, NULL }  ,  { &&lw, NULL }  ,  { NULL, arraylwPLUSerror } 
 ,  { NULL, arraylwPLUSerror }  ,  { NULL, arraylwPLUSerror }  ,  { NULL, arraylwPLUSerror }  ,  { NULL, arraylwPLUSerror }  ,  { NULL, arraylwPLUSerror }  ,  { NULL, arraylwPLUSerror }  ,  { NULL, arraylwPLUSerror }  ,  { &&lw, NULL }  ,  { &&lw, NULL }  ,  { &&lw, NULL } 
 ,  { NULL, arraylwPLUSerror }  ,  { NULL, arraylwPLUSerror }  ,  { NULL, arraylwPLUSerror }  ,  { NULL, arraylwPLUSerror }  ,  { NULL, arraylwPLUSerror }  ,  { &&lw, NULL }  ,  { &&lw, NULL }  ,  { &&lw, NULL }  ,  { NULL, arraylwPLUSlw }  ,  { NULL, arraylwPLUSlbu } 
 ,  { &&lw, NULL }  ,  { &&lw, NULL }  ,  { NULL, arraylwPLUSerror }  ,  { &&lw, NULL }  ,  { &&lw, NULL }  ,  { &&lw, NULL }  ,  { NULL, arraylwPLUSsw }  ,  { NULL, arraylwPLUSerror }  ,  { NULL, arraylwPLUSerror }  ,  { &&lw, NULL } 
 ,  { NULL, arraylwPLUSerror }  ,  { NULL, arraylwPLUSerror }  ,  { NULL, arraylwPLUSerror }  ,  { NULL, arraylwPLUSerror }  ,  { NULL, arraylwPLUSerror }  ,  { NULL, arraylwPLUSerror }  ,  { NULL, arraylwPLUSerror }  ,  { NULL, arraylwPLUSerror }  ,  { NULL, arraylwPLUSerror }  ,  { NULL, arraylwPLUSerror } 
 ,  { NULL, arraylwPLUSerror }  ,  { NULL, arraylwPLUSerror }  ,  { NULL, arraylwPLUSerror }  ,  { NULL, arraylwPLUSerror }  ,  { NULL, arraylwPLUSerror }  ,  { NULL, arraylwPLUSerror }  ,  { NULL, arraylwPLUSerror }  ,  { NULL, arraylwPLUSerror }  ,  { NULL, arraylwPLUSerror }  ,  { NULL, arraylwPLUSerror } 
 }; 

struct pointer arraynor[T_SIZE] = {  { &&nor, NULL }  ,  { &&nor, NULL }  ,  { NULL, arraynorPLUSsrl }  ,  { &&nor, NULL }  ,  { &&nor, NULL }  ,  { &&nor, NULL }  ,  { &&nor, NULL }  ,  { &&nor, NULL }  ,  { NULL, arraynorPLUSjr }  ,  { &&nor, NULL } 
 ,  { &&nor, NULL }  ,  { &&nor, NULL }  ,  { &&nor, NULL }  ,  { &&nor, NULL }  ,  { &&nor, NULL }  ,  { &&nor, NULL }  ,  { &&nor, NULL }  ,  { &&nor, NULL }  ,  { &&nor, NULL }  ,  { &&nor, NULL } 
 ,  { &&nor, NULL }  ,  { &&nor, NULL }  ,  { &&nor, NULL }  ,  { &&nor, NULL }  ,  { &&nor, NULL }  ,  { &&nor, NULL }  ,  { &&nor, NULL }  ,  { &&nor, NULL }  ,  { &&nor, NULL }  ,  { &&nor, NULL } 
 ,  { &&nor, NULL }  ,  { &&nor, NULL }  ,  { &&nor, NULL }  ,  { &&nor, NULL }  ,  { &&nor, NULL }  ,  { &&nor, NULL }  ,  { &&nor, NULL }  ,  { &&nor, NULL }  ,  { &&nor, NULL }  ,  { &&nor, NULL } 
 ,  { &&nor, NULL }  ,  { &&nor, NULL }  ,  { &&nor, NULL }  ,  { &&nor, NULL }  ,  { &&nor, NULL }  ,  { &&nor, NULL }  ,  { &&nor, NULL }  ,  { &&nor, NULL }  ,  { &&nor, NULL }  ,  { &&nor, NULL } 
 ,  { &&nor, NULL }  ,  { &&nor, NULL }  ,  { &&nor, NULL }  ,  { &&nor, NULL }  ,  { &&nor, NULL }  ,  { &&nor, NULL }  ,  { &&nor, NULL }  ,  { &&nor, NULL }  ,  { &&nor, NULL }  ,  { &&nor, NULL } 
 ,  { &&nor, NULL }  ,  { &&nor, NULL }  ,  { &&nor, NULL }  ,  { &&nor, NULL }  ,  { &&nor, NULL }  ,  { &&nor, NULL }  ,  { &&nor, NULL }  ,  { &&nor, NULL }  ,  { &&nor, NULL }  ,  { &&nor, NULL } 
 ,  { &&nor, NULL }  ,  { &&nor, NULL }  ,  { &&nor, NULL }  ,  { &&nor, NULL }  ,  { &&nor, NULL }  ,  { &&nor, NULL }  ,  { &&nor, NULL }  ,  { &&nor, NULL }  ,  { &&nor, NULL }  ,  { &&nor, NULL } 
 ,  { &&nor, NULL }  ,  { &&nor, NULL }  ,  { &&nor, NULL }  ,  { &&nor, NULL }  ,  { &&nor, NULL }  ,  { &&nor, NULL }  ,  { &&nor, NULL }  ,  { &&nor, NULL }  ,  { &&nor, NULL }  ,  { &&nor, NULL } 
 ,  { &&nor, NULL }  ,  { &&nor, NULL }  ,  { &&nor, NULL }  ,  { &&nor, NULL }  ,  { &&nor, NULL }  ,  { &&nor, NULL }  ,  { &&nor, NULL }  ,  { &&nor, NULL }  ,  { &&nor, NULL }  ,  { &&nor, NULL } 
 ,  { &&nor, NULL }  ,  { &&nor, NULL }  ,  { &&nor, NULL }  ,  { &&nor, NULL }  ,  { &&nor, NULL }  ,  { &&nor, NULL }  ,  { &&nor, NULL }  ,  { &&nor, NULL }  ,  { &&nor, NULL }  ,  { &&nor, NULL } 
 }; 

struct pointer arraysh[T_SIZE] = {  { &&sh, NULL }  ,  { &&sh, NULL }  ,  { &&sh, NULL }  ,  { &&sh, NULL }  ,  { &&sh, NULL }  ,  { &&sh, NULL }  ,  { &&sh, NULL }  ,  { &&sh, NULL }  ,  { &&sh, NULL }  ,  { &&sh, NULL } 
 ,  { &&sh, NULL }  ,  { &&sh, NULL }  ,  { &&sh, NULL }  ,  { &&sh, NULL }  ,  { &&sh, NULL }  ,  { &&sh, NULL }  ,  { &&sh, NULL }  ,  { &&sh, NULL }  ,  { &&sh, NULL }  ,  { &&sh, NULL } 
 ,  { &&sh, NULL }  ,  { &&sh, NULL }  ,  { &&sh, NULL }  ,  { &&sh, NULL }  ,  { &&sh, NULL }  ,  { &&sh, NULL }  ,  { &&sh, NULL }  ,  { &&sh, NULL }  ,  { &&sh, NULL }  ,  { &&sh, NULL } 
 ,  { &&sh, NULL }  ,  { &&sh, NULL }  ,  { &&sh, NULL }  ,  { &&sh, NULL }  ,  { &&sh, NULL }  ,  { &&sh, NULL }  ,  { &&sh, NULL }  ,  { NULL, arrayshPLUSor }  ,  { &&sh, NULL }  ,  { &&sh, NULL } 
 ,  { &&sh, NULL }  ,  { &&sh, NULL }  ,  { &&sh, NULL }  ,  { &&sh, NULL }  ,  { &&sh, NULL }  ,  { &&sh, NULL }  ,  { &&sh, NULL }  ,  { &&sh, NULL }  ,  { &&sh, NULL }  ,  { &&sh, NULL } 
 ,  { &&sh, NULL }  ,  { &&sh, NULL }  ,  { &&sh, NULL }  ,  { &&sh, NULL }  ,  { &&sh, NULL }  ,  { &&sh, NULL }  ,  { &&sh, NULL }  ,  { &&sh, NULL }  ,  { &&sh, NULL }  ,  { &&sh, NULL } 
 ,  { &&sh, NULL }  ,  { &&sh, NULL }  ,  { &&sh, NULL }  ,  { &&sh, NULL }  ,  { &&sh, NULL }  ,  { &&sh, NULL }  ,  { &&sh, NULL }  ,  { &&sh, NULL }  ,  { &&sh, NULL }  ,  { &&sh, NULL } 
 ,  { &&sh, NULL }  ,  { &&sh, NULL }  ,  { &&sh, NULL }  ,  { &&sh, NULL }  ,  { &&sh, NULL }  ,  { &&sh, NULL }  ,  { &&sh, NULL }  ,  { &&sh, NULL }  ,  { &&sh, NULL }  ,  { &&sh, NULL } 
 ,  { &&sh, NULL }  ,  { &&sh, NULL }  ,  { &&sh, NULL }  ,  { &&sh, NULL }  ,  { &&sh, NULL }  ,  { &&sh, NULL }  ,  { &&sh, NULL }  ,  { &&sh, NULL }  ,  { &&sh, NULL }  ,  { &&sh, NULL } 
 ,  { &&sh, NULL }  ,  { &&sh, NULL }  ,  { &&sh, NULL }  ,  { &&sh, NULL }  ,  { &&sh, NULL }  ,  { &&sh, NULL }  ,  { &&sh, NULL }  ,  { &&sh, NULL }  ,  { &&sh, NULL }  ,  { &&sh, NULL } 
 ,  { &&sh, NULL }  ,  { &&sh, NULL }  ,  { &&sh, NULL }  ,  { &&sh, NULL }  ,  { &&sh, NULL }  ,  { &&sh, NULL }  ,  { &&sh, NULL }  ,  { &&sh, NULL }  ,  { &&sh, NULL }  ,  { &&sh, NULL } 
 }; 

struct pointer arrayori[T_SIZE] = {  { NULL, arrayoriPLUSsll }  ,  { &&ori, NULL }  ,  { &&ori, NULL }  ,  { &&ori, NULL }  ,  { &&ori, NULL }  ,  { &&ori, NULL }  ,  { &&ori, NULL }  ,  { &&ori, NULL }  ,  { &&ori, NULL }  ,  { &&ori, NULL } 
 ,  { &&ori, NULL }  ,  { &&ori, NULL }  ,  { &&ori, NULL }  ,  { &&ori, NULL }  ,  { &&ori, NULL }  ,  { &&ori, NULL }  ,  { &&ori, NULL }  ,  { &&ori, NULL }  ,  { &&ori, NULL }  ,  { &&ori, NULL } 
 ,  { &&ori, NULL }  ,  { &&ori, NULL }  ,  { &&ori, NULL }  ,  { &&ori, NULL }  ,  { NULL, arrayoriPLUSmult }  ,  { &&ori, NULL }  ,  { &&ori, NULL }  ,  { &&ori, NULL }  ,  { &&ori, NULL }  ,  { &&ori, NULL } 
 ,  { &&ori, NULL }  ,  { &&ori, NULL }  ,  { &&ori, NULL }  ,  { NULL, arrayoriPLUSaddu }  ,  { &&ori, NULL }  ,  { &&ori, NULL }  ,  { NULL, arrayoriPLUSand }  ,  { &&ori, NULL }  ,  { &&ori, NULL }  ,  { &&ori, NULL } 
 ,  { &&ori, NULL }  ,  { &&ori, NULL }  ,  { &&ori, NULL }  ,  { &&ori, NULL }  ,  { &&ori, NULL }  ,  { &&ori, NULL }  ,  { &&ori, NULL }  ,  { &&ori, NULL }  ,  { &&ori, NULL }  ,  { &&ori, NULL } 
 ,  { &&ori, NULL }  ,  { &&ori, NULL }  ,  { NULL, arrayoriPLUSaddiu }  ,  { &&ori, NULL }  ,  { &&ori, NULL }  ,  { NULL, arrayoriPLUSandi }  ,  { &&ori, NULL }  ,  { &&ori, NULL }  ,  { &&ori, NULL }  ,  { &&ori, NULL } 
 ,  { &&ori, NULL }  ,  { &&ori, NULL }  ,  { &&ori, NULL }  ,  { &&ori, NULL }  ,  { &&ori, NULL }  ,  { &&ori, NULL }  ,  { &&ori, NULL }  ,  { &&ori, NULL }  ,  { &&ori, NULL }  ,  { &&ori, NULL } 
 ,  { &&ori, NULL }  ,  { &&ori, NULL }  ,  { &&ori, NULL }  ,  { &&ori, NULL }  ,  { &&ori, NULL }  ,  { &&ori, NULL }  ,  { &&ori, NULL }  ,  { &&ori, NULL }  ,  { &&ori, NULL }  ,  { &&ori, NULL } 
 ,  { &&ori, NULL }  ,  { &&ori, NULL }  ,  { &&ori, NULL }  ,  { &&ori, NULL }  ,  { &&ori, NULL }  ,  { &&ori, NULL }  ,  { &&ori, NULL }  ,  { &&ori, NULL }  ,  { &&ori, NULL }  ,  { &&ori, NULL } 
 ,  { &&ori, NULL }  ,  { &&ori, NULL }  ,  { &&ori, NULL }  ,  { &&ori, NULL }  ,  { &&ori, NULL }  ,  { &&ori, NULL }  ,  { &&ori, NULL }  ,  { &&ori, NULL }  ,  { &&ori, NULL }  ,  { &&ori, NULL } 
 ,  { &&ori, NULL }  ,  { &&ori, NULL }  ,  { &&ori, NULL }  ,  { &&ori, NULL }  ,  { &&ori, NULL }  ,  { &&ori, NULL }  ,  { &&ori, NULL }  ,  { &&ori, NULL }  ,  { &&ori, NULL }  ,  { &&ori, NULL } 
 }; 

struct pointer arraybeq[T_SIZE] = {  { NULL, arraybeqPLUSsll }  ,  { &&beq, NULL }  ,  { &&beq, NULL }  ,  { &&beq, NULL }  ,  { &&beq, NULL }  ,  { &&beq, NULL }  ,  { &&beq, NULL }  ,  { &&beq, NULL }  ,  { &&beq, NULL }  ,  { &&beq, NULL } 
 ,  { &&beq, NULL }  ,  { &&beq, NULL }  ,  { &&beq, NULL }  ,  { &&beq, NULL }  ,  { &&beq, NULL }  ,  { &&beq, NULL }  ,  { &&beq, NULL }  ,  { &&beq, NULL }  ,  { &&beq, NULL }  ,  { &&beq, NULL } 
 ,  { &&beq, NULL }  ,  { &&beq, NULL }  ,  { &&beq, NULL }  ,  { &&beq, NULL }  ,  { &&beq, NULL }  ,  { &&beq, NULL }  ,  { &&beq, NULL }  ,  { &&beq, NULL }  ,  { &&beq, NULL }  ,  { &&beq, NULL } 
 ,  { &&beq, NULL }  ,  { &&beq, NULL }  ,  { &&beq, NULL }  ,  { NULL, arraybeqPLUSaddu }  ,  { &&beq, NULL }  ,  { &&beq, NULL }  ,  { &&beq, NULL }  ,  { &&beq, NULL }  ,  { &&beq, NULL }  ,  { &&beq, NULL } 
 ,  { &&beq, NULL }  ,  { &&beq, NULL }  ,  { &&beq, NULL }  ,  { &&beq, NULL }  ,  { &&beq, NULL }  ,  { &&beq, NULL }  ,  { &&beq, NULL }  ,  { &&beq, NULL }  ,  { &&beq, NULL }  ,  { &&beq, NULL } 
 ,  { &&beq, NULL }  ,  { &&beq, NULL }  ,  { NULL, arraybeqPLUSaddiu }  ,  { &&beq, NULL }  ,  { &&beq, NULL }  ,  { &&beq, NULL }  ,  { &&beq, NULL }  ,  { &&beq, NULL }  ,  { &&beq, NULL }  ,  { &&beq, NULL } 
 ,  { &&beq, NULL }  ,  { &&beq, NULL }  ,  { &&beq, NULL }  ,  { &&beq, NULL }  ,  { &&beq, NULL }  ,  { &&beq, NULL }  ,  { &&beq, NULL }  ,  { &&beq, NULL }  ,  { &&beq, NULL }  ,  { &&beq, NULL } 
 ,  { &&beq, NULL }  ,  { &&beq, NULL }  ,  { &&beq, NULL }  ,  { &&beq, NULL }  ,  { &&beq, NULL }  ,  { &&beq, NULL }  ,  { &&beq, NULL }  ,  { &&beq, NULL }  ,  { &&beq, NULL }  ,  { &&beq, NULL } 
 ,  { &&beq, NULL }  ,  { &&beq, NULL }  ,  { &&beq, NULL }  ,  { &&beq, NULL }  ,  { &&beq, NULL }  ,  { &&beq, NULL }  ,  { NULL, arraybeqPLUSsw }  ,  { &&beq, NULL }  ,  { &&beq, NULL }  ,  { &&beq, NULL } 
 ,  { &&beq, NULL }  ,  { &&beq, NULL }  ,  { &&beq, NULL }  ,  { &&beq, NULL }  ,  { &&beq, NULL }  ,  { &&beq, NULL }  ,  { &&beq, NULL }  ,  { &&beq, NULL }  ,  { &&beq, NULL }  ,  { &&beq, NULL } 
 ,  { &&beq, NULL }  ,  { &&beq, NULL }  ,  { &&beq, NULL }  ,  { &&beq, NULL }  ,  { &&beq, NULL }  ,  { &&beq, NULL }  ,  { &&beq, NULL }  ,  { &&beq, NULL }  ,  { &&beq, NULL }  ,  { &&beq, NULL } 
 }; 

struct pointer arrayand[T_SIZE] = {  { NULL, arrayandPLUSsll }  ,  { &&and, NULL }  ,  { NULL, arrayandPLUSsrl }  ,  { &&and, NULL }  ,  { &&and, NULL }  ,  { &&and, NULL }  ,  { &&and, NULL }  ,  { &&and, NULL }  ,  { &&and, NULL }  ,  { &&and, NULL } 
 ,  { &&and, NULL }  ,  { &&and, NULL }  ,  { &&and, NULL }  ,  { &&and, NULL }  ,  { &&and, NULL }  ,  { &&and, NULL }  ,  { &&and, NULL }  ,  { &&and, NULL }  ,  { &&and, NULL }  ,  { &&and, NULL } 
 ,  { &&and, NULL }  ,  { &&and, NULL }  ,  { &&and, NULL }  ,  { &&and, NULL }  ,  { &&and, NULL }  ,  { &&and, NULL }  ,  { &&and, NULL }  ,  { &&and, NULL }  ,  { &&and, NULL }  ,  { &&and, NULL } 
 ,  { &&and, NULL }  ,  { &&and, NULL }  ,  { &&and, NULL }  ,  { &&and, NULL }  ,  { &&and, NULL }  ,  { &&and, NULL }  ,  { &&and, NULL }  ,  { NULL, arrayandPLUSor }  ,  { NULL, arrayandPLUSxor }  ,  { &&and, NULL } 
 ,  { &&and, NULL }  ,  { &&and, NULL }  ,  { &&and, NULL }  ,  { &&and, NULL }  ,  { &&and, NULL }  ,  { &&and, NULL }  ,  { &&and, NULL }  ,  { &&and, NULL }  ,  { &&and, NULL }  ,  { &&and, NULL } 
 ,  { &&and, NULL }  ,  { &&and, NULL }  ,  { &&and, NULL }  ,  { &&and, NULL }  ,  { &&and, NULL }  ,  { NULL, arrayandPLUSandi }  ,  { &&and, NULL }  ,  { &&and, NULL }  ,  { &&and, NULL }  ,  { &&and, NULL } 
 ,  { &&and, NULL }  ,  { &&and, NULL }  ,  { &&and, NULL }  ,  { &&and, NULL }  ,  { &&and, NULL }  ,  { &&and, NULL }  ,  { &&and, NULL }  ,  { &&and, NULL }  ,  { &&and, NULL }  ,  { &&and, NULL } 
 ,  { &&and, NULL }  ,  { &&and, NULL }  ,  { &&and, NULL }  ,  { &&and, NULL }  ,  { &&and, NULL }  ,  { &&and, NULL }  ,  { &&and, NULL }  ,  { &&and, NULL }  ,  { &&and, NULL }  ,  { &&and, NULL } 
 ,  { &&and, NULL }  ,  { &&and, NULL }  ,  { &&and, NULL }  ,  { &&and, NULL }  ,  { &&and, NULL }  ,  { &&and, NULL }  ,  { &&and, NULL }  ,  { &&and, NULL }  ,  { &&and, NULL }  ,  { &&and, NULL } 
 ,  { &&and, NULL }  ,  { &&and, NULL }  ,  { &&and, NULL }  ,  { &&and, NULL }  ,  { &&and, NULL }  ,  { &&and, NULL }  ,  { &&and, NULL }  ,  { &&and, NULL }  ,  { &&and, NULL }  ,  { &&and, NULL } 
 ,  { &&and, NULL }  ,  { &&and, NULL }  ,  { &&and, NULL }  ,  { &&and, NULL }  ,  { &&and, NULL }  ,  { &&and, NULL }  ,  { &&and, NULL }  ,  { &&and, NULL }  ,  { &&and, NULL }  ,  { &&and, NULL } 
 }; 

struct pointer arraylbu[T_SIZE] = {  { &&lbu, NULL }  ,  { &&lbu, NULL }  ,  { &&lbu, NULL }  ,  { &&lbu, NULL }  ,  { &&lbu, NULL }  ,  { &&lbu, NULL }  ,  { &&lbu, NULL }  ,  { &&lbu, NULL }  ,  { &&lbu, NULL }  ,  { &&lbu, NULL } 
 ,  { &&lbu, NULL }  ,  { &&lbu, NULL }  ,  { &&lbu, NULL }  ,  { &&lbu, NULL }  ,  { &&lbu, NULL }  ,  { &&lbu, NULL }  ,  { &&lbu, NULL }  ,  { &&lbu, NULL }  ,  { &&lbu, NULL }  ,  { &&lbu, NULL } 
 ,  { &&lbu, NULL }  ,  { &&lbu, NULL }  ,  { &&lbu, NULL }  ,  { &&lbu, NULL }  ,  { &&lbu, NULL }  ,  { &&lbu, NULL }  ,  { &&lbu, NULL }  ,  { &&lbu, NULL }  ,  { &&lbu, NULL }  ,  { &&lbu, NULL } 
 ,  { &&lbu, NULL }  ,  { &&lbu, NULL }  ,  { &&lbu, NULL }  ,  { &&lbu, NULL }  ,  { &&lbu, NULL }  ,  { NULL, arraylbuPLUSsubu }  ,  { &&lbu, NULL }  ,  { &&lbu, NULL }  ,  { NULL, arraylbuPLUSxor }  ,  { &&lbu, NULL } 
 ,  { &&lbu, NULL }  ,  { &&lbu, NULL }  ,  { &&lbu, NULL }  ,  { &&lbu, NULL }  ,  { &&lbu, NULL }  ,  { &&lbu, NULL }  ,  { &&lbu, NULL }  ,  { NULL, arraylbuPLUSbeq }  ,  { &&lbu, NULL }  ,  { &&lbu, NULL } 
 ,  { &&lbu, NULL }  ,  { &&lbu, NULL }  ,  { NULL, arraylbuPLUSaddiu }  ,  { &&lbu, NULL }  ,  { &&lbu, NULL }  ,  { &&lbu, NULL }  ,  { &&lbu, NULL }  ,  { &&lbu, NULL }  ,  { &&lbu, NULL }  ,  { &&lbu, NULL } 
 ,  { &&lbu, NULL }  ,  { &&lbu, NULL }  ,  { &&lbu, NULL }  ,  { &&lbu, NULL }  ,  { &&lbu, NULL }  ,  { &&lbu, NULL }  ,  { &&lbu, NULL }  ,  { &&lbu, NULL }  ,  { &&lbu, NULL }  ,  { &&lbu, NULL } 
 ,  { &&lbu, NULL }  ,  { &&lbu, NULL }  ,  { &&lbu, NULL }  ,  { &&lbu, NULL }  ,  { &&lbu, NULL }  ,  { &&lbu, NULL }  ,  { &&lbu, NULL }  ,  { &&lbu, NULL }  ,  { &&lbu, NULL }  ,  { &&lbu, NULL } 
 ,  { &&lbu, NULL }  ,  { &&lbu, NULL }  ,  { &&lbu, NULL }  ,  { &&lbu, NULL }  ,  { &&lbu, NULL }  ,  { &&lbu, NULL }  ,  { &&lbu, NULL }  ,  { &&lbu, NULL }  ,  { &&lbu, NULL }  ,  { &&lbu, NULL } 
 ,  { &&lbu, NULL }  ,  { &&lbu, NULL }  ,  { &&lbu, NULL }  ,  { &&lbu, NULL }  ,  { &&lbu, NULL }  ,  { &&lbu, NULL }  ,  { &&lbu, NULL }  ,  { &&lbu, NULL }  ,  { &&lbu, NULL }  ,  { &&lbu, NULL } 
 ,  { &&lbu, NULL }  ,  { &&lbu, NULL }  ,  { &&lbu, NULL }  ,  { &&lbu, NULL }  ,  { &&lbu, NULL }  ,  { &&lbu, NULL }  ,  { &&lbu, NULL }  ,  { &&lbu, NULL }  ,  { &&lbu, NULL }  ,  { &&lbu, NULL } 
 }; 

struct pointer arraysb[T_SIZE] = {  { &&sb, NULL }  ,  { &&sb, NULL }  ,  { &&sb, NULL }  ,  { &&sb, NULL }  ,  { &&sb, NULL }  ,  { &&sb, NULL }  ,  { &&sb, NULL }  ,  { &&sb, NULL }  ,  { &&sb, NULL }  ,  { &&sb, NULL } 
 ,  { &&sb, NULL }  ,  { &&sb, NULL }  ,  { &&sb, NULL }  ,  { &&sb, NULL }  ,  { &&sb, NULL }  ,  { &&sb, NULL }  ,  { &&sb, NULL }  ,  { &&sb, NULL }  ,  { &&sb, NULL }  ,  { &&sb, NULL } 
 ,  { &&sb, NULL }  ,  { &&sb, NULL }  ,  { &&sb, NULL }  ,  { &&sb, NULL }  ,  { &&sb, NULL }  ,  { &&sb, NULL }  ,  { &&sb, NULL }  ,  { &&sb, NULL }  ,  { &&sb, NULL }  ,  { &&sb, NULL } 
 ,  { &&sb, NULL }  ,  { &&sb, NULL }  ,  { &&sb, NULL }  ,  { &&sb, NULL }  ,  { &&sb, NULL }  ,  { &&sb, NULL }  ,  { &&sb, NULL }  ,  { &&sb, NULL }  ,  { &&sb, NULL }  ,  { &&sb, NULL } 
 ,  { &&sb, NULL }  ,  { &&sb, NULL }  ,  { &&sb, NULL }  ,  { &&sb, NULL }  ,  { &&sb, NULL }  ,  { &&sb, NULL }  ,  { NULL, arraysbPLUSjal }  ,  { &&sb, NULL }  ,  { &&sb, NULL }  ,  { &&sb, NULL } 
 ,  { &&sb, NULL }  ,  { &&sb, NULL }  ,  { &&sb, NULL }  ,  { &&sb, NULL }  ,  { &&sb, NULL }  ,  { &&sb, NULL }  ,  { &&sb, NULL }  ,  { &&sb, NULL }  ,  { &&sb, NULL }  ,  { &&sb, NULL } 
 ,  { &&sb, NULL }  ,  { &&sb, NULL }  ,  { &&sb, NULL }  ,  { &&sb, NULL }  ,  { &&sb, NULL }  ,  { &&sb, NULL }  ,  { &&sb, NULL }  ,  { &&sb, NULL }  ,  { &&sb, NULL }  ,  { &&sb, NULL } 
 ,  { &&sb, NULL }  ,  { &&sb, NULL }  ,  { &&sb, NULL }  ,  { &&sb, NULL }  ,  { &&sb, NULL }  ,  { &&sb, NULL }  ,  { &&sb, NULL }  ,  { &&sb, NULL }  ,  { &&sb, NULL }  ,  { &&sb, NULL } 
 ,  { &&sb, NULL }  ,  { &&sb, NULL }  ,  { &&sb, NULL }  ,  { &&sb, NULL }  ,  { NULL, arraysbPLUSsh }  ,  { &&sb, NULL }  ,  { &&sb, NULL }  ,  { &&sb, NULL }  ,  { &&sb, NULL }  ,  { &&sb, NULL } 
 ,  { &&sb, NULL }  ,  { &&sb, NULL }  ,  { &&sb, NULL }  ,  { &&sb, NULL }  ,  { &&sb, NULL }  ,  { &&sb, NULL }  ,  { &&sb, NULL }  ,  { &&sb, NULL }  ,  { &&sb, NULL }  ,  { &&sb, NULL } 
 ,  { &&sb, NULL }  ,  { &&sb, NULL }  ,  { &&sb, NULL }  ,  { &&sb, NULL }  ,  { &&sb, NULL }  ,  { &&sb, NULL }  ,  { &&sb, NULL }  ,  { &&sb, NULL }  ,  { &&sb, NULL }  ,  { &&sb, NULL } 
 }; 

struct pointer arrayjr[T_SIZE] = {  { NULL, arrayjrPLUSsll }  ,  { &&jr, NULL }  ,  { &&jr, NULL }  ,  { &&jr, NULL }  ,  { &&jr, NULL }  ,  { &&jr, NULL }  ,  { &&jr, NULL }  ,  { &&jr, NULL }  ,  { &&jr, NULL }  ,  { &&jr, NULL } 
 ,  { &&jr, NULL }  ,  { &&jr, NULL }  ,  { &&jr, NULL }  ,  { &&jr, NULL }  ,  { &&jr, NULL }  ,  { &&jr, NULL }  ,  { &&jr, NULL }  ,  { &&jr, NULL }  ,  { &&jr, NULL }  ,  { &&jr, NULL } 
 ,  { &&jr, NULL }  ,  { &&jr, NULL }  ,  { &&jr, NULL }  ,  { &&jr, NULL }  ,  { &&jr, NULL }  ,  { &&jr, NULL }  ,  { &&jr, NULL }  ,  { &&jr, NULL }  ,  { &&jr, NULL }  ,  { &&jr, NULL } 
 ,  { &&jr, NULL }  ,  { &&jr, NULL }  ,  { &&jr, NULL }  ,  { &&jr, NULL }  ,  { &&jr, NULL }  ,  { &&jr, NULL }  ,  { &&jr, NULL }  ,  { NULL, arrayjrPLUSor }  ,  { &&jr, NULL }  ,  { &&jr, NULL } 
 ,  { &&jr, NULL }  ,  { &&jr, NULL }  ,  { &&jr, NULL }  ,  { &&jr, NULL }  ,  { &&jr, NULL }  ,  { &&jr, NULL }  ,  { &&jr, NULL }  ,  { &&jr, NULL }  ,  { &&jr, NULL }  ,  { &&jr, NULL } 
 ,  { &&jr, NULL }  ,  { &&jr, NULL }  ,  { NULL, arrayjrPLUSaddiu }  ,  { &&jr, NULL }  ,  { &&jr, NULL }  ,  { &&jr, NULL }  ,  { &&jr, NULL }  ,  { &&jr, NULL }  ,  { &&jr, NULL }  ,  { &&jr, NULL } 
 ,  { &&jr, NULL }  ,  { &&jr, NULL }  ,  { &&jr, NULL }  ,  { &&jr, NULL }  ,  { &&jr, NULL }  ,  { &&jr, NULL }  ,  { &&jr, NULL }  ,  { &&jr, NULL }  ,  { &&jr, NULL }  ,  { &&jr, NULL } 
 ,  { &&jr, NULL }  ,  { &&jr, NULL }  ,  { &&jr, NULL }  ,  { &&jr, NULL }  ,  { &&jr, NULL }  ,  { &&jr, NULL }  ,  { &&jr, NULL }  ,  { &&jr, NULL }  ,  { &&jr, NULL }  ,  { &&jr, NULL } 
 ,  { &&jr, NULL }  ,  { &&jr, NULL }  ,  { &&jr, NULL }  ,  { &&jr, NULL }  ,  { &&jr, NULL }  ,  { &&jr, NULL }  ,  { &&jr, NULL }  ,  { &&jr, NULL }  ,  { &&jr, NULL }  ,  { &&jr, NULL } 
 ,  { &&jr, NULL }  ,  { &&jr, NULL }  ,  { &&jr, NULL }  ,  { &&jr, NULL }  ,  { &&jr, NULL }  ,  { &&jr, NULL }  ,  { &&jr, NULL }  ,  { &&jr, NULL }  ,  { &&jr, NULL }  ,  { &&jr, NULL } 
 ,  { &&jr, NULL }  ,  { &&jr, NULL }  ,  { &&jr, NULL }  ,  { &&jr, NULL }  ,  { &&jr, NULL }  ,  { &&jr, NULL }  ,  { &&jr, NULL }  ,  { &&jr, NULL }  ,  { &&jr, NULL }  ,  { &&jr, NULL } 
 }; 

struct pointer arrayjal[T_SIZE] = {  { NULL, arrayjalPLUSsll }  ,  { &&jal, NULL }  ,  { &&jal, NULL }  ,  { &&jal, NULL }  ,  { &&jal, NULL }  ,  { &&jal, NULL }  ,  { &&jal, NULL }  ,  { &&jal, NULL }  ,  { &&jal, NULL }  ,  { &&jal, NULL } 
 ,  { &&jal, NULL }  ,  { &&jal, NULL }  ,  { &&jal, NULL }  ,  { &&jal, NULL }  ,  { &&jal, NULL }  ,  { &&jal, NULL }  ,  { &&jal, NULL }  ,  { &&jal, NULL }  ,  { &&jal, NULL }  ,  { &&jal, NULL } 
 ,  { &&jal, NULL }  ,  { &&jal, NULL }  ,  { &&jal, NULL }  ,  { &&jal, NULL }  ,  { &&jal, NULL }  ,  { &&jal, NULL }  ,  { &&jal, NULL }  ,  { &&jal, NULL }  ,  { &&jal, NULL }  ,  { &&jal, NULL } 
 ,  { &&jal, NULL }  ,  { &&jal, NULL }  ,  { &&jal, NULL }  ,  { NULL, arrayjalPLUSaddu }  ,  { &&jal, NULL }  ,  { &&jal, NULL }  ,  { &&jal, NULL }  ,  { &&jal, NULL }  ,  { &&jal, NULL }  ,  { &&jal, NULL } 
 ,  { &&jal, NULL }  ,  { &&jal, NULL }  ,  { &&jal, NULL }  ,  { &&jal, NULL }  ,  { &&jal, NULL }  ,  { &&jal, NULL }  ,  { &&jal, NULL }  ,  { &&jal, NULL }  ,  { &&jal, NULL }  ,  { &&jal, NULL } 
 ,  { &&jal, NULL }  ,  { &&jal, NULL }  ,  { NULL, arrayjalPLUSaddiu }  ,  { &&jal, NULL }  ,  { &&jal, NULL }  ,  { &&jal, NULL }  ,  { &&jal, NULL }  ,  { &&jal, NULL }  ,  { &&jal, NULL }  ,  { &&jal, NULL } 
 ,  { &&jal, NULL }  ,  { &&jal, NULL }  ,  { &&jal, NULL }  ,  { &&jal, NULL }  ,  { &&jal, NULL }  ,  { &&jal, NULL }  ,  { &&jal, NULL }  ,  { &&jal, NULL }  ,  { &&jal, NULL }  ,  { &&jal, NULL } 
 ,  { &&jal, NULL }  ,  { &&jal, NULL }  ,  { &&jal, NULL }  ,  { &&jal, NULL }  ,  { &&jal, NULL }  ,  { &&jal, NULL }  ,  { &&jal, NULL }  ,  { &&jal, NULL }  ,  { &&jal, NULL }  ,  { &&jal, NULL } 
 ,  { &&jal, NULL }  ,  { &&jal, NULL }  ,  { &&jal, NULL }  ,  { &&jal, NULL }  ,  { &&jal, NULL }  ,  { &&jal, NULL }  ,  { &&jal, NULL }  ,  { &&jal, NULL }  ,  { &&jal, NULL }  ,  { &&jal, NULL } 
 ,  { &&jal, NULL }  ,  { &&jal, NULL }  ,  { &&jal, NULL }  ,  { &&jal, NULL }  ,  { &&jal, NULL }  ,  { &&jal, NULL }  ,  { &&jal, NULL }  ,  { &&jal, NULL }  ,  { &&jal, NULL }  ,  { &&jal, NULL } 
 ,  { &&jal, NULL }  ,  { &&jal, NULL }  ,  { &&jal, NULL }  ,  { &&jal, NULL }  ,  { &&jal, NULL }  ,  { &&jal, NULL }  ,  { &&jal, NULL }  ,  { &&jal, NULL }  ,  { &&jal, NULL }  ,  { &&jal, NULL } 
 }; 

struct pointer arraymfhi[T_SIZE] = {  { NULL, arraymfhiPLUSsll }  ,  { &&mfhi, NULL }  ,  { NULL, arraymfhiPLUSsrl }  ,  { &&mfhi, NULL }  ,  { &&mfhi, NULL }  ,  { &&mfhi, NULL }  ,  { &&mfhi, NULL }  ,  { &&mfhi, NULL }  ,  { &&mfhi, NULL }  ,  { &&mfhi, NULL } 
 ,  { &&mfhi, NULL }  ,  { &&mfhi, NULL }  ,  { &&mfhi, NULL }  ,  { &&mfhi, NULL }  ,  { &&mfhi, NULL }  ,  { &&mfhi, NULL }  ,  { &&mfhi, NULL }  ,  { &&mfhi, NULL }  ,  { &&mfhi, NULL }  ,  { &&mfhi, NULL } 
 ,  { &&mfhi, NULL }  ,  { &&mfhi, NULL }  ,  { &&mfhi, NULL }  ,  { &&mfhi, NULL }  ,  { NULL, arraymfhiPLUSmult }  ,  { &&mfhi, NULL }  ,  { &&mfhi, NULL }  ,  { &&mfhi, NULL }  ,  { &&mfhi, NULL }  ,  { &&mfhi, NULL } 
 ,  { &&mfhi, NULL }  ,  { &&mfhi, NULL }  ,  { &&mfhi, NULL }  ,  { &&mfhi, NULL }  ,  { &&mfhi, NULL }  ,  { &&mfhi, NULL }  ,  { &&mfhi, NULL }  ,  { &&mfhi, NULL }  ,  { &&mfhi, NULL }  ,  { &&mfhi, NULL } 
 ,  { &&mfhi, NULL }  ,  { &&mfhi, NULL }  ,  { &&mfhi, NULL }  ,  { &&mfhi, NULL }  ,  { &&mfhi, NULL }  ,  { &&mfhi, NULL }  ,  { &&mfhi, NULL }  ,  { &&mfhi, NULL }  ,  { &&mfhi, NULL }  ,  { &&mfhi, NULL } 
 ,  { &&mfhi, NULL }  ,  { &&mfhi, NULL }  ,  { NULL, arraymfhiPLUSaddiu }  ,  { &&mfhi, NULL }  ,  { &&mfhi, NULL }  ,  { &&mfhi, NULL }  ,  { &&mfhi, NULL }  ,  { &&mfhi, NULL }  ,  { &&mfhi, NULL }  ,  { &&mfhi, NULL } 
 ,  { &&mfhi, NULL }  ,  { &&mfhi, NULL }  ,  { &&mfhi, NULL }  ,  { &&mfhi, NULL }  ,  { &&mfhi, NULL }  ,  { &&mfhi, NULL }  ,  { &&mfhi, NULL }  ,  { &&mfhi, NULL }  ,  { &&mfhi, NULL }  ,  { &&mfhi, NULL } 
 ,  { &&mfhi, NULL }  ,  { &&mfhi, NULL }  ,  { &&mfhi, NULL }  ,  { &&mfhi, NULL }  ,  { &&mfhi, NULL }  ,  { &&mfhi, NULL }  ,  { &&mfhi, NULL }  ,  { &&mfhi, NULL }  ,  { &&mfhi, NULL }  ,  { &&mfhi, NULL } 
 ,  { &&mfhi, NULL }  ,  { &&mfhi, NULL }  ,  { &&mfhi, NULL }  ,  { &&mfhi, NULL }  ,  { &&mfhi, NULL }  ,  { &&mfhi, NULL }  ,  { &&mfhi, NULL }  ,  { &&mfhi, NULL }  ,  { &&mfhi, NULL }  ,  { &&mfhi, NULL } 
 ,  { &&mfhi, NULL }  ,  { &&mfhi, NULL }  ,  { &&mfhi, NULL }  ,  { &&mfhi, NULL }  ,  { &&mfhi, NULL }  ,  { &&mfhi, NULL }  ,  { &&mfhi, NULL }  ,  { &&mfhi, NULL }  ,  { &&mfhi, NULL }  ,  { &&mfhi, NULL } 
 ,  { &&mfhi, NULL }  ,  { &&mfhi, NULL }  ,  { &&mfhi, NULL }  ,  { &&mfhi, NULL }  ,  { &&mfhi, NULL }  ,  { &&mfhi, NULL }  ,  { &&mfhi, NULL }  ,  { &&mfhi, NULL }  ,  { &&mfhi, NULL }  ,  { &&mfhi, NULL } 
 }; 

struct pointer arrayblez[T_SIZE] = {  { NULL, arrayblezPLUSsll }  ,  { &&blez, NULL }  ,  { &&blez, NULL }  ,  { &&blez, NULL }  ,  { &&blez, NULL }  ,  { &&blez, NULL }  ,  { &&blez, NULL }  ,  { &&blez, NULL }  ,  { &&blez, NULL }  ,  { &&blez, NULL } 
 ,  { &&blez, NULL }  ,  { &&blez, NULL }  ,  { &&blez, NULL }  ,  { &&blez, NULL }  ,  { &&blez, NULL }  ,  { &&blez, NULL }  ,  { &&blez, NULL }  ,  { &&blez, NULL }  ,  { &&blez, NULL }  ,  { &&blez, NULL } 
 ,  { &&blez, NULL }  ,  { &&blez, NULL }  ,  { &&blez, NULL }  ,  { &&blez, NULL }  ,  { &&blez, NULL }  ,  { &&blez, NULL }  ,  { &&blez, NULL }  ,  { &&blez, NULL }  ,  { &&blez, NULL }  ,  { &&blez, NULL } 
 ,  { &&blez, NULL }  ,  { &&blez, NULL }  ,  { &&blez, NULL }  ,  { &&blez, NULL }  ,  { &&blez, NULL }  ,  { &&blez, NULL }  ,  { &&blez, NULL }  ,  { &&blez, NULL }  ,  { &&blez, NULL }  ,  { &&blez, NULL } 
 ,  { &&blez, NULL }  ,  { &&blez, NULL }  ,  { &&blez, NULL }  ,  { &&blez, NULL }  ,  { &&blez, NULL }  ,  { &&blez, NULL }  ,  { &&blez, NULL }  ,  { &&blez, NULL }  ,  { &&blez, NULL }  ,  { &&blez, NULL } 
 ,  { &&blez, NULL }  ,  { &&blez, NULL }  ,  { NULL, arrayblezPLUSaddiu }  ,  { &&blez, NULL }  ,  { &&blez, NULL }  ,  { &&blez, NULL }  ,  { &&blez, NULL }  ,  { &&blez, NULL }  ,  { &&blez, NULL }  ,  { &&blez, NULL } 
 ,  { &&blez, NULL }  ,  { &&blez, NULL }  ,  { &&blez, NULL }  ,  { &&blez, NULL }  ,  { &&blez, NULL }  ,  { &&blez, NULL }  ,  { &&blez, NULL }  ,  { &&blez, NULL }  ,  { &&blez, NULL }  ,  { &&blez, NULL } 
 ,  { &&blez, NULL }  ,  { &&blez, NULL }  ,  { &&blez, NULL }  ,  { &&blez, NULL }  ,  { &&blez, NULL }  ,  { &&blez, NULL }  ,  { &&blez, NULL }  ,  { &&blez, NULL }  ,  { &&blez, NULL }  ,  { &&blez, NULL } 
 ,  { &&blez, NULL }  ,  { &&blez, NULL }  ,  { &&blez, NULL }  ,  { &&blez, NULL }  ,  { &&blez, NULL }  ,  { &&blez, NULL }  ,  { &&blez, NULL }  ,  { &&blez, NULL }  ,  { &&blez, NULL }  ,  { &&blez, NULL } 
 ,  { &&blez, NULL }  ,  { &&blez, NULL }  ,  { &&blez, NULL }  ,  { &&blez, NULL }  ,  { &&blez, NULL }  ,  { &&blez, NULL }  ,  { &&blez, NULL }  ,  { &&blez, NULL }  ,  { &&blez, NULL }  ,  { &&blez, NULL } 
 ,  { &&blez, NULL }  ,  { &&blez, NULL }  ,  { &&blez, NULL }  ,  { &&blez, NULL }  ,  { &&blez, NULL }  ,  { &&blez, NULL }  ,  { &&blez, NULL }  ,  { &&blez, NULL }  ,  { &&blez, NULL }  ,  { &&blez, NULL } 
 }; 

struct pointer arraylui[T_SIZE] = {  { &&lui, NULL }  ,  { &&lui, NULL }  ,  { NULL, arrayluiPLUSsrl }  ,  { &&lui, NULL }  ,  { &&lui, NULL }  ,  { &&lui, NULL }  ,  { &&lui, NULL }  ,  { &&lui, NULL }  ,  { &&lui, NULL }  ,  { &&lui, NULL } 
 ,  { &&lui, NULL }  ,  { &&lui, NULL }  ,  { &&lui, NULL }  ,  { &&lui, NULL }  ,  { &&lui, NULL }  ,  { &&lui, NULL }  ,  { &&lui, NULL }  ,  { &&lui, NULL }  ,  { &&lui, NULL }  ,  { &&lui, NULL } 
 ,  { &&lui, NULL }  ,  { &&lui, NULL }  ,  { &&lui, NULL }  ,  { &&lui, NULL }  ,  { &&lui, NULL }  ,  { &&lui, NULL }  ,  { &&lui, NULL }  ,  { &&lui, NULL }  ,  { &&lui, NULL }  ,  { &&lui, NULL } 
 ,  { &&lui, NULL }  ,  { &&lui, NULL }  ,  { &&lui, NULL }  ,  { &&lui, NULL }  ,  { &&lui, NULL }  ,  { &&lui, NULL }  ,  { &&lui, NULL }  ,  { &&lui, NULL }  ,  { &&lui, NULL }  ,  { &&lui, NULL } 
 ,  { &&lui, NULL }  ,  { &&lui, NULL }  ,  { &&lui, NULL }  ,  { &&lui, NULL }  ,  { &&lui, NULL }  ,  { &&lui, NULL }  ,  { NULL, arrayluiPLUSjal }  ,  { &&lui, NULL }  ,  { &&lui, NULL }  ,  { &&lui, NULL } 
 ,  { &&lui, NULL }  ,  { &&lui, NULL }  ,  { NULL, arrayluiPLUSaddiu }  ,  { &&lui, NULL }  ,  { &&lui, NULL }  ,  { &&lui, NULL }  ,  { NULL, arrayluiPLUSori }  ,  { &&lui, NULL }  ,  { NULL, arrayluiPLUSlui }  ,  { &&lui, NULL } 
 ,  { &&lui, NULL }  ,  { &&lui, NULL }  ,  { &&lui, NULL }  ,  { &&lui, NULL }  ,  { &&lui, NULL }  ,  { &&lui, NULL }  ,  { &&lui, NULL }  ,  { &&lui, NULL }  ,  { &&lui, NULL }  ,  { &&lui, NULL } 
 ,  { &&lui, NULL }  ,  { &&lui, NULL }  ,  { &&lui, NULL }  ,  { &&lui, NULL }  ,  { &&lui, NULL }  ,  { &&lui, NULL }  ,  { &&lui, NULL }  ,  { &&lui, NULL }  ,  { NULL, arrayluiPLUSlw }  ,  { &&lui, NULL } 
 ,  { &&lui, NULL }  ,  { &&lui, NULL }  ,  { &&lui, NULL }  ,  { &&lui, NULL }  ,  { &&lui, NULL }  ,  { &&lui, NULL }  ,  { NULL, arrayluiPLUSsw }  ,  { &&lui, NULL }  ,  { &&lui, NULL }  ,  { &&lui, NULL } 
 ,  { &&lui, NULL }  ,  { &&lui, NULL }  ,  { &&lui, NULL }  ,  { &&lui, NULL }  ,  { &&lui, NULL }  ,  { &&lui, NULL }  ,  { &&lui, NULL }  ,  { &&lui, NULL }  ,  { &&lui, NULL }  ,  { &&lui, NULL } 
 ,  { &&lui, NULL }  ,  { &&lui, NULL }  ,  { &&lui, NULL }  ,  { &&lui, NULL }  ,  { &&lui, NULL }  ,  { &&lui, NULL }  ,  { &&lui, NULL }  ,  { &&lui, NULL }  ,  { &&lui, NULL }  ,  { &&lui, NULL } 
 }; 

struct pointer arrayerror[T_SIZE] = {  { &&error, NULL }  ,  { NULL, arrayerrorPLUSerror }  ,  { &&error, NULL }  ,  { &&error, NULL }  ,  { &&error, NULL }  ,  { NULL, arrayerrorPLUSerror }  ,  { &&error, NULL }  ,  { &&error, NULL }  ,  { &&error, NULL }  ,  { &&error, NULL } 
 ,  { &&error, NULL }  ,  { &&error, NULL }  ,  { &&error, NULL }  ,  { NULL, arrayerrorPLUSerror }  ,  { NULL, arrayerrorPLUSerror }  ,  { NULL, arrayerrorPLUSerror }  ,  { &&error, NULL }  ,  { &&error, NULL }  ,  { &&error, NULL }  ,  { &&error, NULL } 
 ,  { NULL, arrayerrorPLUSerror }  ,  { NULL, arrayerrorPLUSerror }  ,  { NULL, arrayerrorPLUSerror }  ,  { NULL, arrayerrorPLUSerror }  ,  { &&error, NULL }  ,  { &&error, NULL }  ,  { &&error, NULL }  ,  { &&error, NULL }  ,  { NULL, arrayerrorPLUSerror }  ,  { NULL, arrayerrorPLUSerror } 
 ,  { NULL, arrayerrorPLUSerror }  ,  { NULL, arrayerrorPLUSerror }  ,  { &&error, NULL }  ,  { NULL, arrayerrorPLUSaddu }  ,  { &&error, NULL }  ,  { NULL, arrayerrorPLUSsubu }  ,  { &&error, NULL }  ,  { &&error, NULL }  ,  { &&error, NULL }  ,  { &&error, NULL } 
 ,  { NULL, arrayerrorPLUSerror }  ,  { NULL, arrayerrorPLUSerror }  ,  { &&error, NULL }  ,  { &&error, NULL }  ,  { &&error, NULL }  ,  { &&error, NULL }  ,  { &&error, NULL }  ,  { &&error, NULL }  ,  { &&error, NULL }  ,  { &&error, NULL } 
 ,  { &&error, NULL }  ,  { &&error, NULL }  ,  { NULL, arrayerrorPLUSaddiu }  ,  { &&error, NULL }  ,  { &&error, NULL }  ,  { &&error, NULL }  ,  { &&error, NULL }  ,  { &&error, NULL }  ,  { &&error, NULL }  ,  { NULL, arrayerrorPLUSerror } 
 ,  { NULL, arrayerrorPLUSerror }  ,  { NULL, arrayerrorPLUSerror }  ,  { NULL, arrayerrorPLUSerror }  ,  { NULL, arrayerrorPLUSerror }  ,  { NULL, arrayerrorPLUSerror }  ,  { NULL, arrayerrorPLUSerror }  ,  { NULL, arrayerrorPLUSerror }  ,  { &&error, NULL }  ,  { &&error, NULL }  ,  { &&error, NULL } 
 ,  { NULL, arrayerrorPLUSerror }  ,  { NULL, arrayerrorPLUSerror }  ,  { NULL, arrayerrorPLUSerror }  ,  { NULL, arrayerrorPLUSerror }  ,  { NULL, arrayerrorPLUSerror }  ,  { &&error, NULL }  ,  { &&error, NULL }  ,  { &&error, NULL }  ,  { NULL, arrayerrorPLUSlw }  ,  { &&error, NULL } 
 ,  { &&error, NULL }  ,  { &&error, NULL }  ,  { NULL, arrayerrorPLUSerror }  ,  { &&error, NULL }  ,  { &&error, NULL }  ,  { &&error, NULL }  ,  { &&error, NULL }  ,  { NULL, arrayerrorPLUSerror }  ,  { NULL, arrayerrorPLUSerror }  ,  { &&error, NULL } 
 ,  { NULL, arrayerrorPLUSerror }  ,  { NULL, arrayerrorPLUSerror }  ,  { NULL, arrayerrorPLUSerror }  ,  { NULL, arrayerrorPLUSerror }  ,  { NULL, arrayerrorPLUSerror }  ,  { NULL, arrayerrorPLUSerror }  ,  { NULL, arrayerrorPLUSerror }  ,  { NULL, arrayerrorPLUSerror }  ,  { NULL, arrayerrorPLUSerror }  ,  { NULL, arrayerrorPLUSerror } 
 ,  { NULL, arrayerrorPLUSerror }  ,  { NULL, arrayerrorPLUSerror }  ,  { NULL, arrayerrorPLUSerror }  ,  { NULL, arrayerrorPLUSerror }  ,  { NULL, arrayerrorPLUSerror }  ,  { NULL, arrayerrorPLUSerror }  ,  { NULL, arrayerrorPLUSerror }  ,  { NULL, arrayerrorPLUSerror }  ,  { NULL, arrayerrorPLUSerror }  ,  { NULL, arrayerrorPLUSerror } 
 }; 

struct pointer arrayaddiu[T_SIZE] = {  { NULL, arrayaddiuPLUSsll }  ,  { NULL, arrayaddiuPLUSerror }  ,  { NULL, arrayaddiuPLUSsrl }  ,  { &&addiu, NULL }  ,  { &&addiu, NULL }  ,  { NULL, arrayaddiuPLUSerror }  ,  { &&addiu, NULL }  ,  { &&addiu, NULL }  ,  { NULL, arrayaddiuPLUSjr }  ,  { &&addiu, NULL } 
 ,  { &&addiu, NULL }  ,  { &&addiu, NULL }  ,  { NULL, arrayaddiuPLUSsysc }  ,  { NULL, arrayaddiuPLUSerror }  ,  { NULL, arrayaddiuPLUSerror }  ,  { NULL, arrayaddiuPLUSerror }  ,  { &&addiu, NULL }  ,  { &&addiu, NULL }  ,  { &&addiu, NULL }  ,  { &&addiu, NULL } 
 ,  { NULL, arrayaddiuPLUSerror }  ,  { NULL, arrayaddiuPLUSerror }  ,  { NULL, arrayaddiuPLUSerror }  ,  { NULL, arrayaddiuPLUSerror }  ,  { NULL, arrayaddiuPLUSmult }  ,  { &&addiu, NULL }  ,  { &&addiu, NULL }  ,  { &&addiu, NULL }  ,  { NULL, arrayaddiuPLUSerror }  ,  { NULL, arrayaddiuPLUSerror } 
 ,  { NULL, arrayaddiuPLUSerror }  ,  { NULL, arrayaddiuPLUSerror }  ,  { &&addiu, NULL }  ,  { NULL, arrayaddiuPLUSaddu }  ,  { &&addiu, NULL }  ,  { NULL, arrayaddiuPLUSsubu }  ,  { &&addiu, NULL }  ,  { &&addiu, NULL }  ,  { NULL, arrayaddiuPLUSxor }  ,  { &&addiu, NULL } 
 ,  { NULL, arrayaddiuPLUSerror }  ,  { NULL, arrayaddiuPLUSerror }  ,  { NULL, arrayaddiuPLUSslt }  ,  { NULL, arrayaddiuPLUSsltu }  ,  { &&addiu, NULL }  ,  { NULL, arrayaddiuPLUSjump }  ,  { NULL, arrayaddiuPLUSjal }  ,  { NULL, arrayaddiuPLUSbeq }  ,  { NULL, arrayaddiuPLUSbne }  ,  { NULL, arrayaddiuPLUSblez } 
 ,  { &&addiu, NULL }  ,  { &&addiu, NULL }  ,  { NULL, arrayaddiuPLUSaddiu }  ,  { NULL, arrayaddiuPLUSslti }  ,  { &&addiu, NULL }  ,  { NULL, arrayaddiuPLUSandi }  ,  { &&addiu, NULL }  ,  { &&addiu, NULL }  ,  { NULL, arrayaddiuPLUSlui }  ,  { NULL, arrayaddiuPLUSerror } 
 ,  { NULL, arrayaddiuPLUSerror }  ,  { NULL, arrayaddiuPLUSerror }  ,  { NULL, arrayaddiuPLUSerror }  ,  { NULL, arrayaddiuPLUSerror }  ,  { NULL, arrayaddiuPLUSerror }  ,  { NULL, arrayaddiuPLUSerror }  ,  { NULL, arrayaddiuPLUSerror }  ,  { &&addiu, NULL }  ,  { &&addiu, NULL }  ,  { &&addiu, NULL } 
 ,  { NULL, arrayaddiuPLUSerror }  ,  { NULL, arrayaddiuPLUSerror }  ,  { NULL, arrayaddiuPLUSerror }  ,  { NULL, arrayaddiuPLUSerror }  ,  { NULL, arrayaddiuPLUSerror }  ,  { &&addiu, NULL }  ,  { &&addiu, NULL }  ,  { &&addiu, NULL }  ,  { NULL, arrayaddiuPLUSlw }  ,  { NULL, arrayaddiuPLUSlbu } 
 ,  { &&addiu, NULL }  ,  { &&addiu, NULL }  ,  { NULL, arrayaddiuPLUSerror }  ,  { &&addiu, NULL }  ,  { &&addiu, NULL }  ,  { &&addiu, NULL }  ,  { NULL, arrayaddiuPLUSsw }  ,  { NULL, arrayaddiuPLUSerror }  ,  { NULL, arrayaddiuPLUSerror }  ,  { &&addiu, NULL } 
 ,  { NULL, arrayaddiuPLUSerror }  ,  { NULL, arrayaddiuPLUSerror }  ,  { NULL, arrayaddiuPLUSerror }  ,  { NULL, arrayaddiuPLUSerror }  ,  { NULL, arrayaddiuPLUSerror }  ,  { NULL, arrayaddiuPLUSerror }  ,  { NULL, arrayaddiuPLUSerror }  ,  { NULL, arrayaddiuPLUSerror }  ,  { NULL, arrayaddiuPLUSerror }  ,  { NULL, arrayaddiuPLUSerror } 
 ,  { NULL, arrayaddiuPLUSerror }  ,  { NULL, arrayaddiuPLUSerror }  ,  { NULL, arrayaddiuPLUSerror }  ,  { NULL, arrayaddiuPLUSerror }  ,  { NULL, arrayaddiuPLUSerror }  ,  { NULL, arrayaddiuPLUSerror }  ,  { NULL, arrayaddiuPLUSerror }  ,  { NULL, arrayaddiuPLUSerror }  ,  { NULL, arrayaddiuPLUSerror }  ,  { NULL, arrayaddiuPLUSerror } 
 }; 

struct pointer arraybgtz[T_SIZE] = {  { NULL, arraybgtzPLUSsll }  ,  { &&bgtz, NULL }  ,  { &&bgtz, NULL }  ,  { &&bgtz, NULL }  ,  { &&bgtz, NULL }  ,  { &&bgtz, NULL }  ,  { &&bgtz, NULL }  ,  { &&bgtz, NULL }  ,  { &&bgtz, NULL }  ,  { &&bgtz, NULL } 
 ,  { &&bgtz, NULL }  ,  { &&bgtz, NULL }  ,  { &&bgtz, NULL }  ,  { &&bgtz, NULL }  ,  { &&bgtz, NULL }  ,  { &&bgtz, NULL }  ,  { &&bgtz, NULL }  ,  { &&bgtz, NULL }  ,  { &&bgtz, NULL }  ,  { &&bgtz, NULL } 
 ,  { &&bgtz, NULL }  ,  { &&bgtz, NULL }  ,  { &&bgtz, NULL }  ,  { &&bgtz, NULL }  ,  { &&bgtz, NULL }  ,  { &&bgtz, NULL }  ,  { &&bgtz, NULL }  ,  { &&bgtz, NULL }  ,  { &&bgtz, NULL }  ,  { &&bgtz, NULL } 
 ,  { &&bgtz, NULL }  ,  { &&bgtz, NULL }  ,  { &&bgtz, NULL }  ,  { &&bgtz, NULL }  ,  { &&bgtz, NULL }  ,  { &&bgtz, NULL }  ,  { &&bgtz, NULL }  ,  { &&bgtz, NULL }  ,  { &&bgtz, NULL }  ,  { &&bgtz, NULL } 
 ,  { &&bgtz, NULL }  ,  { &&bgtz, NULL }  ,  { &&bgtz, NULL }  ,  { &&bgtz, NULL }  ,  { &&bgtz, NULL }  ,  { &&bgtz, NULL }  ,  { &&bgtz, NULL }  ,  { &&bgtz, NULL }  ,  { &&bgtz, NULL }  ,  { &&bgtz, NULL } 
 ,  { &&bgtz, NULL }  ,  { &&bgtz, NULL }  ,  { &&bgtz, NULL }  ,  { &&bgtz, NULL }  ,  { &&bgtz, NULL }  ,  { &&bgtz, NULL }  ,  { &&bgtz, NULL }  ,  { &&bgtz, NULL }  ,  { &&bgtz, NULL }  ,  { &&bgtz, NULL } 
 ,  { &&bgtz, NULL }  ,  { &&bgtz, NULL }  ,  { &&bgtz, NULL }  ,  { &&bgtz, NULL }  ,  { &&bgtz, NULL }  ,  { &&bgtz, NULL }  ,  { &&bgtz, NULL }  ,  { &&bgtz, NULL }  ,  { &&bgtz, NULL }  ,  { &&bgtz, NULL } 
 ,  { &&bgtz, NULL }  ,  { &&bgtz, NULL }  ,  { &&bgtz, NULL }  ,  { &&bgtz, NULL }  ,  { &&bgtz, NULL }  ,  { &&bgtz, NULL }  ,  { &&bgtz, NULL }  ,  { &&bgtz, NULL }  ,  { &&bgtz, NULL }  ,  { &&bgtz, NULL } 
 ,  { &&bgtz, NULL }  ,  { &&bgtz, NULL }  ,  { &&bgtz, NULL }  ,  { &&bgtz, NULL }  ,  { &&bgtz, NULL }  ,  { &&bgtz, NULL }  ,  { &&bgtz, NULL }  ,  { &&bgtz, NULL }  ,  { &&bgtz, NULL }  ,  { &&bgtz, NULL } 
 ,  { &&bgtz, NULL }  ,  { &&bgtz, NULL }  ,  { &&bgtz, NULL }  ,  { &&bgtz, NULL }  ,  { &&bgtz, NULL }  ,  { &&bgtz, NULL }  ,  { &&bgtz, NULL }  ,  { &&bgtz, NULL }  ,  { &&bgtz, NULL }  ,  { &&bgtz, NULL } 
 ,  { &&bgtz, NULL }  ,  { &&bgtz, NULL }  ,  { &&bgtz, NULL }  ,  { &&bgtz, NULL }  ,  { &&bgtz, NULL }  ,  { &&bgtz, NULL }  ,  { &&bgtz, NULL }  ,  { &&bgtz, NULL }  ,  { &&bgtz, NULL }  ,  { &&bgtz, NULL } 
 }; 

struct pointer arrayslt[T_SIZE] = {  { &&slt, NULL }  ,  { &&slt, NULL }  ,  { &&slt, NULL }  ,  { &&slt, NULL }  ,  { &&slt, NULL }  ,  { &&slt, NULL }  ,  { &&slt, NULL }  ,  { &&slt, NULL }  ,  { &&slt, NULL }  ,  { &&slt, NULL } 
 ,  { &&slt, NULL }  ,  { &&slt, NULL }  ,  { &&slt, NULL }  ,  { &&slt, NULL }  ,  { &&slt, NULL }  ,  { &&slt, NULL }  ,  { &&slt, NULL }  ,  { &&slt, NULL }  ,  { &&slt, NULL }  ,  { &&slt, NULL } 
 ,  { &&slt, NULL }  ,  { &&slt, NULL }  ,  { &&slt, NULL }  ,  { &&slt, NULL }  ,  { &&slt, NULL }  ,  { &&slt, NULL }  ,  { &&slt, NULL }  ,  { &&slt, NULL }  ,  { &&slt, NULL }  ,  { &&slt, NULL } 
 ,  { &&slt, NULL }  ,  { &&slt, NULL }  ,  { &&slt, NULL }  ,  { NULL, arraysltPLUSaddu }  ,  { &&slt, NULL }  ,  { &&slt, NULL }  ,  { &&slt, NULL }  ,  { &&slt, NULL }  ,  { &&slt, NULL }  ,  { &&slt, NULL } 
 ,  { &&slt, NULL }  ,  { &&slt, NULL }  ,  { &&slt, NULL }  ,  { &&slt, NULL }  ,  { &&slt, NULL }  ,  { &&slt, NULL }  ,  { &&slt, NULL }  ,  { NULL, arraysltPLUSbeq }  ,  { NULL, arraysltPLUSbne }  ,  { &&slt, NULL } 
 ,  { &&slt, NULL }  ,  { &&slt, NULL }  ,  { &&slt, NULL }  ,  { &&slt, NULL }  ,  { &&slt, NULL }  ,  { &&slt, NULL }  ,  { &&slt, NULL }  ,  { &&slt, NULL }  ,  { &&slt, NULL }  ,  { &&slt, NULL } 
 ,  { &&slt, NULL }  ,  { &&slt, NULL }  ,  { &&slt, NULL }  ,  { &&slt, NULL }  ,  { &&slt, NULL }  ,  { &&slt, NULL }  ,  { &&slt, NULL }  ,  { &&slt, NULL }  ,  { &&slt, NULL }  ,  { &&slt, NULL } 
 ,  { &&slt, NULL }  ,  { &&slt, NULL }  ,  { &&slt, NULL }  ,  { &&slt, NULL }  ,  { &&slt, NULL }  ,  { &&slt, NULL }  ,  { &&slt, NULL }  ,  { &&slt, NULL }  ,  { NULL, arraysltPLUSlw }  ,  { &&slt, NULL } 
 ,  { &&slt, NULL }  ,  { &&slt, NULL }  ,  { &&slt, NULL }  ,  { &&slt, NULL }  ,  { &&slt, NULL }  ,  { &&slt, NULL }  ,  { &&slt, NULL }  ,  { &&slt, NULL }  ,  { &&slt, NULL }  ,  { &&slt, NULL } 
 ,  { &&slt, NULL }  ,  { &&slt, NULL }  ,  { &&slt, NULL }  ,  { &&slt, NULL }  ,  { &&slt, NULL }  ,  { &&slt, NULL }  ,  { &&slt, NULL }  ,  { &&slt, NULL }  ,  { &&slt, NULL }  ,  { &&slt, NULL } 
 ,  { &&slt, NULL }  ,  { &&slt, NULL }  ,  { &&slt, NULL }  ,  { &&slt, NULL }  ,  { &&slt, NULL }  ,  { &&slt, NULL }  ,  { &&slt, NULL }  ,  { &&slt, NULL }  ,  { &&slt, NULL }  ,  { &&slt, NULL } 
 }; 

struct pointer arraybne[T_SIZE] = {  { NULL, arraybnePLUSsll }  ,  { &&bne, NULL }  ,  { &&bne, NULL }  ,  { &&bne, NULL }  ,  { &&bne, NULL }  ,  { &&bne, NULL }  ,  { &&bne, NULL }  ,  { &&bne, NULL }  ,  { &&bne, NULL }  ,  { &&bne, NULL } 
 ,  { &&bne, NULL }  ,  { &&bne, NULL }  ,  { &&bne, NULL }  ,  { &&bne, NULL }  ,  { &&bne, NULL }  ,  { &&bne, NULL }  ,  { &&bne, NULL }  ,  { &&bne, NULL }  ,  { &&bne, NULL }  ,  { &&bne, NULL } 
 ,  { &&bne, NULL }  ,  { &&bne, NULL }  ,  { &&bne, NULL }  ,  { &&bne, NULL }  ,  { &&bne, NULL }  ,  { &&bne, NULL }  ,  { &&bne, NULL }  ,  { &&bne, NULL }  ,  { &&bne, NULL }  ,  { &&bne, NULL } 
 ,  { &&bne, NULL }  ,  { &&bne, NULL }  ,  { &&bne, NULL }  ,  { NULL, arraybnePLUSaddu }  ,  { &&bne, NULL }  ,  { &&bne, NULL }  ,  { &&bne, NULL }  ,  { &&bne, NULL }  ,  { NULL, arraybnePLUSxor }  ,  { &&bne, NULL } 
 ,  { &&bne, NULL }  ,  { &&bne, NULL }  ,  { &&bne, NULL }  ,  { &&bne, NULL }  ,  { &&bne, NULL }  ,  { &&bne, NULL }  ,  { &&bne, NULL }  ,  { &&bne, NULL }  ,  { &&bne, NULL }  ,  { &&bne, NULL } 
 ,  { &&bne, NULL }  ,  { &&bne, NULL }  ,  { NULL, arraybnePLUSaddiu }  ,  { &&bne, NULL }  ,  { &&bne, NULL }  ,  { &&bne, NULL }  ,  { &&bne, NULL }  ,  { &&bne, NULL }  ,  { &&bne, NULL }  ,  { &&bne, NULL } 
 ,  { &&bne, NULL }  ,  { &&bne, NULL }  ,  { &&bne, NULL }  ,  { &&bne, NULL }  ,  { &&bne, NULL }  ,  { &&bne, NULL }  ,  { &&bne, NULL }  ,  { &&bne, NULL }  ,  { &&bne, NULL }  ,  { &&bne, NULL } 
 ,  { &&bne, NULL }  ,  { &&bne, NULL }  ,  { &&bne, NULL }  ,  { &&bne, NULL }  ,  { &&bne, NULL }  ,  { &&bne, NULL }  ,  { &&bne, NULL }  ,  { &&bne, NULL }  ,  { &&bne, NULL }  ,  { &&bne, NULL } 
 ,  { &&bne, NULL }  ,  { &&bne, NULL }  ,  { &&bne, NULL }  ,  { &&bne, NULL }  ,  { &&bne, NULL }  ,  { &&bne, NULL }  ,  { NULL, arraybnePLUSsw }  ,  { &&bne, NULL }  ,  { &&bne, NULL }  ,  { &&bne, NULL } 
 ,  { &&bne, NULL }  ,  { &&bne, NULL }  ,  { &&bne, NULL }  ,  { &&bne, NULL }  ,  { &&bne, NULL }  ,  { &&bne, NULL }  ,  { &&bne, NULL }  ,  { &&bne, NULL }  ,  { &&bne, NULL }  ,  { &&bne, NULL } 
 ,  { &&bne, NULL }  ,  { &&bne, NULL }  ,  { &&bne, NULL }  ,  { &&bne, NULL }  ,  { &&bne, NULL }  ,  { &&bne, NULL }  ,  { &&bne, NULL }  ,  { &&bne, NULL }  ,  { &&bne, NULL }  ,  { &&bne, NULL } 
 }; 

struct pointer arraysra[T_SIZE] = {  { &&sra, NULL }  ,  { &&sra, NULL }  ,  { &&sra, NULL }  ,  { &&sra, NULL }  ,  { &&sra, NULL }  ,  { &&sra, NULL }  ,  { &&sra, NULL }  ,  { &&sra, NULL }  ,  { &&sra, NULL }  ,  { &&sra, NULL } 
 ,  { &&sra, NULL }  ,  { &&sra, NULL }  ,  { &&sra, NULL }  ,  { &&sra, NULL }  ,  { &&sra, NULL }  ,  { &&sra, NULL }  ,  { &&sra, NULL }  ,  { &&sra, NULL }  ,  { &&sra, NULL }  ,  { &&sra, NULL } 
 ,  { &&sra, NULL }  ,  { &&sra, NULL }  ,  { &&sra, NULL }  ,  { &&sra, NULL }  ,  { &&sra, NULL }  ,  { &&sra, NULL }  ,  { &&sra, NULL }  ,  { &&sra, NULL }  ,  { &&sra, NULL }  ,  { &&sra, NULL } 
 ,  { &&sra, NULL }  ,  { &&sra, NULL }  ,  { &&sra, NULL }  ,  { NULL, arraysraPLUSaddu }  ,  { &&sra, NULL }  ,  { &&sra, NULL }  ,  { &&sra, NULL }  ,  { &&sra, NULL }  ,  { &&sra, NULL }  ,  { &&sra, NULL } 
 ,  { &&sra, NULL }  ,  { &&sra, NULL }  ,  { &&sra, NULL }  ,  { &&sra, NULL }  ,  { &&sra, NULL }  ,  { &&sra, NULL }  ,  { &&sra, NULL }  ,  { &&sra, NULL }  ,  { &&sra, NULL }  ,  { &&sra, NULL } 
 ,  { &&sra, NULL }  ,  { &&sra, NULL }  ,  { &&sra, NULL }  ,  { &&sra, NULL }  ,  { &&sra, NULL }  ,  { &&sra, NULL }  ,  { &&sra, NULL }  ,  { &&sra, NULL }  ,  { &&sra, NULL }  ,  { &&sra, NULL } 
 ,  { &&sra, NULL }  ,  { &&sra, NULL }  ,  { &&sra, NULL }  ,  { &&sra, NULL }  ,  { &&sra, NULL }  ,  { &&sra, NULL }  ,  { &&sra, NULL }  ,  { &&sra, NULL }  ,  { &&sra, NULL }  ,  { &&sra, NULL } 
 ,  { &&sra, NULL }  ,  { &&sra, NULL }  ,  { &&sra, NULL }  ,  { &&sra, NULL }  ,  { &&sra, NULL }  ,  { &&sra, NULL }  ,  { &&sra, NULL }  ,  { &&sra, NULL }  ,  { &&sra, NULL }  ,  { &&sra, NULL } 
 ,  { &&sra, NULL }  ,  { &&sra, NULL }  ,  { &&sra, NULL }  ,  { &&sra, NULL }  ,  { &&sra, NULL }  ,  { &&sra, NULL }  ,  { &&sra, NULL }  ,  { &&sra, NULL }  ,  { &&sra, NULL }  ,  { &&sra, NULL } 
 ,  { &&sra, NULL }  ,  { &&sra, NULL }  ,  { &&sra, NULL }  ,  { &&sra, NULL }  ,  { &&sra, NULL }  ,  { &&sra, NULL }  ,  { &&sra, NULL }  ,  { &&sra, NULL }  ,  { &&sra, NULL }  ,  { &&sra, NULL } 
 ,  { &&sra, NULL }  ,  { &&sra, NULL }  ,  { &&sra, NULL }  ,  { &&sra, NULL }  ,  { &&sra, NULL }  ,  { &&sra, NULL }  ,  { &&sra, NULL }  ,  { &&sra, NULL }  ,  { &&sra, NULL }  ,  { &&sra, NULL } 
 }; 

struct pointer arraysrl[T_SIZE] = {  { NULL, arraysrlPLUSsll }  ,  { NULL, arraysrlPLUSerror }  ,  { &&srl, NULL }  ,  { NULL, arraysrlPLUSsra }  ,  { &&srl, NULL }  ,  { NULL, arraysrlPLUSerror }  ,  { &&srl, NULL }  ,  { &&srl, NULL }  ,  { &&srl, NULL }  ,  { &&srl, NULL } 
 ,  { &&srl, NULL }  ,  { &&srl, NULL }  ,  { &&srl, NULL }  ,  { NULL, arraysrlPLUSerror }  ,  { NULL, arraysrlPLUSerror }  ,  { NULL, arraysrlPLUSerror }  ,  { &&srl, NULL }  ,  { &&srl, NULL }  ,  { &&srl, NULL }  ,  { &&srl, NULL } 
 ,  { NULL, arraysrlPLUSerror }  ,  { NULL, arraysrlPLUSerror }  ,  { NULL, arraysrlPLUSerror }  ,  { NULL, arraysrlPLUSerror }  ,  { &&srl, NULL }  ,  { &&srl, NULL }  ,  { &&srl, NULL }  ,  { &&srl, NULL }  ,  { NULL, arraysrlPLUSerror }  ,  { NULL, arraysrlPLUSerror } 
 ,  { NULL, arraysrlPLUSerror }  ,  { NULL, arraysrlPLUSerror }  ,  { &&srl, NULL }  ,  { NULL, arraysrlPLUSaddu }  ,  { &&srl, NULL }  ,  { &&srl, NULL }  ,  { &&srl, NULL }  ,  { NULL, arraysrlPLUSor }  ,  { NULL, arraysrlPLUSxor }  ,  { &&srl, NULL } 
 ,  { NULL, arraysrlPLUSerror }  ,  { NULL, arraysrlPLUSerror }  ,  { &&srl, NULL }  ,  { &&srl, NULL }  ,  { &&srl, NULL }  ,  { &&srl, NULL }  ,  { &&srl, NULL }  ,  { &&srl, NULL }  ,  { NULL, arraysrlPLUSbne }  ,  { &&srl, NULL } 
 ,  { &&srl, NULL }  ,  { &&srl, NULL }  ,  { &&srl, NULL }  ,  { &&srl, NULL }  ,  { &&srl, NULL }  ,  { NULL, arraysrlPLUSandi }  ,  { NULL, arraysrlPLUSori }  ,  { &&srl, NULL }  ,  { NULL, arraysrlPLUSlui }  ,  { NULL, arraysrlPLUSerror } 
 ,  { NULL, arraysrlPLUSerror }  ,  { NULL, arraysrlPLUSerror }  ,  { NULL, arraysrlPLUSerror }  ,  { NULL, arraysrlPLUSerror }  ,  { NULL, arraysrlPLUSerror }  ,  { NULL, arraysrlPLUSerror }  ,  { NULL, arraysrlPLUSerror }  ,  { &&srl, NULL }  ,  { &&srl, NULL }  ,  { &&srl, NULL } 
 ,  { NULL, arraysrlPLUSerror }  ,  { NULL, arraysrlPLUSerror }  ,  { NULL, arraysrlPLUSerror }  ,  { NULL, arraysrlPLUSerror }  ,  { NULL, arraysrlPLUSerror }  ,  { &&srl, NULL }  ,  { &&srl, NULL }  ,  { &&srl, NULL }  ,  { &&srl, NULL }  ,  { &&srl, NULL } 
 ,  { &&srl, NULL }  ,  { &&srl, NULL }  ,  { NULL, arraysrlPLUSerror }  ,  { &&srl, NULL }  ,  { &&srl, NULL }  ,  { &&srl, NULL }  ,  { &&srl, NULL }  ,  { NULL, arraysrlPLUSerror }  ,  { NULL, arraysrlPLUSerror }  ,  { &&srl, NULL } 
 ,  { NULL, arraysrlPLUSerror }  ,  { NULL, arraysrlPLUSerror }  ,  { NULL, arraysrlPLUSerror }  ,  { NULL, arraysrlPLUSerror }  ,  { NULL, arraysrlPLUSerror }  ,  { NULL, arraysrlPLUSerror }  ,  { NULL, arraysrlPLUSerror }  ,  { NULL, arraysrlPLUSerror }  ,  { NULL, arraysrlPLUSerror }  ,  { NULL, arraysrlPLUSerror } 
 ,  { NULL, arraysrlPLUSerror }  ,  { NULL, arraysrlPLUSerror }  ,  { NULL, arraysrlPLUSerror }  ,  { NULL, arraysrlPLUSerror }  ,  { NULL, arraysrlPLUSerror }  ,  { NULL, arraysrlPLUSerror }  ,  { NULL, arraysrlPLUSerror }  ,  { NULL, arraysrlPLUSerror }  ,  { NULL, arraysrlPLUSerror }  ,  { NULL, arraysrlPLUSerror } 
 }; 

struct pointer arrayor[T_SIZE] = {  { NULL, arrayorPLUSsll }  ,  { &&or, NULL }  ,  { NULL, arrayorPLUSsrl }  ,  { &&or, NULL }  ,  { &&or, NULL }  ,  { &&or, NULL }  ,  { &&or, NULL }  ,  { &&or, NULL }  ,  { &&or, NULL }  ,  { &&or, NULL } 
 ,  { &&or, NULL }  ,  { &&or, NULL }  ,  { &&or, NULL }  ,  { &&or, NULL }  ,  { &&or, NULL }  ,  { &&or, NULL }  ,  { &&or, NULL }  ,  { &&or, NULL }  ,  { &&or, NULL }  ,  { &&or, NULL } 
 ,  { &&or, NULL }  ,  { &&or, NULL }  ,  { &&or, NULL }  ,  { &&or, NULL }  ,  { &&or, NULL }  ,  { &&or, NULL }  ,  { &&or, NULL }  ,  { &&or, NULL }  ,  { &&or, NULL }  ,  { &&or, NULL } 
 ,  { &&or, NULL }  ,  { &&or, NULL }  ,  { &&or, NULL }  ,  { NULL, arrayorPLUSaddu }  ,  { &&or, NULL }  ,  { &&or, NULL }  ,  { &&or, NULL }  ,  { NULL, arrayorPLUSor }  ,  { &&or, NULL }  ,  { &&or, NULL } 
 ,  { &&or, NULL }  ,  { &&or, NULL }  ,  { &&or, NULL }  ,  { NULL, arrayorPLUSsltu }  ,  { &&or, NULL }  ,  { &&or, NULL }  ,  { &&or, NULL }  ,  { &&or, NULL }  ,  { &&or, NULL }  ,  { &&or, NULL } 
 ,  { &&or, NULL }  ,  { &&or, NULL }  ,  { &&or, NULL }  ,  { &&or, NULL }  ,  { &&or, NULL }  ,  { &&or, NULL }  ,  { &&or, NULL }  ,  { &&or, NULL }  ,  { NULL, arrayorPLUSlui }  ,  { &&or, NULL } 
 ,  { &&or, NULL }  ,  { &&or, NULL }  ,  { &&or, NULL }  ,  { &&or, NULL }  ,  { &&or, NULL }  ,  { &&or, NULL }  ,  { &&or, NULL }  ,  { &&or, NULL }  ,  { &&or, NULL }  ,  { &&or, NULL } 
 ,  { &&or, NULL }  ,  { &&or, NULL }  ,  { &&or, NULL }  ,  { &&or, NULL }  ,  { &&or, NULL }  ,  { &&or, NULL }  ,  { &&or, NULL }  ,  { &&or, NULL }  ,  { &&or, NULL }  ,  { &&or, NULL } 
 ,  { &&or, NULL }  ,  { &&or, NULL }  ,  { &&or, NULL }  ,  { &&or, NULL }  ,  { &&or, NULL }  ,  { &&or, NULL }  ,  { NULL, arrayorPLUSsw }  ,  { &&or, NULL }  ,  { &&or, NULL }  ,  { &&or, NULL } 
 ,  { &&or, NULL }  ,  { &&or, NULL }  ,  { &&or, NULL }  ,  { &&or, NULL }  ,  { &&or, NULL }  ,  { &&or, NULL }  ,  { &&or, NULL }  ,  { &&or, NULL }  ,  { &&or, NULL }  ,  { &&or, NULL } 
 ,  { &&or, NULL }  ,  { &&or, NULL }  ,  { &&or, NULL }  ,  { &&or, NULL }  ,  { &&or, NULL }  ,  { &&or, NULL }  ,  { &&or, NULL }  ,  { &&or, NULL }  ,  { &&or, NULL }  ,  { &&or, NULL } 
 }; 

struct pointer arraysubu[T_SIZE] = {  { &&subu, NULL }  ,  { &&subu, NULL }  ,  { &&subu, NULL }  ,  { &&subu, NULL }  ,  { &&subu, NULL }  ,  { &&subu, NULL }  ,  { &&subu, NULL }  ,  { &&subu, NULL }  ,  { &&subu, NULL }  ,  { &&subu, NULL } 
 ,  { &&subu, NULL }  ,  { &&subu, NULL }  ,  { &&subu, NULL }  ,  { &&subu, NULL }  ,  { &&subu, NULL }  ,  { &&subu, NULL }  ,  { &&subu, NULL }  ,  { &&subu, NULL }  ,  { &&subu, NULL }  ,  { &&subu, NULL } 
 ,  { &&subu, NULL }  ,  { &&subu, NULL }  ,  { &&subu, NULL }  ,  { &&subu, NULL }  ,  { &&subu, NULL }  ,  { &&subu, NULL }  ,  { &&subu, NULL }  ,  { &&subu, NULL }  ,  { &&subu, NULL }  ,  { &&subu, NULL } 
 ,  { &&subu, NULL }  ,  { &&subu, NULL }  ,  { &&subu, NULL }  ,  { NULL, arraysubuPLUSaddu }  ,  { &&subu, NULL }  ,  { &&subu, NULL }  ,  { NULL, arraysubuPLUSand }  ,  { &&subu, NULL }  ,  { &&subu, NULL }  ,  { &&subu, NULL } 
 ,  { &&subu, NULL }  ,  { &&subu, NULL }  ,  { &&subu, NULL }  ,  { &&subu, NULL }  ,  { &&subu, NULL }  ,  { &&subu, NULL }  ,  { &&subu, NULL }  ,  { &&subu, NULL }  ,  { &&subu, NULL }  ,  { &&subu, NULL } 
 ,  { &&subu, NULL }  ,  { &&subu, NULL }  ,  { NULL, arraysubuPLUSaddiu }  ,  { &&subu, NULL }  ,  { &&subu, NULL }  ,  { &&subu, NULL }  ,  { &&subu, NULL }  ,  { &&subu, NULL }  ,  { &&subu, NULL }  ,  { &&subu, NULL } 
 ,  { &&subu, NULL }  ,  { &&subu, NULL }  ,  { &&subu, NULL }  ,  { &&subu, NULL }  ,  { &&subu, NULL }  ,  { &&subu, NULL }  ,  { &&subu, NULL }  ,  { &&subu, NULL }  ,  { &&subu, NULL }  ,  { &&subu, NULL } 
 ,  { &&subu, NULL }  ,  { &&subu, NULL }  ,  { &&subu, NULL }  ,  { &&subu, NULL }  ,  { &&subu, NULL }  ,  { &&subu, NULL }  ,  { &&subu, NULL }  ,  { &&subu, NULL }  ,  { &&subu, NULL }  ,  { &&subu, NULL } 
 ,  { &&subu, NULL }  ,  { &&subu, NULL }  ,  { &&subu, NULL }  ,  { &&subu, NULL }  ,  { &&subu, NULL }  ,  { &&subu, NULL }  ,  { NULL, arraysubuPLUSsw }  ,  { &&subu, NULL }  ,  { &&subu, NULL }  ,  { &&subu, NULL } 
 ,  { &&subu, NULL }  ,  { &&subu, NULL }  ,  { &&subu, NULL }  ,  { &&subu, NULL }  ,  { &&subu, NULL }  ,  { &&subu, NULL }  ,  { &&subu, NULL }  ,  { &&subu, NULL }  ,  { &&subu, NULL }  ,  { &&subu, NULL } 
 ,  { &&subu, NULL }  ,  { &&subu, NULL }  ,  { &&subu, NULL }  ,  { &&subu, NULL }  ,  { &&subu, NULL }  ,  { &&subu, NULL }  ,  { &&subu, NULL }  ,  { &&subu, NULL }  ,  { &&subu, NULL }  ,  { &&subu, NULL } 
 }; 

struct pointer arraysysc[T_SIZE] = {  { &&sysc, NULL }  ,  { &&sysc, NULL }  ,  { &&sysc, NULL }  ,  { &&sysc, NULL }  ,  { &&sysc, NULL }  ,  { &&sysc, NULL }  ,  { &&sysc, NULL }  ,  { &&sysc, NULL }  ,  { NULL, arraysyscPLUSjr }  ,  { &&sysc, NULL } 
 ,  { &&sysc, NULL }  ,  { &&sysc, NULL }  ,  { &&sysc, NULL }  ,  { &&sysc, NULL }  ,  { &&sysc, NULL }  ,  { &&sysc, NULL }  ,  { &&sysc, NULL }  ,  { &&sysc, NULL }  ,  { &&sysc, NULL }  ,  { &&sysc, NULL } 
 ,  { &&sysc, NULL }  ,  { &&sysc, NULL }  ,  { &&sysc, NULL }  ,  { &&sysc, NULL }  ,  { &&sysc, NULL }  ,  { &&sysc, NULL }  ,  { &&sysc, NULL }  ,  { &&sysc, NULL }  ,  { &&sysc, NULL }  ,  { &&sysc, NULL } 
 ,  { &&sysc, NULL }  ,  { &&sysc, NULL }  ,  { &&sysc, NULL }  ,  { &&sysc, NULL }  ,  { &&sysc, NULL }  ,  { &&sysc, NULL }  ,  { &&sysc, NULL }  ,  { &&sysc, NULL }  ,  { &&sysc, NULL }  ,  { &&sysc, NULL } 
 ,  { &&sysc, NULL }  ,  { &&sysc, NULL }  ,  { &&sysc, NULL }  ,  { &&sysc, NULL }  ,  { &&sysc, NULL }  ,  { &&sysc, NULL }  ,  { NULL, arraysyscPLUSjal }  ,  { &&sysc, NULL }  ,  { &&sysc, NULL }  ,  { &&sysc, NULL } 
 ,  { &&sysc, NULL }  ,  { &&sysc, NULL }  ,  { &&sysc, NULL }  ,  { &&sysc, NULL }  ,  { &&sysc, NULL }  ,  { &&sysc, NULL }  ,  { &&sysc, NULL }  ,  { &&sysc, NULL }  ,  { &&sysc, NULL }  ,  { &&sysc, NULL } 
 ,  { &&sysc, NULL }  ,  { &&sysc, NULL }  ,  { &&sysc, NULL }  ,  { &&sysc, NULL }  ,  { &&sysc, NULL }  ,  { &&sysc, NULL }  ,  { &&sysc, NULL }  ,  { &&sysc, NULL }  ,  { &&sysc, NULL }  ,  { &&sysc, NULL } 
 ,  { &&sysc, NULL }  ,  { &&sysc, NULL }  ,  { &&sysc, NULL }  ,  { &&sysc, NULL }  ,  { &&sysc, NULL }  ,  { &&sysc, NULL }  ,  { &&sysc, NULL }  ,  { &&sysc, NULL }  ,  { &&sysc, NULL }  ,  { &&sysc, NULL } 
 ,  { &&sysc, NULL }  ,  { &&sysc, NULL }  ,  { &&sysc, NULL }  ,  { &&sysc, NULL }  ,  { &&sysc, NULL }  ,  { &&sysc, NULL }  ,  { &&sysc, NULL }  ,  { &&sysc, NULL }  ,  { &&sysc, NULL }  ,  { &&sysc, NULL } 
 ,  { &&sysc, NULL }  ,  { &&sysc, NULL }  ,  { &&sysc, NULL }  ,  { &&sysc, NULL }  ,  { &&sysc, NULL }  ,  { &&sysc, NULL }  ,  { &&sysc, NULL }  ,  { &&sysc, NULL }  ,  { &&sysc, NULL }  ,  { &&sysc, NULL } 
 ,  { &&sysc, NULL }  ,  { &&sysc, NULL }  ,  { &&sysc, NULL }  ,  { &&sysc, NULL }  ,  { &&sysc, NULL }  ,  { &&sysc, NULL }  ,  { &&sysc, NULL }  ,  { &&sysc, NULL }  ,  { &&sysc, NULL }  ,  { &&sysc, NULL } 
 }; 

struct pointer array[T_SIZE] = {  { NULL, arraysll }  ,  { NULL, arrayerror }  ,  { NULL, arraysrl }  ,  { NULL, arraysra }  ,  { &&sllv, NULL }  ,  { NULL, arrayerror }  ,  { &&srlv, NULL }  ,  { &&srav, NULL }  ,  { NULL, arrayjr }  ,  { &&jalr, NULL } 
 ,  { &&movz, NULL }  ,  { NULL, arraymovn }  ,  { NULL, arraysysc }  ,  { NULL, arrayerror }  ,  { NULL, arrayerror }  ,  { NULL, arrayerror }  ,  { NULL, arraymfhi }  ,  { &&mthi, NULL }  ,  { &&mflo, NULL }  ,  { &&mtlo, NULL } 
 ,  { NULL, arrayerror }  ,  { NULL, arrayerror }  ,  { NULL, arrayerror }  ,  { NULL, arrayerror }  ,  { NULL, arraymult }  ,  { &&multu, NULL }  ,  { &&div, NULL }  ,  { &&divu, NULL }  ,  { NULL, arrayerror }  ,  { NULL, arrayerror } 
 ,  { NULL, arrayerror }  ,  { NULL, arrayerror }  ,  { &&add, NULL }  ,  { NULL, arrayaddu }  ,  { &&sub, NULL }  ,  { NULL, arraysubu }  ,  { NULL, arrayand }  ,  { NULL, arrayor }  ,  { NULL, arrayxor }  ,  { NULL, arraynor } 
 ,  { NULL, arrayerror }  ,  { NULL, arrayerror }  ,  { NULL, arrayslt }  ,  { NULL, arraysltu }  ,  { &&branch, NULL }  ,  { NULL, arrayjump }  ,  { NULL, arrayjal }  ,  { NULL, arraybeq }  ,  { NULL, arraybne }  ,  { NULL, arrayblez } 
 ,  { NULL, arraybgtz }  ,  { &&addi, NULL }  ,  { NULL, arrayaddiu }  ,  { NULL, arrayslti }  ,  { &&sltiu, NULL }  ,  { NULL, arrayandi }  ,  { NULL, arrayori }  ,  { &&xori, NULL }  ,  { NULL, arraylui }  ,  { NULL, arrayerror } 
 ,  { NULL, arrayerror }  ,  { NULL, arrayerror }  ,  { NULL, arrayerror }  ,  { NULL, arrayerror }  ,  { NULL, arrayerror }  ,  { NULL, arrayerror }  ,  { NULL, arrayerror }  ,  { &&llo, NULL }  ,  { &&lhi, NULL }  ,  { &&trap, NULL } 
 ,  { NULL, arrayerror }  ,  { NULL, arrayerror }  ,  { NULL, arrayerror }  ,  { NULL, arrayerror }  ,  { NULL, arrayerror }  ,  { &&lb, NULL }  ,  { &&lh, NULL }  ,  { &&lwl, NULL }  ,  { NULL, arraylw }  ,  { NULL, arraylbu } 
 ,  { &&lhu, NULL }  ,  { &&lwr, NULL }  ,  { NULL, arrayerror }  ,  { NULL, arraysb }  ,  { NULL, arraysh }  ,  { &&swl, NULL }  ,  { NULL, arraysw }  ,  { NULL, arrayerror }  ,  { NULL, arrayerror }  ,  { &&swr, NULL } 
 ,  { NULL, arrayerror }  ,  { NULL, arrayerror }  ,  { NULL, arrayerror }  ,  { NULL, arrayerror }  ,  { NULL, arrayerror }  ,  { NULL, arrayerror }  ,  { NULL, arrayerror }  ,  { NULL, arrayerror }  ,  { NULL, arrayerror }  ,  { NULL, arrayerror } 
 ,  { NULL, arrayerror }  ,  { NULL, arrayerror }  ,  { NULL, arrayerror }  ,  { NULL, arrayerror }  ,  { NULL, arrayerror }  ,  { NULL, arrayerror }  ,  { NULL, arrayerror }  ,  { NULL, arrayerror }  ,  { NULL, arrayerror }  ,  { NULL, arrayerror } 
 }; 

  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;

movn:
#if INDIRECT_DEBUG
printf("%d|movn\n",counter);
counter++;
#endif

rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
if (RF[rt] != 0) RF[rd] = RF[rs];
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


movz:
#if INDIRECT_DEBUG
printf("%d|movz\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
if (RF[rt] == 0) RF[rd] = RF[rs];
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


add:
#if INDIRECT_DEBUG
printf("%d|add\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


addu:
#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


and:
#if INDIRECT_DEBUG
printf("%d|and\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rs] & RF[rt];
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


div:
#if INDIRECT_DEBUG
printf("%d|div\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
LO = RF[rs] / RF[rt];
HI = RF[rs] % RF[rt];
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


divu:
#if INDIRECT_DEBUG
printf("%d|divu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
LO = RF[rs] / RF[rt];
HI = RF[rs] % RF[rt];
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


mult:
#if INDIRECT_DEBUG
printf("%d|mult\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
mult = (uint64_t)RF[rs] * (uint64_t) RF[rt];
HI = (mult >> 32) & 0xFFFFFFFF;
LO = mult & 0xFFFFFFFF;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


multu:
#if INDIRECT_DEBUG
printf("%d|multu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
mult = (uint64_t)RF[rs] * (uint64_t) RF[rt];
HI = (mult >> 32) & 0xFFFFFFFF;
LO = mult & 0xFFFFFFFF;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


nor:
#if INDIRECT_DEBUG
printf("%d|nor\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = ~(RF[rs] | RF[rt]);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


or:
#if INDIRECT_DEBUG
printf("%d|or\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rs] | RF[rt];
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


sll:
#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr0 >> 6) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


sllv:
#if INDIRECT_DEBUG
printf("%d|sllv\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rt] << RF[rs];
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


sra:
#if INDIRECT_DEBUG
printf("%d|sra\n",counter);
counter++;
#endif
shamt = (instr0 >> 6) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
if ((int32_t)RF[rt] < 0 && shamt > 0) {
rd = (instr0 >> 11) & 0x1F;
RF[rd] = (int32_t)RF[rt] | ~(~0U >> shamt);
}
else {
rd = (instr0 >> 11) & 0x1F;
RF[rd] = (int32_t)RF[rt] >> shamt;
}
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


srav:
#if INDIRECT_DEBUG
printf("%d|srav\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rt] >> RF[rs];
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


srl:
#if INDIRECT_DEBUG
printf("%d|srl\n",counter);
counter++;
#endif
shamt = (instr0 >> 6) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rt] >> shamt;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


srlv:
#if INDIRECT_DEBUG
printf("%d|srlv\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rt] >> RF[rs];
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


sub:
#if INDIRECT_DEBUG
printf("%d|sub\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rs] - RF[rt];
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


subu:
#if INDIRECT_DEBUG
printf("%d|subu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rs] - RF[rt];
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


xor:
#if INDIRECT_DEBUG
printf("%d|xor\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rs] ^ RF[rt];
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


slt:
#if INDIRECT_DEBUG
printf("%d|slt\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = (RF[rs] < RF[rt])?1:0;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


sltu:
#if INDIRECT_DEBUG
printf("%d|sltu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = (RF[rs] < RF[rt])?1:0;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


jalr:
#if INDIRECT_DEBUG
printf("%d|jalr\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
RF[31] = PC+8;
PC = nPC;
nPC = RF[rs];
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


jr:
#if INDIRECT_DEBUG
printf("%d|jr\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
PC = nPC;
nPC = RF[rs];
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


mfhi:
#if INDIRECT_DEBUG
printf("%d|mfhi\n",counter);
counter++;
#endif
rd = (instr0 >> 11) & 0x1F;
RF[rd] = HI;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


mflo:
#if INDIRECT_DEBUG
printf("%d|mflo\n",counter);
counter++;
#endif
rd = (instr0 >> 11) & 0x1F;
RF[rd] = LO;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


mthi:
#if INDIRECT_DEBUG
printf("%d|mthi\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
HI = RF[rs];
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


mtlo:
#if INDIRECT_DEBUG
printf("%d|mtlo\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
LO = RF[rs];
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


sysc:
#if INDIRECT_DEBUG
printf("%d|sysc\n",counter);
counter++;
#endif
if (syscall((uint8_t)RF[2])) //registers $4 and $5 useb by hallcall (sensid and retval respectively)
{
halted = 1; //Syscall returned 1, exit code
goto end;
}
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


addi:
#if INDIRECT_DEBUG
printf("%d|addi\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = RF[rs] + immediate; //Implementar trap!
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


addiu:
#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


andi:
#if INDIRECT_DEBUG
printf("%d|andi\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = RF[rs] & (uint32_t)immediate;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


ori:
#if INDIRECT_DEBUG
printf("%d|ori\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = RF[rs] | (uint32_t)immediate;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


xori:
#if INDIRECT_DEBUG
printf("%d|xori\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rd] = RF[rs] ^ (uint32_t)immediate;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


lui:
#if INDIRECT_DEBUG
printf("%d|lui\n",counter);
counter++;
#endif
// NOTHING IMPLEMENTED, COPIED FROM BELOW
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)immediate) << 16;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


lhi:
#if INDIRECT_DEBUG
printf("%d|lhi\n",counter);
counter++;
#endif
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)immediate) << 16;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


llo:
#if INDIRECT_DEBUG
printf("%d|llo\n",counter);
counter++;
#endif
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = immediate;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


slti:
#if INDIRECT_DEBUG
printf("%d|slti\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] < immediate)?1:0;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


sltiu:
#if INDIRECT_DEBUG
printf("%d|sltiu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] < immediate)?1:0;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


branch:
rt = (instr0 >> 16) & 0x1F;
if (RF[rt] == 0b00001) //bgez Rsrc, offset: Branch on Greater Than Equal Zero
{
  #if INDIRECT_DEBUG
  printf("%d|bgez\n",counter);
  counter++;
  #endif
  rs = (instr0 >> 21) & 0x1F;
  if ((int32_t)RF[rs] >= 0)
  {
    immediate = (instr0 >> 0) & 0xFFFF;
    PC  =  nPC;
    nPC  += (immediate << 2);
      if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


  }
  else
  {
    PC  =  nPC;
    nPC  += 4;
  }
}
else if (RF[rt] == 0b10001) //bgezal Rsrc, offset: Branch on Greater Than Equal Zero And Link
{
  #if INDIRECT_DEBUG
  printf("%d|bgezal\n",counter);
  counter++;
  #endif
  rs = (instr0 >> 21) & 0x1F;
  if ((int32_t)RF[rs] >= 0)
  {
    RF[31] = PC + 8;
    immediate = (instr0 >> 0) & 0xFFFF;
    PC  =  nPC;
    nPC  += (immediate << 2);
      if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


  }
  else
  {
    PC  =  nPC;
    nPC  += 4;
  }
}
else if (RF[rt] == 0b00000) //bltz Rsrc, offset: Branch on Less Than Zero
{
  #if INDIRECT_DEBUG
  printf("%d|bltz\n",counter);
  counter++;
  #endif
  rs = (instr0 >> 21) & 0x1F;
  if ((int32_t)RF[rs] < 0)
  {
    immediate = (instr0 >> 0) & 0xFFFF;
    PC  =  nPC;
    nPC  += (immediate << 2);
      if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


  }
  else
  {
    PC  =  nPC;
    nPC  += 4;
  }
}
else if (RF[rt] == 0b10000) //bltzal Rsrc, offset: Branch on Less Than And Link
{
  #if INDIRECT_DEBUG
  printf("%d|bltzal\n",counter);
  counter++;
  #endif
  rs = (instr0 >> 21) & 0x1F;
  if ((int32_t)RF[rs] < 0)
  {
    RF[31] = PC + 8;
    immediate = (instr0 >> 0) & 0xFFFF;
    PC  =  nPC;
    nPC  += (immediate << 2);
      if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


  }
  else
  {
    PC  =  nPC;
    nPC  += 4;
  }
}
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


beq:
#if INDIRECT_DEBUG
printf("%d|beq\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
if (RF[rs] == RF[rt])
{
  immediate = (instr0 >> 0) & 0xFFFF;
  PC  =  nPC;
  nPC  += (immediate << 2);
    if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


}
else
{
  PC  =  nPC;
  nPC  += 4;
}
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


bgtz:
#if INDIRECT_DEBUG
printf("%d|bgtz\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
if ((int32_t)RF[rs] > 0)
{
  immediate = (instr0 >> 0) & 0xFFFF;
  PC  =  nPC;
  nPC  += (immediate << 2);
    if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


}
else
{
  PC  =  nPC;
  nPC  += 4;
}
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


blez:
#if INDIRECT_DEBUG
printf("%d|blez\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
if ((int32_t)RF[rs] <= 0)
{
  immediate = (instr0 >> 0) & 0xFFFF;
  PC  =  nPC;
  nPC  += (immediate << 2);
    if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


}
else
{
  PC  =  nPC;
  nPC  += 4;
}
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


bne:
#if INDIRECT_DEBUG
printf("%d|bne\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
if (RF[rs] != RF[rt])
{
  immediate = (instr0 >> 0) & 0xFFFF;
  PC  =  nPC;
  nPC  += (immediate << 2);
    if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


}
else
{
  PC  =  nPC;
  nPC  += 4;
}
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


lb:
#if INDIRECT_DEBUG
printf("%d|lb\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)VM_memory[RF[rs] + immediate]& 0x7F)  | (uint32_t)(VM_memory[RF[rs] + immediate] & 0x80)<<24; //Load byte carrying signal to the register
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


lbu:
#if INDIRECT_DEBUG
printf("%d|lbu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)VM_memory[RF[rs] + immediate]) & 0xFF;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


lh:
#if INDIRECT_DEBUG
printf("%d|lh\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = ((((uint32_t)(VM_memory[RF[rs] + immediate])<< 16) | ((uint32_t)VM_memory[RF[rs] + immediate + 1])) & 0x7FFF) | (uint32_t)((VM_memory[RF[rs] + immediate + 1]) & 0x8000) << 16;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


lhu:
#if INDIRECT_DEBUG
printf("%d|lhu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = ((((uint32_t)(VM_memory[RF[rs] + immediate])<<16) | ((uint32_t)VM_memory[RF[rs] + immediate + 1])) & 0xFFFF);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


lw:
#if INDIRECT_DEBUG
printf("%d|lw\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)(VM_memory[RF[rs] + immediate]) << 24) | ((uint32_t)(VM_memory[RF[rs] + immediate + 1]) << 16) | ((uint32_t)(VM_memory[RF[rs] + immediate + 2]) << 8) | ((uint32_t)VM_memory[RF[rs] + immediate + 3]);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


sb:
#if INDIRECT_DEBUG
printf("%d|sb\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
VM_memory[RF[rs] + immediate] = (uint8_t)(RF[rt] & 0xFF);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


sh:
#if INDIRECT_DEBUG
printf("%d|sh\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
VM_memory[RF[rs] + immediate] = (uint8_t)((RF[rt] & 0xFF00) >> 8);
VM_memory[RF[rs] + immediate + 1] = (uint8_t)(RF[rt] & 0xFF);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


sw:
#if INDIRECT_DEBUG
printf("%d|sw\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
VM_memory[RF[rs] + immediate] = (uint8_t)((RF[rt] & 0xFF000000) >> 24);
VM_memory[RF[rs] + immediate + 1] = (uint8_t)((RF[rt] & 0xFF0000) >> 16);
VM_memory[RF[rs] + immediate + 2] = (uint8_t)((RF[rt] & 0xFF00) >> 8);
VM_memory[RF[rs] + immediate + 3] = (uint8_t)(RF[rt] & 0xFF);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


jump:
#if INDIRECT_DEBUG
printf("%d|jump\n",counter);
counter++;
#endif
PC = nPC;
address = (instr0 >> 0) & 0x3FFFFFF;
nPC = address << 2;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


jal:
#if INDIRECT_DEBUG
printf("%d|jal\n",counter);
counter++;
#endif
RF[31] = PC + 8;
PC = nPC;
address = (instr0 >> 0) & 0x3FFFFFF;
nPC = address << 2;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


trap:
#if INDIRECT_DEBUG
printf("%d|trap\n",counter);
counter++;
#endif
address = (instr0 >> 0) & 0x3FFFFFF;
syscall((uint8_t)(address&0xFF));
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


swl:
#if INDIRECT_DEBUG
printf("%d|swl\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
VM_memory[RF[rs] + immediate] = (uint8_t)((RF[rt] & 0xFF000000) >> 24);
VM_memory[RF[rs] + immediate + 1] = (uint8_t)((RF[rt] & 0xFF0000) >> 16);
PC  =  nPC;
nPC  += 4;  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


swr:
#if INDIRECT_DEBUG
printf("%d|swr\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
VM_memory[RF[rs] + immediate] = (uint8_t)(RF[rt] & 0xFF);
VM_memory[RF[rs] + immediate - 1] = (uint8_t)(RF[rt] & 0xFF00) >> 8;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


lwl:
#if INDIRECT_DEBUG
printf("%d|lwl\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)(VM_memory[RF[rs] + immediate]) << 24) | ((uint32_t)(VM_memory[RF[rs] + immediate + 1]) << 16);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


lwr:
#if INDIRECT_DEBUG
printf("%d|lwr\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)(VM_memory[RF[rs] + immediate -1]) << 8) | ((uint32_t)VM_memory[RF[rs] + immediate]);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


error:
#if INDIRECT_DEBUG
printf("Error, unknown instr0uction %d.\n", instr0);
#endif
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


sltuPLUSbeq:
#if INDIRECT_DEBUG
printf("%d|sltu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = (RF[rs] < RF[rt])?1:0;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|beq\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
if (RF[rs] == RF[rt])
{
  immediate = (instr1 >> 0) & 0xFFFF;
  PC  =  nPC;
  nPC  += (immediate << 2);
    if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


}
else
{
  PC  =  nPC;
  nPC  += 4;
}
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


addiuPLUSslt:
#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|slt\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = (RF[rs] < RF[rt])?1:0;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


addiuPLUSsll:
#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr1 >> 6) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


sllPLUSbne:
#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr0 >> 6) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|bne\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
if (RF[rs] != RF[rt])
{
  immediate = (instr1 >> 0) & 0xFFFF;
  PC  =  nPC;
  nPC  += (immediate << 2);
    if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


}
else
{
  PC  =  nPC;
  nPC  += 4;
}
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


syscPLUSjr:
#if INDIRECT_DEBUG
printf("%d|sysc\n",counter);
counter++;
#endif
if (syscall((uint8_t)RF[2])) //registers $4 and $5 useb by hallcall (sensid and retval respectively)
{
halted = 1; //Syscall returned 1, exit code
goto end;
}
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|jr\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
PC = nPC;
nPC = RF[rs];
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


sltiPLUSmovn:
#if INDIRECT_DEBUG
printf("%d|slti\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] < immediate)?1:0;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|movn\n",counter);
counter++;
#endif

rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
if (RF[rt] != 0) RF[rd] = RF[rs];
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


sllPLUSlui:
#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr0 >> 6) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|lui\n",counter);
counter++;
#endif
// NOTHING IMPLEMENTED, COPIED FROM BELOW
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)immediate) << 16;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


bnePLUSsll:
#if INDIRECT_DEBUG
printf("%d|bne\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
if (RF[rs] != RF[rt])
{
  immediate = (instr0 >> 0) & 0xFFFF;
  PC  =  nPC;
  nPC  += (immediate << 2);
    if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


}
else
{
  PC  =  nPC;
  nPC  += 4;
}

#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr1 >> 6) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


addiuPLUSbne:
#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|bne\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
if (RF[rs] != RF[rt])
{
  immediate = (instr1 >> 0) & 0xFFFF;
  PC  =  nPC;
  nPC  += (immediate << 2);
    if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


}
else
{
  PC  =  nPC;
  nPC  += 4;
}
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


swPLUSjump:
#if INDIRECT_DEBUG
printf("%d|sw\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
VM_memory[RF[rs] + immediate] = (uint8_t)((RF[rt] & 0xFF000000) >> 24);
VM_memory[RF[rs] + immediate + 1] = (uint8_t)((RF[rt] & 0xFF0000) >> 16);
VM_memory[RF[rs] + immediate + 2] = (uint8_t)((RF[rt] & 0xFF00) >> 8);
VM_memory[RF[rs] + immediate + 3] = (uint8_t)(RF[rt] & 0xFF);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|jump\n",counter);
counter++;
#endif
PC = nPC;
address = (instr1 >> 0) & 0x3FFFFFF;
nPC = address << 2;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


sltiPLUSsw:
#if INDIRECT_DEBUG
printf("%d|slti\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] < immediate)?1:0;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sw\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
VM_memory[RF[rs] + immediate] = (uint8_t)((RF[rt] & 0xFF000000) >> 24);
VM_memory[RF[rs] + immediate + 1] = (uint8_t)((RF[rt] & 0xFF0000) >> 16);
VM_memory[RF[rs] + immediate + 2] = (uint8_t)((RF[rt] & 0xFF00) >> 8);
VM_memory[RF[rs] + immediate + 3] = (uint8_t)(RF[rt] & 0xFF);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


orPLUSaddu:
#if INDIRECT_DEBUG
printf("%d|or\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rs] | RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


addiuPLUSjal:
#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|jal\n",counter);
counter++;
#endif
RF[31] = PC + 8;
PC = nPC;
address = (instr1 >> 0) & 0x3FFFFFF;
nPC = address << 2;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


addiuPLUSmult:
#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|mult\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
mult = (uint64_t)RF[rs] * (uint64_t) RF[rt];
HI = (mult >> 32) & 0xFFFFFFFF;
LO = mult & 0xFFFFFFFF;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


blezPLUSaddiu:
#if INDIRECT_DEBUG
printf("%d|blez\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
if ((int32_t)RF[rs] <= 0)
{
  immediate = (instr0 >> 0) & 0xFFFF;
  PC  =  nPC;
  nPC  += (immediate << 2);
    if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


}
else
{
  PC  =  nPC;
  nPC  += 4;
}

#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


subuPLUSsw:
#if INDIRECT_DEBUG
printf("%d|subu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rs] - RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sw\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
VM_memory[RF[rs] + immediate] = (uint8_t)((RF[rt] & 0xFF000000) >> 24);
VM_memory[RF[rs] + immediate + 1] = (uint8_t)((RF[rt] & 0xFF0000) >> 16);
VM_memory[RF[rs] + immediate + 2] = (uint8_t)((RF[rt] & 0xFF00) >> 8);
VM_memory[RF[rs] + immediate + 3] = (uint8_t)(RF[rt] & 0xFF);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


sllPLUSsrl:
#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr0 >> 6) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|srl\n",counter);
counter++;
#endif
shamt = (instr1 >> 6) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rt] >> shamt;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


lwPLUSaddiu:
#if INDIRECT_DEBUG
printf("%d|lw\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)(VM_memory[RF[rs] + immediate]) << 24) | ((uint32_t)(VM_memory[RF[rs] + immediate + 1]) << 16) | ((uint32_t)(VM_memory[RF[rs] + immediate + 2]) << 8) | ((uint32_t)VM_memory[RF[rs] + immediate + 3]);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


sllPLUSsll:
#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr0 >> 6) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr1 >> 6) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


sllPLUSxor:
#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr0 >> 6) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|xor\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rs] ^ RF[rt];
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


sltPLUSbne:
#if INDIRECT_DEBUG
printf("%d|slt\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = (RF[rs] < RF[rt])?1:0;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|bne\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
if (RF[rs] != RF[rt])
{
  immediate = (instr1 >> 0) & 0xFFFF;
  PC  =  nPC;
  nPC  += (immediate << 2);
    if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


}
else
{
  PC  =  nPC;
  nPC  += 4;
}
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


sllPLUSslt:
#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr0 >> 6) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|slt\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = (RF[rs] < RF[rt])?1:0;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


srlPLUSor:
#if INDIRECT_DEBUG
printf("%d|srl\n",counter);
counter++;
#endif
shamt = (instr0 >> 6) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rt] >> shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|or\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rs] | RF[rt];
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


addiuPLUSsubu:
#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|subu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rs] - RF[rt];
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


swPLUSjal:
#if INDIRECT_DEBUG
printf("%d|sw\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
VM_memory[RF[rs] + immediate] = (uint8_t)((RF[rt] & 0xFF000000) >> 24);
VM_memory[RF[rs] + immediate + 1] = (uint8_t)((RF[rt] & 0xFF0000) >> 16);
VM_memory[RF[rs] + immediate + 2] = (uint8_t)((RF[rt] & 0xFF00) >> 8);
VM_memory[RF[rs] + immediate + 3] = (uint8_t)(RF[rt] & 0xFF);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|jal\n",counter);
counter++;
#endif
RF[31] = PC + 8;
PC = nPC;
address = (instr1 >> 0) & 0x3FFFFFF;
nPC = address << 2;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


addiuPLUSslti:
#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|slti\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] < immediate)?1:0;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


addiuPLUSsltu:
#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sltu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = (RF[rs] < RF[rt])?1:0;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


sllPLUSandi:
#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr0 >> 6) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|andi\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = RF[rs] & (uint32_t)immediate;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


luiPLUSsrl:
#if INDIRECT_DEBUG
printf("%d|lui\n",counter);
counter++;
#endif
// NOTHING IMPLEMENTED, COPIED FROM BELOW
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)immediate) << 16;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|srl\n",counter);
counter++;
#endif
shamt = (instr1 >> 6) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rt] >> shamt;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


srlPLUSxor:
#if INDIRECT_DEBUG
printf("%d|srl\n",counter);
counter++;
#endif
shamt = (instr0 >> 6) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rt] >> shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|xor\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rs] ^ RF[rt];
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


andiPLUSsll:
#if INDIRECT_DEBUG
printf("%d|andi\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = RF[rs] & (uint32_t)immediate;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr1 >> 6) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


movnPLUSjump:
#if INDIRECT_DEBUG
printf("%d|movn\n",counter);
counter++;
#endif

rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
if (RF[rt] != 0) RF[rd] = RF[rs];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|jump\n",counter);
counter++;
#endif
PC = nPC;
address = (instr1 >> 0) & 0x3FFFFFF;
nPC = address << 2;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


jalPLUSaddiu:
#if INDIRECT_DEBUG
printf("%d|jal\n",counter);
counter++;
#endif
RF[31] = PC + 8;
PC = nPC;
address = (instr0 >> 0) & 0x3FFFFFF;
nPC = address << 2;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;



#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


addiuPLUSsw:
#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sw\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
VM_memory[RF[rs] + immediate] = (uint8_t)((RF[rt] & 0xFF000000) >> 24);
VM_memory[RF[rs] + immediate + 1] = (uint8_t)((RF[rt] & 0xFF0000) >> 16);
VM_memory[RF[rs] + immediate + 2] = (uint8_t)((RF[rt] & 0xFF00) >> 8);
VM_memory[RF[rs] + immediate + 3] = (uint8_t)(RF[rt] & 0xFF);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


sltPLUSaddu:
#if INDIRECT_DEBUG
printf("%d|slt\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = (RF[rs] < RF[rt])?1:0;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


lwPLUSsll:
#if INDIRECT_DEBUG
printf("%d|lw\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)(VM_memory[RF[rs] + immediate]) << 24) | ((uint32_t)(VM_memory[RF[rs] + immediate + 1]) << 16) | ((uint32_t)(VM_memory[RF[rs] + immediate + 2]) << 8) | ((uint32_t)VM_memory[RF[rs] + immediate + 3]);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr1 >> 6) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


srlPLUSsll:
#if INDIRECT_DEBUG
printf("%d|srl\n",counter);
counter++;
#endif
shamt = (instr0 >> 6) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rt] >> shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr1 >> 6) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


lwPLUSslt:
#if INDIRECT_DEBUG
printf("%d|lw\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)(VM_memory[RF[rs] + immediate]) << 24) | ((uint32_t)(VM_memory[RF[rs] + immediate + 1]) << 16) | ((uint32_t)(VM_memory[RF[rs] + immediate + 2]) << 8) | ((uint32_t)VM_memory[RF[rs] + immediate + 3]);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|slt\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = (RF[rs] < RF[rt])?1:0;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


swPLUSaddu:
#if INDIRECT_DEBUG
printf("%d|sw\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
VM_memory[RF[rs] + immediate] = (uint8_t)((RF[rt] & 0xFF000000) >> 24);
VM_memory[RF[rs] + immediate + 1] = (uint8_t)((RF[rt] & 0xFF0000) >> 16);
VM_memory[RF[rs] + immediate + 2] = (uint8_t)((RF[rt] & 0xFF00) >> 8);
VM_memory[RF[rs] + immediate + 3] = (uint8_t)(RF[rt] & 0xFF);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


bnePLUSaddu:
#if INDIRECT_DEBUG
printf("%d|bne\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
if (RF[rs] != RF[rt])
{
  immediate = (instr0 >> 0) & 0xFFFF;
  PC  =  nPC;
  nPC  += (immediate << 2);
    if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


}
else
{
  PC  =  nPC;
  nPC  += 4;
}

#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


lwPLUSbeq:
#if INDIRECT_DEBUG
printf("%d|lw\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)(VM_memory[RF[rs] + immediate]) << 24) | ((uint32_t)(VM_memory[RF[rs] + immediate + 1]) << 16) | ((uint32_t)(VM_memory[RF[rs] + immediate + 2]) << 8) | ((uint32_t)VM_memory[RF[rs] + immediate + 3]);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|beq\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
if (RF[rs] == RF[rt])
{
  immediate = (instr1 >> 0) & 0xFFFF;
  PC  =  nPC;
  nPC  += (immediate << 2);
    if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


}
else
{
  PC  =  nPC;
  nPC  += 4;
}
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


sllPLUSlbu:
#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr0 >> 6) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|lbu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)VM_memory[RF[rs] + immediate]) & 0xFF;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


addiuPLUSblez:
#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|blez\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
if ((int32_t)RF[rs] <= 0)
{
  immediate = (instr1 >> 0) & 0xFFFF;
  PC  =  nPC;
  nPC  += (immediate << 2);
    if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


}
else
{
  PC  =  nPC;
  nPC  += 4;
}
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


sbPLUSjal:
#if INDIRECT_DEBUG
printf("%d|sb\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
VM_memory[RF[rs] + immediate] = (uint8_t)(RF[rt] & 0xFF);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|jal\n",counter);
counter++;
#endif
RF[31] = PC + 8;
PC = nPC;
address = (instr1 >> 0) & 0x3FFFFFF;
nPC = address << 2;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


sltiPLUSbne:
#if INDIRECT_DEBUG
printf("%d|slti\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] < immediate)?1:0;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|bne\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
if (RF[rs] != RF[rt])
{
  immediate = (instr1 >> 0) & 0xFFFF;
  PC  =  nPC;
  nPC  += (immediate << 2);
    if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


}
else
{
  PC  =  nPC;
  nPC  += 4;
}
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


luiPLUSori:
#if INDIRECT_DEBUG
printf("%d|lui\n",counter);
counter++;
#endif
// NOTHING IMPLEMENTED, COPIED FROM BELOW
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)immediate) << 16;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|ori\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = RF[rs] | (uint32_t)immediate;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


bnePLUSsw:
#if INDIRECT_DEBUG
printf("%d|bne\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
if (RF[rs] != RF[rt])
{
  immediate = (instr0 >> 0) & 0xFFFF;
  PC  =  nPC;
  nPC  += (immediate << 2);
    if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


}
else
{
  PC  =  nPC;
  nPC  += 4;
}

#if INDIRECT_DEBUG
printf("%d|sw\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
VM_memory[RF[rs] + immediate] = (uint8_t)((RF[rt] & 0xFF000000) >> 24);
VM_memory[RF[rs] + immediate + 1] = (uint8_t)((RF[rt] & 0xFF0000) >> 16);
VM_memory[RF[rs] + immediate + 2] = (uint8_t)((RF[rt] & 0xFF00) >> 8);
VM_memory[RF[rs] + immediate + 3] = (uint8_t)(RF[rt] & 0xFF);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


beqPLUSsw:
#if INDIRECT_DEBUG
printf("%d|beq\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
if (RF[rs] == RF[rt])
{
  immediate = (instr0 >> 0) & 0xFFFF;
  PC  =  nPC;
  nPC  += (immediate << 2);
    if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


}
else
{
  PC  =  nPC;
  nPC  += 4;
}

#if INDIRECT_DEBUG
printf("%d|sw\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
VM_memory[RF[rs] + immediate] = (uint8_t)((RF[rt] & 0xFF000000) >> 24);
VM_memory[RF[rs] + immediate + 1] = (uint8_t)((RF[rt] & 0xFF0000) >> 16);
VM_memory[RF[rs] + immediate + 2] = (uint8_t)((RF[rt] & 0xFF00) >> 8);
VM_memory[RF[rs] + immediate + 3] = (uint8_t)(RF[rt] & 0xFF);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


xorPLUSxor:
#if INDIRECT_DEBUG
printf("%d|xor\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rs] ^ RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|xor\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rs] ^ RF[rt];
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


oriPLUSandi:
#if INDIRECT_DEBUG
printf("%d|ori\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = RF[rs] | (uint32_t)immediate;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|andi\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = RF[rs] & (uint32_t)immediate;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


adduPLUSnor:
#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|nor\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = ~(RF[rs] | RF[rt]);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


sllPLUSslti:
#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr0 >> 6) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|slti\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] < immediate)?1:0;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


lwPLUSbne:
#if INDIRECT_DEBUG
printf("%d|lw\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)(VM_memory[RF[rs] + immediate]) << 24) | ((uint32_t)(VM_memory[RF[rs] + immediate + 1]) << 16) | ((uint32_t)(VM_memory[RF[rs] + immediate + 2]) << 8) | ((uint32_t)VM_memory[RF[rs] + immediate + 3]);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|bne\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
if (RF[rs] != RF[rt])
{
  immediate = (instr1 >> 0) & 0xFFFF;
  PC  =  nPC;
  nPC  += (immediate << 2);
    if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


}
else
{
  PC  =  nPC;
  nPC  += 4;
}
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


lwPLUSerror:
#if INDIRECT_DEBUG
printf("%d|lw\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)(VM_memory[RF[rs] + immediate]) << 24) | ((uint32_t)(VM_memory[RF[rs] + immediate + 1]) << 16) | ((uint32_t)(VM_memory[RF[rs] + immediate + 2]) << 8) | ((uint32_t)VM_memory[RF[rs] + immediate + 3]);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("Error, unknown instr1uction %d.\n", instr1);
#endif
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


lbuPLUSbeq:
#if INDIRECT_DEBUG
printf("%d|lbu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)VM_memory[RF[rs] + immediate]) & 0xFF;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|beq\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
if (RF[rs] == RF[rt])
{
  immediate = (instr1 >> 0) & 0xFFFF;
  PC  =  nPC;
  nPC  += (immediate << 2);
    if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


}
else
{
  PC  =  nPC;
  nPC  += 4;
}
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


movnPLUSaddiu:
#if INDIRECT_DEBUG
printf("%d|movn\n",counter);
counter++;
#endif

rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
if (RF[rt] != 0) RF[rd] = RF[rs];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


orPLUSsrl:
#if INDIRECT_DEBUG
printf("%d|or\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rs] | RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|srl\n",counter);
counter++;
#endif
shamt = (instr1 >> 6) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rt] >> shamt;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


errorPLUSaddiu:
#if INDIRECT_DEBUG
printf("Error, unknown instr0uction %d.\n", instr0);
#endif
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


luiPLUSlw:
#if INDIRECT_DEBUG
printf("%d|lui\n",counter);
counter++;
#endif
// NOTHING IMPLEMENTED, COPIED FROM BELOW
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)immediate) << 16;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|lw\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)(VM_memory[RF[rs] + immediate]) << 24) | ((uint32_t)(VM_memory[RF[rs] + immediate + 1]) << 16) | ((uint32_t)(VM_memory[RF[rs] + immediate + 2]) << 8) | ((uint32_t)VM_memory[RF[rs] + immediate + 3]);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


swPLUSsw:
#if INDIRECT_DEBUG
printf("%d|sw\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
VM_memory[RF[rs] + immediate] = (uint8_t)((RF[rt] & 0xFF000000) >> 24);
VM_memory[RF[rs] + immediate + 1] = (uint8_t)((RF[rt] & 0xFF0000) >> 16);
VM_memory[RF[rs] + immediate + 2] = (uint8_t)((RF[rt] & 0xFF00) >> 8);
VM_memory[RF[rs] + immediate + 3] = (uint8_t)(RF[rt] & 0xFF);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sw\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
VM_memory[RF[rs] + immediate] = (uint8_t)((RF[rt] & 0xFF000000) >> 24);
VM_memory[RF[rs] + immediate + 1] = (uint8_t)((RF[rt] & 0xFF0000) >> 16);
VM_memory[RF[rs] + immediate + 2] = (uint8_t)((RF[rt] & 0xFF00) >> 8);
VM_memory[RF[rs] + immediate + 3] = (uint8_t)(RF[rt] & 0xFF);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


adduPLUSaddiu:
#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


addiuPLUSjump:
#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|jump\n",counter);
counter++;
#endif
PC = nPC;
address = (instr1 >> 0) & 0x3FFFFFF;
nPC = address << 2;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


xorPLUSandi:
#if INDIRECT_DEBUG
printf("%d|xor\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rs] ^ RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|andi\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = RF[rs] & (uint32_t)immediate;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


adduPLUSbne:
#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|bne\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
if (RF[rs] != RF[rt])
{
  immediate = (instr1 >> 0) & 0xFFFF;
  PC  =  nPC;
  nPC  += (immediate << 2);
    if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


}
else
{
  PC  =  nPC;
  nPC  += 4;
}
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


oriPLUSaddiu:
#if INDIRECT_DEBUG
printf("%d|ori\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = RF[rs] | (uint32_t)immediate;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


swPLUSsb:
#if INDIRECT_DEBUG
printf("%d|sw\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
VM_memory[RF[rs] + immediate] = (uint8_t)((RF[rt] & 0xFF000000) >> 24);
VM_memory[RF[rs] + immediate + 1] = (uint8_t)((RF[rt] & 0xFF0000) >> 16);
VM_memory[RF[rs] + immediate + 2] = (uint8_t)((RF[rt] & 0xFF00) >> 8);
VM_memory[RF[rs] + immediate + 3] = (uint8_t)(RF[rt] & 0xFF);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sb\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
VM_memory[RF[rs] + immediate] = (uint8_t)(RF[rt] & 0xFF);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


swPLUSslti:
#if INDIRECT_DEBUG
printf("%d|sw\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
VM_memory[RF[rs] + immediate] = (uint8_t)((RF[rt] & 0xFF000000) >> 24);
VM_memory[RF[rs] + immediate + 1] = (uint8_t)((RF[rt] & 0xFF0000) >> 16);
VM_memory[RF[rs] + immediate + 2] = (uint8_t)((RF[rt] & 0xFF00) >> 8);
VM_memory[RF[rs] + immediate + 3] = (uint8_t)(RF[rt] & 0xFF);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|slti\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] < immediate)?1:0;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


sllPLUSaddu:
#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr0 >> 6) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


andPLUSxor:
#if INDIRECT_DEBUG
printf("%d|and\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rs] & RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|xor\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rs] ^ RF[rt];
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


jrPLUSaddiu:
#if INDIRECT_DEBUG
printf("%d|jr\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
PC = nPC;
nPC = RF[rs];
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;



#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


xorPLUSerror:
#if INDIRECT_DEBUG
printf("%d|xor\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rs] ^ RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("Error, unknown instr1uction %d.\n", instr1);
#endif
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


mfhiPLUSsll:
#if INDIRECT_DEBUG
printf("%d|mfhi\n",counter);
counter++;
#endif
rd = (instr0 >> 11) & 0x1F;
RF[rd] = HI;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr1 >> 6) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


jrPLUSor:
#if INDIRECT_DEBUG
printf("%d|jr\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
PC = nPC;
nPC = RF[rs];
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;



#if INDIRECT_DEBUG
printf("%d|or\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rs] | RF[rt];
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


addiuPLUSjr:
#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|jr\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
PC = nPC;
nPC = RF[rs];
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


lwPLUSjr:
#if INDIRECT_DEBUG
printf("%d|lw\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)(VM_memory[RF[rs] + immediate]) << 24) | ((uint32_t)(VM_memory[RF[rs] + immediate + 1]) << 16) | ((uint32_t)(VM_memory[RF[rs] + immediate + 2]) << 8) | ((uint32_t)VM_memory[RF[rs] + immediate + 3]);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|jr\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
PC = nPC;
nPC = RF[rs];
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


luiPLUSsw:
#if INDIRECT_DEBUG
printf("%d|lui\n",counter);
counter++;
#endif
// NOTHING IMPLEMENTED, COPIED FROM BELOW
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)immediate) << 16;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sw\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
VM_memory[RF[rs] + immediate] = (uint8_t)((RF[rt] & 0xFF000000) >> 24);
VM_memory[RF[rs] + immediate + 1] = (uint8_t)((RF[rt] & 0xFF0000) >> 16);
VM_memory[RF[rs] + immediate + 2] = (uint8_t)((RF[rt] & 0xFF00) >> 8);
VM_memory[RF[rs] + immediate + 3] = (uint8_t)(RF[rt] & 0xFF);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


errorPLUSerror:
#if INDIRECT_DEBUG
printf("Error, unknown instr0uction %d.\n", instr0);
#endif
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("Error, unknown instr1uction %d.\n", instr1);
#endif
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


subuPLUSand:
#if INDIRECT_DEBUG
printf("%d|subu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rs] - RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|and\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rs] & RF[rt];
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


shPLUSor:
#if INDIRECT_DEBUG
printf("%d|sh\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
VM_memory[RF[rs] + immediate] = (uint8_t)((RF[rt] & 0xFF00) >> 8);
VM_memory[RF[rs] + immediate + 1] = (uint8_t)(RF[rt] & 0xFF);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|or\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rs] | RF[rt];
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


adduPLUSlui:
#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|lui\n",counter);
counter++;
#endif
// NOTHING IMPLEMENTED, COPIED FROM BELOW
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)immediate) << 16;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


multPLUSmfhi:
#if INDIRECT_DEBUG
printf("%d|mult\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
mult = (uint64_t)RF[rs] * (uint64_t) RF[rt];
HI = (mult >> 32) & 0xFFFFFFFF;
LO = mult & 0xFFFFFFFF;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|mfhi\n",counter);
counter++;
#endif
rd = (instr1 >> 11) & 0x1F;
RF[rd] = HI;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


swPLUSbne:
#if INDIRECT_DEBUG
printf("%d|sw\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
VM_memory[RF[rs] + immediate] = (uint8_t)((RF[rt] & 0xFF000000) >> 24);
VM_memory[RF[rs] + immediate + 1] = (uint8_t)((RF[rt] & 0xFF0000) >> 16);
VM_memory[RF[rs] + immediate + 2] = (uint8_t)((RF[rt] & 0xFF00) >> 8);
VM_memory[RF[rs] + immediate + 3] = (uint8_t)(RF[rt] & 0xFF);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|bne\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
if (RF[rs] != RF[rt])
{
  immediate = (instr1 >> 0) & 0xFFFF;
  PC  =  nPC;
  nPC  += (immediate << 2);
    if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


}
else
{
  PC  =  nPC;
  nPC  += 4;
}
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


sllPLUSjump:
#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr0 >> 6) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|jump\n",counter);
counter++;
#endif
PC = nPC;
address = (instr1 >> 0) & 0x3FFFFFF;
nPC = address << 2;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


addiuPLUSandi:
#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|andi\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = RF[rs] & (uint32_t)immediate;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


sltiPLUSbeq:
#if INDIRECT_DEBUG
printf("%d|slti\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] < immediate)?1:0;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|beq\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
if (RF[rs] == RF[rt])
{
  immediate = (instr1 >> 0) & 0xFFFF;
  PC  =  nPC;
  nPC  += (immediate << 2);
    if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


}
else
{
  PC  =  nPC;
  nPC  += 4;
}
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


srlPLUSaddu:
#if INDIRECT_DEBUG
printf("%d|srl\n",counter);
counter++;
#endif
shamt = (instr0 >> 6) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rt] >> shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


addiuPLUSaddu:
#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


swPLUSlw:
#if INDIRECT_DEBUG
printf("%d|sw\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
VM_memory[RF[rs] + immediate] = (uint8_t)((RF[rt] & 0xFF000000) >> 24);
VM_memory[RF[rs] + immediate + 1] = (uint8_t)((RF[rt] & 0xFF0000) >> 16);
VM_memory[RF[rs] + immediate + 2] = (uint8_t)((RF[rt] & 0xFF00) >> 8);
VM_memory[RF[rs] + immediate + 3] = (uint8_t)(RF[rt] & 0xFF);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|lw\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)(VM_memory[RF[rs] + immediate]) << 24) | ((uint32_t)(VM_memory[RF[rs] + immediate + 1]) << 16) | ((uint32_t)(VM_memory[RF[rs] + immediate + 2]) << 8) | ((uint32_t)VM_memory[RF[rs] + immediate + 3]);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


luiPLUSlui:
#if INDIRECT_DEBUG
printf("%d|lui\n",counter);
counter++;
#endif
// NOTHING IMPLEMENTED, COPIED FROM BELOW
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)immediate) << 16;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|lui\n",counter);
counter++;
#endif
// NOTHING IMPLEMENTED, COPIED FROM BELOW
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)immediate) << 16;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


srlPLUSbne:
#if INDIRECT_DEBUG
printf("%d|srl\n",counter);
counter++;
#endif
shamt = (instr0 >> 6) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rt] >> shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|bne\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
if (RF[rs] != RF[rt])
{
  immediate = (instr1 >> 0) & 0xFFFF;
  PC  =  nPC;
  nPC  += (immediate << 2);
    if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


}
else
{
  PC  =  nPC;
  nPC  += 4;
}
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


bnePLUSaddiu:
#if INDIRECT_DEBUG
printf("%d|bne\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
if (RF[rs] != RF[rt])
{
  immediate = (instr0 >> 0) & 0xFFFF;
  PC  =  nPC;
  nPC  += (immediate << 2);
    if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


}
else
{
  PC  =  nPC;
  nPC  += 4;
}

#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


bgtzPLUSsll:
#if INDIRECT_DEBUG
printf("%d|bgtz\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
if ((int32_t)RF[rs] > 0)
{
  immediate = (instr0 >> 0) & 0xFFFF;
  PC  =  nPC;
  nPC  += (immediate << 2);
    if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


}
else
{
  PC  =  nPC;
  nPC  += 4;
}

#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr1 >> 6) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


luiPLUSjal:
#if INDIRECT_DEBUG
printf("%d|lui\n",counter);
counter++;
#endif
// NOTHING IMPLEMENTED, COPIED FROM BELOW
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)immediate) << 16;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|jal\n",counter);
counter++;
#endif
RF[31] = PC + 8;
PC = nPC;
address = (instr1 >> 0) & 0x3FFFFFF;
nPC = address << 2;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


sraPLUSaddu:
#if INDIRECT_DEBUG
printf("%d|sra\n",counter);
counter++;
#endif
shamt = (instr0 >> 6) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
if ((int32_t)RF[rt] < 0 && shamt > 0) {
rd = (instr0 >> 11) & 0x1F;
RF[rd] = (int32_t)RF[rt] | ~(~0U >> shamt);
}
else {
rd = (instr0 >> 11) & 0x1F;
RF[rd] = (int32_t)RF[rt] >> shamt;
}
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


adduPLUSerror:
#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("Error, unknown instr1uction %d.\n", instr1);
#endif
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


srlPLUSandi:
#if INDIRECT_DEBUG
printf("%d|srl\n",counter);
counter++;
#endif
shamt = (instr0 >> 6) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rt] >> shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|andi\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = RF[rs] & (uint32_t)immediate;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


errorPLUSsubu:
#if INDIRECT_DEBUG
printf("Error, unknown instr0uction %d.\n", instr0);
#endif
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|subu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rs] - RF[rt];
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


movnPLUSsll:
#if INDIRECT_DEBUG
printf("%d|movn\n",counter);
counter++;
#endif

rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
if (RF[rt] != 0) RF[rd] = RF[rs];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr1 >> 6) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


lwPLUSlbu:
#if INDIRECT_DEBUG
printf("%d|lw\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)(VM_memory[RF[rs] + immediate]) << 24) | ((uint32_t)(VM_memory[RF[rs] + immediate + 1]) << 16) | ((uint32_t)(VM_memory[RF[rs] + immediate + 2]) << 8) | ((uint32_t)VM_memory[RF[rs] + immediate + 3]);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|lbu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)VM_memory[RF[rs] + immediate]) & 0xFF;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


addiuPLUSlui:
#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|lui\n",counter);
counter++;
#endif
// NOTHING IMPLEMENTED, COPIED FROM BELOW
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)immediate) << 16;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


andPLUSsrl:
#if INDIRECT_DEBUG
printf("%d|and\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rs] & RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|srl\n",counter);
counter++;
#endif
shamt = (instr1 >> 6) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rt] >> shamt;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


beqPLUSaddu:
#if INDIRECT_DEBUG
printf("%d|beq\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
if (RF[rs] == RF[rt])
{
  immediate = (instr0 >> 0) & 0xFFFF;
  PC  =  nPC;
  nPC  += (immediate << 2);
    if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


}
else
{
  PC  =  nPC;
  nPC  += 4;
}

#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


lwPLUSsltu:
#if INDIRECT_DEBUG
printf("%d|lw\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)(VM_memory[RF[rs] + immediate]) << 24) | ((uint32_t)(VM_memory[RF[rs] + immediate + 1]) << 16) | ((uint32_t)(VM_memory[RF[rs] + immediate + 2]) << 8) | ((uint32_t)VM_memory[RF[rs] + immediate + 3]);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sltu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = (RF[rs] < RF[rt])?1:0;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


sltuPLUSaddiu:
#if INDIRECT_DEBUG
printf("%d|sltu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = (RF[rs] < RF[rt])?1:0;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


addiuPLUSsrl:
#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|srl\n",counter);
counter++;
#endif
shamt = (instr1 >> 6) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rt] >> shamt;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


lwPLUSblez:
#if INDIRECT_DEBUG
printf("%d|lw\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)(VM_memory[RF[rs] + immediate]) << 24) | ((uint32_t)(VM_memory[RF[rs] + immediate + 1]) << 16) | ((uint32_t)(VM_memory[RF[rs] + immediate + 2]) << 8) | ((uint32_t)VM_memory[RF[rs] + immediate + 3]);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|blez\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
if ((int32_t)RF[rs] <= 0)
{
  immediate = (instr1 >> 0) & 0xFFFF;
  PC  =  nPC;
  nPC  += (immediate << 2);
    if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


}
else
{
  PC  =  nPC;
  nPC  += 4;
}
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


orPLUSor:
#if INDIRECT_DEBUG
printf("%d|or\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rs] | RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|or\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rs] | RF[rt];
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


lwPLUSslti:
#if INDIRECT_DEBUG
printf("%d|lw\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)(VM_memory[RF[rs] + immediate]) << 24) | ((uint32_t)(VM_memory[RF[rs] + immediate + 1]) << 16) | ((uint32_t)(VM_memory[RF[rs] + immediate + 2]) << 8) | ((uint32_t)VM_memory[RF[rs] + immediate + 3]);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|slti\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] < immediate)?1:0;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


lbuPLUSxor:
#if INDIRECT_DEBUG
printf("%d|lbu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)VM_memory[RF[rs] + immediate]) & 0xFF;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|xor\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rs] ^ RF[rt];
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


adduPLUSslt:
#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|slt\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = (RF[rs] < RF[rt])?1:0;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


adduPLUSsll:
#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr1 >> 6) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


lwPLUSsw:
#if INDIRECT_DEBUG
printf("%d|lw\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)(VM_memory[RF[rs] + immediate]) << 24) | ((uint32_t)(VM_memory[RF[rs] + immediate + 1]) << 16) | ((uint32_t)(VM_memory[RF[rs] + immediate + 2]) << 8) | ((uint32_t)VM_memory[RF[rs] + immediate + 3]);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sw\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
VM_memory[RF[rs] + immediate] = (uint8_t)((RF[rt] & 0xFF000000) >> 24);
VM_memory[RF[rs] + immediate + 1] = (uint8_t)((RF[rt] & 0xFF0000) >> 16);
VM_memory[RF[rs] + immediate + 2] = (uint8_t)((RF[rt] & 0xFF00) >> 8);
VM_memory[RF[rs] + immediate + 3] = (uint8_t)(RF[rt] & 0xFF);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


jumpPLUSaddu:
#if INDIRECT_DEBUG
printf("%d|jump\n",counter);
counter++;
#endif
PC = nPC;
address = (instr0 >> 0) & 0x3FFFFFF;
nPC = address << 2;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;



#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


oriPLUSsll:
#if INDIRECT_DEBUG
printf("%d|ori\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = RF[rs] | (uint32_t)immediate;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr1 >> 6) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


adduPLUSandi:
#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|andi\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = RF[rs] & (uint32_t)immediate;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


movnPLUSbne:
#if INDIRECT_DEBUG
printf("%d|movn\n",counter);
counter++;
#endif

rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
if (RF[rt] != 0) RF[rd] = RF[rs];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|bne\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
if (RF[rs] != RF[rt])
{
  immediate = (instr1 >> 0) & 0xFFFF;
  PC  =  nPC;
  nPC  += (immediate << 2);
    if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


}
else
{
  PC  =  nPC;
  nPC  += 4;
}
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


adduPLUSsrl:
#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|srl\n",counter);
counter++;
#endif
shamt = (instr1 >> 6) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rt] >> shamt;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


mfhiPLUSaddiu:
#if INDIRECT_DEBUG
printf("%d|mfhi\n",counter);
counter++;
#endif
rd = (instr0 >> 11) & 0x1F;
RF[rd] = HI;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


xorPLUSsll:
#if INDIRECT_DEBUG
printf("%d|xor\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rs] ^ RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr1 >> 6) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


xorPLUSnor:
#if INDIRECT_DEBUG
printf("%d|xor\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rs] ^ RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|nor\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = ~(RF[rs] | RF[rt]);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


addiuPLUSbeq:
#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|beq\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
if (RF[rs] == RF[rt])
{
  immediate = (instr1 >> 0) & 0xFFFF;
  PC  =  nPC;
  nPC  += (immediate << 2);
    if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


}
else
{
  PC  =  nPC;
  nPC  += 4;
}
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


addiuPLUSsysc:
#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sysc\n",counter);
counter++;
#endif
if (syscall((uint8_t)RF[2])) //registers $4 and $5 useb by hallcall (sensid and retval respectively)
{
halted = 1; //Syscall returned 1, exit code
goto end;
}
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


andPLUSsll:
#if INDIRECT_DEBUG
printf("%d|and\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rs] & RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr1 >> 6) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


sltuPLUSlw:
#if INDIRECT_DEBUG
printf("%d|sltu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = (RF[rs] < RF[rt])?1:0;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|lw\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)(VM_memory[RF[rs] + immediate]) << 24) | ((uint32_t)(VM_memory[RF[rs] + immediate + 1]) << 16) | ((uint32_t)(VM_memory[RF[rs] + immediate + 2]) << 8) | ((uint32_t)VM_memory[RF[rs] + immediate + 3]);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


sllPLUSmult:
#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr0 >> 6) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|mult\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
mult = (uint64_t)RF[rs] * (uint64_t) RF[rt];
HI = (mult >> 32) & 0xFFFFFFFF;
LO = mult & 0xFFFFFFFF;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


andPLUSor:
#if INDIRECT_DEBUG
printf("%d|and\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rs] & RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|or\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rs] | RF[rt];
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


jumpPLUSaddiu:
#if INDIRECT_DEBUG
printf("%d|jump\n",counter);
counter++;
#endif
PC = nPC;
address = (instr0 >> 0) & 0x3FFFFFF;
nPC = address << 2;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;



#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


jalPLUSsll:
#if INDIRECT_DEBUG
printf("%d|jal\n",counter);
counter++;
#endif
RF[31] = PC + 8;
PC = nPC;
address = (instr0 >> 0) & 0x3FFFFFF;
nPC = address << 2;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;



#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr1 >> 6) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


addiuPLUSlw:
#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|lw\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)(VM_memory[RF[rs] + immediate]) << 24) | ((uint32_t)(VM_memory[RF[rs] + immediate + 1]) << 16) | ((uint32_t)(VM_memory[RF[rs] + immediate + 2]) << 8) | ((uint32_t)VM_memory[RF[rs] + immediate + 3]);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


adduPLUSmult:
#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|mult\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
mult = (uint64_t)RF[rs] * (uint64_t) RF[rt];
HI = (mult >> 32) & 0xFFFFFFFF;
LO = mult & 0xFFFFFFFF;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


orPLUSsw:
#if INDIRECT_DEBUG
printf("%d|or\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rs] | RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sw\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
VM_memory[RF[rs] + immediate] = (uint8_t)((RF[rt] & 0xFF000000) >> 24);
VM_memory[RF[rs] + immediate + 1] = (uint8_t)((RF[rt] & 0xFF0000) >> 16);
VM_memory[RF[rs] + immediate + 2] = (uint8_t)((RF[rt] & 0xFF00) >> 8);
VM_memory[RF[rs] + immediate + 3] = (uint8_t)(RF[rt] & 0xFF);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


xorPLUSaddiu:
#if INDIRECT_DEBUG
printf("%d|xor\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rs] ^ RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


sltuPLUSmovn:
#if INDIRECT_DEBUG
printf("%d|sltu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = (RF[rs] < RF[rt])?1:0;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|movn\n",counter);
counter++;
#endif

rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
if (RF[rt] != 0) RF[rd] = RF[rs];
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


jalPLUSaddu:
#if INDIRECT_DEBUG
printf("%d|jal\n",counter);
counter++;
#endif
RF[31] = PC + 8;
PC = nPC;
address = (instr0 >> 0) & 0x3FFFFFF;
nPC = address << 2;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;



#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


swPLUSsll:
#if INDIRECT_DEBUG
printf("%d|sw\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
VM_memory[RF[rs] + immediate] = (uint8_t)((RF[rt] & 0xFF000000) >> 24);
VM_memory[RF[rs] + immediate + 1] = (uint8_t)((RF[rt] & 0xFF0000) >> 16);
VM_memory[RF[rs] + immediate + 2] = (uint8_t)((RF[rt] & 0xFF00) >> 8);
VM_memory[RF[rs] + immediate + 3] = (uint8_t)(RF[rt] & 0xFF);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr1 >> 6) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


jumpPLUSsll:
#if INDIRECT_DEBUG
printf("%d|jump\n",counter);
counter++;
#endif
PC = nPC;
address = (instr0 >> 0) & 0x3FFFFFF;
nPC = address << 2;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;



#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr1 >> 6) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


lwPLUSjump:
#if INDIRECT_DEBUG
printf("%d|lw\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)(VM_memory[RF[rs] + immediate]) << 24) | ((uint32_t)(VM_memory[RF[rs] + immediate + 1]) << 16) | ((uint32_t)(VM_memory[RF[rs] + immediate + 2]) << 8) | ((uint32_t)VM_memory[RF[rs] + immediate + 3]);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|jump\n",counter);
counter++;
#endif
PC = nPC;
address = (instr1 >> 0) & 0x3FFFFFF;
nPC = address << 2;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


errorPLUSaddu:
#if INDIRECT_DEBUG
printf("Error, unknown instr0uction %d.\n", instr0);
#endif
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


adduPLUSjal:
#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|jal\n",counter);
counter++;
#endif
RF[31] = PC + 8;
PC = nPC;
address = (instr1 >> 0) & 0x3FFFFFF;
nPC = address << 2;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


addiuPLUSlbu:
#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|lbu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)VM_memory[RF[rs] + immediate]) & 0xFF;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


srlPLUSori:
#if INDIRECT_DEBUG
printf("%d|srl\n",counter);
counter++;
#endif
shamt = (instr0 >> 6) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rt] >> shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|ori\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = RF[rs] | (uint32_t)immediate;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


lwPLUSbgtz:
#if INDIRECT_DEBUG
printf("%d|lw\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)(VM_memory[RF[rs] + immediate]) << 24) | ((uint32_t)(VM_memory[RF[rs] + immediate + 1]) << 16) | ((uint32_t)(VM_memory[RF[rs] + immediate + 2]) << 8) | ((uint32_t)VM_memory[RF[rs] + immediate + 3]);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|bgtz\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
if ((int32_t)RF[rs] > 0)
{
  immediate = (instr1 >> 0) & 0xFFFF;
  PC  =  nPC;
  nPC  += (immediate << 2);
    if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


}
else
{
  PC  =  nPC;
  nPC  += 4;
}
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


lwPLUSlw:
#if INDIRECT_DEBUG
printf("%d|lw\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)(VM_memory[RF[rs] + immediate]) << 24) | ((uint32_t)(VM_memory[RF[rs] + immediate + 1]) << 16) | ((uint32_t)(VM_memory[RF[rs] + immediate + 2]) << 8) | ((uint32_t)VM_memory[RF[rs] + immediate + 3]);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|lw\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)(VM_memory[RF[rs] + immediate]) << 24) | ((uint32_t)(VM_memory[RF[rs] + immediate + 1]) << 16) | ((uint32_t)(VM_memory[RF[rs] + immediate + 2]) << 8) | ((uint32_t)VM_memory[RF[rs] + immediate + 3]);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


andiPLUSxor:
#if INDIRECT_DEBUG
printf("%d|andi\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = RF[rs] & (uint32_t)immediate;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|xor\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rs] ^ RF[rt];
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


swPLUSaddiu:
#if INDIRECT_DEBUG
printf("%d|sw\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
VM_memory[RF[rs] + immediate] = (uint8_t)((RF[rt] & 0xFF000000) >> 24);
VM_memory[RF[rs] + immediate + 1] = (uint8_t)((RF[rt] & 0xFF0000) >> 16);
VM_memory[RF[rs] + immediate + 2] = (uint8_t)((RF[rt] & 0xFF00) >> 8);
VM_memory[RF[rs] + immediate + 3] = (uint8_t)(RF[rt] & 0xFF);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


andiPLUSor:
#if INDIRECT_DEBUG
printf("%d|andi\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = RF[rs] & (uint32_t)immediate;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|or\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rs] | RF[rt];
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


srlPLUSerror:
#if INDIRECT_DEBUG
printf("%d|srl\n",counter);
counter++;
#endif
shamt = (instr0 >> 6) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rt] >> shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("Error, unknown instr1uction %d.\n", instr1);
#endif
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


oriPLUSaddu:
#if INDIRECT_DEBUG
printf("%d|ori\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = RF[rs] | (uint32_t)immediate;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


sllPLUSand:
#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr0 >> 6) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|and\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rs] & RF[rt];
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


lbuPLUSaddiu:
#if INDIRECT_DEBUG
printf("%d|lbu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)VM_memory[RF[rs] + immediate]) & 0xFF;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


addiuPLUSxor:
#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|xor\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rs] ^ RF[rt];
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


orPLUSsll:
#if INDIRECT_DEBUG
printf("%d|or\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rs] | RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr1 >> 6) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


sltPLUSbeq:
#if INDIRECT_DEBUG
printf("%d|slt\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = (RF[rs] < RF[rt])?1:0;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|beq\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
if (RF[rs] == RF[rt])
{
  immediate = (instr1 >> 0) & 0xFFFF;
  PC  =  nPC;
  nPC  += (immediate << 2);
    if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


}
else
{
  PC  =  nPC;
  nPC  += 4;
}
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


lwPLUSori:
#if INDIRECT_DEBUG
printf("%d|lw\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)(VM_memory[RF[rs] + immediate]) << 24) | ((uint32_t)(VM_memory[RF[rs] + immediate + 1]) << 16) | ((uint32_t)(VM_memory[RF[rs] + immediate + 2]) << 8) | ((uint32_t)VM_memory[RF[rs] + immediate + 3]);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|ori\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = RF[rs] | (uint32_t)immediate;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


adduPLUSaddu:
#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


movnPLUSandi:
#if INDIRECT_DEBUG
printf("%d|movn\n",counter);
counter++;
#endif

rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
if (RF[rt] != 0) RF[rd] = RF[rs];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|andi\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = RF[rs] & (uint32_t)immediate;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


xorPLUSsrl:
#if INDIRECT_DEBUG
printf("%d|xor\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rs] ^ RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|srl\n",counter);
counter++;
#endif
shamt = (instr1 >> 6) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rt] >> shamt;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


sllPLUSlw:
#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr0 >> 6) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|lw\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)(VM_memory[RF[rs] + immediate]) << 24) | ((uint32_t)(VM_memory[RF[rs] + immediate + 1]) << 16) | ((uint32_t)(VM_memory[RF[rs] + immediate + 2]) << 8) | ((uint32_t)VM_memory[RF[rs] + immediate + 3]);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


adduPLUSlw:
#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|lw\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)(VM_memory[RF[rs] + immediate]) << 24) | ((uint32_t)(VM_memory[RF[rs] + immediate + 1]) << 16) | ((uint32_t)(VM_memory[RF[rs] + immediate + 2]) << 8) | ((uint32_t)VM_memory[RF[rs] + immediate + 3]);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


srlPLUSsra:
#if INDIRECT_DEBUG
printf("%d|srl\n",counter);
counter++;
#endif
shamt = (instr0 >> 6) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rt] >> shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sra\n",counter);
counter++;
#endif
shamt = (instr1 >> 6) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
if ((int32_t)RF[rt] < 0 && shamt > 0) {
rd = (instr1 >> 11) & 0x1F;
RF[rd] = (int32_t)RF[rt] | ~(~0U >> shamt);
}
else {
rd = (instr1 >> 11) & 0x1F;
RF[rd] = (int32_t)RF[rt] >> shamt;
}
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


adduPLUSslti:
#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|slti\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] < immediate)?1:0;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


adduPLUSjump:
#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|jump\n",counter);
counter++;
#endif
PC = nPC;
address = (instr1 >> 0) & 0x3FFFFFF;
nPC = address << 2;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


adduPLUSsubu:
#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|subu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rs] - RF[rt];
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


sllPLUSaddiu:
#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr0 >> 6) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


mfhiPLUSsrl:
#if INDIRECT_DEBUG
printf("%d|mfhi\n",counter);
counter++;
#endif
rd = (instr0 >> 11) & 0x1F;
RF[rd] = HI;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|srl\n",counter);
counter++;
#endif
shamt = (instr1 >> 6) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rt] >> shamt;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


sbPLUSsh:
#if INDIRECT_DEBUG
printf("%d|sb\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
VM_memory[RF[rs] + immediate] = (uint8_t)(RF[rt] & 0xFF);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sh\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
VM_memory[RF[rs] + immediate] = (uint8_t)((RF[rt] & 0xFF00) >> 8);
VM_memory[RF[rs] + immediate + 1] = (uint8_t)(RF[rt] & 0xFF);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


lwPLUSaddu:
#if INDIRECT_DEBUG
printf("%d|lw\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)(VM_memory[RF[rs] + immediate]) << 24) | ((uint32_t)(VM_memory[RF[rs] + immediate + 1]) << 16) | ((uint32_t)(VM_memory[RF[rs] + immediate + 2]) << 8) | ((uint32_t)VM_memory[RF[rs] + immediate + 3]);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


oriPLUSand:
#if INDIRECT_DEBUG
printf("%d|ori\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = RF[rs] | (uint32_t)immediate;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|and\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rs] & RF[rt];
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


andiPLUSsubu:
#if INDIRECT_DEBUG
printf("%d|andi\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = RF[rs] & (uint32_t)immediate;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|subu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rs] - RF[rt];
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


sltPLUSlw:
#if INDIRECT_DEBUG
printf("%d|slt\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = (RF[rs] < RF[rt])?1:0;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|lw\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)(VM_memory[RF[rs] + immediate]) << 24) | ((uint32_t)(VM_memory[RF[rs] + immediate + 1]) << 16) | ((uint32_t)(VM_memory[RF[rs] + immediate + 2]) << 8) | ((uint32_t)VM_memory[RF[rs] + immediate + 3]);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


blezPLUSsll:
#if INDIRECT_DEBUG
printf("%d|blez\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
if ((int32_t)RF[rs] <= 0)
{
  immediate = (instr0 >> 0) & 0xFFFF;
  PC  =  nPC;
  nPC  += (immediate << 2);
    if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


}
else
{
  PC  =  nPC;
  nPC  += 4;
}

#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr1 >> 6) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


sllPLUSsw:
#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr0 >> 6) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sw\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
VM_memory[RF[rs] + immediate] = (uint8_t)((RF[rt] & 0xFF000000) >> 24);
VM_memory[RF[rs] + immediate + 1] = (uint8_t)((RF[rt] & 0xFF0000) >> 16);
VM_memory[RF[rs] + immediate + 2] = (uint8_t)((RF[rt] & 0xFF00) >> 8);
VM_memory[RF[rs] + immediate + 3] = (uint8_t)(RF[rt] & 0xFF);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


beqPLUSaddiu:
#if INDIRECT_DEBUG
printf("%d|beq\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
if (RF[rs] == RF[rt])
{
  immediate = (instr0 >> 0) & 0xFFFF;
  PC  =  nPC;
  nPC  += (immediate << 2);
    if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


}
else
{
  PC  =  nPC;
  nPC  += 4;
}

#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


andPLUSandi:
#if INDIRECT_DEBUG
printf("%d|and\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rs] & RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|andi\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = RF[rs] & (uint32_t)immediate;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


sllPLUSsb:
#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr0 >> 6) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sb\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
VM_memory[RF[rs] + immediate] = (uint8_t)(RF[rt] & 0xFF);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


mfhiPLUSmult:
#if INDIRECT_DEBUG
printf("%d|mfhi\n",counter);
counter++;
#endif
rd = (instr0 >> 11) & 0x1F;
RF[rd] = HI;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|mult\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
mult = (uint64_t)RF[rs] * (uint64_t) RF[rt];
HI = (mult >> 32) & 0xFFFFFFFF;
LO = mult & 0xFFFFFFFF;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


norPLUSsrl:
#if INDIRECT_DEBUG
printf("%d|nor\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = ~(RF[rs] | RF[rt]);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|srl\n",counter);
counter++;
#endif
shamt = (instr1 >> 6) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rt] >> shamt;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


lbuPLUSsubu:
#if INDIRECT_DEBUG
printf("%d|lbu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)VM_memory[RF[rs] + immediate]) & 0xFF;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|subu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rs] - RF[rt];
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


sllPLUSjal:
#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr0 >> 6) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|jal\n",counter);
counter++;
#endif
RF[31] = PC + 8;
PC = nPC;
address = (instr1 >> 0) & 0x3FFFFFF;
nPC = address << 2;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


xorPLUSbne:
#if INDIRECT_DEBUG
printf("%d|xor\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rs] ^ RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|bne\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
if (RF[rs] != RF[rt])
{
  immediate = (instr1 >> 0) & 0xFFFF;
  PC  =  nPC;
  nPC  += (immediate << 2);
    if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


}
else
{
  PC  =  nPC;
  nPC  += 4;
}
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


addiuPLUSaddiu:
#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


xorPLUSslti:
#if INDIRECT_DEBUG
printf("%d|xor\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rs] ^ RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|slti\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] < immediate)?1:0;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


orPLUSlui:
#if INDIRECT_DEBUG
printf("%d|or\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rs] | RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|lui\n",counter);
counter++;
#endif
// NOTHING IMPLEMENTED, COPIED FROM BELOW
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)immediate) << 16;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


srlPLUSlui:
#if INDIRECT_DEBUG
printf("%d|srl\n",counter);
counter++;
#endif
shamt = (instr0 >> 6) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rt] >> shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|lui\n",counter);
counter++;
#endif
// NOTHING IMPLEMENTED, COPIED FROM BELOW
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)immediate) << 16;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


lwPLUSxor:
#if INDIRECT_DEBUG
printf("%d|lw\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)(VM_memory[RF[rs] + immediate]) << 24) | ((uint32_t)(VM_memory[RF[rs] + immediate + 1]) << 16) | ((uint32_t)(VM_memory[RF[rs] + immediate + 2]) << 8) | ((uint32_t)VM_memory[RF[rs] + immediate + 3]);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|xor\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rs] ^ RF[rt];
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


sllPLUSori:
#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr0 >> 6) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|ori\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = RF[rs] | (uint32_t)immediate;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


adduPLUSsw:
#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sw\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
VM_memory[RF[rs] + immediate] = (uint8_t)((RF[rt] & 0xFF000000) >> 24);
VM_memory[RF[rs] + immediate + 1] = (uint8_t)((RF[rt] & 0xFF0000) >> 16);
VM_memory[RF[rs] + immediate + 2] = (uint8_t)((RF[rt] & 0xFF00) >> 8);
VM_memory[RF[rs] + immediate + 3] = (uint8_t)(RF[rt] & 0xFF);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


bnePLUSxor:
#if INDIRECT_DEBUG
printf("%d|bne\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
if (RF[rs] != RF[rt])
{
  immediate = (instr0 >> 0) & 0xFFFF;
  PC  =  nPC;
  nPC  += (immediate << 2);
    if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


}
else
{
  PC  =  nPC;
  nPC  += 4;
}

#if INDIRECT_DEBUG
printf("%d|xor\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rs] ^ RF[rt];
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


sllPLUSblez:
#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr0 >> 6) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|blez\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
if ((int32_t)RF[rs] <= 0)
{
  immediate = (instr1 >> 0) & 0xFFFF;
  PC  =  nPC;
  nPC  += (immediate << 2);
    if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


}
else
{
  PC  =  nPC;
  nPC  += 4;
}
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


addiuPLUSerror:
#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("Error, unknown instr1uction %d.\n", instr1);
#endif
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


subuPLUSaddiu:
#if INDIRECT_DEBUG
printf("%d|subu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rs] - RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


andiPLUSjr:
#if INDIRECT_DEBUG
printf("%d|andi\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = RF[rs] & (uint32_t)immediate;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|jr\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
PC = nPC;
nPC = RF[rs];
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


lwPLUSjal:
#if INDIRECT_DEBUG
printf("%d|lw\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)(VM_memory[RF[rs] + immediate]) << 24) | ((uint32_t)(VM_memory[RF[rs] + immediate + 1]) << 16) | ((uint32_t)(VM_memory[RF[rs] + immediate + 2]) << 8) | ((uint32_t)VM_memory[RF[rs] + immediate + 3]);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|jal\n",counter);
counter++;
#endif
RF[31] = PC + 8;
PC = nPC;
address = (instr1 >> 0) & 0x3FFFFFF;
nPC = address << 2;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


jumpPLUSsw:
#if INDIRECT_DEBUG
printf("%d|jump\n",counter);
counter++;
#endif
PC = nPC;
address = (instr0 >> 0) & 0x3FFFFFF;
nPC = address << 2;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;



#if INDIRECT_DEBUG
printf("%d|sw\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
VM_memory[RF[rs] + immediate] = (uint8_t)((RF[rt] & 0xFF000000) >> 24);
VM_memory[RF[rs] + immediate + 1] = (uint8_t)((RF[rt] & 0xFF0000) >> 16);
VM_memory[RF[rs] + immediate + 2] = (uint8_t)((RF[rt] & 0xFF00) >> 8);
VM_memory[RF[rs] + immediate + 3] = (uint8_t)(RF[rt] & 0xFF);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


jrPLUSsll:
#if INDIRECT_DEBUG
printf("%d|jr\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
PC = nPC;
nPC = RF[rs];
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;



#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr1 >> 6) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


oriPLUSmult:
#if INDIRECT_DEBUG
printf("%d|ori\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = RF[rs] | (uint32_t)immediate;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|mult\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
mult = (uint64_t)RF[rs] * (uint64_t) RF[rt];
HI = (mult >> 32) & 0xFFFFFFFF;
LO = mult & 0xFFFFFFFF;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


syscPLUSjal:
#if INDIRECT_DEBUG
printf("%d|sysc\n",counter);
counter++;
#endif
if (syscall((uint8_t)RF[2])) //registers $4 and $5 useb by hallcall (sensid and retval respectively)
{
halted = 1; //Syscall returned 1, exit code
goto end;
}
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|jal\n",counter);
counter++;
#endif
RF[31] = PC + 8;
PC = nPC;
address = (instr1 >> 0) & 0x3FFFFFF;
nPC = address << 2;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


adduPLUSlbu:
#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|lbu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)VM_memory[RF[rs] + immediate]) & 0xFF;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


swPLUSlui:
#if INDIRECT_DEBUG
printf("%d|sw\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
VM_memory[RF[rs] + immediate] = (uint8_t)((RF[rt] & 0xFF000000) >> 24);
VM_memory[RF[rs] + immediate + 1] = (uint8_t)((RF[rt] & 0xFF0000) >> 16);
VM_memory[RF[rs] + immediate + 2] = (uint8_t)((RF[rt] & 0xFF00) >> 8);
VM_memory[RF[rs] + immediate + 3] = (uint8_t)(RF[rt] & 0xFF);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|lui\n",counter);
counter++;
#endif
// NOTHING IMPLEMENTED, COPIED FROM BELOW
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)immediate) << 16;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


sllPLUSor:
#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr0 >> 6) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|or\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rs] | RF[rt];
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


errorPLUSlw:
#if INDIRECT_DEBUG
printf("Error, unknown instr0uction %d.\n", instr0);
#endif
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|lw\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)(VM_memory[RF[rs] + immediate]) << 24) | ((uint32_t)(VM_memory[RF[rs] + immediate + 1]) << 16) | ((uint32_t)(VM_memory[RF[rs] + immediate + 2]) << 8) | ((uint32_t)VM_memory[RF[rs] + immediate + 3]);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


norPLUSjr:
#if INDIRECT_DEBUG
printf("%d|nor\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = ~(RF[rs] | RF[rt]);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|jr\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
PC = nPC;
nPC = RF[rs];
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


orPLUSsltu:
#if INDIRECT_DEBUG
printf("%d|or\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rs] | RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sltu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = (RF[rs] < RF[rt])?1:0;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


luiPLUSaddiu:
#if INDIRECT_DEBUG
printf("%d|lui\n",counter);
counter++;
#endif
// NOTHING IMPLEMENTED, COPIED FROM BELOW
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)immediate) << 16;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


xorPLUSsw:
#if INDIRECT_DEBUG
printf("%d|xor\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rs] ^ RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sw\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
VM_memory[RF[rs] + immediate] = (uint8_t)((RF[rt] & 0xFF000000) >> 24);
VM_memory[RF[rs] + immediate + 1] = (uint8_t)((RF[rt] & 0xFF0000) >> 16);
VM_memory[RF[rs] + immediate + 2] = (uint8_t)((RF[rt] & 0xFF00) >> 8);
VM_memory[RF[rs] + immediate + 3] = (uint8_t)(RF[rt] & 0xFF);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


beqPLUSsll:
#if INDIRECT_DEBUG
printf("%d|beq\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
if (RF[rs] == RF[rt])
{
  immediate = (instr0 >> 0) & 0xFFFF;
  PC  =  nPC;
  nPC  += (immediate << 2);
    if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


}
else
{
  PC  =  nPC;
  nPC  += 4;
}

#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr1 >> 6) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


subuPLUSaddu:
#if INDIRECT_DEBUG
printf("%d|subu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rs] - RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


beqPLUSsllPLUSaddiu:
#if INDIRECT_DEBUG
printf("%d|beq\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
if (RF[rs] == RF[rt])
{
  immediate = (instr0 >> 0) & 0xFFFF;
  PC  =  nPC;
  nPC  += (immediate << 2);
    if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


}
else
{
  PC  =  nPC;
  nPC  += 4;
}

#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr1 >> 6) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


sllPLUSxorPLUSslti:
#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr0 >> 6) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|xor\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rs] ^ RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|slti\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] < immediate)?1:0;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


lwPLUSsltPLUSbne:
#if INDIRECT_DEBUG
printf("%d|lw\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)(VM_memory[RF[rs] + immediate]) << 24) | ((uint32_t)(VM_memory[RF[rs] + immediate + 1]) << 16) | ((uint32_t)(VM_memory[RF[rs] + immediate + 2]) << 8) | ((uint32_t)VM_memory[RF[rs] + immediate + 3]);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|slt\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = (RF[rs] < RF[rt])?1:0;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|bne\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
if (RF[rs] != RF[rt])
{
  immediate = (instr2 >> 0) & 0xFFFF;
  PC  =  nPC;
  nPC  += (immediate << 2);
    if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


}
else
{
  PC  =  nPC;
  nPC  += 4;
}
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


adduPLUSnorPLUSjr:
#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|nor\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = ~(RF[rs] | RF[rt]);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|jr\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
PC = nPC;
nPC = RF[rs];
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


sraPLUSadduPLUSsll:
#if INDIRECT_DEBUG
printf("%d|sra\n",counter);
counter++;
#endif
shamt = (instr0 >> 6) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
if ((int32_t)RF[rt] < 0 && shamt > 0) {
rd = (instr0 >> 11) & 0x1F;
RF[rd] = (int32_t)RF[rt] | ~(~0U >> shamt);
}
else {
rd = (instr0 >> 11) & 0x1F;
RF[rd] = (int32_t)RF[rt] >> shamt;
}
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr2 >> 6) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


lwPLUSaddiuPLUSjr:
#if INDIRECT_DEBUG
printf("%d|lw\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)(VM_memory[RF[rs] + immediate]) << 24) | ((uint32_t)(VM_memory[RF[rs] + immediate + 1]) << 16) | ((uint32_t)(VM_memory[RF[rs] + immediate + 2]) << 8) | ((uint32_t)VM_memory[RF[rs] + immediate + 3]);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|jr\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
PC = nPC;
nPC = RF[rs];
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


addiuPLUSsllPLUSaddu:
#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr1 >> 6) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


addiuPLUSlbuPLUSsubu:
#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|lbu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)VM_memory[RF[rs] + immediate]) & 0xFF;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|subu\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rs] - RF[rt];
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


errorPLUSsubuPLUSand:
#if INDIRECT_DEBUG
printf("Error, unknown instr0uction %d.\n", instr0);
#endif
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|subu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rs] - RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|and\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rs] & RF[rt];
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


andiPLUSsllPLUSor:
#if INDIRECT_DEBUG
printf("%d|andi\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = RF[rs] & (uint32_t)immediate;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr1 >> 6) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|or\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rs] | RF[rt];
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


addiuPLUSaddiuPLUSslti:
#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|slti\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] < immediate)?1:0;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


errorPLUSaddiuPLUSlbu:
#if INDIRECT_DEBUG
printf("Error, unknown instr0uction %d.\n", instr0);
#endif
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|lbu\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)VM_memory[RF[rs] + immediate]) & 0xFF;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


sllPLUSlwPLUSsw:
#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr0 >> 6) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|lw\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)(VM_memory[RF[rs] + immediate]) << 24) | ((uint32_t)(VM_memory[RF[rs] + immediate + 1]) << 16) | ((uint32_t)(VM_memory[RF[rs] + immediate + 2]) << 8) | ((uint32_t)VM_memory[RF[rs] + immediate + 3]);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sw\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
VM_memory[RF[rs] + immediate] = (uint8_t)((RF[rt] & 0xFF000000) >> 24);
VM_memory[RF[rs] + immediate + 1] = (uint8_t)((RF[rt] & 0xFF0000) >> 16);
VM_memory[RF[rs] + immediate + 2] = (uint8_t)((RF[rt] & 0xFF00) >> 8);
VM_memory[RF[rs] + immediate + 3] = (uint8_t)(RF[rt] & 0xFF);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


addiuPLUSaddiuPLUSsw:
#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sw\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
VM_memory[RF[rs] + immediate] = (uint8_t)((RF[rt] & 0xFF000000) >> 24);
VM_memory[RF[rs] + immediate + 1] = (uint8_t)((RF[rt] & 0xFF0000) >> 16);
VM_memory[RF[rs] + immediate + 2] = (uint8_t)((RF[rt] & 0xFF00) >> 8);
VM_memory[RF[rs] + immediate + 3] = (uint8_t)(RF[rt] & 0xFF);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


jumpPLUSsllPLUSsll:
#if INDIRECT_DEBUG
printf("%d|jump\n",counter);
counter++;
#endif
PC = nPC;
address = (instr0 >> 0) & 0x3FFFFFF;
nPC = address << 2;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;



#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr1 >> 6) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr2 >> 6) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


oriPLUSadduPLUSsw:
#if INDIRECT_DEBUG
printf("%d|ori\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = RF[rs] | (uint32_t)immediate;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sw\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
VM_memory[RF[rs] + immediate] = (uint8_t)((RF[rt] & 0xFF000000) >> 24);
VM_memory[RF[rs] + immediate + 1] = (uint8_t)((RF[rt] & 0xFF0000) >> 16);
VM_memory[RF[rs] + immediate + 2] = (uint8_t)((RF[rt] & 0xFF00) >> 8);
VM_memory[RF[rs] + immediate + 3] = (uint8_t)(RF[rt] & 0xFF);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


bnePLUSadduPLUSslt:
#if INDIRECT_DEBUG
printf("%d|bne\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
if (RF[rs] != RF[rt])
{
  immediate = (instr0 >> 0) & 0xFFFF;
  PC  =  nPC;
  nPC  += (immediate << 2);
    if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


}
else
{
  PC  =  nPC;
  nPC  += 4;
}

#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|slt\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = (RF[rs] < RF[rt])?1:0;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


jrPLUSsllPLUSaddu:
#if INDIRECT_DEBUG
printf("%d|jr\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
PC = nPC;
nPC = RF[rs];
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;



#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr1 >> 6) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


sllPLUSluiPLUSaddiu:
#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr0 >> 6) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|lui\n",counter);
counter++;
#endif
// NOTHING IMPLEMENTED, COPIED FROM BELOW
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)immediate) << 16;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


xorPLUSerrorPLUSsubu:
#if INDIRECT_DEBUG
printf("%d|xor\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rs] ^ RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("Error, unknown instr1uction %d.\n", instr1);
#endif
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|subu\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rs] - RF[rt];
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


lwPLUSblezPLUSsll:
#if INDIRECT_DEBUG
printf("%d|lw\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)(VM_memory[RF[rs] + immediate]) << 24) | ((uint32_t)(VM_memory[RF[rs] + immediate + 1]) << 16) | ((uint32_t)(VM_memory[RF[rs] + immediate + 2]) << 8) | ((uint32_t)VM_memory[RF[rs] + immediate + 3]);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|blez\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
if ((int32_t)RF[rs] <= 0)
{
  immediate = (instr1 >> 0) & 0xFFFF;
  PC  =  nPC;
  nPC  += (immediate << 2);
    if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


}
else
{
  PC  =  nPC;
  nPC  += 4;
}

#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr2 >> 6) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


bnePLUSsllPLUSlui:
#if INDIRECT_DEBUG
printf("%d|bne\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
if (RF[rs] != RF[rt])
{
  immediate = (instr0 >> 0) & 0xFFFF;
  PC  =  nPC;
  nPC  += (immediate << 2);
    if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


}
else
{
  PC  =  nPC;
  nPC  += 4;
}

#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr1 >> 6) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|lui\n",counter);
counter++;
#endif
// NOTHING IMPLEMENTED, COPIED FROM BELOW
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)immediate) << 16;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


bnePLUSadduPLUSsll:
#if INDIRECT_DEBUG
printf("%d|bne\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
if (RF[rs] != RF[rt])
{
  immediate = (instr0 >> 0) & 0xFFFF;
  PC  =  nPC;
  nPC  += (immediate << 2);
    if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


}
else
{
  PC  =  nPC;
  nPC  += 4;
}

#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr2 >> 6) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


adduPLUSadduPLUSlw:
#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|lw\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)(VM_memory[RF[rs] + immediate]) << 24) | ((uint32_t)(VM_memory[RF[rs] + immediate + 1]) << 16) | ((uint32_t)(VM_memory[RF[rs] + immediate + 2]) << 8) | ((uint32_t)VM_memory[RF[rs] + immediate + 3]);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


jrPLUSsllPLUSlui:
#if INDIRECT_DEBUG
printf("%d|jr\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
PC = nPC;
nPC = RF[rs];
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;



#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr1 >> 6) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|lui\n",counter);
counter++;
#endif
// NOTHING IMPLEMENTED, COPIED FROM BELOW
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)immediate) << 16;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


adduPLUSswPLUSlw:
#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sw\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
VM_memory[RF[rs] + immediate] = (uint8_t)((RF[rt] & 0xFF000000) >> 24);
VM_memory[RF[rs] + immediate + 1] = (uint8_t)((RF[rt] & 0xFF0000) >> 16);
VM_memory[RF[rs] + immediate + 2] = (uint8_t)((RF[rt] & 0xFF00) >> 8);
VM_memory[RF[rs] + immediate + 3] = (uint8_t)(RF[rt] & 0xFF);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|lw\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)(VM_memory[RF[rs] + immediate]) << 24) | ((uint32_t)(VM_memory[RF[rs] + immediate + 1]) << 16) | ((uint32_t)(VM_memory[RF[rs] + immediate + 2]) << 8) | ((uint32_t)VM_memory[RF[rs] + immediate + 3]);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


luiPLUSswPLUSaddiu:
#if INDIRECT_DEBUG
printf("%d|lui\n",counter);
counter++;
#endif
// NOTHING IMPLEMENTED, COPIED FROM BELOW
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)immediate) << 16;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sw\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
VM_memory[RF[rs] + immediate] = (uint8_t)((RF[rt] & 0xFF000000) >> 24);
VM_memory[RF[rs] + immediate + 1] = (uint8_t)((RF[rt] & 0xFF0000) >> 16);
VM_memory[RF[rs] + immediate + 2] = (uint8_t)((RF[rt] & 0xFF00) >> 8);
VM_memory[RF[rs] + immediate + 3] = (uint8_t)(RF[rt] & 0xFF);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


bnePLUSadduPLUSlbu:
#if INDIRECT_DEBUG
printf("%d|bne\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
if (RF[rs] != RF[rt])
{
  immediate = (instr0 >> 0) & 0xFFFF;
  PC  =  nPC;
  nPC  += (immediate << 2);
    if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


}
else
{
  PC  =  nPC;
  nPC  += 4;
}

#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|lbu\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)VM_memory[RF[rs] + immediate]) & 0xFF;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


lwPLUSbeqPLUSsll:
#if INDIRECT_DEBUG
printf("%d|lw\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)(VM_memory[RF[rs] + immediate]) << 24) | ((uint32_t)(VM_memory[RF[rs] + immediate + 1]) << 16) | ((uint32_t)(VM_memory[RF[rs] + immediate + 2]) << 8) | ((uint32_t)VM_memory[RF[rs] + immediate + 3]);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|beq\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
if (RF[rs] == RF[rt])
{
  immediate = (instr1 >> 0) & 0xFFFF;
  PC  =  nPC;
  nPC  += (immediate << 2);
    if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


}
else
{
  PC  =  nPC;
  nPC  += 4;
}

#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr2 >> 6) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


sltiPLUSbeqPLUSsll:
#if INDIRECT_DEBUG
printf("%d|slti\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] < immediate)?1:0;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|beq\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
if (RF[rs] == RF[rt])
{
  immediate = (instr1 >> 0) & 0xFFFF;
  PC  =  nPC;
  nPC  += (immediate << 2);
    if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


}
else
{
  PC  =  nPC;
  nPC  += 4;
}

#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr2 >> 6) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


srlPLUSsllPLUSxor:
#if INDIRECT_DEBUG
printf("%d|srl\n",counter);
counter++;
#endif
shamt = (instr0 >> 6) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rt] >> shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr1 >> 6) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|xor\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rs] ^ RF[rt];
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


bnePLUSaddiuPLUSjump:
#if INDIRECT_DEBUG
printf("%d|bne\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
if (RF[rs] != RF[rt])
{
  immediate = (instr0 >> 0) & 0xFFFF;
  PC  =  nPC;
  nPC  += (immediate << 2);
    if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


}
else
{
  PC  =  nPC;
  nPC  += 4;
}

#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|jump\n",counter);
counter++;
#endif
PC = nPC;
address = (instr2 >> 0) & 0x3FFFFFF;
nPC = address << 2;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


sllPLUSadduPLUSaddiu:
#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr0 >> 6) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


addiuPLUSjumpPLUSaddiu:
#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|jump\n",counter);
counter++;
#endif
PC = nPC;
address = (instr1 >> 0) & 0x3FFFFFF;
nPC = address << 2;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;



#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


sllPLUSsltPLUSbeq:
#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr0 >> 6) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|slt\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = (RF[rs] < RF[rt])?1:0;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|beq\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
if (RF[rs] == RF[rt])
{
  immediate = (instr2 >> 0) & 0xFFFF;
  PC  =  nPC;
  nPC  += (immediate << 2);
    if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


}
else
{
  PC  =  nPC;
  nPC  += 4;
}
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


sllPLUSaddiuPLUSslti:
#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr0 >> 6) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|slti\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] < immediate)?1:0;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


swPLUSswPLUSsb:
#if INDIRECT_DEBUG
printf("%d|sw\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
VM_memory[RF[rs] + immediate] = (uint8_t)((RF[rt] & 0xFF000000) >> 24);
VM_memory[RF[rs] + immediate + 1] = (uint8_t)((RF[rt] & 0xFF0000) >> 16);
VM_memory[RF[rs] + immediate + 2] = (uint8_t)((RF[rt] & 0xFF00) >> 8);
VM_memory[RF[rs] + immediate + 3] = (uint8_t)(RF[rt] & 0xFF);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sw\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
VM_memory[RF[rs] + immediate] = (uint8_t)((RF[rt] & 0xFF000000) >> 24);
VM_memory[RF[rs] + immediate + 1] = (uint8_t)((RF[rt] & 0xFF0000) >> 16);
VM_memory[RF[rs] + immediate + 2] = (uint8_t)((RF[rt] & 0xFF00) >> 8);
VM_memory[RF[rs] + immediate + 3] = (uint8_t)(RF[rt] & 0xFF);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sb\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
VM_memory[RF[rs] + immediate] = (uint8_t)(RF[rt] & 0xFF);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


srlPLUSerrorPLUSsubu:
#if INDIRECT_DEBUG
printf("%d|srl\n",counter);
counter++;
#endif
shamt = (instr0 >> 6) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rt] >> shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("Error, unknown instr1uction %d.\n", instr1);
#endif
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|subu\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rs] - RF[rt];
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


sllPLUSlwPLUSaddu:
#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr0 >> 6) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|lw\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)(VM_memory[RF[rs] + immediate]) << 24) | ((uint32_t)(VM_memory[RF[rs] + immediate + 1]) << 16) | ((uint32_t)(VM_memory[RF[rs] + immediate + 2]) << 8) | ((uint32_t)VM_memory[RF[rs] + immediate + 3]);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


sltuPLUSaddiuPLUSbne:
#if INDIRECT_DEBUG
printf("%d|sltu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = (RF[rs] < RF[rt])?1:0;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|bne\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
if (RF[rs] != RF[rt])
{
  immediate = (instr2 >> 0) & 0xFFFF;
  PC  =  nPC;
  nPC  += (immediate << 2);
    if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


}
else
{
  PC  =  nPC;
  nPC  += 4;
}
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


adduPLUSjalPLUSaddu:
#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|jal\n",counter);
counter++;
#endif
RF[31] = PC + 8;
PC = nPC;
address = (instr1 >> 0) & 0x3FFFFFF;
nPC = address << 2;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;



#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


swPLUSswPLUSsw:
#if INDIRECT_DEBUG
printf("%d|sw\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
VM_memory[RF[rs] + immediate] = (uint8_t)((RF[rt] & 0xFF000000) >> 24);
VM_memory[RF[rs] + immediate + 1] = (uint8_t)((RF[rt] & 0xFF0000) >> 16);
VM_memory[RF[rs] + immediate + 2] = (uint8_t)((RF[rt] & 0xFF00) >> 8);
VM_memory[RF[rs] + immediate + 3] = (uint8_t)(RF[rt] & 0xFF);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sw\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
VM_memory[RF[rs] + immediate] = (uint8_t)((RF[rt] & 0xFF000000) >> 24);
VM_memory[RF[rs] + immediate + 1] = (uint8_t)((RF[rt] & 0xFF0000) >> 16);
VM_memory[RF[rs] + immediate + 2] = (uint8_t)((RF[rt] & 0xFF00) >> 8);
VM_memory[RF[rs] + immediate + 3] = (uint8_t)(RF[rt] & 0xFF);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sw\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
VM_memory[RF[rs] + immediate] = (uint8_t)((RF[rt] & 0xFF000000) >> 24);
VM_memory[RF[rs] + immediate + 1] = (uint8_t)((RF[rt] & 0xFF0000) >> 16);
VM_memory[RF[rs] + immediate + 2] = (uint8_t)((RF[rt] & 0xFF00) >> 8);
VM_memory[RF[rs] + immediate + 3] = (uint8_t)(RF[rt] & 0xFF);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


addiuPLUSswPLUSjump:
#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sw\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
VM_memory[RF[rs] + immediate] = (uint8_t)((RF[rt] & 0xFF000000) >> 24);
VM_memory[RF[rs] + immediate + 1] = (uint8_t)((RF[rt] & 0xFF0000) >> 16);
VM_memory[RF[rs] + immediate + 2] = (uint8_t)((RF[rt] & 0xFF00) >> 8);
VM_memory[RF[rs] + immediate + 3] = (uint8_t)(RF[rt] & 0xFF);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|jump\n",counter);
counter++;
#endif
PC = nPC;
address = (instr2 >> 0) & 0x3FFFFFF;
nPC = address << 2;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


swPLUSsllPLUSaddu:
#if INDIRECT_DEBUG
printf("%d|sw\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
VM_memory[RF[rs] + immediate] = (uint8_t)((RF[rt] & 0xFF000000) >> 24);
VM_memory[RF[rs] + immediate + 1] = (uint8_t)((RF[rt] & 0xFF0000) >> 16);
VM_memory[RF[rs] + immediate + 2] = (uint8_t)((RF[rt] & 0xFF00) >> 8);
VM_memory[RF[rs] + immediate + 3] = (uint8_t)(RF[rt] & 0xFF);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr1 >> 6) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


sllPLUSaddiuPLUSlw:
#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr0 >> 6) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|lw\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)(VM_memory[RF[rs] + immediate]) << 24) | ((uint32_t)(VM_memory[RF[rs] + immediate + 1]) << 16) | ((uint32_t)(VM_memory[RF[rs] + immediate + 2]) << 8) | ((uint32_t)VM_memory[RF[rs] + immediate + 3]);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


addiuPLUSaddiuPLUSlw:
#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|lw\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)(VM_memory[RF[rs] + immediate]) << 24) | ((uint32_t)(VM_memory[RF[rs] + immediate + 1]) << 16) | ((uint32_t)(VM_memory[RF[rs] + immediate + 2]) << 8) | ((uint32_t)VM_memory[RF[rs] + immediate + 3]);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


xorPLUSsltiPLUSmovn:
#if INDIRECT_DEBUG
printf("%d|xor\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rs] ^ RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|slti\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] < immediate)?1:0;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|movn\n",counter);
counter++;
#endif

rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
if (RF[rt] != 0) RF[rd] = RF[rs];
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


bnePLUSsllPLUSslt:
#if INDIRECT_DEBUG
printf("%d|bne\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
if (RF[rs] != RF[rt])
{
  immediate = (instr0 >> 0) & 0xFFFF;
  PC  =  nPC;
  nPC  += (immediate << 2);
    if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


}
else
{
  PC  =  nPC;
  nPC  += 4;
}

#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr1 >> 6) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|slt\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = (RF[rs] < RF[rt])?1:0;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


jrPLUSorPLUSaddu:
#if INDIRECT_DEBUG
printf("%d|jr\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
PC = nPC;
nPC = RF[rs];
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;



#if INDIRECT_DEBUG
printf("%d|or\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rs] | RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


lwPLUSswPLUSsll:
#if INDIRECT_DEBUG
printf("%d|lw\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)(VM_memory[RF[rs] + immediate]) << 24) | ((uint32_t)(VM_memory[RF[rs] + immediate + 1]) << 16) | ((uint32_t)(VM_memory[RF[rs] + immediate + 2]) << 8) | ((uint32_t)VM_memory[RF[rs] + immediate + 3]);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sw\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
VM_memory[RF[rs] + immediate] = (uint8_t)((RF[rt] & 0xFF000000) >> 24);
VM_memory[RF[rs] + immediate + 1] = (uint8_t)((RF[rt] & 0xFF0000) >> 16);
VM_memory[RF[rs] + immediate + 2] = (uint8_t)((RF[rt] & 0xFF00) >> 8);
VM_memory[RF[rs] + immediate + 3] = (uint8_t)(RF[rt] & 0xFF);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr2 >> 6) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


addiuPLUSsltPLUSbne:
#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|slt\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = (RF[rs] < RF[rt])?1:0;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|bne\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
if (RF[rs] != RF[rt])
{
  immediate = (instr2 >> 0) & 0xFFFF;
  PC  =  nPC;
  nPC  += (immediate << 2);
    if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


}
else
{
  PC  =  nPC;
  nPC  += 4;
}
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


bnePLUSaddiuPLUSaddiu:
#if INDIRECT_DEBUG
printf("%d|bne\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
if (RF[rs] != RF[rt])
{
  immediate = (instr0 >> 0) & 0xFFFF;
  PC  =  nPC;
  nPC  += (immediate << 2);
    if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


}
else
{
  PC  =  nPC;
  nPC  += 4;
}

#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


bnePLUSxorPLUSnor:
#if INDIRECT_DEBUG
printf("%d|bne\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
if (RF[rs] != RF[rt])
{
  immediate = (instr0 >> 0) & 0xFFFF;
  PC  =  nPC;
  nPC  += (immediate << 2);
    if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


}
else
{
  PC  =  nPC;
  nPC  += 4;
}

#if INDIRECT_DEBUG
printf("%d|xor\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rs] ^ RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|nor\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = ~(RF[rs] | RF[rt]);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


blezPLUSsllPLUSaddiu:
#if INDIRECT_DEBUG
printf("%d|blez\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
if ((int32_t)RF[rs] <= 0)
{
  immediate = (instr0 >> 0) & 0xFFFF;
  PC  =  nPC;
  nPC  += (immediate << 2);
    if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


}
else
{
  PC  =  nPC;
  nPC  += 4;
}

#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr1 >> 6) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


andPLUSsllPLUSori:
#if INDIRECT_DEBUG
printf("%d|and\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rs] & RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr1 >> 6) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|ori\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
RF[rt] = RF[rs] | (uint32_t)immediate;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


addiuPLUSjalPLUSaddu:
#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|jal\n",counter);
counter++;
#endif
RF[31] = PC + 8;
PC = nPC;
address = (instr1 >> 0) & 0x3FFFFFF;
nPC = address << 2;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;



#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


sllPLUSadduPLUSlw:
#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr0 >> 6) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|lw\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)(VM_memory[RF[rs] + immediate]) << 24) | ((uint32_t)(VM_memory[RF[rs] + immediate + 1]) << 16) | ((uint32_t)(VM_memory[RF[rs] + immediate + 2]) << 8) | ((uint32_t)VM_memory[RF[rs] + immediate + 3]);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


bnePLUSaddiuPLUSaddu:
#if INDIRECT_DEBUG
printf("%d|bne\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
if (RF[rs] != RF[rt])
{
  immediate = (instr0 >> 0) & 0xFFFF;
  PC  =  nPC;
  nPC  += (immediate << 2);
    if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


}
else
{
  PC  =  nPC;
  nPC  += 4;
}

#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


addiuPLUSaddiuPLUSjr:
#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|jr\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
PC = nPC;
nPC = RF[rs];
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


oriPLUSandiPLUSxor:
#if INDIRECT_DEBUG
printf("%d|ori\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = RF[rs] | (uint32_t)immediate;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|andi\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = RF[rs] & (uint32_t)immediate;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|xor\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rs] ^ RF[rt];
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


lwPLUSjalPLUSaddu:
#if INDIRECT_DEBUG
printf("%d|lw\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)(VM_memory[RF[rs] + immediate]) << 24) | ((uint32_t)(VM_memory[RF[rs] + immediate + 1]) << 16) | ((uint32_t)(VM_memory[RF[rs] + immediate + 2]) << 8) | ((uint32_t)VM_memory[RF[rs] + immediate + 3]);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|jal\n",counter);
counter++;
#endif
RF[31] = PC + 8;
PC = nPC;
address = (instr1 >> 0) & 0x3FFFFFF;
nPC = address << 2;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;



#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


addiuPLUSbnePLUSaddiu:
#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|bne\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
if (RF[rs] != RF[rt])
{
  immediate = (instr1 >> 0) & 0xFFFF;
  PC  =  nPC;
  nPC  += (immediate << 2);
    if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


}
else
{
  PC  =  nPC;
  nPC  += 4;
}

#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


sltPLUSadduPLUSbne:
#if INDIRECT_DEBUG
printf("%d|slt\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = (RF[rs] < RF[rt])?1:0;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|bne\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
if (RF[rs] != RF[rt])
{
  immediate = (instr2 >> 0) & 0xFFFF;
  PC  =  nPC;
  nPC  += (immediate << 2);
    if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


}
else
{
  PC  =  nPC;
  nPC  += 4;
}
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


sllPLUSswPLUSlui:
#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr0 >> 6) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sw\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
VM_memory[RF[rs] + immediate] = (uint8_t)((RF[rt] & 0xFF000000) >> 24);
VM_memory[RF[rs] + immediate + 1] = (uint8_t)((RF[rt] & 0xFF0000) >> 16);
VM_memory[RF[rs] + immediate + 2] = (uint8_t)((RF[rt] & 0xFF00) >> 8);
VM_memory[RF[rs] + immediate + 3] = (uint8_t)(RF[rt] & 0xFF);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|lui\n",counter);
counter++;
#endif
// NOTHING IMPLEMENTED, COPIED FROM BELOW
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)immediate) << 16;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


swPLUSswPLUSlw:
#if INDIRECT_DEBUG
printf("%d|sw\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
VM_memory[RF[rs] + immediate] = (uint8_t)((RF[rt] & 0xFF000000) >> 24);
VM_memory[RF[rs] + immediate + 1] = (uint8_t)((RF[rt] & 0xFF0000) >> 16);
VM_memory[RF[rs] + immediate + 2] = (uint8_t)((RF[rt] & 0xFF00) >> 8);
VM_memory[RF[rs] + immediate + 3] = (uint8_t)(RF[rt] & 0xFF);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sw\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
VM_memory[RF[rs] + immediate] = (uint8_t)((RF[rt] & 0xFF000000) >> 24);
VM_memory[RF[rs] + immediate + 1] = (uint8_t)((RF[rt] & 0xFF0000) >> 16);
VM_memory[RF[rs] + immediate + 2] = (uint8_t)((RF[rt] & 0xFF00) >> 8);
VM_memory[RF[rs] + immediate + 3] = (uint8_t)(RF[rt] & 0xFF);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|lw\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)(VM_memory[RF[rs] + immediate]) << 24) | ((uint32_t)(VM_memory[RF[rs] + immediate + 1]) << 16) | ((uint32_t)(VM_memory[RF[rs] + immediate + 2]) << 8) | ((uint32_t)VM_memory[RF[rs] + immediate + 3]);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


swPLUSjalPLUSaddiu:
#if INDIRECT_DEBUG
printf("%d|sw\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
VM_memory[RF[rs] + immediate] = (uint8_t)((RF[rt] & 0xFF000000) >> 24);
VM_memory[RF[rs] + immediate + 1] = (uint8_t)((RF[rt] & 0xFF0000) >> 16);
VM_memory[RF[rs] + immediate + 2] = (uint8_t)((RF[rt] & 0xFF00) >> 8);
VM_memory[RF[rs] + immediate + 3] = (uint8_t)(RF[rt] & 0xFF);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|jal\n",counter);
counter++;
#endif
RF[31] = PC + 8;
PC = nPC;
address = (instr1 >> 0) & 0x3FFFFFF;
nPC = address << 2;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;



#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


addiuPLUSsubuPLUSaddiu:
#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|subu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rs] - RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


errorPLUSlwPLUSaddu:
#if INDIRECT_DEBUG
printf("Error, unknown instr0uction %d.\n", instr0);
#endif
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|lw\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)(VM_memory[RF[rs] + immediate]) << 24) | ((uint32_t)(VM_memory[RF[rs] + immediate + 1]) << 16) | ((uint32_t)(VM_memory[RF[rs] + immediate + 2]) << 8) | ((uint32_t)VM_memory[RF[rs] + immediate + 3]);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


oriPLUSaddiuPLUSmult:
#if INDIRECT_DEBUG
printf("%d|ori\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = RF[rs] | (uint32_t)immediate;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|mult\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
mult = (uint64_t)RF[rs] * (uint64_t) RF[rt];
HI = (mult >> 32) & 0xFFFFFFFF;
LO = mult & 0xFFFFFFFF;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


errorPLUSerrorPLUSlw:
#if INDIRECT_DEBUG
printf("Error, unknown instr0uction %d.\n", instr0);
#endif
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("Error, unknown instr1uction %d.\n", instr1);
#endif
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|lw\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)(VM_memory[RF[rs] + immediate]) << 24) | ((uint32_t)(VM_memory[RF[rs] + immediate + 1]) << 16) | ((uint32_t)(VM_memory[RF[rs] + immediate + 2]) << 8) | ((uint32_t)VM_memory[RF[rs] + immediate + 3]);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


orPLUSsrlPLUSlui:
#if INDIRECT_DEBUG
printf("%d|or\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rs] | RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|srl\n",counter);
counter++;
#endif
shamt = (instr1 >> 6) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rt] >> shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|lui\n",counter);
counter++;
#endif
// NOTHING IMPLEMENTED, COPIED FROM BELOW
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)immediate) << 16;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


swPLUSaddiuPLUSsll:
#if INDIRECT_DEBUG
printf("%d|sw\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
VM_memory[RF[rs] + immediate] = (uint8_t)((RF[rt] & 0xFF000000) >> 24);
VM_memory[RF[rs] + immediate + 1] = (uint8_t)((RF[rt] & 0xFF0000) >> 16);
VM_memory[RF[rs] + immediate + 2] = (uint8_t)((RF[rt] & 0xFF00) >> 8);
VM_memory[RF[rs] + immediate + 3] = (uint8_t)(RF[rt] & 0xFF);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr2 >> 6) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


sllPLUSaddiuPLUSsysc:
#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr0 >> 6) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sysc\n",counter);
counter++;
#endif
if (syscall((uint8_t)RF[2])) //registers $4 and $5 useb by hallcall (sensid and retval respectively)
{
halted = 1; //Syscall returned 1, exit code
goto end;
}
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


lwPLUSerrorPLUSaddiu:
#if INDIRECT_DEBUG
printf("%d|lw\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)(VM_memory[RF[rs] + immediate]) << 24) | ((uint32_t)(VM_memory[RF[rs] + immediate + 1]) << 16) | ((uint32_t)(VM_memory[RF[rs] + immediate + 2]) << 8) | ((uint32_t)VM_memory[RF[rs] + immediate + 3]);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("Error, unknown instr1uction %d.\n", instr1);
#endif
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


lwPLUSjrPLUSaddiu:
#if INDIRECT_DEBUG
printf("%d|lw\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)(VM_memory[RF[rs] + immediate]) << 24) | ((uint32_t)(VM_memory[RF[rs] + immediate + 1]) << 16) | ((uint32_t)(VM_memory[RF[rs] + immediate + 2]) << 8) | ((uint32_t)VM_memory[RF[rs] + immediate + 3]);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|jr\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
PC = nPC;
nPC = RF[rs];
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;



#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


norPLUSjrPLUSsll:
#if INDIRECT_DEBUG
printf("%d|nor\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = ~(RF[rs] | RF[rt]);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|jr\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
PC = nPC;
nPC = RF[rs];
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;



#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr2 >> 6) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


addiuPLUSandiPLUSsll:
#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|andi\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = RF[rs] & (uint32_t)immediate;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr2 >> 6) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


bnePLUSsllPLUSsll:
#if INDIRECT_DEBUG
printf("%d|bne\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
if (RF[rs] != RF[rt])
{
  immediate = (instr0 >> 0) & 0xFFFF;
  PC  =  nPC;
  nPC  += (immediate << 2);
    if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


}
else
{
  PC  =  nPC;
  nPC  += 4;
}

#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr1 >> 6) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr2 >> 6) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


xorPLUSswPLUSbne:
#if INDIRECT_DEBUG
printf("%d|xor\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rs] ^ RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sw\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
VM_memory[RF[rs] + immediate] = (uint8_t)((RF[rt] & 0xFF000000) >> 24);
VM_memory[RF[rs] + immediate + 1] = (uint8_t)((RF[rt] & 0xFF0000) >> 16);
VM_memory[RF[rs] + immediate + 2] = (uint8_t)((RF[rt] & 0xFF00) >> 8);
VM_memory[RF[rs] + immediate + 3] = (uint8_t)(RF[rt] & 0xFF);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|bne\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
if (RF[rs] != RF[rt])
{
  immediate = (instr2 >> 0) & 0xFFFF;
  PC  =  nPC;
  nPC  += (immediate << 2);
    if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


}
else
{
  PC  =  nPC;
  nPC  += 4;
}
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


lwPLUSsltPLUSbeq:
#if INDIRECT_DEBUG
printf("%d|lw\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)(VM_memory[RF[rs] + immediate]) << 24) | ((uint32_t)(VM_memory[RF[rs] + immediate + 1]) << 16) | ((uint32_t)(VM_memory[RF[rs] + immediate + 2]) << 8) | ((uint32_t)VM_memory[RF[rs] + immediate + 3]);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|slt\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = (RF[rs] < RF[rt])?1:0;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|beq\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
if (RF[rs] == RF[rt])
{
  immediate = (instr2 >> 0) & 0xFFFF;
  PC  =  nPC;
  nPC  += (immediate << 2);
    if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


}
else
{
  PC  =  nPC;
  nPC  += 4;
}
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


adduPLUSaddiuPLUSlw:
#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|lw\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)(VM_memory[RF[rs] + immediate]) << 24) | ((uint32_t)(VM_memory[RF[rs] + immediate + 1]) << 16) | ((uint32_t)(VM_memory[RF[rs] + immediate + 2]) << 8) | ((uint32_t)VM_memory[RF[rs] + immediate + 3]);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


lwPLUSaddiuPLUSslti:
#if INDIRECT_DEBUG
printf("%d|lw\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)(VM_memory[RF[rs] + immediate]) << 24) | ((uint32_t)(VM_memory[RF[rs] + immediate + 1]) << 16) | ((uint32_t)(VM_memory[RF[rs] + immediate + 2]) << 8) | ((uint32_t)VM_memory[RF[rs] + immediate + 3]);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|slti\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] < immediate)?1:0;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


xorPLUSerrorPLUSaddiu:
#if INDIRECT_DEBUG
printf("%d|xor\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rs] ^ RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("Error, unknown instr1uction %d.\n", instr1);
#endif
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


addiuPLUSsltiPLUSbeq:
#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|slti\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] < immediate)?1:0;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|beq\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
if (RF[rs] == RF[rt])
{
  immediate = (instr2 >> 0) & 0xFFFF;
  PC  =  nPC;
  nPC  += (immediate << 2);
    if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


}
else
{
  PC  =  nPC;
  nPC  += 4;
}
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


lwPLUSlwPLUSaddu:
#if INDIRECT_DEBUG
printf("%d|lw\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)(VM_memory[RF[rs] + immediate]) << 24) | ((uint32_t)(VM_memory[RF[rs] + immediate + 1]) << 16) | ((uint32_t)(VM_memory[RF[rs] + immediate + 2]) << 8) | ((uint32_t)VM_memory[RF[rs] + immediate + 3]);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|lw\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)(VM_memory[RF[rs] + immediate]) << 24) | ((uint32_t)(VM_memory[RF[rs] + immediate + 1]) << 16) | ((uint32_t)(VM_memory[RF[rs] + immediate + 2]) << 8) | ((uint32_t)VM_memory[RF[rs] + immediate + 3]);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


luiPLUSaddiuPLUSsysc:
#if INDIRECT_DEBUG
printf("%d|lui\n",counter);
counter++;
#endif
// NOTHING IMPLEMENTED, COPIED FROM BELOW
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)immediate) << 16;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sysc\n",counter);
counter++;
#endif
if (syscall((uint8_t)RF[2])) //registers $4 and $5 useb by hallcall (sensid and retval respectively)
{
halted = 1; //Syscall returned 1, exit code
goto end;
}
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


bnePLUSadduPLUSerror:
#if INDIRECT_DEBUG
printf("%d|bne\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
if (RF[rs] != RF[rt])
{
  immediate = (instr0 >> 0) & 0xFFFF;
  PC  =  nPC;
  nPC  += (immediate << 2);
    if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


}
else
{
  PC  =  nPC;
  nPC  += 4;
}

#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("Error, unknown instr2uction %d.\n", instr2);
#endif
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


bnePLUSswPLUSaddu:
#if INDIRECT_DEBUG
printf("%d|bne\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
if (RF[rs] != RF[rt])
{
  immediate = (instr0 >> 0) & 0xFFFF;
  PC  =  nPC;
  nPC  += (immediate << 2);
    if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


}
else
{
  PC  =  nPC;
  nPC  += 4;
}

#if INDIRECT_DEBUG
printf("%d|sw\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
VM_memory[RF[rs] + immediate] = (uint8_t)((RF[rt] & 0xFF000000) >> 24);
VM_memory[RF[rs] + immediate + 1] = (uint8_t)((RF[rt] & 0xFF0000) >> 16);
VM_memory[RF[rs] + immediate + 2] = (uint8_t)((RF[rt] & 0xFF00) >> 8);
VM_memory[RF[rs] + immediate + 3] = (uint8_t)(RF[rt] & 0xFF);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


addiuPLUSjumpPLUSaddu:
#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|jump\n",counter);
counter++;
#endif
PC = nPC;
address = (instr1 >> 0) & 0x3FFFFFF;
nPC = address << 2;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;



#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


addiuPLUSaddiuPLUSsubu:
#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|subu\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rs] - RF[rt];
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


srlPLUSoriPLUSand:
#if INDIRECT_DEBUG
printf("%d|srl\n",counter);
counter++;
#endif
shamt = (instr0 >> 6) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rt] >> shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|ori\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = RF[rs] | (uint32_t)immediate;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|and\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rs] & RF[rt];
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


blezPLUSsllPLUSaddu:
#if INDIRECT_DEBUG
printf("%d|blez\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
if ((int32_t)RF[rs] <= 0)
{
  immediate = (instr0 >> 0) & 0xFFFF;
  PC  =  nPC;
  nPC  += (immediate << 2);
    if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


}
else
{
  PC  =  nPC;
  nPC  += 4;
}

#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr1 >> 6) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


errorPLUSaddiuPLUSaddu:
#if INDIRECT_DEBUG
printf("Error, unknown instr0uction %d.\n", instr0);
#endif
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


addiuPLUSswPLUSaddiu:
#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sw\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
VM_memory[RF[rs] + immediate] = (uint8_t)((RF[rt] & 0xFF000000) >> 24);
VM_memory[RF[rs] + immediate + 1] = (uint8_t)((RF[rt] & 0xFF0000) >> 16);
VM_memory[RF[rs] + immediate + 2] = (uint8_t)((RF[rt] & 0xFF00) >> 8);
VM_memory[RF[rs] + immediate + 3] = (uint8_t)(RF[rt] & 0xFF);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


lwPLUSswPLUSlw:
#if INDIRECT_DEBUG
printf("%d|lw\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)(VM_memory[RF[rs] + immediate]) << 24) | ((uint32_t)(VM_memory[RF[rs] + immediate + 1]) << 16) | ((uint32_t)(VM_memory[RF[rs] + immediate + 2]) << 8) | ((uint32_t)VM_memory[RF[rs] + immediate + 3]);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sw\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
VM_memory[RF[rs] + immediate] = (uint8_t)((RF[rt] & 0xFF000000) >> 24);
VM_memory[RF[rs] + immediate + 1] = (uint8_t)((RF[rt] & 0xFF0000) >> 16);
VM_memory[RF[rs] + immediate + 2] = (uint8_t)((RF[rt] & 0xFF00) >> 8);
VM_memory[RF[rs] + immediate + 3] = (uint8_t)(RF[rt] & 0xFF);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|lw\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)(VM_memory[RF[rs] + immediate]) << 24) | ((uint32_t)(VM_memory[RF[rs] + immediate + 1]) << 16) | ((uint32_t)(VM_memory[RF[rs] + immediate + 2]) << 8) | ((uint32_t)VM_memory[RF[rs] + immediate + 3]);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


sllPLUSorPLUSsll:
#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr0 >> 6) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|or\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rs] | RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr2 >> 6) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


xorPLUSsllPLUSxor:
#if INDIRECT_DEBUG
printf("%d|xor\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rs] ^ RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr1 >> 6) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|xor\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rs] ^ RF[rt];
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


sllPLUSjumpPLUSsll:
#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr0 >> 6) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|jump\n",counter);
counter++;
#endif
PC = nPC;
address = (instr1 >> 0) & 0x3FFFFFF;
nPC = address << 2;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;



#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr2 >> 6) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


sllPLUSjumpPLUSaddu:
#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr0 >> 6) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|jump\n",counter);
counter++;
#endif
PC = nPC;
address = (instr1 >> 0) & 0x3FFFFFF;
nPC = address << 2;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;



#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


orPLUSadduPLUSjal:
#if INDIRECT_DEBUG
printf("%d|or\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rs] | RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|jal\n",counter);
counter++;
#endif
RF[31] = PC + 8;
PC = nPC;
address = (instr2 >> 0) & 0x3FFFFFF;
nPC = address << 2;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


sllPLUSblezPLUSaddiu:
#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr0 >> 6) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|blez\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
if ((int32_t)RF[rs] <= 0)
{
  immediate = (instr1 >> 0) & 0xFFFF;
  PC  =  nPC;
  nPC  += (immediate << 2);
    if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


}
else
{
  PC  =  nPC;
  nPC  += 4;
}

#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


addiuPLUSbnePLUSsll:
#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|bne\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
if (RF[rs] != RF[rt])
{
  immediate = (instr1 >> 0) & 0xFFFF;
  PC  =  nPC;
  nPC  += (immediate << 2);
    if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


}
else
{
  PC  =  nPC;
  nPC  += 4;
}

#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr2 >> 6) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


xorPLUSandiPLUSsll:
#if INDIRECT_DEBUG
printf("%d|xor\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rs] ^ RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|andi\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = RF[rs] & (uint32_t)immediate;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr2 >> 6) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


andPLUSsrlPLUSerror:
#if INDIRECT_DEBUG
printf("%d|and\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rs] & RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|srl\n",counter);
counter++;
#endif
shamt = (instr1 >> 6) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rt] >> shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("Error, unknown instr2uction %d.\n", instr2);
#endif
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


sllPLUSlwPLUSxor:
#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr0 >> 6) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|lw\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)(VM_memory[RF[rs] + immediate]) << 24) | ((uint32_t)(VM_memory[RF[rs] + immediate + 1]) << 16) | ((uint32_t)(VM_memory[RF[rs] + immediate + 2]) << 8) | ((uint32_t)VM_memory[RF[rs] + immediate + 3]);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|xor\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rs] ^ RF[rt];
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


sllPLUSsltiPLUSbne:
#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr0 >> 6) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|slti\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] < immediate)?1:0;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|bne\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
if (RF[rs] != RF[rt])
{
  immediate = (instr2 >> 0) & 0xFFFF;
  PC  =  nPC;
  nPC  += (immediate << 2);
    if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


}
else
{
  PC  =  nPC;
  nPC  += 4;
}
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


movnPLUSandiPLUSor:
#if INDIRECT_DEBUG
printf("%d|movn\n",counter);
counter++;
#endif

rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
if (RF[rt] != 0) RF[rd] = RF[rs];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|andi\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = RF[rs] & (uint32_t)immediate;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|or\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rs] | RF[rt];
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


xorPLUSnorPLUSjr:
#if INDIRECT_DEBUG
printf("%d|xor\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rs] ^ RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|nor\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = ~(RF[rs] | RF[rt]);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|jr\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
PC = nPC;
nPC = RF[rs];
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


addiuPLUSbeqPLUSsw:
#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|beq\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
if (RF[rs] == RF[rt])
{
  immediate = (instr1 >> 0) & 0xFFFF;
  PC  =  nPC;
  nPC  += (immediate << 2);
    if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


}
else
{
  PC  =  nPC;
  nPC  += 4;
}

#if INDIRECT_DEBUG
printf("%d|sw\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
VM_memory[RF[rs] + immediate] = (uint8_t)((RF[rt] & 0xFF000000) >> 24);
VM_memory[RF[rs] + immediate + 1] = (uint8_t)((RF[rt] & 0xFF0000) >> 16);
VM_memory[RF[rs] + immediate + 2] = (uint8_t)((RF[rt] & 0xFF00) >> 8);
VM_memory[RF[rs] + immediate + 3] = (uint8_t)(RF[rt] & 0xFF);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


addiuPLUSsllPLUSandi:
#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr1 >> 6) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|andi\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
RF[rt] = RF[rs] & (uint32_t)immediate;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


beqPLUSaddiuPLUSsll:
#if INDIRECT_DEBUG
printf("%d|beq\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
if (RF[rs] == RF[rt])
{
  immediate = (instr0 >> 0) & 0xFFFF;
  PC  =  nPC;
  nPC  += (immediate << 2);
    if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


}
else
{
  PC  =  nPC;
  nPC  += 4;
}

#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr2 >> 6) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


lwPLUSsltuPLUSbeq:
#if INDIRECT_DEBUG
printf("%d|lw\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)(VM_memory[RF[rs] + immediate]) << 24) | ((uint32_t)(VM_memory[RF[rs] + immediate + 1]) << 16) | ((uint32_t)(VM_memory[RF[rs] + immediate + 2]) << 8) | ((uint32_t)VM_memory[RF[rs] + immediate + 3]);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sltu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = (RF[rs] < RF[rt])?1:0;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|beq\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
if (RF[rs] == RF[rt])
{
  immediate = (instr2 >> 0) & 0xFFFF;
  PC  =  nPC;
  nPC  += (immediate << 2);
    if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


}
else
{
  PC  =  nPC;
  nPC  += 4;
}
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


jumpPLUSswPLUSslti:
#if INDIRECT_DEBUG
printf("%d|jump\n",counter);
counter++;
#endif
PC = nPC;
address = (instr0 >> 0) & 0x3FFFFFF;
nPC = address << 2;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;



#if INDIRECT_DEBUG
printf("%d|sw\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
VM_memory[RF[rs] + immediate] = (uint8_t)((RF[rt] & 0xFF000000) >> 24);
VM_memory[RF[rs] + immediate + 1] = (uint8_t)((RF[rt] & 0xFF0000) >> 16);
VM_memory[RF[rs] + immediate + 2] = (uint8_t)((RF[rt] & 0xFF00) >> 8);
VM_memory[RF[rs] + immediate + 3] = (uint8_t)(RF[rt] & 0xFF);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|slti\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] < immediate)?1:0;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


adduPLUSadduPLUSjump:
#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|jump\n",counter);
counter++;
#endif
PC = nPC;
address = (instr2 >> 0) & 0x3FFFFFF;
nPC = address << 2;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


lwPLUSaddiuPLUSsw:
#if INDIRECT_DEBUG
printf("%d|lw\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)(VM_memory[RF[rs] + immediate]) << 24) | ((uint32_t)(VM_memory[RF[rs] + immediate + 1]) << 16) | ((uint32_t)(VM_memory[RF[rs] + immediate + 2]) << 8) | ((uint32_t)VM_memory[RF[rs] + immediate + 3]);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sw\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
VM_memory[RF[rs] + immediate] = (uint8_t)((RF[rt] & 0xFF000000) >> 24);
VM_memory[RF[rs] + immediate + 1] = (uint8_t)((RF[rt] & 0xFF0000) >> 16);
VM_memory[RF[rs] + immediate + 2] = (uint8_t)((RF[rt] & 0xFF00) >> 8);
VM_memory[RF[rs] + immediate + 3] = (uint8_t)(RF[rt] & 0xFF);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


sllPLUSxorPLUSxor:
#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr0 >> 6) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|xor\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rs] ^ RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|xor\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rs] ^ RF[rt];
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


luiPLUSaddiuPLUSlw:
#if INDIRECT_DEBUG
printf("%d|lui\n",counter);
counter++;
#endif
// NOTHING IMPLEMENTED, COPIED FROM BELOW
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)immediate) << 16;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|lw\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)(VM_memory[RF[rs] + immediate]) << 24) | ((uint32_t)(VM_memory[RF[rs] + immediate + 1]) << 16) | ((uint32_t)(VM_memory[RF[rs] + immediate + 2]) << 8) | ((uint32_t)VM_memory[RF[rs] + immediate + 3]);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


srlPLUSxorPLUSerror:
#if INDIRECT_DEBUG
printf("%d|srl\n",counter);
counter++;
#endif
shamt = (instr0 >> 6) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rt] >> shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|xor\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rs] ^ RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("Error, unknown instr2uction %d.\n", instr2);
#endif
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


addiuPLUSblezPLUSaddiu:
#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|blez\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
if ((int32_t)RF[rs] <= 0)
{
  immediate = (instr1 >> 0) & 0xFFFF;
  PC  =  nPC;
  nPC  += (immediate << 2);
    if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


}
else
{
  PC  =  nPC;
  nPC  += 4;
}

#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


syscPLUSjrPLUSsll:
#if INDIRECT_DEBUG
printf("%d|sysc\n",counter);
counter++;
#endif
if (syscall((uint8_t)RF[2])) //registers $4 and $5 useb by hallcall (sensid and retval respectively)
{
halted = 1; //Syscall returned 1, exit code
goto end;
}
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|jr\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
PC = nPC;
nPC = RF[rs];
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;



#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr2 >> 6) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


bnePLUSsllPLUSlw:
#if INDIRECT_DEBUG
printf("%d|bne\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
if (RF[rs] != RF[rt])
{
  immediate = (instr0 >> 0) & 0xFFFF;
  PC  =  nPC;
  nPC  += (immediate << 2);
    if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


}
else
{
  PC  =  nPC;
  nPC  += 4;
}

#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr1 >> 6) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|lw\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)(VM_memory[RF[rs] + immediate]) << 24) | ((uint32_t)(VM_memory[RF[rs] + immediate + 1]) << 16) | ((uint32_t)(VM_memory[RF[rs] + immediate + 2]) << 8) | ((uint32_t)VM_memory[RF[rs] + immediate + 3]);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


xorPLUSsrlPLUSerror:
#if INDIRECT_DEBUG
printf("%d|xor\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rs] ^ RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|srl\n",counter);
counter++;
#endif
shamt = (instr1 >> 6) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rt] >> shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("Error, unknown instr2uction %d.\n", instr2);
#endif
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


luiPLUSaddiuPLUSaddiu:
#if INDIRECT_DEBUG
printf("%d|lui\n",counter);
counter++;
#endif
// NOTHING IMPLEMENTED, COPIED FROM BELOW
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)immediate) << 16;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


addiuPLUSlwPLUSsltu:
#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|lw\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)(VM_memory[RF[rs] + immediate]) << 24) | ((uint32_t)(VM_memory[RF[rs] + immediate + 1]) << 16) | ((uint32_t)(VM_memory[RF[rs] + immediate + 2]) << 8) | ((uint32_t)VM_memory[RF[rs] + immediate + 3]);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sltu\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = (RF[rs] < RF[rt])?1:0;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


adduPLUSsllPLUSaddu:
#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr1 >> 6) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


sllPLUSluiPLUSjal:
#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr0 >> 6) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|lui\n",counter);
counter++;
#endif
// NOTHING IMPLEMENTED, COPIED FROM BELOW
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)immediate) << 16;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|jal\n",counter);
counter++;
#endif
RF[31] = PC + 8;
PC = nPC;
address = (instr2 >> 0) & 0x3FFFFFF;
nPC = address << 2;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


sllPLUSmultPLUSmfhi:
#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr0 >> 6) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|mult\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
mult = (uint64_t)RF[rs] * (uint64_t) RF[rt];
HI = (mult >> 32) & 0xFFFFFFFF;
LO = mult & 0xFFFFFFFF;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|mfhi\n",counter);
counter++;
#endif
rd = (instr2 >> 11) & 0x1F;
RF[rd] = HI;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


sltiPLUSbnePLUSsll:
#if INDIRECT_DEBUG
printf("%d|slti\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] < immediate)?1:0;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|bne\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
if (RF[rs] != RF[rt])
{
  immediate = (instr1 >> 0) & 0xFFFF;
  PC  =  nPC;
  nPC  += (immediate << 2);
    if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


}
else
{
  PC  =  nPC;
  nPC  += 4;
}

#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr2 >> 6) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


swPLUSsltiPLUSbne:
#if INDIRECT_DEBUG
printf("%d|sw\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
VM_memory[RF[rs] + immediate] = (uint8_t)((RF[rt] & 0xFF000000) >> 24);
VM_memory[RF[rs] + immediate + 1] = (uint8_t)((RF[rt] & 0xFF0000) >> 16);
VM_memory[RF[rs] + immediate + 2] = (uint8_t)((RF[rt] & 0xFF00) >> 8);
VM_memory[RF[rs] + immediate + 3] = (uint8_t)(RF[rt] & 0xFF);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|slti\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] < immediate)?1:0;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|bne\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
if (RF[rs] != RF[rt])
{
  immediate = (instr2 >> 0) & 0xFFFF;
  PC  =  nPC;
  nPC  += (immediate << 2);
    if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


}
else
{
  PC  =  nPC;
  nPC  += 4;
}
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


bnePLUSsllPLUSaddiu:
#if INDIRECT_DEBUG
printf("%d|bne\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
if (RF[rs] != RF[rt])
{
  immediate = (instr0 >> 0) & 0xFFFF;
  PC  =  nPC;
  nPC  += (immediate << 2);
    if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


}
else
{
  PC  =  nPC;
  nPC  += 4;
}

#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr1 >> 6) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


orPLUSsllPLUSsb:
#if INDIRECT_DEBUG
printf("%d|or\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rs] | RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr1 >> 6) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sb\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
VM_memory[RF[rs] + immediate] = (uint8_t)(RF[rt] & 0xFF);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


luiPLUSjalPLUSaddiu:
#if INDIRECT_DEBUG
printf("%d|lui\n",counter);
counter++;
#endif
// NOTHING IMPLEMENTED, COPIED FROM BELOW
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)immediate) << 16;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|jal\n",counter);
counter++;
#endif
RF[31] = PC + 8;
PC = nPC;
address = (instr1 >> 0) & 0x3FFFFFF;
nPC = address << 2;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;



#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


addiuPLUSswPLUSlw:
#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sw\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
VM_memory[RF[rs] + immediate] = (uint8_t)((RF[rt] & 0xFF000000) >> 24);
VM_memory[RF[rs] + immediate + 1] = (uint8_t)((RF[rt] & 0xFF0000) >> 16);
VM_memory[RF[rs] + immediate + 2] = (uint8_t)((RF[rt] & 0xFF00) >> 8);
VM_memory[RF[rs] + immediate + 3] = (uint8_t)(RF[rt] & 0xFF);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|lw\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)(VM_memory[RF[rs] + immediate]) << 24) | ((uint32_t)(VM_memory[RF[rs] + immediate + 1]) << 16) | ((uint32_t)(VM_memory[RF[rs] + immediate + 2]) << 8) | ((uint32_t)VM_memory[RF[rs] + immediate + 3]);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


addiuPLUSsltuPLUSbeq:
#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sltu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = (RF[rs] < RF[rt])?1:0;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|beq\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
if (RF[rs] == RF[rt])
{
  immediate = (instr2 >> 0) & 0xFFFF;
  PC  =  nPC;
  nPC  += (immediate << 2);
    if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


}
else
{
  PC  =  nPC;
  nPC  += 4;
}
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


bnePLUSaddiuPLUSsw:
#if INDIRECT_DEBUG
printf("%d|bne\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
if (RF[rs] != RF[rt])
{
  immediate = (instr0 >> 0) & 0xFFFF;
  PC  =  nPC;
  nPC  += (immediate << 2);
    if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


}
else
{
  PC  =  nPC;
  nPC  += 4;
}

#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sw\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
VM_memory[RF[rs] + immediate] = (uint8_t)((RF[rt] & 0xFF000000) >> 24);
VM_memory[RF[rs] + immediate + 1] = (uint8_t)((RF[rt] & 0xFF0000) >> 16);
VM_memory[RF[rs] + immediate + 2] = (uint8_t)((RF[rt] & 0xFF00) >> 8);
VM_memory[RF[rs] + immediate + 3] = (uint8_t)(RF[rt] & 0xFF);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


addiuPLUSaddiuPLUSjump:
#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|jump\n",counter);
counter++;
#endif
PC = nPC;
address = (instr2 >> 0) & 0x3FFFFFF;
nPC = address << 2;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


adduPLUSbnePLUSaddu:
#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|bne\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
if (RF[rs] != RF[rt])
{
  immediate = (instr1 >> 0) & 0xFFFF;
  PC  =  nPC;
  nPC  += (immediate << 2);
    if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


}
else
{
  PC  =  nPC;
  nPC  += 4;
}

#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


xorPLUSbnePLUSaddu:
#if INDIRECT_DEBUG
printf("%d|xor\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rs] ^ RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|bne\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
if (RF[rs] != RF[rt])
{
  immediate = (instr1 >> 0) & 0xFFFF;
  PC  =  nPC;
  nPC  += (immediate << 2);
    if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


}
else
{
  PC  =  nPC;
  nPC  += 4;
}

#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


xorPLUSxorPLUSxor:
#if INDIRECT_DEBUG
printf("%d|xor\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rs] ^ RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|xor\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rs] ^ RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|xor\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rs] ^ RF[rt];
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


errorPLUSaddiuPLUSaddiu:
#if INDIRECT_DEBUG
printf("Error, unknown instr0uction %d.\n", instr0);
#endif
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


lwPLUSswPLUSsw:
#if INDIRECT_DEBUG
printf("%d|lw\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)(VM_memory[RF[rs] + immediate]) << 24) | ((uint32_t)(VM_memory[RF[rs] + immediate + 1]) << 16) | ((uint32_t)(VM_memory[RF[rs] + immediate + 2]) << 8) | ((uint32_t)VM_memory[RF[rs] + immediate + 3]);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sw\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
VM_memory[RF[rs] + immediate] = (uint8_t)((RF[rt] & 0xFF000000) >> 24);
VM_memory[RF[rs] + immediate + 1] = (uint8_t)((RF[rt] & 0xFF0000) >> 16);
VM_memory[RF[rs] + immediate + 2] = (uint8_t)((RF[rt] & 0xFF00) >> 8);
VM_memory[RF[rs] + immediate + 3] = (uint8_t)(RF[rt] & 0xFF);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sw\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
VM_memory[RF[rs] + immediate] = (uint8_t)((RF[rt] & 0xFF000000) >> 24);
VM_memory[RF[rs] + immediate + 1] = (uint8_t)((RF[rt] & 0xFF0000) >> 16);
VM_memory[RF[rs] + immediate + 2] = (uint8_t)((RF[rt] & 0xFF00) >> 8);
VM_memory[RF[rs] + immediate + 3] = (uint8_t)(RF[rt] & 0xFF);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


subuPLUSandPLUSandi:
#if INDIRECT_DEBUG
printf("%d|subu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rs] - RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|and\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rs] & RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|andi\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
RF[rt] = RF[rs] & (uint32_t)immediate;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


syscPLUSjalPLUSsll:
#if INDIRECT_DEBUG
printf("%d|sysc\n",counter);
counter++;
#endif
if (syscall((uint8_t)RF[2])) //registers $4 and $5 useb by hallcall (sensid and retval respectively)
{
halted = 1; //Syscall returned 1, exit code
goto end;
}
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|jal\n",counter);
counter++;
#endif
RF[31] = PC + 8;
PC = nPC;
address = (instr1 >> 0) & 0x3FFFFFF;
nPC = address << 2;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;



#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr2 >> 6) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


sllPLUSadduPLUSsrl:
#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr0 >> 6) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|srl\n",counter);
counter++;
#endif
shamt = (instr2 >> 6) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rt] >> shamt;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


sllPLUSaddiuPLUSbne:
#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr0 >> 6) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|bne\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
if (RF[rs] != RF[rt])
{
  immediate = (instr2 >> 0) & 0xFFFF;
  PC  =  nPC;
  nPC  += (immediate << 2);
    if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


}
else
{
  PC  =  nPC;
  nPC  += 4;
}
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


andiPLUSsllPLUSxor:
#if INDIRECT_DEBUG
printf("%d|andi\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = RF[rs] & (uint32_t)immediate;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr1 >> 6) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|xor\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rs] ^ RF[rt];
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


beqPLUSaddiuPLUSaddu:
#if INDIRECT_DEBUG
printf("%d|beq\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
if (RF[rs] == RF[rt])
{
  immediate = (instr0 >> 0) & 0xFFFF;
  PC  =  nPC;
  nPC  += (immediate << 2);
    if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


}
else
{
  PC  =  nPC;
  nPC  += 4;
}

#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


orPLUSluiPLUSlui:
#if INDIRECT_DEBUG
printf("%d|or\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rs] | RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|lui\n",counter);
counter++;
#endif
// NOTHING IMPLEMENTED, COPIED FROM BELOW
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)immediate) << 16;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|lui\n",counter);
counter++;
#endif
// NOTHING IMPLEMENTED, COPIED FROM BELOW
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)immediate) << 16;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


lwPLUSlwPLUSsltu:
#if INDIRECT_DEBUG
printf("%d|lw\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)(VM_memory[RF[rs] + immediate]) << 24) | ((uint32_t)(VM_memory[RF[rs] + immediate + 1]) << 16) | ((uint32_t)(VM_memory[RF[rs] + immediate + 2]) << 8) | ((uint32_t)VM_memory[RF[rs] + immediate + 3]);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|lw\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)(VM_memory[RF[rs] + immediate]) << 24) | ((uint32_t)(VM_memory[RF[rs] + immediate + 1]) << 16) | ((uint32_t)(VM_memory[RF[rs] + immediate + 2]) << 8) | ((uint32_t)VM_memory[RF[rs] + immediate + 3]);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sltu\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = (RF[rs] < RF[rt])?1:0;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


addiuPLUSsltiPLUSbne:
#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|slti\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] < immediate)?1:0;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|bne\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
if (RF[rs] != RF[rt])
{
  immediate = (instr2 >> 0) & 0xFFFF;
  PC  =  nPC;
  nPC  += (immediate << 2);
    if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


}
else
{
  PC  =  nPC;
  nPC  += 4;
}
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


sllPLUSoriPLUSand:
#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr0 >> 6) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|ori\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = RF[rs] | (uint32_t)immediate;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|and\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rs] & RF[rt];
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


adduPLUSjumpPLUSsll:
#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|jump\n",counter);
counter++;
#endif
PC = nPC;
address = (instr1 >> 0) & 0x3FFFFFF;
nPC = address << 2;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;



#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr2 >> 6) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


sllPLUSsllPLUSaddu:
#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr0 >> 6) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr1 >> 6) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


sllPLUSandiPLUSor:
#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr0 >> 6) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|andi\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = RF[rs] & (uint32_t)immediate;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|or\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rs] | RF[rt];
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


bnePLUSsllPLUSandi:
#if INDIRECT_DEBUG
printf("%d|bne\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
if (RF[rs] != RF[rt])
{
  immediate = (instr0 >> 0) & 0xFFFF;
  PC  =  nPC;
  nPC  += (immediate << 2);
    if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


}
else
{
  PC  =  nPC;
  nPC  += 4;
}

#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr1 >> 6) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|andi\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
RF[rt] = RF[rs] & (uint32_t)immediate;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


luiPLUSoriPLUSaddiu:
#if INDIRECT_DEBUG
printf("%d|lui\n",counter);
counter++;
#endif
// NOTHING IMPLEMENTED, COPIED FROM BELOW
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)immediate) << 16;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|ori\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = RF[rs] | (uint32_t)immediate;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


addiuPLUSaddiuPLUSaddu:
#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


sllPLUSadduPLUSjal:
#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr0 >> 6) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|jal\n",counter);
counter++;
#endif
RF[31] = PC + 8;
PC = nPC;
address = (instr2 >> 0) & 0x3FFFFFF;
nPC = address << 2;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


lwPLUSadduPLUSlw:
#if INDIRECT_DEBUG
printf("%d|lw\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)(VM_memory[RF[rs] + immediate]) << 24) | ((uint32_t)(VM_memory[RF[rs] + immediate + 1]) << 16) | ((uint32_t)(VM_memory[RF[rs] + immediate + 2]) << 8) | ((uint32_t)VM_memory[RF[rs] + immediate + 3]);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|lw\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)(VM_memory[RF[rs] + immediate]) << 24) | ((uint32_t)(VM_memory[RF[rs] + immediate + 1]) << 16) | ((uint32_t)(VM_memory[RF[rs] + immediate + 2]) << 8) | ((uint32_t)VM_memory[RF[rs] + immediate + 3]);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


swPLUSaddiuPLUSjal:
#if INDIRECT_DEBUG
printf("%d|sw\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
VM_memory[RF[rs] + immediate] = (uint8_t)((RF[rt] & 0xFF000000) >> 24);
VM_memory[RF[rs] + immediate + 1] = (uint8_t)((RF[rt] & 0xFF0000) >> 16);
VM_memory[RF[rs] + immediate + 2] = (uint8_t)((RF[rt] & 0xFF00) >> 8);
VM_memory[RF[rs] + immediate + 3] = (uint8_t)(RF[rt] & 0xFF);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|jal\n",counter);
counter++;
#endif
RF[31] = PC + 8;
PC = nPC;
address = (instr2 >> 0) & 0x3FFFFFF;
nPC = address << 2;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


lwPLUSjumpPLUSsll:
#if INDIRECT_DEBUG
printf("%d|lw\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)(VM_memory[RF[rs] + immediate]) << 24) | ((uint32_t)(VM_memory[RF[rs] + immediate + 1]) << 16) | ((uint32_t)(VM_memory[RF[rs] + immediate + 2]) << 8) | ((uint32_t)VM_memory[RF[rs] + immediate + 3]);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|jump\n",counter);
counter++;
#endif
PC = nPC;
address = (instr1 >> 0) & 0x3FFFFFF;
nPC = address << 2;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;



#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr2 >> 6) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


subuPLUSaddiuPLUSjump:
#if INDIRECT_DEBUG
printf("%d|subu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rs] - RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|jump\n",counter);
counter++;
#endif
PC = nPC;
address = (instr2 >> 0) & 0x3FFFFFF;
nPC = address << 2;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


sllPLUSadduPLUSsubu:
#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr0 >> 6) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|subu\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rs] - RF[rt];
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


bgtzPLUSsllPLUSsll:
#if INDIRECT_DEBUG
printf("%d|bgtz\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
if ((int32_t)RF[rs] > 0)
{
  immediate = (instr0 >> 0) & 0xFFFF;
  PC  =  nPC;
  nPC  += (immediate << 2);
    if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


}
else
{
  PC  =  nPC;
  nPC  += 4;
}

#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr1 >> 6) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr2 >> 6) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


sllPLUSswPLUSaddu:
#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr0 >> 6) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sw\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
VM_memory[RF[rs] + immediate] = (uint8_t)((RF[rt] & 0xFF000000) >> 24);
VM_memory[RF[rs] + immediate + 1] = (uint8_t)((RF[rt] & 0xFF0000) >> 16);
VM_memory[RF[rs] + immediate + 2] = (uint8_t)((RF[rt] & 0xFF00) >> 8);
VM_memory[RF[rs] + immediate + 3] = (uint8_t)(RF[rt] & 0xFF);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


sllPLUSswPLUSslti:
#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr0 >> 6) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sw\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
VM_memory[RF[rs] + immediate] = (uint8_t)((RF[rt] & 0xFF000000) >> 24);
VM_memory[RF[rs] + immediate + 1] = (uint8_t)((RF[rt] & 0xFF0000) >> 16);
VM_memory[RF[rs] + immediate + 2] = (uint8_t)((RF[rt] & 0xFF00) >> 8);
VM_memory[RF[rs] + immediate + 3] = (uint8_t)(RF[rt] & 0xFF);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|slti\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] < immediate)?1:0;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


adduPLUSlwPLUSjump:
#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|lw\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)(VM_memory[RF[rs] + immediate]) << 24) | ((uint32_t)(VM_memory[RF[rs] + immediate + 1]) << 16) | ((uint32_t)(VM_memory[RF[rs] + immediate + 2]) << 8) | ((uint32_t)VM_memory[RF[rs] + immediate + 3]);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|jump\n",counter);
counter++;
#endif
PC = nPC;
address = (instr2 >> 0) & 0x3FFFFFF;
nPC = address << 2;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


sllPLUSxorPLUSsrl:
#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr0 >> 6) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|xor\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rs] ^ RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|srl\n",counter);
counter++;
#endif
shamt = (instr2 >> 6) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rt] >> shamt;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


subuPLUSswPLUSsw:
#if INDIRECT_DEBUG
printf("%d|subu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rs] - RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sw\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
VM_memory[RF[rs] + immediate] = (uint8_t)((RF[rt] & 0xFF000000) >> 24);
VM_memory[RF[rs] + immediate + 1] = (uint8_t)((RF[rt] & 0xFF0000) >> 16);
VM_memory[RF[rs] + immediate + 2] = (uint8_t)((RF[rt] & 0xFF00) >> 8);
VM_memory[RF[rs] + immediate + 3] = (uint8_t)(RF[rt] & 0xFF);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sw\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
VM_memory[RF[rs] + immediate] = (uint8_t)((RF[rt] & 0xFF000000) >> 24);
VM_memory[RF[rs] + immediate + 1] = (uint8_t)((RF[rt] & 0xFF0000) >> 16);
VM_memory[RF[rs] + immediate + 2] = (uint8_t)((RF[rt] & 0xFF00) >> 8);
VM_memory[RF[rs] + immediate + 3] = (uint8_t)(RF[rt] & 0xFF);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


adduPLUSandiPLUSxor:
#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|andi\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = RF[rs] & (uint32_t)immediate;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|xor\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rs] ^ RF[rt];
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


sbPLUSshPLUSor:
#if INDIRECT_DEBUG
printf("%d|sb\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
VM_memory[RF[rs] + immediate] = (uint8_t)(RF[rt] & 0xFF);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sh\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
VM_memory[RF[rs] + immediate] = (uint8_t)((RF[rt] & 0xFF00) >> 8);
VM_memory[RF[rs] + immediate + 1] = (uint8_t)(RF[rt] & 0xFF);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|or\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rs] | RF[rt];
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


bgtzPLUSsllPLUSslt:
#if INDIRECT_DEBUG
printf("%d|bgtz\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
if ((int32_t)RF[rs] > 0)
{
  immediate = (instr0 >> 0) & 0xFFFF;
  PC  =  nPC;
  nPC  += (immediate << 2);
    if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


}
else
{
  PC  =  nPC;
  nPC  += 4;
}

#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr1 >> 6) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|slt\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = (RF[rs] < RF[rt])?1:0;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


luiPLUSsrlPLUSori:
#if INDIRECT_DEBUG
printf("%d|lui\n",counter);
counter++;
#endif
// NOTHING IMPLEMENTED, COPIED FROM BELOW
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)immediate) << 16;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|srl\n",counter);
counter++;
#endif
shamt = (instr1 >> 6) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rt] >> shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|ori\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
RF[rt] = RF[rs] | (uint32_t)immediate;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


bgtzPLUSsllPLUSbne:
#if INDIRECT_DEBUG
printf("%d|bgtz\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
if ((int32_t)RF[rs] > 0)
{
  immediate = (instr0 >> 0) & 0xFFFF;
  PC  =  nPC;
  nPC  += (immediate << 2);
    if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


}
else
{
  PC  =  nPC;
  nPC  += 4;
}

#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr1 >> 6) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|bne\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
if (RF[rs] != RF[rt])
{
  immediate = (instr2 >> 0) & 0xFFFF;
  PC  =  nPC;
  nPC  += (immediate << 2);
    if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


}
else
{
  PC  =  nPC;
  nPC  += 4;
}
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


swPLUSadduPLUSlw:
#if INDIRECT_DEBUG
printf("%d|sw\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
VM_memory[RF[rs] + immediate] = (uint8_t)((RF[rt] & 0xFF000000) >> 24);
VM_memory[RF[rs] + immediate + 1] = (uint8_t)((RF[rt] & 0xFF0000) >> 16);
VM_memory[RF[rs] + immediate + 2] = (uint8_t)((RF[rt] & 0xFF00) >> 8);
VM_memory[RF[rs] + immediate + 3] = (uint8_t)(RF[rt] & 0xFF);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|lw\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)(VM_memory[RF[rs] + immediate]) << 24) | ((uint32_t)(VM_memory[RF[rs] + immediate + 1]) << 16) | ((uint32_t)(VM_memory[RF[rs] + immediate + 2]) << 8) | ((uint32_t)VM_memory[RF[rs] + immediate + 3]);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


lwPLUSerrorPLUSaddu:
#if INDIRECT_DEBUG
printf("%d|lw\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)(VM_memory[RF[rs] + immediate]) << 24) | ((uint32_t)(VM_memory[RF[rs] + immediate + 1]) << 16) | ((uint32_t)(VM_memory[RF[rs] + immediate + 2]) << 8) | ((uint32_t)VM_memory[RF[rs] + immediate + 3]);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("Error, unknown instr1uction %d.\n", instr1);
#endif
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


beqPLUSswPLUSaddu:
#if INDIRECT_DEBUG
printf("%d|beq\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
if (RF[rs] == RF[rt])
{
  immediate = (instr0 >> 0) & 0xFFFF;
  PC  =  nPC;
  nPC  += (immediate << 2);
    if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


}
else
{
  PC  =  nPC;
  nPC  += 4;
}

#if INDIRECT_DEBUG
printf("%d|sw\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
VM_memory[RF[rs] + immediate] = (uint8_t)((RF[rt] & 0xFF000000) >> 24);
VM_memory[RF[rs] + immediate + 1] = (uint8_t)((RF[rt] & 0xFF0000) >> 16);
VM_memory[RF[rs] + immediate + 2] = (uint8_t)((RF[rt] & 0xFF00) >> 8);
VM_memory[RF[rs] + immediate + 3] = (uint8_t)(RF[rt] & 0xFF);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


luiPLUSswPLUSlw:
#if INDIRECT_DEBUG
printf("%d|lui\n",counter);
counter++;
#endif
// NOTHING IMPLEMENTED, COPIED FROM BELOW
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)immediate) << 16;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sw\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
VM_memory[RF[rs] + immediate] = (uint8_t)((RF[rt] & 0xFF000000) >> 24);
VM_memory[RF[rs] + immediate + 1] = (uint8_t)((RF[rt] & 0xFF0000) >> 16);
VM_memory[RF[rs] + immediate + 2] = (uint8_t)((RF[rt] & 0xFF00) >> 8);
VM_memory[RF[rs] + immediate + 3] = (uint8_t)(RF[rt] & 0xFF);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|lw\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)(VM_memory[RF[rs] + immediate]) << 24) | ((uint32_t)(VM_memory[RF[rs] + immediate + 1]) << 16) | ((uint32_t)(VM_memory[RF[rs] + immediate + 2]) << 8) | ((uint32_t)VM_memory[RF[rs] + immediate + 3]);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


sltiPLUSswPLUSaddiu:
#if INDIRECT_DEBUG
printf("%d|slti\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] < immediate)?1:0;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sw\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
VM_memory[RF[rs] + immediate] = (uint8_t)((RF[rt] & 0xFF000000) >> 24);
VM_memory[RF[rs] + immediate + 1] = (uint8_t)((RF[rt] & 0xFF0000) >> 16);
VM_memory[RF[rs] + immediate + 2] = (uint8_t)((RF[rt] & 0xFF00) >> 8);
VM_memory[RF[rs] + immediate + 3] = (uint8_t)(RF[rt] & 0xFF);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


xorPLUSxorPLUSslti:
#if INDIRECT_DEBUG
printf("%d|xor\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rs] ^ RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|xor\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rs] ^ RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|slti\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] < immediate)?1:0;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


adduPLUSerrorPLUSsubu:
#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("Error, unknown instr1uction %d.\n", instr1);
#endif
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|subu\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rs] - RF[rt];
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


luiPLUSoriPLUSand:
#if INDIRECT_DEBUG
printf("%d|lui\n",counter);
counter++;
#endif
// NOTHING IMPLEMENTED, COPIED FROM BELOW
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)immediate) << 16;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|ori\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = RF[rs] | (uint32_t)immediate;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|and\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rs] & RF[rt];
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


swPLUSlwPLUSslti:
#if INDIRECT_DEBUG
printf("%d|sw\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
VM_memory[RF[rs] + immediate] = (uint8_t)((RF[rt] & 0xFF000000) >> 24);
VM_memory[RF[rs] + immediate + 1] = (uint8_t)((RF[rt] & 0xFF0000) >> 16);
VM_memory[RF[rs] + immediate + 2] = (uint8_t)((RF[rt] & 0xFF00) >> 8);
VM_memory[RF[rs] + immediate + 3] = (uint8_t)(RF[rt] & 0xFF);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|lw\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)(VM_memory[RF[rs] + immediate]) << 24) | ((uint32_t)(VM_memory[RF[rs] + immediate + 1]) << 16) | ((uint32_t)(VM_memory[RF[rs] + immediate + 2]) << 8) | ((uint32_t)VM_memory[RF[rs] + immediate + 3]);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|slti\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] < immediate)?1:0;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


orPLUSsllPLUSlbu:
#if INDIRECT_DEBUG
printf("%d|or\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rs] | RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr1 >> 6) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|lbu\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)VM_memory[RF[rs] + immediate]) & 0xFF;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


sltiPLUSmovnPLUSaddiu:
#if INDIRECT_DEBUG
printf("%d|slti\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] < immediate)?1:0;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|movn\n",counter);
counter++;
#endif

rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
if (RF[rt] != 0) RF[rd] = RF[rs];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


addiuPLUSsrlPLUSaddu:
#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|srl\n",counter);
counter++;
#endif
shamt = (instr1 >> 6) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rt] >> shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


sllPLUSaddiuPLUSaddiu:
#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr0 >> 6) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


addiuPLUSadduPLUSaddiu:
#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


sllPLUSorPLUSsw:
#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr0 >> 6) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|or\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rs] | RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sw\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
VM_memory[RF[rs] + immediate] = (uint8_t)((RF[rt] & 0xFF000000) >> 24);
VM_memory[RF[rs] + immediate + 1] = (uint8_t)((RF[rt] & 0xFF0000) >> 16);
VM_memory[RF[rs] + immediate + 2] = (uint8_t)((RF[rt] & 0xFF00) >> 8);
VM_memory[RF[rs] + immediate + 3] = (uint8_t)(RF[rt] & 0xFF);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


adduPLUSmultPLUSmfhi:
#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|mult\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
mult = (uint64_t)RF[rs] * (uint64_t) RF[rt];
HI = (mult >> 32) & 0xFFFFFFFF;
LO = mult & 0xFFFFFFFF;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|mfhi\n",counter);
counter++;
#endif
rd = (instr2 >> 11) & 0x1F;
RF[rd] = HI;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


jrPLUSsllPLUSjal:
#if INDIRECT_DEBUG
printf("%d|jr\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
PC = nPC;
nPC = RF[rs];
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;



#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr1 >> 6) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|jal\n",counter);
counter++;
#endif
RF[31] = PC + 8;
PC = nPC;
address = (instr2 >> 0) & 0x3FFFFFF;
nPC = address << 2;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


sllPLUSaddiuPLUSblez:
#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr0 >> 6) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|blez\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
if ((int32_t)RF[rs] <= 0)
{
  immediate = (instr2 >> 0) & 0xFFFF;
  PC  =  nPC;
  nPC  += (immediate << 2);
    if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


}
else
{
  PC  =  nPC;
  nPC  += 4;
}
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


sllPLUSsllPLUSslt:
#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr0 >> 6) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr1 >> 6) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|slt\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = (RF[rs] < RF[rt])?1:0;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


orPLUSsllPLUSor:
#if INDIRECT_DEBUG
printf("%d|or\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rs] | RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr1 >> 6) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|or\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rs] | RF[rt];
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


sllPLUSsllPLUSsll:
#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr0 >> 6) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr1 >> 6) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr2 >> 6) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


adduPLUSnorPLUSsrl:
#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|nor\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = ~(RF[rs] | RF[rt]);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|srl\n",counter);
counter++;
#endif
shamt = (instr2 >> 6) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rt] >> shamt;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


jalPLUSadduPLUSaddiu:
#if INDIRECT_DEBUG
printf("%d|jal\n",counter);
counter++;
#endif
RF[31] = PC + 8;
PC = nPC;
address = (instr0 >> 0) & 0x3FFFFFF;
nPC = address << 2;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;



#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


andPLUSsllPLUSlui:
#if INDIRECT_DEBUG
printf("%d|and\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rs] & RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr1 >> 6) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|lui\n",counter);
counter++;
#endif
// NOTHING IMPLEMENTED, COPIED FROM BELOW
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)immediate) << 16;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


lbuPLUSbeqPLUSaddiu:
#if INDIRECT_DEBUG
printf("%d|lbu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)VM_memory[RF[rs] + immediate]) & 0xFF;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|beq\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
if (RF[rs] == RF[rt])
{
  immediate = (instr1 >> 0) & 0xFFFF;
  PC  =  nPC;
  nPC  += (immediate << 2);
    if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


}
else
{
  PC  =  nPC;
  nPC  += 4;
}

#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


oriPLUSandPLUSsll:
#if INDIRECT_DEBUG
printf("%d|ori\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = RF[rs] | (uint32_t)immediate;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|and\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rs] & RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr2 >> 6) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


adduPLUSswPLUSslti:
#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sw\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
VM_memory[RF[rs] + immediate] = (uint8_t)((RF[rt] & 0xFF000000) >> 24);
VM_memory[RF[rs] + immediate + 1] = (uint8_t)((RF[rt] & 0xFF0000) >> 16);
VM_memory[RF[rs] + immediate + 2] = (uint8_t)((RF[rt] & 0xFF00) >> 8);
VM_memory[RF[rs] + immediate + 3] = (uint8_t)(RF[rt] & 0xFF);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|slti\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] < immediate)?1:0;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


adduPLUSlwPLUSblez:
#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|lw\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)(VM_memory[RF[rs] + immediate]) << 24) | ((uint32_t)(VM_memory[RF[rs] + immediate + 1]) << 16) | ((uint32_t)(VM_memory[RF[rs] + immediate + 2]) << 8) | ((uint32_t)VM_memory[RF[rs] + immediate + 3]);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|blez\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
if ((int32_t)RF[rs] <= 0)
{
  immediate = (instr2 >> 0) & 0xFFFF;
  PC  =  nPC;
  nPC  += (immediate << 2);
    if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


}
else
{
  PC  =  nPC;
  nPC  += 4;
}
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


errorPLUSadduPLUSaddu:
#if INDIRECT_DEBUG
printf("Error, unknown instr0uction %d.\n", instr0);
#endif
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


sllPLUSlbuPLUSxor:
#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr0 >> 6) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|lbu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)VM_memory[RF[rs] + immediate]) & 0xFF;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|xor\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rs] ^ RF[rt];
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


adduPLUSsubuPLUSsw:
#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|subu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rs] - RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sw\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
VM_memory[RF[rs] + immediate] = (uint8_t)((RF[rt] & 0xFF000000) >> 24);
VM_memory[RF[rs] + immediate + 1] = (uint8_t)((RF[rt] & 0xFF0000) >> 16);
VM_memory[RF[rs] + immediate + 2] = (uint8_t)((RF[rt] & 0xFF00) >> 8);
VM_memory[RF[rs] + immediate + 3] = (uint8_t)(RF[rt] & 0xFF);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


srlPLUSxorPLUSsw:
#if INDIRECT_DEBUG
printf("%d|srl\n",counter);
counter++;
#endif
shamt = (instr0 >> 6) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rt] >> shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|xor\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rs] ^ RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sw\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
VM_memory[RF[rs] + immediate] = (uint8_t)((RF[rt] & 0xFF000000) >> 24);
VM_memory[RF[rs] + immediate + 1] = (uint8_t)((RF[rt] & 0xFF0000) >> 16);
VM_memory[RF[rs] + immediate + 2] = (uint8_t)((RF[rt] & 0xFF00) >> 8);
VM_memory[RF[rs] + immediate + 3] = (uint8_t)(RF[rt] & 0xFF);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


beqPLUSsllPLUSmult:
#if INDIRECT_DEBUG
printf("%d|beq\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
if (RF[rs] == RF[rt])
{
  immediate = (instr0 >> 0) & 0xFFFF;
  PC  =  nPC;
  nPC  += (immediate << 2);
    if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


}
else
{
  PC  =  nPC;
  nPC  += 4;
}

#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr1 >> 6) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|mult\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
mult = (uint64_t)RF[rs] * (uint64_t) RF[rt];
HI = (mult >> 32) & 0xFFFFFFFF;
LO = mult & 0xFFFFFFFF;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


addiuPLUSadduPLUSslt:
#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|slt\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = (RF[rs] < RF[rt])?1:0;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


lwPLUSbeqPLUSaddiu:
#if INDIRECT_DEBUG
printf("%d|lw\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)(VM_memory[RF[rs] + immediate]) << 24) | ((uint32_t)(VM_memory[RF[rs] + immediate + 1]) << 16) | ((uint32_t)(VM_memory[RF[rs] + immediate + 2]) << 8) | ((uint32_t)VM_memory[RF[rs] + immediate + 3]);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|beq\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
if (RF[rs] == RF[rt])
{
  immediate = (instr1 >> 0) & 0xFFFF;
  PC  =  nPC;
  nPC  += (immediate << 2);
    if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


}
else
{
  PC  =  nPC;
  nPC  += 4;
}

#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


sltiPLUSmovnPLUSandi:
#if INDIRECT_DEBUG
printf("%d|slti\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] < immediate)?1:0;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|movn\n",counter);
counter++;
#endif

rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
if (RF[rt] != 0) RF[rd] = RF[rs];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|andi\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
RF[rt] = RF[rs] & (uint32_t)immediate;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


jalPLUSaddiuPLUSaddiu:
#if INDIRECT_DEBUG
printf("%d|jal\n",counter);
counter++;
#endif
RF[31] = PC + 8;
PC = nPC;
address = (instr0 >> 0) & 0x3FFFFFF;
nPC = address << 2;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;



#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


adduPLUSlwPLUSjal:
#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|lw\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)(VM_memory[RF[rs] + immediate]) << 24) | ((uint32_t)(VM_memory[RF[rs] + immediate + 1]) << 16) | ((uint32_t)(VM_memory[RF[rs] + immediate + 2]) << 8) | ((uint32_t)VM_memory[RF[rs] + immediate + 3]);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|jal\n",counter);
counter++;
#endif
RF[31] = PC + 8;
PC = nPC;
address = (instr2 >> 0) & 0x3FFFFFF;
nPC = address << 2;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


jalPLUSsllPLUSaddiu:
#if INDIRECT_DEBUG
printf("%d|jal\n",counter);
counter++;
#endif
RF[31] = PC + 8;
PC = nPC;
address = (instr0 >> 0) & 0x3FFFFFF;
nPC = address << 2;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;



#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr1 >> 6) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


addiuPLUSadduPLUSsll:
#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr2 >> 6) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


swPLUSswPLUSaddiu:
#if INDIRECT_DEBUG
printf("%d|sw\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
VM_memory[RF[rs] + immediate] = (uint8_t)((RF[rt] & 0xFF000000) >> 24);
VM_memory[RF[rs] + immediate + 1] = (uint8_t)((RF[rt] & 0xFF0000) >> 16);
VM_memory[RF[rs] + immediate + 2] = (uint8_t)((RF[rt] & 0xFF00) >> 8);
VM_memory[RF[rs] + immediate + 3] = (uint8_t)(RF[rt] & 0xFF);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sw\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
VM_memory[RF[rs] + immediate] = (uint8_t)((RF[rt] & 0xFF000000) >> 24);
VM_memory[RF[rs] + immediate + 1] = (uint8_t)((RF[rt] & 0xFF0000) >> 16);
VM_memory[RF[rs] + immediate + 2] = (uint8_t)((RF[rt] & 0xFF00) >> 8);
VM_memory[RF[rs] + immediate + 3] = (uint8_t)(RF[rt] & 0xFF);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


andiPLUSsllPLUSaddu:
#if INDIRECT_DEBUG
printf("%d|andi\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = RF[rs] & (uint32_t)immediate;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr1 >> 6) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


sllPLUSandPLUSor:
#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr0 >> 6) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|and\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rs] & RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|or\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rs] | RF[rt];
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


bnePLUSaddiuPLUSlw:
#if INDIRECT_DEBUG
printf("%d|bne\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
if (RF[rs] != RF[rt])
{
  immediate = (instr0 >> 0) & 0xFFFF;
  PC  =  nPC;
  nPC  += (immediate << 2);
    if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


}
else
{
  PC  =  nPC;
  nPC  += 4;
}

#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|lw\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)(VM_memory[RF[rs] + immediate]) << 24) | ((uint32_t)(VM_memory[RF[rs] + immediate + 1]) << 16) | ((uint32_t)(VM_memory[RF[rs] + immediate + 2]) << 8) | ((uint32_t)VM_memory[RF[rs] + immediate + 3]);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


srlPLUSsraPLUSaddu:
#if INDIRECT_DEBUG
printf("%d|srl\n",counter);
counter++;
#endif
shamt = (instr0 >> 6) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rt] >> shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sra\n",counter);
counter++;
#endif
shamt = (instr1 >> 6) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
if ((int32_t)RF[rt] < 0 && shamt > 0) {
rd = (instr1 >> 11) & 0x1F;
RF[rd] = (int32_t)RF[rt] | ~(~0U >> shamt);
}
else {
rd = (instr1 >> 11) & 0x1F;
RF[rd] = (int32_t)RF[rt] >> shamt;
}
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


addiuPLUSlwPLUSlw:
#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|lw\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)(VM_memory[RF[rs] + immediate]) << 24) | ((uint32_t)(VM_memory[RF[rs] + immediate + 1]) << 16) | ((uint32_t)(VM_memory[RF[rs] + immediate + 2]) << 8) | ((uint32_t)VM_memory[RF[rs] + immediate + 3]);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|lw\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)(VM_memory[RF[rs] + immediate]) << 24) | ((uint32_t)(VM_memory[RF[rs] + immediate + 1]) << 16) | ((uint32_t)(VM_memory[RF[rs] + immediate + 2]) << 8) | ((uint32_t)VM_memory[RF[rs] + immediate + 3]);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


adduPLUSswPLUSaddu:
#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sw\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
VM_memory[RF[rs] + immediate] = (uint8_t)((RF[rt] & 0xFF000000) >> 24);
VM_memory[RF[rs] + immediate + 1] = (uint8_t)((RF[rt] & 0xFF0000) >> 16);
VM_memory[RF[rs] + immediate + 2] = (uint8_t)((RF[rt] & 0xFF00) >> 8);
VM_memory[RF[rs] + immediate + 3] = (uint8_t)(RF[rt] & 0xFF);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


srlPLUSxorPLUSsrl:
#if INDIRECT_DEBUG
printf("%d|srl\n",counter);
counter++;
#endif
shamt = (instr0 >> 6) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rt] >> shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|xor\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rs] ^ RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|srl\n",counter);
counter++;
#endif
shamt = (instr2 >> 6) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rt] >> shamt;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


sllPLUSblezPLUSsll:
#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr0 >> 6) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|blez\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
if ((int32_t)RF[rs] <= 0)
{
  immediate = (instr1 >> 0) & 0xFFFF;
  PC  =  nPC;
  nPC  += (immediate << 2);
    if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


}
else
{
  PC  =  nPC;
  nPC  += 4;
}

#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr2 >> 6) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


adduPLUSlwPLUSlbu:
#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|lw\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)(VM_memory[RF[rs] + immediate]) << 24) | ((uint32_t)(VM_memory[RF[rs] + immediate + 1]) << 16) | ((uint32_t)(VM_memory[RF[rs] + immediate + 2]) << 8) | ((uint32_t)VM_memory[RF[rs] + immediate + 3]);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|lbu\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)VM_memory[RF[rs] + immediate]) & 0xFF;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


beqPLUSadduPLUSjump:
#if INDIRECT_DEBUG
printf("%d|beq\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
if (RF[rs] == RF[rt])
{
  immediate = (instr0 >> 0) & 0xFFFF;
  PC  =  nPC;
  nPC  += (immediate << 2);
    if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


}
else
{
  PC  =  nPC;
  nPC  += 4;
}

#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|jump\n",counter);
counter++;
#endif
PC = nPC;
address = (instr2 >> 0) & 0x3FFFFFF;
nPC = address << 2;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


adduPLUSadduPLUSaddiu:
#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


adduPLUSswPLUSsw:
#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sw\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
VM_memory[RF[rs] + immediate] = (uint8_t)((RF[rt] & 0xFF000000) >> 24);
VM_memory[RF[rs] + immediate + 1] = (uint8_t)((RF[rt] & 0xFF0000) >> 16);
VM_memory[RF[rs] + immediate + 2] = (uint8_t)((RF[rt] & 0xFF00) >> 8);
VM_memory[RF[rs] + immediate + 3] = (uint8_t)(RF[rt] & 0xFF);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sw\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
VM_memory[RF[rs] + immediate] = (uint8_t)((RF[rt] & 0xFF000000) >> 24);
VM_memory[RF[rs] + immediate + 1] = (uint8_t)((RF[rt] & 0xFF0000) >> 16);
VM_memory[RF[rs] + immediate + 2] = (uint8_t)((RF[rt] & 0xFF00) >> 8);
VM_memory[RF[rs] + immediate + 3] = (uint8_t)(RF[rt] & 0xFF);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


sltiPLUSmovnPLUSsll:
#if INDIRECT_DEBUG
printf("%d|slti\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] < immediate)?1:0;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|movn\n",counter);
counter++;
#endif

rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
if (RF[rt] != 0) RF[rd] = RF[rs];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr2 >> 6) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


lwPLUSsltuPLUSmovn:
#if INDIRECT_DEBUG
printf("%d|lw\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)(VM_memory[RF[rs] + immediate]) << 24) | ((uint32_t)(VM_memory[RF[rs] + immediate + 1]) << 16) | ((uint32_t)(VM_memory[RF[rs] + immediate + 2]) << 8) | ((uint32_t)VM_memory[RF[rs] + immediate + 3]);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sltu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = (RF[rs] < RF[rt])?1:0;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|movn\n",counter);
counter++;
#endif

rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
if (RF[rt] != 0) RF[rd] = RF[rs];
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


andiPLUSsllPLUSandi:
#if INDIRECT_DEBUG
printf("%d|andi\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = RF[rs] & (uint32_t)immediate;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr1 >> 6) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|andi\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
RF[rt] = RF[rs] & (uint32_t)immediate;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


addiuPLUSadduPLUSsw:
#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sw\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
VM_memory[RF[rs] + immediate] = (uint8_t)((RF[rt] & 0xFF000000) >> 24);
VM_memory[RF[rs] + immediate + 1] = (uint8_t)((RF[rt] & 0xFF0000) >> 16);
VM_memory[RF[rs] + immediate + 2] = (uint8_t)((RF[rt] & 0xFF00) >> 8);
VM_memory[RF[rs] + immediate + 3] = (uint8_t)(RF[rt] & 0xFF);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


lwPLUSoriPLUSsll:
#if INDIRECT_DEBUG
printf("%d|lw\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)(VM_memory[RF[rs] + immediate]) << 24) | ((uint32_t)(VM_memory[RF[rs] + immediate + 1]) << 16) | ((uint32_t)(VM_memory[RF[rs] + immediate + 2]) << 8) | ((uint32_t)VM_memory[RF[rs] + immediate + 3]);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|ori\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = RF[rs] | (uint32_t)immediate;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr2 >> 6) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


sltPLUSbeqPLUSsll:
#if INDIRECT_DEBUG
printf("%d|slt\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = (RF[rs] < RF[rt])?1:0;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|beq\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
if (RF[rs] == RF[rt])
{
  immediate = (instr1 >> 0) & 0xFFFF;
  PC  =  nPC;
  nPC  += (immediate << 2);
    if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


}
else
{
  PC  =  nPC;
  nPC  += 4;
}

#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr2 >> 6) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


addiuPLUSaddiuPLUSslt:
#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|slt\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = (RF[rs] < RF[rt])?1:0;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


addiuPLUSjrPLUSsll:
#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|jr\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
PC = nPC;
nPC = RF[rs];
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;



#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr2 >> 6) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


multPLUSmfhiPLUSmult:
#if INDIRECT_DEBUG
printf("%d|mult\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
mult = (uint64_t)RF[rs] * (uint64_t) RF[rt];
HI = (mult >> 32) & 0xFFFFFFFF;
LO = mult & 0xFFFFFFFF;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|mfhi\n",counter);
counter++;
#endif
rd = (instr1 >> 11) & 0x1F;
RF[rd] = HI;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|mult\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
mult = (uint64_t)RF[rs] * (uint64_t) RF[rt];
HI = (mult >> 32) & 0xFFFFFFFF;
LO = mult & 0xFFFFFFFF;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


mfhiPLUSsrlPLUSaddu:
#if INDIRECT_DEBUG
printf("%d|mfhi\n",counter);
counter++;
#endif
rd = (instr0 >> 11) & 0x1F;
RF[rd] = HI;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|srl\n",counter);
counter++;
#endif
shamt = (instr1 >> 6) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rt] >> shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


adduPLUSbnePLUSsw:
#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|bne\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
if (RF[rs] != RF[rt])
{
  immediate = (instr1 >> 0) & 0xFFFF;
  PC  =  nPC;
  nPC  += (immediate << 2);
    if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


}
else
{
  PC  =  nPC;
  nPC  += 4;
}

#if INDIRECT_DEBUG
printf("%d|sw\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
VM_memory[RF[rs] + immediate] = (uint8_t)((RF[rt] & 0xFF000000) >> 24);
VM_memory[RF[rs] + immediate + 1] = (uint8_t)((RF[rt] & 0xFF0000) >> 16);
VM_memory[RF[rs] + immediate + 2] = (uint8_t)((RF[rt] & 0xFF00) >> 8);
VM_memory[RF[rs] + immediate + 3] = (uint8_t)(RF[rt] & 0xFF);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


blezPLUSaddiuPLUSaddu:
#if INDIRECT_DEBUG
printf("%d|blez\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
if ((int32_t)RF[rs] <= 0)
{
  immediate = (instr0 >> 0) & 0xFFFF;
  PC  =  nPC;
  nPC  += (immediate << 2);
    if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


}
else
{
  PC  =  nPC;
  nPC  += 4;
}

#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


luiPLUSswPLUSlui:
#if INDIRECT_DEBUG
printf("%d|lui\n",counter);
counter++;
#endif
// NOTHING IMPLEMENTED, COPIED FROM BELOW
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)immediate) << 16;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sw\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
VM_memory[RF[rs] + immediate] = (uint8_t)((RF[rt] & 0xFF000000) >> 24);
VM_memory[RF[rs] + immediate + 1] = (uint8_t)((RF[rt] & 0xFF0000) >> 16);
VM_memory[RF[rs] + immediate + 2] = (uint8_t)((RF[rt] & 0xFF00) >> 8);
VM_memory[RF[rs] + immediate + 3] = (uint8_t)(RF[rt] & 0xFF);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|lui\n",counter);
counter++;
#endif
// NOTHING IMPLEMENTED, COPIED FROM BELOW
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)immediate) << 16;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


adduPLUSswPLUSaddiu:
#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sw\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
VM_memory[RF[rs] + immediate] = (uint8_t)((RF[rt] & 0xFF000000) >> 24);
VM_memory[RF[rs] + immediate + 1] = (uint8_t)((RF[rt] & 0xFF0000) >> 16);
VM_memory[RF[rs] + immediate + 2] = (uint8_t)((RF[rt] & 0xFF00) >> 8);
VM_memory[RF[rs] + immediate + 3] = (uint8_t)(RF[rt] & 0xFF);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


lwPLUSjalPLUSaddiu:
#if INDIRECT_DEBUG
printf("%d|lw\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)(VM_memory[RF[rs] + immediate]) << 24) | ((uint32_t)(VM_memory[RF[rs] + immediate + 1]) << 16) | ((uint32_t)(VM_memory[RF[rs] + immediate + 2]) << 8) | ((uint32_t)VM_memory[RF[rs] + immediate + 3]);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|jal\n",counter);
counter++;
#endif
RF[31] = PC + 8;
PC = nPC;
address = (instr1 >> 0) & 0x3FFFFFF;
nPC = address << 2;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;



#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


lwPLUSlbuPLUSaddiu:
#if INDIRECT_DEBUG
printf("%d|lw\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)(VM_memory[RF[rs] + immediate]) << 24) | ((uint32_t)(VM_memory[RF[rs] + immediate + 1]) << 16) | ((uint32_t)(VM_memory[RF[rs] + immediate + 2]) << 8) | ((uint32_t)VM_memory[RF[rs] + immediate + 3]);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|lbu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)VM_memory[RF[rs] + immediate]) & 0xFF;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


movnPLUSjumpPLUSaddu:
#if INDIRECT_DEBUG
printf("%d|movn\n",counter);
counter++;
#endif

rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
if (RF[rt] != 0) RF[rd] = RF[rs];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|jump\n",counter);
counter++;
#endif
PC = nPC;
address = (instr1 >> 0) & 0x3FFFFFF;
nPC = address << 2;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;



#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


shPLUSorPLUSsll:
#if INDIRECT_DEBUG
printf("%d|sh\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
VM_memory[RF[rs] + immediate] = (uint8_t)((RF[rt] & 0xFF00) >> 8);
VM_memory[RF[rs] + immediate + 1] = (uint8_t)(RF[rt] & 0xFF);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|or\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rs] | RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr2 >> 6) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


sltiPLUSbeqPLUSsw:
#if INDIRECT_DEBUG
printf("%d|slti\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] < immediate)?1:0;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|beq\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
if (RF[rs] == RF[rt])
{
  immediate = (instr1 >> 0) & 0xFFFF;
  PC  =  nPC;
  nPC  += (immediate << 2);
    if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


}
else
{
  PC  =  nPC;
  nPC  += 4;
}

#if INDIRECT_DEBUG
printf("%d|sw\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
VM_memory[RF[rs] + immediate] = (uint8_t)((RF[rt] & 0xFF000000) >> 24);
VM_memory[RF[rs] + immediate + 1] = (uint8_t)((RF[rt] & 0xFF0000) >> 16);
VM_memory[RF[rs] + immediate + 2] = (uint8_t)((RF[rt] & 0xFF00) >> 8);
VM_memory[RF[rs] + immediate + 3] = (uint8_t)(RF[rt] & 0xFF);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


swPLUSadduPLUSaddu:
#if INDIRECT_DEBUG
printf("%d|sw\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
VM_memory[RF[rs] + immediate] = (uint8_t)((RF[rt] & 0xFF000000) >> 24);
VM_memory[RF[rs] + immediate + 1] = (uint8_t)((RF[rt] & 0xFF0000) >> 16);
VM_memory[RF[rs] + immediate + 2] = (uint8_t)((RF[rt] & 0xFF00) >> 8);
VM_memory[RF[rs] + immediate + 3] = (uint8_t)(RF[rt] & 0xFF);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


sllPLUSorPLUSor:
#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr0 >> 6) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|or\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rs] | RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|or\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rs] | RF[rt];
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


orPLUSsllPLUSsrl:
#if INDIRECT_DEBUG
printf("%d|or\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rs] | RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr1 >> 6) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|srl\n",counter);
counter++;
#endif
shamt = (instr2 >> 6) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rt] >> shamt;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


sltPLUSbeqPLUSaddu:
#if INDIRECT_DEBUG
printf("%d|slt\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = (RF[rs] < RF[rt])?1:0;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|beq\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
if (RF[rs] == RF[rt])
{
  immediate = (instr1 >> 0) & 0xFFFF;
  PC  =  nPC;
  nPC  += (immediate << 2);
    if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


}
else
{
  PC  =  nPC;
  nPC  += 4;
}

#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


adduPLUSsltiPLUSbeq:
#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|slti\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] < immediate)?1:0;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|beq\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
if (RF[rs] == RF[rt])
{
  immediate = (instr2 >> 0) & 0xFFFF;
  PC  =  nPC;
  nPC  += (immediate << 2);
    if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


}
else
{
  PC  =  nPC;
  nPC  += 4;
}
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


luiPLUSoriPLUSmult:
#if INDIRECT_DEBUG
printf("%d|lui\n",counter);
counter++;
#endif
// NOTHING IMPLEMENTED, COPIED FROM BELOW
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)immediate) << 16;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|ori\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = RF[rs] | (uint32_t)immediate;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|mult\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
mult = (uint64_t)RF[rs] * (uint64_t) RF[rt];
HI = (mult >> 32) & 0xFFFFFFFF;
LO = mult & 0xFFFFFFFF;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


subuPLUSandPLUSxor:
#if INDIRECT_DEBUG
printf("%d|subu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rs] - RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|and\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rs] & RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|xor\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rs] ^ RF[rt];
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


addiuPLUSaddiuPLUSlui:
#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|lui\n",counter);
counter++;
#endif
// NOTHING IMPLEMENTED, COPIED FROM BELOW
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)immediate) << 16;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


sllPLUSbnePLUSaddiu:
#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr0 >> 6) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|bne\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
if (RF[rs] != RF[rt])
{
  immediate = (instr1 >> 0) & 0xFFFF;
  PC  =  nPC;
  nPC  += (immediate << 2);
    if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


}
else
{
  PC  =  nPC;
  nPC  += 4;
}

#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


jumpPLUSaddiuPLUSslti:
#if INDIRECT_DEBUG
printf("%d|jump\n",counter);
counter++;
#endif
PC = nPC;
address = (instr0 >> 0) & 0x3FFFFFF;
nPC = address << 2;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;



#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|slti\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] < immediate)?1:0;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


addiuPLUSlwPLUSjr:
#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|lw\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)(VM_memory[RF[rs] + immediate]) << 24) | ((uint32_t)(VM_memory[RF[rs] + immediate + 1]) << 16) | ((uint32_t)(VM_memory[RF[rs] + immediate + 2]) << 8) | ((uint32_t)VM_memory[RF[rs] + immediate + 3]);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|jr\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
PC = nPC;
nPC = RF[rs];
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


luiPLUSaddiuPLUSjal:
#if INDIRECT_DEBUG
printf("%d|lui\n",counter);
counter++;
#endif
// NOTHING IMPLEMENTED, COPIED FROM BELOW
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)immediate) << 16;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|jal\n",counter);
counter++;
#endif
RF[31] = PC + 8;
PC = nPC;
address = (instr2 >> 0) & 0x3FFFFFF;
nPC = address << 2;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


subuPLUSadduPLUSsll:
#if INDIRECT_DEBUG
printf("%d|subu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rs] - RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr2 >> 6) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


jumpPLUSaddiuPLUSlw:
#if INDIRECT_DEBUG
printf("%d|jump\n",counter);
counter++;
#endif
PC = nPC;
address = (instr0 >> 0) & 0x3FFFFFF;
nPC = address << 2;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;



#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|lw\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)(VM_memory[RF[rs] + immediate]) << 24) | ((uint32_t)(VM_memory[RF[rs] + immediate + 1]) << 16) | ((uint32_t)(VM_memory[RF[rs] + immediate + 2]) << 8) | ((uint32_t)VM_memory[RF[rs] + immediate + 3]);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


beqPLUSsllPLUSjump:
#if INDIRECT_DEBUG
printf("%d|beq\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
if (RF[rs] == RF[rt])
{
  immediate = (instr0 >> 0) & 0xFFFF;
  PC  =  nPC;
  nPC  += (immediate << 2);
    if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


}
else
{
  PC  =  nPC;
  nPC  += 4;
}

#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr1 >> 6) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|jump\n",counter);
counter++;
#endif
PC = nPC;
address = (instr2 >> 0) & 0x3FFFFFF;
nPC = address << 2;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


andPLUSorPLUSlui:
#if INDIRECT_DEBUG
printf("%d|and\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rs] & RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|or\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rs] | RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|lui\n",counter);
counter++;
#endif
// NOTHING IMPLEMENTED, COPIED FROM BELOW
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)immediate) << 16;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


lwPLUSaddiuPLUSbeq:
#if INDIRECT_DEBUG
printf("%d|lw\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)(VM_memory[RF[rs] + immediate]) << 24) | ((uint32_t)(VM_memory[RF[rs] + immediate + 1]) << 16) | ((uint32_t)(VM_memory[RF[rs] + immediate + 2]) << 8) | ((uint32_t)VM_memory[RF[rs] + immediate + 3]);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|beq\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
if (RF[rs] == RF[rt])
{
  immediate = (instr2 >> 0) & 0xFFFF;
  PC  =  nPC;
  nPC  += (immediate << 2);
    if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


}
else
{
  PC  =  nPC;
  nPC  += 4;
}
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


swPLUSsltiPLUSsw:
#if INDIRECT_DEBUG
printf("%d|sw\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
VM_memory[RF[rs] + immediate] = (uint8_t)((RF[rt] & 0xFF000000) >> 24);
VM_memory[RF[rs] + immediate + 1] = (uint8_t)((RF[rt] & 0xFF0000) >> 16);
VM_memory[RF[rs] + immediate + 2] = (uint8_t)((RF[rt] & 0xFF00) >> 8);
VM_memory[RF[rs] + immediate + 3] = (uint8_t)(RF[rt] & 0xFF);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|slti\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] < immediate)?1:0;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sw\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
VM_memory[RF[rs] + immediate] = (uint8_t)((RF[rt] & 0xFF000000) >> 24);
VM_memory[RF[rs] + immediate + 1] = (uint8_t)((RF[rt] & 0xFF0000) >> 16);
VM_memory[RF[rs] + immediate + 2] = (uint8_t)((RF[rt] & 0xFF00) >> 8);
VM_memory[RF[rs] + immediate + 3] = (uint8_t)(RF[rt] & 0xFF);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


adduPLUSlwPLUSsltu:
#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|lw\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)(VM_memory[RF[rs] + immediate]) << 24) | ((uint32_t)(VM_memory[RF[rs] + immediate + 1]) << 16) | ((uint32_t)(VM_memory[RF[rs] + immediate + 2]) << 8) | ((uint32_t)VM_memory[RF[rs] + immediate + 3]);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sltu\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = (RF[rs] < RF[rt])?1:0;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


addiuPLUSaddiuPLUSandi:
#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|andi\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
RF[rt] = RF[rs] & (uint32_t)immediate;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


sllPLUSaddiuPLUSsll:
#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr0 >> 6) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr2 >> 6) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


sltuPLUSmovnPLUSjump:
#if INDIRECT_DEBUG
printf("%d|sltu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = (RF[rs] < RF[rt])?1:0;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|movn\n",counter);
counter++;
#endif

rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
if (RF[rt] != 0) RF[rd] = RF[rs];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|jump\n",counter);
counter++;
#endif
PC = nPC;
address = (instr2 >> 0) & 0x3FFFFFF;
nPC = address << 2;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


luiPLUSaddiuPLUSaddu:
#if INDIRECT_DEBUG
printf("%d|lui\n",counter);
counter++;
#endif
// NOTHING IMPLEMENTED, COPIED FROM BELOW
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)immediate) << 16;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


addiuPLUSbeqPLUSaddu:
#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|beq\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
if (RF[rs] == RF[rt])
{
  immediate = (instr1 >> 0) & 0xFFFF;
  PC  =  nPC;
  nPC  += (immediate << 2);
    if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


}
else
{
  PC  =  nPC;
  nPC  += 4;
}

#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


sllPLUSsrlPLUSor:
#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr0 >> 6) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|srl\n",counter);
counter++;
#endif
shamt = (instr1 >> 6) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rt] >> shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|or\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rs] | RF[rt];
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


sltPLUSbnePLUSsll:
#if INDIRECT_DEBUG
printf("%d|slt\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = (RF[rs] < RF[rt])?1:0;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|bne\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
if (RF[rs] != RF[rt])
{
  immediate = (instr1 >> 0) & 0xFFFF;
  PC  =  nPC;
  nPC  += (immediate << 2);
    if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


}
else
{
  PC  =  nPC;
  nPC  += 4;
}

#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr2 >> 6) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


addiuPLUSsltPLUSbeq:
#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|slt\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = (RF[rs] < RF[rt])?1:0;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|beq\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
if (RF[rs] == RF[rt])
{
  immediate = (instr2 >> 0) & 0xFFFF;
  PC  =  nPC;
  nPC  += (immediate << 2);
    if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


}
else
{
  PC  =  nPC;
  nPC  += 4;
}
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


sbPLUSjalPLUSaddu:
#if INDIRECT_DEBUG
printf("%d|sb\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
VM_memory[RF[rs] + immediate] = (uint8_t)(RF[rt] & 0xFF);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|jal\n",counter);
counter++;
#endif
RF[31] = PC + 8;
PC = nPC;
address = (instr1 >> 0) & 0x3FFFFFF;
nPC = address << 2;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;



#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


sllPLUSadduPLUSsw:
#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr0 >> 6) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sw\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
VM_memory[RF[rs] + immediate] = (uint8_t)((RF[rt] & 0xFF000000) >> 24);
VM_memory[RF[rs] + immediate + 1] = (uint8_t)((RF[rt] & 0xFF0000) >> 16);
VM_memory[RF[rs] + immediate + 2] = (uint8_t)((RF[rt] & 0xFF00) >> 8);
VM_memory[RF[rs] + immediate + 3] = (uint8_t)(RF[rt] & 0xFF);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


adduPLUSlwPLUSlw:
#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|lw\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)(VM_memory[RF[rs] + immediate]) << 24) | ((uint32_t)(VM_memory[RF[rs] + immediate + 1]) << 16) | ((uint32_t)(VM_memory[RF[rs] + immediate + 2]) << 8) | ((uint32_t)VM_memory[RF[rs] + immediate + 3]);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|lw\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)(VM_memory[RF[rs] + immediate]) << 24) | ((uint32_t)(VM_memory[RF[rs] + immediate + 1]) << 16) | ((uint32_t)(VM_memory[RF[rs] + immediate + 2]) << 8) | ((uint32_t)VM_memory[RF[rs] + immediate + 3]);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


movnPLUSbnePLUSaddu:
#if INDIRECT_DEBUG
printf("%d|movn\n",counter);
counter++;
#endif

rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
if (RF[rt] != 0) RF[rd] = RF[rs];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|bne\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
if (RF[rs] != RF[rt])
{
  immediate = (instr1 >> 0) & 0xFFFF;
  PC  =  nPC;
  nPC  += (immediate << 2);
    if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


}
else
{
  PC  =  nPC;
  nPC  += 4;
}

#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


sltiPLUSmovnPLUSbne:
#if INDIRECT_DEBUG
printf("%d|slti\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] < immediate)?1:0;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|movn\n",counter);
counter++;
#endif

rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
if (RF[rt] != 0) RF[rd] = RF[rs];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|bne\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
if (RF[rs] != RF[rt])
{
  immediate = (instr2 >> 0) & 0xFFFF;
  PC  =  nPC;
  nPC  += (immediate << 2);
    if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


}
else
{
  PC  =  nPC;
  nPC  += 4;
}
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


addiuPLUSlwPLUSerror:
#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|lw\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)(VM_memory[RF[rs] + immediate]) << 24) | ((uint32_t)(VM_memory[RF[rs] + immediate + 1]) << 16) | ((uint32_t)(VM_memory[RF[rs] + immediate + 2]) << 8) | ((uint32_t)VM_memory[RF[rs] + immediate + 3]);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("Error, unknown instr2uction %d.\n", instr2);
#endif
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


sllPLUSswPLUSsw:
#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr0 >> 6) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sw\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
VM_memory[RF[rs] + immediate] = (uint8_t)((RF[rt] & 0xFF000000) >> 24);
VM_memory[RF[rs] + immediate + 1] = (uint8_t)((RF[rt] & 0xFF0000) >> 16);
VM_memory[RF[rs] + immediate + 2] = (uint8_t)((RF[rt] & 0xFF00) >> 8);
VM_memory[RF[rs] + immediate + 3] = (uint8_t)(RF[rt] & 0xFF);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sw\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
VM_memory[RF[rs] + immediate] = (uint8_t)((RF[rt] & 0xFF000000) >> 24);
VM_memory[RF[rs] + immediate + 1] = (uint8_t)((RF[rt] & 0xFF0000) >> 16);
VM_memory[RF[rs] + immediate + 2] = (uint8_t)((RF[rt] & 0xFF00) >> 8);
VM_memory[RF[rs] + immediate + 3] = (uint8_t)(RF[rt] & 0xFF);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


sllPLUSadduPLUSslt:
#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr0 >> 6) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|slt\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = (RF[rs] < RF[rt])?1:0;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


luiPLUSlwPLUSaddiu:
#if INDIRECT_DEBUG
printf("%d|lui\n",counter);
counter++;
#endif
// NOTHING IMPLEMENTED, COPIED FROM BELOW
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)immediate) << 16;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|lw\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)(VM_memory[RF[rs] + immediate]) << 24) | ((uint32_t)(VM_memory[RF[rs] + immediate + 1]) << 16) | ((uint32_t)(VM_memory[RF[rs] + immediate + 2]) << 8) | ((uint32_t)VM_memory[RF[rs] + immediate + 3]);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


swPLUSaddiuPLUSaddiu:
#if INDIRECT_DEBUG
printf("%d|sw\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
VM_memory[RF[rs] + immediate] = (uint8_t)((RF[rt] & 0xFF000000) >> 24);
VM_memory[RF[rs] + immediate + 1] = (uint8_t)((RF[rt] & 0xFF0000) >> 16);
VM_memory[RF[rs] + immediate + 2] = (uint8_t)((RF[rt] & 0xFF00) >> 8);
VM_memory[RF[rs] + immediate + 3] = (uint8_t)(RF[rt] & 0xFF);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


sllPLUSadduPLUSsll:
#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr0 >> 6) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr2 >> 6) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


lwPLUSlwPLUSerror:
#if INDIRECT_DEBUG
printf("%d|lw\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)(VM_memory[RF[rs] + immediate]) << 24) | ((uint32_t)(VM_memory[RF[rs] + immediate + 1]) << 16) | ((uint32_t)(VM_memory[RF[rs] + immediate + 2]) << 8) | ((uint32_t)VM_memory[RF[rs] + immediate + 3]);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|lw\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)(VM_memory[RF[rs] + immediate]) << 24) | ((uint32_t)(VM_memory[RF[rs] + immediate + 1]) << 16) | ((uint32_t)(VM_memory[RF[rs] + immediate + 2]) << 8) | ((uint32_t)VM_memory[RF[rs] + immediate + 3]);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("Error, unknown instr2uction %d.\n", instr2);
#endif
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


sltiPLUSbnePLUSaddiu:
#if INDIRECT_DEBUG
printf("%d|slti\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] < immediate)?1:0;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|bne\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
if (RF[rs] != RF[rt])
{
  immediate = (instr1 >> 0) & 0xFFFF;
  PC  =  nPC;
  nPC  += (immediate << 2);
    if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


}
else
{
  PC  =  nPC;
  nPC  += 4;
}

#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


sltuPLUSbeqPLUSaddiu:
#if INDIRECT_DEBUG
printf("%d|sltu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = (RF[rs] < RF[rt])?1:0;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|beq\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
if (RF[rs] == RF[rt])
{
  immediate = (instr1 >> 0) & 0xFFFF;
  PC  =  nPC;
  nPC  += (immediate << 2);
    if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


}
else
{
  PC  =  nPC;
  nPC  += 4;
}

#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


lwPLUSlwPLUSblez:
#if INDIRECT_DEBUG
printf("%d|lw\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)(VM_memory[RF[rs] + immediate]) << 24) | ((uint32_t)(VM_memory[RF[rs] + immediate + 1]) << 16) | ((uint32_t)(VM_memory[RF[rs] + immediate + 2]) << 8) | ((uint32_t)VM_memory[RF[rs] + immediate + 3]);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|lw\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)(VM_memory[RF[rs] + immediate]) << 24) | ((uint32_t)(VM_memory[RF[rs] + immediate + 1]) << 16) | ((uint32_t)(VM_memory[RF[rs] + immediate + 2]) << 8) | ((uint32_t)VM_memory[RF[rs] + immediate + 3]);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|blez\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
if ((int32_t)RF[rs] <= 0)
{
  immediate = (instr2 >> 0) & 0xFFFF;
  PC  =  nPC;
  nPC  += (immediate << 2);
    if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


}
else
{
  PC  =  nPC;
  nPC  += 4;
}
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


swPLUSlwPLUSjal:
#if INDIRECT_DEBUG
printf("%d|sw\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
VM_memory[RF[rs] + immediate] = (uint8_t)((RF[rt] & 0xFF000000) >> 24);
VM_memory[RF[rs] + immediate + 1] = (uint8_t)((RF[rt] & 0xFF0000) >> 16);
VM_memory[RF[rs] + immediate + 2] = (uint8_t)((RF[rt] & 0xFF00) >> 8);
VM_memory[RF[rs] + immediate + 3] = (uint8_t)(RF[rt] & 0xFF);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|lw\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)(VM_memory[RF[rs] + immediate]) << 24) | ((uint32_t)(VM_memory[RF[rs] + immediate + 1]) << 16) | ((uint32_t)(VM_memory[RF[rs] + immediate + 2]) << 8) | ((uint32_t)VM_memory[RF[rs] + immediate + 3]);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|jal\n",counter);
counter++;
#endif
RF[31] = PC + 8;
PC = nPC;
address = (instr2 >> 0) & 0x3FFFFFF;
nPC = address << 2;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


swPLUSadduPLUSaddiu:
#if INDIRECT_DEBUG
printf("%d|sw\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
VM_memory[RF[rs] + immediate] = (uint8_t)((RF[rt] & 0xFF000000) >> 24);
VM_memory[RF[rs] + immediate + 1] = (uint8_t)((RF[rt] & 0xFF0000) >> 16);
VM_memory[RF[rs] + immediate + 2] = (uint8_t)((RF[rt] & 0xFF00) >> 8);
VM_memory[RF[rs] + immediate + 3] = (uint8_t)(RF[rt] & 0xFF);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


jalPLUSadduPLUSlui:
#if INDIRECT_DEBUG
printf("%d|jal\n",counter);
counter++;
#endif
RF[31] = PC + 8;
PC = nPC;
address = (instr0 >> 0) & 0x3FFFFFF;
nPC = address << 2;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;



#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|lui\n",counter);
counter++;
#endif
// NOTHING IMPLEMENTED, COPIED FROM BELOW
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)immediate) << 16;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


sllPLUSjumpPLUSsw:
#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr0 >> 6) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|jump\n",counter);
counter++;
#endif
PC = nPC;
address = (instr1 >> 0) & 0x3FFFFFF;
nPC = address << 2;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;



#if INDIRECT_DEBUG
printf("%d|sw\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
VM_memory[RF[rs] + immediate] = (uint8_t)((RF[rt] & 0xFF000000) >> 24);
VM_memory[RF[rs] + immediate + 1] = (uint8_t)((RF[rt] & 0xFF0000) >> 16);
VM_memory[RF[rs] + immediate + 2] = (uint8_t)((RF[rt] & 0xFF00) >> 8);
VM_memory[RF[rs] + immediate + 3] = (uint8_t)(RF[rt] & 0xFF);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


swPLUSlwPLUSlw:
#if INDIRECT_DEBUG
printf("%d|sw\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
VM_memory[RF[rs] + immediate] = (uint8_t)((RF[rt] & 0xFF000000) >> 24);
VM_memory[RF[rs] + immediate + 1] = (uint8_t)((RF[rt] & 0xFF0000) >> 16);
VM_memory[RF[rs] + immediate + 2] = (uint8_t)((RF[rt] & 0xFF00) >> 8);
VM_memory[RF[rs] + immediate + 3] = (uint8_t)(RF[rt] & 0xFF);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|lw\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)(VM_memory[RF[rs] + immediate]) << 24) | ((uint32_t)(VM_memory[RF[rs] + immediate + 1]) << 16) | ((uint32_t)(VM_memory[RF[rs] + immediate + 2]) << 8) | ((uint32_t)VM_memory[RF[rs] + immediate + 3]);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|lw\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)(VM_memory[RF[rs] + immediate]) << 24) | ((uint32_t)(VM_memory[RF[rs] + immediate + 1]) << 16) | ((uint32_t)(VM_memory[RF[rs] + immediate + 2]) << 8) | ((uint32_t)VM_memory[RF[rs] + immediate + 3]);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


addiuPLUSerrorPLUSsubu:
#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("Error, unknown instr1uction %d.\n", instr1);
#endif
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|subu\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rs] - RF[rt];
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


swPLUSaddiuPLUSsrl:
#if INDIRECT_DEBUG
printf("%d|sw\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
VM_memory[RF[rs] + immediate] = (uint8_t)((RF[rt] & 0xFF000000) >> 24);
VM_memory[RF[rs] + immediate + 1] = (uint8_t)((RF[rt] & 0xFF0000) >> 16);
VM_memory[RF[rs] + immediate + 2] = (uint8_t)((RF[rt] & 0xFF00) >> 8);
VM_memory[RF[rs] + immediate + 3] = (uint8_t)(RF[rt] & 0xFF);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|srl\n",counter);
counter++;
#endif
shamt = (instr2 >> 6) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rt] >> shamt;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


addiuPLUSsubuPLUSand:
#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|subu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rs] - RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|and\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rs] & RF[rt];
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


luiPLUSaddiuPLUSxor:
#if INDIRECT_DEBUG
printf("%d|lui\n",counter);
counter++;
#endif
// NOTHING IMPLEMENTED, COPIED FROM BELOW
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)immediate) << 16;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|xor\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rs] ^ RF[rt];
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


jrPLUSaddiuPLUSbne:
#if INDIRECT_DEBUG
printf("%d|jr\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
PC = nPC;
nPC = RF[rs];
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;



#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|bne\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
if (RF[rs] != RF[rt])
{
  immediate = (instr2 >> 0) & 0xFFFF;
  PC  =  nPC;
  nPC  += (immediate << 2);
    if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


}
else
{
  PC  =  nPC;
  nPC  += 4;
}
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


oriPLUSandPLUSor:
#if INDIRECT_DEBUG
printf("%d|ori\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = RF[rs] | (uint32_t)immediate;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|and\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rs] & RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|or\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rs] | RF[rt];
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


swPLUSlwPLUSsw:
#if INDIRECT_DEBUG
printf("%d|sw\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
VM_memory[RF[rs] + immediate] = (uint8_t)((RF[rt] & 0xFF000000) >> 24);
VM_memory[RF[rs] + immediate + 1] = (uint8_t)((RF[rt] & 0xFF0000) >> 16);
VM_memory[RF[rs] + immediate + 2] = (uint8_t)((RF[rt] & 0xFF00) >> 8);
VM_memory[RF[rs] + immediate + 3] = (uint8_t)(RF[rt] & 0xFF);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|lw\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)(VM_memory[RF[rs] + immediate]) << 24) | ((uint32_t)(VM_memory[RF[rs] + immediate + 1]) << 16) | ((uint32_t)(VM_memory[RF[rs] + immediate + 2]) << 8) | ((uint32_t)VM_memory[RF[rs] + immediate + 3]);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sw\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
VM_memory[RF[rs] + immediate] = (uint8_t)((RF[rt] & 0xFF000000) >> 24);
VM_memory[RF[rs] + immediate + 1] = (uint8_t)((RF[rt] & 0xFF0000) >> 16);
VM_memory[RF[rs] + immediate + 2] = (uint8_t)((RF[rt] & 0xFF00) >> 8);
VM_memory[RF[rs] + immediate + 3] = (uint8_t)(RF[rt] & 0xFF);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


sllPLUSaddiuPLUSsw:
#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr0 >> 6) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sw\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
VM_memory[RF[rs] + immediate] = (uint8_t)((RF[rt] & 0xFF000000) >> 24);
VM_memory[RF[rs] + immediate + 1] = (uint8_t)((RF[rt] & 0xFF0000) >> 16);
VM_memory[RF[rs] + immediate + 2] = (uint8_t)((RF[rt] & 0xFF00) >> 8);
VM_memory[RF[rs] + immediate + 3] = (uint8_t)(RF[rt] & 0xFF);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


swPLUSsllPLUSslt:
#if INDIRECT_DEBUG
printf("%d|sw\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
VM_memory[RF[rs] + immediate] = (uint8_t)((RF[rt] & 0xFF000000) >> 24);
VM_memory[RF[rs] + immediate + 1] = (uint8_t)((RF[rt] & 0xFF0000) >> 16);
VM_memory[RF[rs] + immediate + 2] = (uint8_t)((RF[rt] & 0xFF00) >> 8);
VM_memory[RF[rs] + immediate + 3] = (uint8_t)(RF[rt] & 0xFF);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr1 >> 6) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|slt\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = (RF[rs] < RF[rt])?1:0;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


andiPLUSorPLUSsrl:
#if INDIRECT_DEBUG
printf("%d|andi\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = RF[rs] & (uint32_t)immediate;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|or\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rs] | RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|srl\n",counter);
counter++;
#endif
shamt = (instr2 >> 6) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rt] >> shamt;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


movnPLUSaddiuPLUSsll:
#if INDIRECT_DEBUG
printf("%d|movn\n",counter);
counter++;
#endif

rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
if (RF[rt] != 0) RF[rd] = RF[rs];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr2 >> 6) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


adduPLUSluiPLUSaddiu:
#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|lui\n",counter);
counter++;
#endif
// NOTHING IMPLEMENTED, COPIED FROM BELOW
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)immediate) << 16;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


addiuPLUSaddiuPLUSsrl:
#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|srl\n",counter);
counter++;
#endif
shamt = (instr2 >> 6) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rt] >> shamt;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


jumpPLUSadduPLUSsll:
#if INDIRECT_DEBUG
printf("%d|jump\n",counter);
counter++;
#endif
PC = nPC;
address = (instr0 >> 0) & 0x3FFFFFF;
nPC = address << 2;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;



#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr2 >> 6) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


addiuPLUSlwPLUSbeq:
#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|lw\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)(VM_memory[RF[rs] + immediate]) << 24) | ((uint32_t)(VM_memory[RF[rs] + immediate + 1]) << 16) | ((uint32_t)(VM_memory[RF[rs] + immediate + 2]) << 8) | ((uint32_t)VM_memory[RF[rs] + immediate + 3]);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|beq\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
if (RF[rs] == RF[rt])
{
  immediate = (instr2 >> 0) & 0xFFFF;
  PC  =  nPC;
  nPC  += (immediate << 2);
    if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


}
else
{
  PC  =  nPC;
  nPC  += 4;
}
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


lwPLUSxorPLUSxor:
#if INDIRECT_DEBUG
printf("%d|lw\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)(VM_memory[RF[rs] + immediate]) << 24) | ((uint32_t)(VM_memory[RF[rs] + immediate + 1]) << 16) | ((uint32_t)(VM_memory[RF[rs] + immediate + 2]) << 8) | ((uint32_t)VM_memory[RF[rs] + immediate + 3]);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|xor\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rs] ^ RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|xor\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rs] ^ RF[rt];
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


addiuPLUSswPLUSsw:
#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sw\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
VM_memory[RF[rs] + immediate] = (uint8_t)((RF[rt] & 0xFF000000) >> 24);
VM_memory[RF[rs] + immediate + 1] = (uint8_t)((RF[rt] & 0xFF0000) >> 16);
VM_memory[RF[rs] + immediate + 2] = (uint8_t)((RF[rt] & 0xFF00) >> 8);
VM_memory[RF[rs] + immediate + 3] = (uint8_t)(RF[rt] & 0xFF);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sw\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
VM_memory[RF[rs] + immediate] = (uint8_t)((RF[rt] & 0xFF000000) >> 24);
VM_memory[RF[rs] + immediate + 1] = (uint8_t)((RF[rt] & 0xFF0000) >> 16);
VM_memory[RF[rs] + immediate + 2] = (uint8_t)((RF[rt] & 0xFF00) >> 8);
VM_memory[RF[rs] + immediate + 3] = (uint8_t)(RF[rt] & 0xFF);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


andPLUSxorPLUSbne:
#if INDIRECT_DEBUG
printf("%d|and\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rs] & RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|xor\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rs] ^ RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|bne\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
if (RF[rs] != RF[rt])
{
  immediate = (instr2 >> 0) & 0xFFFF;
  PC  =  nPC;
  nPC  += (immediate << 2);
    if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


}
else
{
  PC  =  nPC;
  nPC  += 4;
}
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


mfhiPLUSaddiuPLUSaddiu:
#if INDIRECT_DEBUG
printf("%d|mfhi\n",counter);
counter++;
#endif
rd = (instr0 >> 11) & 0x1F;
RF[rd] = HI;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


adduPLUSlwPLUSori:
#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|lw\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)(VM_memory[RF[rs] + immediate]) << 24) | ((uint32_t)(VM_memory[RF[rs] + immediate + 1]) << 16) | ((uint32_t)(VM_memory[RF[rs] + immediate + 2]) << 8) | ((uint32_t)VM_memory[RF[rs] + immediate + 3]);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|ori\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
RF[rt] = RF[rs] | (uint32_t)immediate;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


bnePLUSadduPLUSmult:
#if INDIRECT_DEBUG
printf("%d|bne\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
if (RF[rs] != RF[rt])
{
  immediate = (instr0 >> 0) & 0xFFFF;
  PC  =  nPC;
  nPC  += (immediate << 2);
    if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


}
else
{
  PC  =  nPC;
  nPC  += 4;
}

#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|mult\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
mult = (uint64_t)RF[rs] * (uint64_t) RF[rt];
HI = (mult >> 32) & 0xFFFFFFFF;
LO = mult & 0xFFFFFFFF;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


sllPLUSxorPLUSandi:
#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr0 >> 6) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|xor\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rs] ^ RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|andi\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
RF[rt] = RF[rs] & (uint32_t)immediate;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


addiuPLUSxorPLUSandi:
#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|xor\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rs] ^ RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|andi\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
RF[rt] = RF[rs] & (uint32_t)immediate;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


swPLUSsbPLUSjal:
#if INDIRECT_DEBUG
printf("%d|sw\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
VM_memory[RF[rs] + immediate] = (uint8_t)((RF[rt] & 0xFF000000) >> 24);
VM_memory[RF[rs] + immediate + 1] = (uint8_t)((RF[rt] & 0xFF0000) >> 16);
VM_memory[RF[rs] + immediate + 2] = (uint8_t)((RF[rt] & 0xFF00) >> 8);
VM_memory[RF[rs] + immediate + 3] = (uint8_t)(RF[rt] & 0xFF);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sb\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
VM_memory[RF[rs] + immediate] = (uint8_t)(RF[rt] & 0xFF);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|jal\n",counter);
counter++;
#endif
RF[31] = PC + 8;
PC = nPC;
address = (instr2 >> 0) & 0x3FFFFFF;
nPC = address << 2;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


lwPLUSsllPLUSaddu:
#if INDIRECT_DEBUG
printf("%d|lw\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)(VM_memory[RF[rs] + immediate]) << 24) | ((uint32_t)(VM_memory[RF[rs] + immediate + 1]) << 16) | ((uint32_t)(VM_memory[RF[rs] + immediate + 2]) << 8) | ((uint32_t)VM_memory[RF[rs] + immediate + 3]);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr1 >> 6) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


sltuPLUSaddiuPLUSbeq:
#if INDIRECT_DEBUG
printf("%d|sltu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = (RF[rs] < RF[rt])?1:0;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|beq\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
if (RF[rs] == RF[rt])
{
  immediate = (instr2 >> 0) & 0xFFFF;
  PC  =  nPC;
  nPC  += (immediate << 2);
    if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


}
else
{
  PC  =  nPC;
  nPC  += 4;
}
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


sllPLUSandiPLUSsll:
#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr0 >> 6) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|andi\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = RF[rs] & (uint32_t)immediate;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr2 >> 6) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


beqPLUSaddiuPLUSaddiu:
#if INDIRECT_DEBUG
printf("%d|beq\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
if (RF[rs] == RF[rt])
{
  immediate = (instr0 >> 0) & 0xFFFF;
  PC  =  nPC;
  nPC  += (immediate << 2);
    if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


}
else
{
  PC  =  nPC;
  nPC  += 4;
}

#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


addiuPLUSsrlPLUSbne:
#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|srl\n",counter);
counter++;
#endif
shamt = (instr1 >> 6) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rt] >> shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|bne\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
if (RF[rs] != RF[rt])
{
  immediate = (instr2 >> 0) & 0xFFFF;
  PC  =  nPC;
  nPC  += (immediate << 2);
    if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


}
else
{
  PC  =  nPC;
  nPC  += 4;
}
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


swPLUSaddiuPLUSslti:
#if INDIRECT_DEBUG
printf("%d|sw\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
VM_memory[RF[rs] + immediate] = (uint8_t)((RF[rt] & 0xFF000000) >> 24);
VM_memory[RF[rs] + immediate + 1] = (uint8_t)((RF[rt] & 0xFF0000) >> 16);
VM_memory[RF[rs] + immediate + 2] = (uint8_t)((RF[rt] & 0xFF00) >> 8);
VM_memory[RF[rs] + immediate + 3] = (uint8_t)(RF[rt] & 0xFF);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|slti\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] < immediate)?1:0;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


sllPLUSlbuPLUSbeq:
#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr0 >> 6) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|lbu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)VM_memory[RF[rs] + immediate]) & 0xFF;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|beq\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
if (RF[rs] == RF[rt])
{
  immediate = (instr2 >> 0) & 0xFFFF;
  PC  =  nPC;
  nPC  += (immediate << 2);
    if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


}
else
{
  PC  =  nPC;
  nPC  += 4;
}
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


lwPLUSlwPLUSaddiu:
#if INDIRECT_DEBUG
printf("%d|lw\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)(VM_memory[RF[rs] + immediate]) << 24) | ((uint32_t)(VM_memory[RF[rs] + immediate + 1]) << 16) | ((uint32_t)(VM_memory[RF[rs] + immediate + 2]) << 8) | ((uint32_t)VM_memory[RF[rs] + immediate + 3]);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|lw\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)(VM_memory[RF[rs] + immediate]) << 24) | ((uint32_t)(VM_memory[RF[rs] + immediate + 1]) << 16) | ((uint32_t)(VM_memory[RF[rs] + immediate + 2]) << 8) | ((uint32_t)VM_memory[RF[rs] + immediate + 3]);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


bnePLUSadduPLUSaddiu:
#if INDIRECT_DEBUG
printf("%d|bne\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
if (RF[rs] != RF[rt])
{
  immediate = (instr0 >> 0) & 0xFFFF;
  PC  =  nPC;
  nPC  += (immediate << 2);
    if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


}
else
{
  PC  =  nPC;
  nPC  += 4;
}

#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


beqPLUSsllPLUSbne:
#if INDIRECT_DEBUG
printf("%d|beq\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
if (RF[rs] == RF[rt])
{
  immediate = (instr0 >> 0) & 0xFFFF;
  PC  =  nPC;
  nPC  += (immediate << 2);
    if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


}
else
{
  PC  =  nPC;
  nPC  += 4;
}

#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr1 >> 6) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|bne\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
if (RF[rs] != RF[rt])
{
  immediate = (instr2 >> 0) & 0xFFFF;
  PC  =  nPC;
  nPC  += (immediate << 2);
    if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


}
else
{
  PC  =  nPC;
  nPC  += 4;
}
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


beqPLUSsllPLUSsw:
#if INDIRECT_DEBUG
printf("%d|beq\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
if (RF[rs] == RF[rt])
{
  immediate = (instr0 >> 0) & 0xFFFF;
  PC  =  nPC;
  nPC  += (immediate << 2);
    if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


}
else
{
  PC  =  nPC;
  nPC  += 4;
}

#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr1 >> 6) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sw\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
VM_memory[RF[rs] + immediate] = (uint8_t)((RF[rt] & 0xFF000000) >> 24);
VM_memory[RF[rs] + immediate + 1] = (uint8_t)((RF[rt] & 0xFF0000) >> 16);
VM_memory[RF[rs] + immediate + 2] = (uint8_t)((RF[rt] & 0xFF00) >> 8);
VM_memory[RF[rs] + immediate + 3] = (uint8_t)(RF[rt] & 0xFF);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


addiuPLUSaddiuPLUSbne:
#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|bne\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
if (RF[rs] != RF[rt])
{
  immediate = (instr2 >> 0) & 0xFFFF;
  PC  =  nPC;
  nPC  += (immediate << 2);
    if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


}
else
{
  PC  =  nPC;
  nPC  += 4;
}
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


adduPLUSsubuPLUSaddu:
#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|subu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rs] - RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


bnePLUSaddiuPLUSslti:
#if INDIRECT_DEBUG
printf("%d|bne\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
if (RF[rs] != RF[rt])
{
  immediate = (instr0 >> 0) & 0xFFFF;
  PC  =  nPC;
  nPC  += (immediate << 2);
    if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


}
else
{
  PC  =  nPC;
  nPC  += 4;
}

#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|slti\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] < immediate)?1:0;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


orPLUSsllPLUSand:
#if INDIRECT_DEBUG
printf("%d|or\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rs] | RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr1 >> 6) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|and\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rs] & RF[rt];
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


mfhiPLUSmultPLUSmfhi:
#if INDIRECT_DEBUG
printf("%d|mfhi\n",counter);
counter++;
#endif
rd = (instr0 >> 11) & 0x1F;
RF[rd] = HI;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|mult\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
mult = (uint64_t)RF[rs] * (uint64_t) RF[rt];
HI = (mult >> 32) & 0xFFFFFFFF;
LO = mult & 0xFFFFFFFF;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|mfhi\n",counter);
counter++;
#endif
rd = (instr2 >> 11) & 0x1F;
RF[rd] = HI;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


sltPLUSbnePLUSaddiu:
#if INDIRECT_DEBUG
printf("%d|slt\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = (RF[rs] < RF[rt])?1:0;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|bne\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
if (RF[rs] != RF[rt])
{
  immediate = (instr1 >> 0) & 0xFFFF;
  PC  =  nPC;
  nPC  += (immediate << 2);
    if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


}
else
{
  PC  =  nPC;
  nPC  += 4;
}

#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


lwPLUSaddiuPLUSjump:
#if INDIRECT_DEBUG
printf("%d|lw\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)(VM_memory[RF[rs] + immediate]) << 24) | ((uint32_t)(VM_memory[RF[rs] + immediate + 1]) << 16) | ((uint32_t)(VM_memory[RF[rs] + immediate + 2]) << 8) | ((uint32_t)VM_memory[RF[rs] + immediate + 3]);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|jump\n",counter);
counter++;
#endif
PC = nPC;
address = (instr2 >> 0) & 0x3FFFFFF;
nPC = address << 2;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


bnePLUSaddiuPLUSsubu:
#if INDIRECT_DEBUG
printf("%d|bne\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
if (RF[rs] != RF[rt])
{
  immediate = (instr0 >> 0) & 0xFFFF;
  PC  =  nPC;
  nPC  += (immediate << 2);
    if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


}
else
{
  PC  =  nPC;
  nPC  += 4;
}

#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|subu\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rs] - RF[rt];
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


addiuPLUSswPLUSaddu:
#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sw\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
VM_memory[RF[rs] + immediate] = (uint8_t)((RF[rt] & 0xFF000000) >> 24);
VM_memory[RF[rs] + immediate + 1] = (uint8_t)((RF[rt] & 0xFF0000) >> 16);
VM_memory[RF[rs] + immediate + 2] = (uint8_t)((RF[rt] & 0xFF00) >> 8);
VM_memory[RF[rs] + immediate + 3] = (uint8_t)(RF[rt] & 0xFF);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


sllPLUSadduPLUSslti:
#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr0 >> 6) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|slti\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] < immediate)?1:0;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


addiuPLUSlwPLUSaddu:
#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|lw\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)(VM_memory[RF[rs] + immediate]) << 24) | ((uint32_t)(VM_memory[RF[rs] + immediate + 1]) << 16) | ((uint32_t)(VM_memory[RF[rs] + immediate + 2]) << 8) | ((uint32_t)VM_memory[RF[rs] + immediate + 3]);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


adduPLUSaddiuPLUSsll:
#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr2 >> 6) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


adduPLUSadduPLUSsll:
#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr2 >> 6) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


jrPLUSaddiuPLUSlw:
#if INDIRECT_DEBUG
printf("%d|jr\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
PC = nPC;
nPC = RF[rs];
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;



#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|lw\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)(VM_memory[RF[rs] + immediate]) << 24) | ((uint32_t)(VM_memory[RF[rs] + immediate + 1]) << 16) | ((uint32_t)(VM_memory[RF[rs] + immediate + 2]) << 8) | ((uint32_t)VM_memory[RF[rs] + immediate + 3]);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


addiuPLUSsyscPLUSjal:
#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sysc\n",counter);
counter++;
#endif
if (syscall((uint8_t)RF[2])) //registers $4 and $5 useb by hallcall (sensid and retval respectively)
{
halted = 1; //Syscall returned 1, exit code
goto end;
}
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|jal\n",counter);
counter++;
#endif
RF[31] = PC + 8;
PC = nPC;
address = (instr2 >> 0) & 0x3FFFFFF;
nPC = address << 2;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


sllPLUSlwPLUSslti:
#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr0 >> 6) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|lw\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)(VM_memory[RF[rs] + immediate]) << 24) | ((uint32_t)(VM_memory[RF[rs] + immediate + 1]) << 16) | ((uint32_t)(VM_memory[RF[rs] + immediate + 2]) << 8) | ((uint32_t)VM_memory[RF[rs] + immediate + 3]);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|slti\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] < immediate)?1:0;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


andiPLUSjrPLUSor:
#if INDIRECT_DEBUG
printf("%d|andi\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = RF[rs] & (uint32_t)immediate;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|jr\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
PC = nPC;
nPC = RF[rs];
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;



#if INDIRECT_DEBUG
printf("%d|or\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rs] | RF[rt];
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


lwPLUSadduPLUSsw:
#if INDIRECT_DEBUG
printf("%d|lw\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)(VM_memory[RF[rs] + immediate]) << 24) | ((uint32_t)(VM_memory[RF[rs] + immediate + 1]) << 16) | ((uint32_t)(VM_memory[RF[rs] + immediate + 2]) << 8) | ((uint32_t)VM_memory[RF[rs] + immediate + 3]);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sw\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
VM_memory[RF[rs] + immediate] = (uint8_t)((RF[rt] & 0xFF000000) >> 24);
VM_memory[RF[rs] + immediate + 1] = (uint8_t)((RF[rt] & 0xFF0000) >> 16);
VM_memory[RF[rs] + immediate + 2] = (uint8_t)((RF[rt] & 0xFF00) >> 8);
VM_memory[RF[rs] + immediate + 3] = (uint8_t)(RF[rt] & 0xFF);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


adduPLUSjumpPLUSaddu:
#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|jump\n",counter);
counter++;
#endif
PC = nPC;
address = (instr1 >> 0) & 0x3FFFFFF;
nPC = address << 2;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;



#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


multPLUSmfhiPLUSsll:
#if INDIRECT_DEBUG
printf("%d|mult\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
mult = (uint64_t)RF[rs] * (uint64_t) RF[rt];
HI = (mult >> 32) & 0xFFFFFFFF;
LO = mult & 0xFFFFFFFF;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|mfhi\n",counter);
counter++;
#endif
rd = (instr1 >> 11) & 0x1F;
RF[rd] = HI;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr2 >> 6) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


mfhiPLUSsllPLUSsll:
#if INDIRECT_DEBUG
printf("%d|mfhi\n",counter);
counter++;
#endif
rd = (instr0 >> 11) & 0x1F;
RF[rd] = HI;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr1 >> 6) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr2 >> 6) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


addiuPLUSmultPLUSmfhi:
#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|mult\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
mult = (uint64_t)RF[rs] * (uint64_t) RF[rt];
HI = (mult >> 32) & 0xFFFFFFFF;
LO = mult & 0xFFFFFFFF;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|mfhi\n",counter);
counter++;
#endif
rd = (instr2 >> 11) & 0x1F;
RF[rd] = HI;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


xorPLUSxorPLUSandi:
#if INDIRECT_DEBUG
printf("%d|xor\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rs] ^ RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|xor\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rs] ^ RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|andi\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
RF[rt] = RF[rs] & (uint32_t)immediate;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


addiuPLUSluiPLUSori:
#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|lui\n",counter);
counter++;
#endif
// NOTHING IMPLEMENTED, COPIED FROM BELOW
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)immediate) << 16;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|ori\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
RF[rt] = RF[rs] | (uint32_t)immediate;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


lwPLUSlwPLUSjr:
#if INDIRECT_DEBUG
printf("%d|lw\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)(VM_memory[RF[rs] + immediate]) << 24) | ((uint32_t)(VM_memory[RF[rs] + immediate + 1]) << 16) | ((uint32_t)(VM_memory[RF[rs] + immediate + 2]) << 8) | ((uint32_t)VM_memory[RF[rs] + immediate + 3]);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|lw\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)(VM_memory[RF[rs] + immediate]) << 24) | ((uint32_t)(VM_memory[RF[rs] + immediate + 1]) << 16) | ((uint32_t)(VM_memory[RF[rs] + immediate + 2]) << 8) | ((uint32_t)VM_memory[RF[rs] + immediate + 3]);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|jr\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
PC = nPC;
nPC = RF[rs];
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


adduPLUSswPLUSsll:
#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sw\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
VM_memory[RF[rs] + immediate] = (uint8_t)((RF[rt] & 0xFF000000) >> 24);
VM_memory[RF[rs] + immediate + 1] = (uint8_t)((RF[rt] & 0xFF0000) >> 16);
VM_memory[RF[rs] + immediate + 2] = (uint8_t)((RF[rt] & 0xFF00) >> 8);
VM_memory[RF[rs] + immediate + 3] = (uint8_t)(RF[rt] & 0xFF);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr2 >> 6) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


sllPLUSlwPLUSaddiu:
#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr0 >> 6) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|lw\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)(VM_memory[RF[rs] + immediate]) << 24) | ((uint32_t)(VM_memory[RF[rs] + immediate + 1]) << 16) | ((uint32_t)(VM_memory[RF[rs] + immediate + 2]) << 8) | ((uint32_t)VM_memory[RF[rs] + immediate + 3]);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


addiuPLUSaddiuPLUSsysc:
#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sysc\n",counter);
counter++;
#endif
if (syscall((uint8_t)RF[2])) //registers $4 and $5 useb by hallcall (sensid and retval respectively)
{
halted = 1; //Syscall returned 1, exit code
goto end;
}
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


adduPLUSsltPLUSlw:
#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|slt\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = (RF[rs] < RF[rt])?1:0;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|lw\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)(VM_memory[RF[rs] + immediate]) << 24) | ((uint32_t)(VM_memory[RF[rs] + immediate + 1]) << 16) | ((uint32_t)(VM_memory[RF[rs] + immediate + 2]) << 8) | ((uint32_t)VM_memory[RF[rs] + immediate + 3]);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


oriPLUSsllPLUSaddu:
#if INDIRECT_DEBUG
printf("%d|ori\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = RF[rs] | (uint32_t)immediate;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr1 >> 6) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


adduPLUSsltPLUSbeq:
#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|slt\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = (RF[rs] < RF[rt])?1:0;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|beq\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
if (RF[rs] == RF[rt])
{
  immediate = (instr2 >> 0) & 0xFFFF;
  PC  =  nPC;
  nPC  += (immediate << 2);
    if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


}
else
{
  PC  =  nPC;
  nPC  += 4;
}
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


lwPLUSerrorPLUSlw:
#if INDIRECT_DEBUG
printf("%d|lw\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)(VM_memory[RF[rs] + immediate]) << 24) | ((uint32_t)(VM_memory[RF[rs] + immediate + 1]) << 16) | ((uint32_t)(VM_memory[RF[rs] + immediate + 2]) << 8) | ((uint32_t)VM_memory[RF[rs] + immediate + 3]);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("Error, unknown instr1uction %d.\n", instr1);
#endif
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|lw\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)(VM_memory[RF[rs] + immediate]) << 24) | ((uint32_t)(VM_memory[RF[rs] + immediate + 1]) << 16) | ((uint32_t)(VM_memory[RF[rs] + immediate + 2]) << 8) | ((uint32_t)VM_memory[RF[rs] + immediate + 3]);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


andiPLUSorPLUSsll:
#if INDIRECT_DEBUG
printf("%d|andi\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = RF[rs] & (uint32_t)immediate;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|or\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rs] | RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr2 >> 6) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


sllPLUSlwPLUSbeq:
#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr0 >> 6) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|lw\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)(VM_memory[RF[rs] + immediate]) << 24) | ((uint32_t)(VM_memory[RF[rs] + immediate + 1]) << 16) | ((uint32_t)(VM_memory[RF[rs] + immediate + 2]) << 8) | ((uint32_t)VM_memory[RF[rs] + immediate + 3]);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|beq\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
if (RF[rs] == RF[rt])
{
  immediate = (instr2 >> 0) & 0xFFFF;
  PC  =  nPC;
  nPC  += (immediate << 2);
    if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


}
else
{
  PC  =  nPC;
  nPC  += 4;
}
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


lwPLUSaddiuPLUSaddiu:
#if INDIRECT_DEBUG
printf("%d|lw\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)(VM_memory[RF[rs] + immediate]) << 24) | ((uint32_t)(VM_memory[RF[rs] + immediate + 1]) << 16) | ((uint32_t)(VM_memory[RF[rs] + immediate + 2]) << 8) | ((uint32_t)VM_memory[RF[rs] + immediate + 3]);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


sllPLUSxorPLUSsll:
#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr0 >> 6) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|xor\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rs] ^ RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr2 >> 6) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


xorPLUSandiPLUSsubu:
#if INDIRECT_DEBUG
printf("%d|xor\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rs] ^ RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|andi\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = RF[rs] & (uint32_t)immediate;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|subu\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rs] - RF[rt];
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


jalPLUSadduPLUSlbu:
#if INDIRECT_DEBUG
printf("%d|jal\n",counter);
counter++;
#endif
RF[31] = PC + 8;
PC = nPC;
address = (instr0 >> 0) & 0x3FFFFFF;
nPC = address << 2;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;



#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|lbu\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)VM_memory[RF[rs] + immediate]) & 0xFF;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


lwPLUSjalPLUSsll:
#if INDIRECT_DEBUG
printf("%d|lw\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)(VM_memory[RF[rs] + immediate]) << 24) | ((uint32_t)(VM_memory[RF[rs] + immediate + 1]) << 16) | ((uint32_t)(VM_memory[RF[rs] + immediate + 2]) << 8) | ((uint32_t)VM_memory[RF[rs] + immediate + 3]);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|jal\n",counter);
counter++;
#endif
RF[31] = PC + 8;
PC = nPC;
address = (instr1 >> 0) & 0x3FFFFFF;
nPC = address << 2;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;



#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr2 >> 6) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


lbuPLUSaddiuPLUSsrl:
#if INDIRECT_DEBUG
printf("%d|lbu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)VM_memory[RF[rs] + immediate]) & 0xFF;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|srl\n",counter);
counter++;
#endif
shamt = (instr2 >> 6) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rt] >> shamt;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


multPLUSmfhiPLUSaddiu:
#if INDIRECT_DEBUG
printf("%d|mult\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
mult = (uint64_t)RF[rs] * (uint64_t) RF[rt];
HI = (mult >> 32) & 0xFFFFFFFF;
LO = mult & 0xFFFFFFFF;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|mfhi\n",counter);
counter++;
#endif
rd = (instr1 >> 11) & 0x1F;
RF[rd] = HI;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


addiuPLUSlwPLUSbne:
#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|lw\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)(VM_memory[RF[rs] + immediate]) << 24) | ((uint32_t)(VM_memory[RF[rs] + immediate + 1]) << 16) | ((uint32_t)(VM_memory[RF[rs] + immediate + 2]) << 8) | ((uint32_t)VM_memory[RF[rs] + immediate + 3]);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|bne\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
if (RF[rs] != RF[rt])
{
  immediate = (instr2 >> 0) & 0xFFFF;
  PC  =  nPC;
  nPC  += (immediate << 2);
    if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


}
else
{
  PC  =  nPC;
  nPC  += 4;
}
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


jalPLUSaddiuPLUSlw:
#if INDIRECT_DEBUG
printf("%d|jal\n",counter);
counter++;
#endif
RF[31] = PC + 8;
PC = nPC;
address = (instr0 >> 0) & 0x3FFFFFF;
nPC = address << 2;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;



#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|lw\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)(VM_memory[RF[rs] + immediate]) << 24) | ((uint32_t)(VM_memory[RF[rs] + immediate + 1]) << 16) | ((uint32_t)(VM_memory[RF[rs] + immediate + 2]) << 8) | ((uint32_t)VM_memory[RF[rs] + immediate + 3]);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


beqPLUSswPLUSsw:
#if INDIRECT_DEBUG
printf("%d|beq\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
if (RF[rs] == RF[rt])
{
  immediate = (instr0 >> 0) & 0xFFFF;
  PC  =  nPC;
  nPC  += (immediate << 2);
    if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


}
else
{
  PC  =  nPC;
  nPC  += 4;
}

#if INDIRECT_DEBUG
printf("%d|sw\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
VM_memory[RF[rs] + immediate] = (uint8_t)((RF[rt] & 0xFF000000) >> 24);
VM_memory[RF[rs] + immediate + 1] = (uint8_t)((RF[rt] & 0xFF0000) >> 16);
VM_memory[RF[rs] + immediate + 2] = (uint8_t)((RF[rt] & 0xFF00) >> 8);
VM_memory[RF[rs] + immediate + 3] = (uint8_t)(RF[rt] & 0xFF);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sw\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
VM_memory[RF[rs] + immediate] = (uint8_t)((RF[rt] & 0xFF000000) >> 24);
VM_memory[RF[rs] + immediate + 1] = (uint8_t)((RF[rt] & 0xFF0000) >> 16);
VM_memory[RF[rs] + immediate + 2] = (uint8_t)((RF[rt] & 0xFF00) >> 8);
VM_memory[RF[rs] + immediate + 3] = (uint8_t)(RF[rt] & 0xFF);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


sllPLUSluiPLUSori:
#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr0 >> 6) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|lui\n",counter);
counter++;
#endif
// NOTHING IMPLEMENTED, COPIED FROM BELOW
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)immediate) << 16;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|ori\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
RF[rt] = RF[rs] | (uint32_t)immediate;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


swPLUSlwPLUSaddiu:
#if INDIRECT_DEBUG
printf("%d|sw\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
VM_memory[RF[rs] + immediate] = (uint8_t)((RF[rt] & 0xFF000000) >> 24);
VM_memory[RF[rs] + immediate + 1] = (uint8_t)((RF[rt] & 0xFF0000) >> 16);
VM_memory[RF[rs] + immediate + 2] = (uint8_t)((RF[rt] & 0xFF00) >> 8);
VM_memory[RF[rs] + immediate + 3] = (uint8_t)(RF[rt] & 0xFF);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|lw\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)(VM_memory[RF[rs] + immediate]) << 24) | ((uint32_t)(VM_memory[RF[rs] + immediate + 1]) << 16) | ((uint32_t)(VM_memory[RF[rs] + immediate + 2]) << 8) | ((uint32_t)VM_memory[RF[rs] + immediate + 3]);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


lwPLUSbgtzPLUSsll:
#if INDIRECT_DEBUG
printf("%d|lw\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)(VM_memory[RF[rs] + immediate]) << 24) | ((uint32_t)(VM_memory[RF[rs] + immediate + 1]) << 16) | ((uint32_t)(VM_memory[RF[rs] + immediate + 2]) << 8) | ((uint32_t)VM_memory[RF[rs] + immediate + 3]);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|bgtz\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
if ((int32_t)RF[rs] > 0)
{
  immediate = (instr1 >> 0) & 0xFFFF;
  PC  =  nPC;
  nPC  += (immediate << 2);
    if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


}
else
{
  PC  =  nPC;
  nPC  += 4;
}

#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr2 >> 6) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


adduPLUSsllPLUSxor:
#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr1 >> 6) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|xor\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rs] ^ RF[rt];
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


swPLUSadduPLUSsw:
#if INDIRECT_DEBUG
printf("%d|sw\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
VM_memory[RF[rs] + immediate] = (uint8_t)((RF[rt] & 0xFF000000) >> 24);
VM_memory[RF[rs] + immediate + 1] = (uint8_t)((RF[rt] & 0xFF0000) >> 16);
VM_memory[RF[rs] + immediate + 2] = (uint8_t)((RF[rt] & 0xFF00) >> 8);
VM_memory[RF[rs] + immediate + 3] = (uint8_t)(RF[rt] & 0xFF);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sw\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
VM_memory[RF[rs] + immediate] = (uint8_t)((RF[rt] & 0xFF000000) >> 24);
VM_memory[RF[rs] + immediate + 1] = (uint8_t)((RF[rt] & 0xFF0000) >> 16);
VM_memory[RF[rs] + immediate + 2] = (uint8_t)((RF[rt] & 0xFF00) >> 8);
VM_memory[RF[rs] + immediate + 3] = (uint8_t)(RF[rt] & 0xFF);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


bnePLUSxorPLUSxor:
#if INDIRECT_DEBUG
printf("%d|bne\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
if (RF[rs] != RF[rt])
{
  immediate = (instr0 >> 0) & 0xFFFF;
  PC  =  nPC;
  nPC  += (immediate << 2);
    if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


}
else
{
  PC  =  nPC;
  nPC  += 4;
}

#if INDIRECT_DEBUG
printf("%d|xor\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rs] ^ RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|xor\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rs] ^ RF[rt];
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


addiuPLUSaddiuPLUSjal:
#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|jal\n",counter);
counter++;
#endif
RF[31] = PC + 8;
PC = nPC;
address = (instr2 >> 0) & 0x3FFFFFF;
nPC = address << 2;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


beqPLUSsllPLUSaddu:
#if INDIRECT_DEBUG
printf("%d|beq\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
if (RF[rs] == RF[rt])
{
  immediate = (instr0 >> 0) & 0xFFFF;
  PC  =  nPC;
  nPC  += (immediate << 2);
    if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


}
else
{
  PC  =  nPC;
  nPC  += 4;
}

#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr1 >> 6) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


bnePLUSsllPLUSlbu:
#if INDIRECT_DEBUG
printf("%d|bne\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
if (RF[rs] != RF[rt])
{
  immediate = (instr0 >> 0) & 0xFFFF;
  PC  =  nPC;
  nPC  += (immediate << 2);
    if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


}
else
{
  PC  =  nPC;
  nPC  += 4;
}

#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr1 >> 6) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|lbu\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)VM_memory[RF[rs] + immediate]) & 0xFF;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


sllPLUSsltPLUSaddu:
#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr0 >> 6) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|slt\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = (RF[rs] < RF[rt])?1:0;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


beqPLUSaddiuPLUSsltu:
#if INDIRECT_DEBUG
printf("%d|beq\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
if (RF[rs] == RF[rt])
{
  immediate = (instr0 >> 0) & 0xFFFF;
  PC  =  nPC;
  nPC  += (immediate << 2);
    if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


}
else
{
  PC  =  nPC;
  nPC  += 4;
}

#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sltu\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = (RF[rs] < RF[rt])?1:0;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


adduPLUSadduPLUSaddu:
#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


bnePLUSaddiuPLUSslt:
#if INDIRECT_DEBUG
printf("%d|bne\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
if (RF[rs] != RF[rt])
{
  immediate = (instr0 >> 0) & 0xFFFF;
  PC  =  nPC;
  nPC  += (immediate << 2);
    if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


}
else
{
  PC  =  nPC;
  nPC  += 4;
}

#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|slt\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = (RF[rs] < RF[rt])?1:0;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


multPLUSmfhiPLUSsrl:
#if INDIRECT_DEBUG
printf("%d|mult\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
mult = (uint64_t)RF[rs] * (uint64_t) RF[rt];
HI = (mult >> 32) & 0xFFFFFFFF;
LO = mult & 0xFFFFFFFF;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|mfhi\n",counter);
counter++;
#endif
rd = (instr1 >> 11) & 0x1F;
RF[rd] = HI;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|srl\n",counter);
counter++;
#endif
shamt = (instr2 >> 6) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rt] >> shamt;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


movnPLUSsllPLUSxor:
#if INDIRECT_DEBUG
printf("%d|movn\n",counter);
counter++;
#endif

rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
if (RF[rt] != 0) RF[rd] = RF[rs];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr1 >> 6) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|xor\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rs] ^ RF[rt];
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


bnePLUSaddiuPLUSsll:
#if INDIRECT_DEBUG
printf("%d|bne\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
if (RF[rs] != RF[rt])
{
  immediate = (instr0 >> 0) & 0xFFFF;
  PC  =  nPC;
  nPC  += (immediate << 2);
    if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


}
else
{
  PC  =  nPC;
  nPC  += 4;
}

#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr2 >> 6) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


swPLUSluiPLUSlw:
#if INDIRECT_DEBUG
printf("%d|sw\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
VM_memory[RF[rs] + immediate] = (uint8_t)((RF[rt] & 0xFF000000) >> 24);
VM_memory[RF[rs] + immediate + 1] = (uint8_t)((RF[rt] & 0xFF0000) >> 16);
VM_memory[RF[rs] + immediate + 2] = (uint8_t)((RF[rt] & 0xFF00) >> 8);
VM_memory[RF[rs] + immediate + 3] = (uint8_t)(RF[rt] & 0xFF);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|lui\n",counter);
counter++;
#endif
// NOTHING IMPLEMENTED, COPIED FROM BELOW
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)immediate) << 16;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|lw\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)(VM_memory[RF[rs] + immediate]) << 24) | ((uint32_t)(VM_memory[RF[rs] + immediate + 1]) << 16) | ((uint32_t)(VM_memory[RF[rs] + immediate + 2]) << 8) | ((uint32_t)VM_memory[RF[rs] + immediate + 3]);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


adduPLUSluiPLUSsw:
#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|lui\n",counter);
counter++;
#endif
// NOTHING IMPLEMENTED, COPIED FROM BELOW
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)immediate) << 16;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sw\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
VM_memory[RF[rs] + immediate] = (uint8_t)((RF[rt] & 0xFF000000) >> 24);
VM_memory[RF[rs] + immediate + 1] = (uint8_t)((RF[rt] & 0xFF0000) >> 16);
VM_memory[RF[rs] + immediate + 2] = (uint8_t)((RF[rt] & 0xFF00) >> 8);
VM_memory[RF[rs] + immediate + 3] = (uint8_t)(RF[rt] & 0xFF);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


sllPLUSaddiuPLUSlui:
#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr0 >> 6) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|lui\n",counter);
counter++;
#endif
// NOTHING IMPLEMENTED, COPIED FROM BELOW
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)immediate) << 16;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


lwPLUSaddiuPLUSlw:
#if INDIRECT_DEBUG
printf("%d|lw\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)(VM_memory[RF[rs] + immediate]) << 24) | ((uint32_t)(VM_memory[RF[rs] + immediate + 1]) << 16) | ((uint32_t)(VM_memory[RF[rs] + immediate + 2]) << 8) | ((uint32_t)VM_memory[RF[rs] + immediate + 3]);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|lw\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)(VM_memory[RF[rs] + immediate]) << 24) | ((uint32_t)(VM_memory[RF[rs] + immediate + 1]) << 16) | ((uint32_t)(VM_memory[RF[rs] + immediate + 2]) << 8) | ((uint32_t)VM_memory[RF[rs] + immediate + 3]);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


luiPLUSoriPLUSandi:
#if INDIRECT_DEBUG
printf("%d|lui\n",counter);
counter++;
#endif
// NOTHING IMPLEMENTED, COPIED FROM BELOW
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)immediate) << 16;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|ori\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = RF[rs] | (uint32_t)immediate;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|andi\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
RF[rt] = RF[rs] & (uint32_t)immediate;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


oriPLUSmultPLUSmfhi:
#if INDIRECT_DEBUG
printf("%d|ori\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = RF[rs] | (uint32_t)immediate;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|mult\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
mult = (uint64_t)RF[rs] * (uint64_t) RF[rt];
HI = (mult >> 32) & 0xFFFFFFFF;
LO = mult & 0xFFFFFFFF;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|mfhi\n",counter);
counter++;
#endif
rd = (instr2 >> 11) & 0x1F;
RF[rd] = HI;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


sllPLUSluiPLUSsw:
#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr0 >> 6) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|lui\n",counter);
counter++;
#endif
// NOTHING IMPLEMENTED, COPIED FROM BELOW
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)immediate) << 16;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sw\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
VM_memory[RF[rs] + immediate] = (uint8_t)((RF[rt] & 0xFF000000) >> 24);
VM_memory[RF[rs] + immediate + 1] = (uint8_t)((RF[rt] & 0xFF0000) >> 16);
VM_memory[RF[rs] + immediate + 2] = (uint8_t)((RF[rt] & 0xFF00) >> 8);
VM_memory[RF[rs] + immediate + 3] = (uint8_t)(RF[rt] & 0xFF);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


sllPLUSjumpPLUSaddiu:
#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr0 >> 6) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|jump\n",counter);
counter++;
#endif
PC = nPC;
address = (instr1 >> 0) & 0x3FFFFFF;
nPC = address << 2;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;



#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


jumpPLUSaddiuPLUSsll:
#if INDIRECT_DEBUG
printf("%d|jump\n",counter);
counter++;
#endif
PC = nPC;
address = (instr0 >> 0) & 0x3FFFFFF;
nPC = address << 2;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;



#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr2 >> 6) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


jrPLUSsllPLUSaddiu:
#if INDIRECT_DEBUG
printf("%d|jr\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
PC = nPC;
nPC = RF[rs];
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;



#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr1 >> 6) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


addiuPLUSaddiuPLUSaddiu:
#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


beqPLUSadduPLUSlui:
#if INDIRECT_DEBUG
printf("%d|beq\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
if (RF[rs] == RF[rt])
{
  immediate = (instr0 >> 0) & 0xFFFF;
  PC  =  nPC;
  nPC  += (immediate << 2);
    if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


}
else
{
  PC  =  nPC;
  nPC  += 4;
}

#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|lui\n",counter);
counter++;
#endif
// NOTHING IMPLEMENTED, COPIED FROM BELOW
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)immediate) << 16;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


andPLUSxorPLUSsrl:
#if INDIRECT_DEBUG
printf("%d|and\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rs] & RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|xor\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rs] ^ RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|srl\n",counter);
counter++;
#endif
shamt = (instr2 >> 6) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rt] >> shamt;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


lwPLUSlwPLUSlw:
#if INDIRECT_DEBUG
printf("%d|lw\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)(VM_memory[RF[rs] + immediate]) << 24) | ((uint32_t)(VM_memory[RF[rs] + immediate + 1]) << 16) | ((uint32_t)(VM_memory[RF[rs] + immediate + 2]) << 8) | ((uint32_t)VM_memory[RF[rs] + immediate + 3]);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|lw\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)(VM_memory[RF[rs] + immediate]) << 24) | ((uint32_t)(VM_memory[RF[rs] + immediate + 1]) << 16) | ((uint32_t)(VM_memory[RF[rs] + immediate + 2]) << 8) | ((uint32_t)VM_memory[RF[rs] + immediate + 3]);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|lw\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)(VM_memory[RF[rs] + immediate]) << 24) | ((uint32_t)(VM_memory[RF[rs] + immediate + 1]) << 16) | ((uint32_t)(VM_memory[RF[rs] + immediate + 2]) << 8) | ((uint32_t)VM_memory[RF[rs] + immediate + 3]);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


lbuPLUSsubuPLUSand:
#if INDIRECT_DEBUG
printf("%d|lbu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)VM_memory[RF[rs] + immediate]) & 0xFF;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|subu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rs] - RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|and\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rs] & RF[rt];
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


bnePLUSsllPLUSjump:
#if INDIRECT_DEBUG
printf("%d|bne\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
if (RF[rs] != RF[rt])
{
  immediate = (instr0 >> 0) & 0xFFFF;
  PC  =  nPC;
  nPC  += (immediate << 2);
    if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


}
else
{
  PC  =  nPC;
  nPC  += 4;
}

#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr1 >> 6) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|jump\n",counter);
counter++;
#endif
PC = nPC;
address = (instr2 >> 0) & 0x3FFFFFF;
nPC = address << 2;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


lbuPLUSxorPLUSsrl:
#if INDIRECT_DEBUG
printf("%d|lbu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)VM_memory[RF[rs] + immediate]) & 0xFF;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|xor\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rs] ^ RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|srl\n",counter);
counter++;
#endif
shamt = (instr2 >> 6) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rt] >> shamt;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


luiPLUSoriPLUSsll:
#if INDIRECT_DEBUG
printf("%d|lui\n",counter);
counter++;
#endif
// NOTHING IMPLEMENTED, COPIED FROM BELOW
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)immediate) << 16;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|ori\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = RF[rs] | (uint32_t)immediate;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr2 >> 6) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


sllPLUSsbPLUSsh:
#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr0 >> 6) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sb\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
VM_memory[RF[rs] + immediate] = (uint8_t)(RF[rt] & 0xFF);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sh\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
VM_memory[RF[rs] + immediate] = (uint8_t)((RF[rt] & 0xFF00) >> 8);
VM_memory[RF[rs] + immediate + 1] = (uint8_t)(RF[rt] & 0xFF);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


adduPLUSlbuPLUSbeq:
#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|lbu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)VM_memory[RF[rs] + immediate]) & 0xFF;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|beq\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
if (RF[rs] == RF[rt])
{
  immediate = (instr2 >> 0) & 0xFFFF;
  PC  =  nPC;
  nPC  += (immediate << 2);
    if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


}
else
{
  PC  =  nPC;
  nPC  += 4;
}
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


adduPLUSsltiPLUSsw:
#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|slti\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] < immediate)?1:0;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sw\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
VM_memory[RF[rs] + immediate] = (uint8_t)((RF[rt] & 0xFF000000) >> 24);
VM_memory[RF[rs] + immediate + 1] = (uint8_t)((RF[rt] & 0xFF0000) >> 16);
VM_memory[RF[rs] + immediate + 2] = (uint8_t)((RF[rt] & 0xFF00) >> 8);
VM_memory[RF[rs] + immediate + 3] = (uint8_t)(RF[rt] & 0xFF);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


subuPLUSandPLUSsrl:
#if INDIRECT_DEBUG
printf("%d|subu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rs] - RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|and\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rs] & RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|srl\n",counter);
counter++;
#endif
shamt = (instr2 >> 6) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rt] >> shamt;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


bnePLUSadduPLUSnor:
#if INDIRECT_DEBUG
printf("%d|bne\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
if (RF[rs] != RF[rt])
{
  immediate = (instr0 >> 0) & 0xFFFF;
  PC  =  nPC;
  nPC  += (immediate << 2);
    if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


}
else
{
  PC  =  nPC;
  nPC  += 4;
}

#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|nor\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = ~(RF[rs] | RF[rt]);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


adduPLUSaddiuPLUSsw:
#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sw\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
VM_memory[RF[rs] + immediate] = (uint8_t)((RF[rt] & 0xFF000000) >> 24);
VM_memory[RF[rs] + immediate + 1] = (uint8_t)((RF[rt] & 0xFF0000) >> 16);
VM_memory[RF[rs] + immediate + 2] = (uint8_t)((RF[rt] & 0xFF00) >> 8);
VM_memory[RF[rs] + immediate + 3] = (uint8_t)(RF[rt] & 0xFF);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


addiuPLUSjalPLUSaddiu:
#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|jal\n",counter);
counter++;
#endif
RF[31] = PC + 8;
PC = nPC;
address = (instr1 >> 0) & 0x3FFFFFF;
nPC = address << 2;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;



#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


orPLUSswPLUSsw:
#if INDIRECT_DEBUG
printf("%d|or\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rs] | RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sw\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
VM_memory[RF[rs] + immediate] = (uint8_t)((RF[rt] & 0xFF000000) >> 24);
VM_memory[RF[rs] + immediate + 1] = (uint8_t)((RF[rt] & 0xFF0000) >> 16);
VM_memory[RF[rs] + immediate + 2] = (uint8_t)((RF[rt] & 0xFF00) >> 8);
VM_memory[RF[rs] + immediate + 3] = (uint8_t)(RF[rt] & 0xFF);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sw\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
VM_memory[RF[rs] + immediate] = (uint8_t)((RF[rt] & 0xFF000000) >> 24);
VM_memory[RF[rs] + immediate + 1] = (uint8_t)((RF[rt] & 0xFF0000) >> 16);
VM_memory[RF[rs] + immediate + 2] = (uint8_t)((RF[rt] & 0xFF00) >> 8);
VM_memory[RF[rs] + immediate + 3] = (uint8_t)(RF[rt] & 0xFF);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


addiuPLUSluiPLUSsw:
#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|lui\n",counter);
counter++;
#endif
// NOTHING IMPLEMENTED, COPIED FROM BELOW
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)immediate) << 16;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sw\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
VM_memory[RF[rs] + immediate] = (uint8_t)((RF[rt] & 0xFF000000) >> 24);
VM_memory[RF[rs] + immediate + 1] = (uint8_t)((RF[rt] & 0xFF0000) >> 16);
VM_memory[RF[rs] + immediate + 2] = (uint8_t)((RF[rt] & 0xFF00) >> 8);
VM_memory[RF[rs] + immediate + 3] = (uint8_t)(RF[rt] & 0xFF);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


addiuPLUSadduPLUSlw:
#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|lw\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)(VM_memory[RF[rs] + immediate]) << 24) | ((uint32_t)(VM_memory[RF[rs] + immediate + 1]) << 16) | ((uint32_t)(VM_memory[RF[rs] + immediate + 2]) << 8) | ((uint32_t)VM_memory[RF[rs] + immediate + 3]);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


sllPLUSlwPLUSlw:
#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr0 >> 6) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|lw\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)(VM_memory[RF[rs] + immediate]) << 24) | ((uint32_t)(VM_memory[RF[rs] + immediate + 1]) << 16) | ((uint32_t)(VM_memory[RF[rs] + immediate + 2]) << 8) | ((uint32_t)VM_memory[RF[rs] + immediate + 3]);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|lw\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)(VM_memory[RF[rs] + immediate]) << 24) | ((uint32_t)(VM_memory[RF[rs] + immediate + 1]) << 16) | ((uint32_t)(VM_memory[RF[rs] + immediate + 2]) << 8) | ((uint32_t)VM_memory[RF[rs] + immediate + 3]);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


andiPLUSsubuPLUSand:
#if INDIRECT_DEBUG
printf("%d|andi\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = RF[rs] & (uint32_t)immediate;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|subu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rs] - RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|and\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rs] & RF[rt];
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


swPLUSaddiuPLUSaddu:
#if INDIRECT_DEBUG
printf("%d|sw\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
VM_memory[RF[rs] + immediate] = (uint8_t)((RF[rt] & 0xFF000000) >> 24);
VM_memory[RF[rs] + immediate + 1] = (uint8_t)((RF[rt] & 0xFF0000) >> 16);
VM_memory[RF[rs] + immediate + 2] = (uint8_t)((RF[rt] & 0xFF00) >> 8);
VM_memory[RF[rs] + immediate + 3] = (uint8_t)(RF[rt] & 0xFF);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


luiPLUSswPLUSaddu:
#if INDIRECT_DEBUG
printf("%d|lui\n",counter);
counter++;
#endif
// NOTHING IMPLEMENTED, COPIED FROM BELOW
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)immediate) << 16;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sw\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
VM_memory[RF[rs] + immediate] = (uint8_t)((RF[rt] & 0xFF000000) >> 24);
VM_memory[RF[rs] + immediate + 1] = (uint8_t)((RF[rt] & 0xFF0000) >> 16);
VM_memory[RF[rs] + immediate + 2] = (uint8_t)((RF[rt] & 0xFF00) >> 8);
VM_memory[RF[rs] + immediate + 3] = (uint8_t)(RF[rt] & 0xFF);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


bnePLUSsllPLUSsw:
#if INDIRECT_DEBUG
printf("%d|bne\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
if (RF[rs] != RF[rt])
{
  immediate = (instr0 >> 0) & 0xFFFF;
  PC  =  nPC;
  nPC  += (immediate << 2);
    if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


}
else
{
  PC  =  nPC;
  nPC  += 4;
}

#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr1 >> 6) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sw\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
VM_memory[RF[rs] + immediate] = (uint8_t)((RF[rt] & 0xFF000000) >> 24);
VM_memory[RF[rs] + immediate + 1] = (uint8_t)((RF[rt] & 0xFF0000) >> 16);
VM_memory[RF[rs] + immediate + 2] = (uint8_t)((RF[rt] & 0xFF00) >> 8);
VM_memory[RF[rs] + immediate + 3] = (uint8_t)(RF[rt] & 0xFF);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


xorPLUSaddiuPLUSsw:
#if INDIRECT_DEBUG
printf("%d|xor\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rs] ^ RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sw\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
VM_memory[RF[rs] + immediate] = (uint8_t)((RF[rt] & 0xFF000000) >> 24);
VM_memory[RF[rs] + immediate + 1] = (uint8_t)((RF[rt] & 0xFF0000) >> 16);
VM_memory[RF[rs] + immediate + 2] = (uint8_t)((RF[rt] & 0xFF00) >> 8);
VM_memory[RF[rs] + immediate + 3] = (uint8_t)(RF[rt] & 0xFF);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


swPLUSswPLUSlui:
#if INDIRECT_DEBUG
printf("%d|sw\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
VM_memory[RF[rs] + immediate] = (uint8_t)((RF[rt] & 0xFF000000) >> 24);
VM_memory[RF[rs] + immediate + 1] = (uint8_t)((RF[rt] & 0xFF0000) >> 16);
VM_memory[RF[rs] + immediate + 2] = (uint8_t)((RF[rt] & 0xFF00) >> 8);
VM_memory[RF[rs] + immediate + 3] = (uint8_t)(RF[rt] & 0xFF);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sw\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
VM_memory[RF[rs] + immediate] = (uint8_t)((RF[rt] & 0xFF000000) >> 24);
VM_memory[RF[rs] + immediate + 1] = (uint8_t)((RF[rt] & 0xFF0000) >> 16);
VM_memory[RF[rs] + immediate + 2] = (uint8_t)((RF[rt] & 0xFF00) >> 8);
VM_memory[RF[rs] + immediate + 3] = (uint8_t)(RF[rt] & 0xFF);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|lui\n",counter);
counter++;
#endif
// NOTHING IMPLEMENTED, COPIED FROM BELOW
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)immediate) << 16;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


norPLUSsrlPLUSlui:
#if INDIRECT_DEBUG
printf("%d|nor\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = ~(RF[rs] | RF[rt]);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|srl\n",counter);
counter++;
#endif
shamt = (instr1 >> 6) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rt] >> shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|lui\n",counter);
counter++;
#endif
// NOTHING IMPLEMENTED, COPIED FROM BELOW
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)immediate) << 16;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


srlPLUSandiPLUSjr:
#if INDIRECT_DEBUG
printf("%d|srl\n",counter);
counter++;
#endif
shamt = (instr0 >> 6) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rt] >> shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|andi\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = RF[rs] & (uint32_t)immediate;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|jr\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
PC = nPC;
nPC = RF[rs];
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


luiPLUSluiPLUSsrl:
#if INDIRECT_DEBUG
printf("%d|lui\n",counter);
counter++;
#endif
// NOTHING IMPLEMENTED, COPIED FROM BELOW
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)immediate) << 16;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|lui\n",counter);
counter++;
#endif
// NOTHING IMPLEMENTED, COPIED FROM BELOW
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)immediate) << 16;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|srl\n",counter);
counter++;
#endif
shamt = (instr2 >> 6) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rt] >> shamt;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


beqPLUSadduPLUSlw:
#if INDIRECT_DEBUG
printf("%d|beq\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
if (RF[rs] == RF[rt])
{
  immediate = (instr0 >> 0) & 0xFFFF;
  PC  =  nPC;
  nPC  += (immediate << 2);
    if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


}
else
{
  PC  =  nPC;
  nPC  += 4;
}

#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|lw\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)(VM_memory[RF[rs] + immediate]) << 24) | ((uint32_t)(VM_memory[RF[rs] + immediate + 1]) << 16) | ((uint32_t)(VM_memory[RF[rs] + immediate + 2]) << 8) | ((uint32_t)VM_memory[RF[rs] + immediate + 3]);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


orPLUSsrlPLUSsll:
#if INDIRECT_DEBUG
printf("%d|or\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rs] | RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|srl\n",counter);
counter++;
#endif
shamt = (instr1 >> 6) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rt] >> shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr2 >> 6) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


adduPLUSaddiuPLUSlui:
#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|lui\n",counter);
counter++;
#endif
// NOTHING IMPLEMENTED, COPIED FROM BELOW
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)immediate) << 16;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


addiuPLUSsyscPLUSjr:
#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sysc\n",counter);
counter++;
#endif
if (syscall((uint8_t)RF[2])) //registers $4 and $5 useb by hallcall (sensid and retval respectively)
{
halted = 1; //Syscall returned 1, exit code
goto end;
}
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|jr\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
PC = nPC;
nPC = RF[rs];
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


jumpPLUSadduPLUSlw:
#if INDIRECT_DEBUG
printf("%d|jump\n",counter);
counter++;
#endif
PC = nPC;
address = (instr0 >> 0) & 0x3FFFFFF;
nPC = address << 2;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;



#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|lw\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)(VM_memory[RF[rs] + immediate]) << 24) | ((uint32_t)(VM_memory[RF[rs] + immediate + 1]) << 16) | ((uint32_t)(VM_memory[RF[rs] + immediate + 2]) << 8) | ((uint32_t)VM_memory[RF[rs] + immediate + 3]);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


orPLUSorPLUSsltu:
#if INDIRECT_DEBUG
printf("%d|or\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rs] | RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|or\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rs] | RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sltu\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = (RF[rs] < RF[rt])?1:0;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


adduPLUSlwPLUSbgtz:
#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|lw\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)(VM_memory[RF[rs] + immediate]) << 24) | ((uint32_t)(VM_memory[RF[rs] + immediate + 1]) << 16) | ((uint32_t)(VM_memory[RF[rs] + immediate + 2]) << 8) | ((uint32_t)VM_memory[RF[rs] + immediate + 3]);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|bgtz\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
if ((int32_t)RF[rs] > 0)
{
  immediate = (instr2 >> 0) & 0xFFFF;
  PC  =  nPC;
  nPC  += (immediate << 2);
    if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


}
else
{
  PC  =  nPC;
  nPC  += 4;
}
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


jumpPLUSsllPLUSlw:
#if INDIRECT_DEBUG
printf("%d|jump\n",counter);
counter++;
#endif
PC = nPC;
address = (instr0 >> 0) & 0x3FFFFFF;
nPC = address << 2;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;



#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr1 >> 6) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|lw\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)(VM_memory[RF[rs] + immediate]) << 24) | ((uint32_t)(VM_memory[RF[rs] + immediate + 1]) << 16) | ((uint32_t)(VM_memory[RF[rs] + immediate + 2]) << 8) | ((uint32_t)VM_memory[RF[rs] + immediate + 3]);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


adduPLUSsrlPLUSaddu:
#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|srl\n",counter);
counter++;
#endif
shamt = (instr1 >> 6) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rt] >> shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


srlPLUSbnePLUSxor:
#if INDIRECT_DEBUG
printf("%d|srl\n",counter);
counter++;
#endif
shamt = (instr0 >> 6) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rt] >> shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|bne\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
if (RF[rs] != RF[rt])
{
  immediate = (instr1 >> 0) & 0xFFFF;
  PC  =  nPC;
  nPC  += (immediate << 2);
    if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


}
else
{
  PC  =  nPC;
  nPC  += 4;
}

#if INDIRECT_DEBUG
printf("%d|xor\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rs] ^ RF[rt];
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


xorPLUSxorPLUSaddiu:
#if INDIRECT_DEBUG
printf("%d|xor\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rs] ^ RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|xor\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rs] ^ RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


errorPLUSlwPLUSlw:
#if INDIRECT_DEBUG
printf("Error, unknown instr0uction %d.\n", instr0);
#endif
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|lw\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)(VM_memory[RF[rs] + immediate]) << 24) | ((uint32_t)(VM_memory[RF[rs] + immediate + 1]) << 16) | ((uint32_t)(VM_memory[RF[rs] + immediate + 2]) << 8) | ((uint32_t)VM_memory[RF[rs] + immediate + 3]);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|lw\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)(VM_memory[RF[rs] + immediate]) << 24) | ((uint32_t)(VM_memory[RF[rs] + immediate + 1]) << 16) | ((uint32_t)(VM_memory[RF[rs] + immediate + 2]) << 8) | ((uint32_t)VM_memory[RF[rs] + immediate + 3]);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


swPLUSswPLUSaddu:
#if INDIRECT_DEBUG
printf("%d|sw\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
VM_memory[RF[rs] + immediate] = (uint8_t)((RF[rt] & 0xFF000000) >> 24);
VM_memory[RF[rs] + immediate + 1] = (uint8_t)((RF[rt] & 0xFF0000) >> 16);
VM_memory[RF[rs] + immediate + 2] = (uint8_t)((RF[rt] & 0xFF00) >> 8);
VM_memory[RF[rs] + immediate + 3] = (uint8_t)(RF[rt] & 0xFF);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sw\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
VM_memory[RF[rs] + immediate] = (uint8_t)((RF[rt] & 0xFF000000) >> 24);
VM_memory[RF[rs] + immediate + 1] = (uint8_t)((RF[rt] & 0xFF0000) >> 16);
VM_memory[RF[rs] + immediate + 2] = (uint8_t)((RF[rt] & 0xFF00) >> 8);
VM_memory[RF[rs] + immediate + 3] = (uint8_t)(RF[rt] & 0xFF);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


beqPLUSsllPLUSslti:
#if INDIRECT_DEBUG
printf("%d|beq\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
if (RF[rs] == RF[rt])
{
  immediate = (instr0 >> 0) & 0xFFFF;
  PC  =  nPC;
  nPC  += (immediate << 2);
    if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


}
else
{
  PC  =  nPC;
  nPC  += 4;
}

#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr1 >> 6) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|slti\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] < immediate)?1:0;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


addiuPLUSsrlPLUSsra:
#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|srl\n",counter);
counter++;
#endif
shamt = (instr1 >> 6) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rt] >> shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sra\n",counter);
counter++;
#endif
shamt = (instr2 >> 6) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
if ((int32_t)RF[rt] < 0 && shamt > 0) {
rd = (instr2 >> 11) & 0x1F;
RF[rd] = (int32_t)RF[rt] | ~(~0U >> shamt);
}
else {
rd = (instr2 >> 11) & 0x1F;
RF[rd] = (int32_t)RF[rt] >> shamt;
}
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


swPLUSswPLUSjal:
#if INDIRECT_DEBUG
printf("%d|sw\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
VM_memory[RF[rs] + immediate] = (uint8_t)((RF[rt] & 0xFF000000) >> 24);
VM_memory[RF[rs] + immediate + 1] = (uint8_t)((RF[rt] & 0xFF0000) >> 16);
VM_memory[RF[rs] + immediate + 2] = (uint8_t)((RF[rt] & 0xFF00) >> 8);
VM_memory[RF[rs] + immediate + 3] = (uint8_t)(RF[rt] & 0xFF);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sw\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
VM_memory[RF[rs] + immediate] = (uint8_t)((RF[rt] & 0xFF000000) >> 24);
VM_memory[RF[rs] + immediate + 1] = (uint8_t)((RF[rt] & 0xFF0000) >> 16);
VM_memory[RF[rs] + immediate + 2] = (uint8_t)((RF[rt] & 0xFF00) >> 8);
VM_memory[RF[rs] + immediate + 3] = (uint8_t)(RF[rt] & 0xFF);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|jal\n",counter);
counter++;
#endif
RF[31] = PC + 8;
PC = nPC;
address = (instr2 >> 0) & 0x3FFFFFF;
nPC = address << 2;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


lwPLUSbnePLUSsll:
#if INDIRECT_DEBUG
printf("%d|lw\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)(VM_memory[RF[rs] + immediate]) << 24) | ((uint32_t)(VM_memory[RF[rs] + immediate + 1]) << 16) | ((uint32_t)(VM_memory[RF[rs] + immediate + 2]) << 8) | ((uint32_t)VM_memory[RF[rs] + immediate + 3]);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|bne\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
if (RF[rs] != RF[rt])
{
  immediate = (instr1 >> 0) & 0xFFFF;
  PC  =  nPC;
  nPC  += (immediate << 2);
    if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


}
else
{
  PC  =  nPC;
  nPC  += 4;
}

#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr2 >> 6) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


sltPLUSlwPLUSbeq:
#if INDIRECT_DEBUG
printf("%d|slt\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = (RF[rs] < RF[rt])?1:0;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|lw\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)(VM_memory[RF[rs] + immediate]) << 24) | ((uint32_t)(VM_memory[RF[rs] + immediate + 1]) << 16) | ((uint32_t)(VM_memory[RF[rs] + immediate + 2]) << 8) | ((uint32_t)VM_memory[RF[rs] + immediate + 3]);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|beq\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
if (RF[rs] == RF[rt])
{
  immediate = (instr2 >> 0) & 0xFFFF;
  PC  =  nPC;
  nPC  += (immediate << 2);
    if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


}
else
{
  PC  =  nPC;
  nPC  += 4;
}
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


beqPLUSsllPLUSsll:
#if INDIRECT_DEBUG
printf("%d|beq\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
if (RF[rs] == RF[rt])
{
  immediate = (instr0 >> 0) & 0xFFFF;
  PC  =  nPC;
  nPC  += (immediate << 2);
    if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


}
else
{
  PC  =  nPC;
  nPC  += 4;
}

#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr1 >> 6) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr2 >> 6) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


sltuPLUSlwPLUSlw:
#if INDIRECT_DEBUG
printf("%d|sltu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = (RF[rs] < RF[rt])?1:0;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|lw\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)(VM_memory[RF[rs] + immediate]) << 24) | ((uint32_t)(VM_memory[RF[rs] + immediate + 1]) << 16) | ((uint32_t)(VM_memory[RF[rs] + immediate + 2]) << 8) | ((uint32_t)VM_memory[RF[rs] + immediate + 3]);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|lw\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)(VM_memory[RF[rs] + immediate]) << 24) | ((uint32_t)(VM_memory[RF[rs] + immediate + 1]) << 16) | ((uint32_t)(VM_memory[RF[rs] + immediate + 2]) << 8) | ((uint32_t)VM_memory[RF[rs] + immediate + 3]);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


srlPLUSorPLUSsll:
#if INDIRECT_DEBUG
printf("%d|srl\n",counter);
counter++;
#endif
shamt = (instr0 >> 6) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rt] >> shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|or\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rs] | RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr2 >> 6) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


swPLUSadduPLUSslt:
#if INDIRECT_DEBUG
printf("%d|sw\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
VM_memory[RF[rs] + immediate] = (uint8_t)((RF[rt] & 0xFF000000) >> 24);
VM_memory[RF[rs] + immediate + 1] = (uint8_t)((RF[rt] & 0xFF0000) >> 16);
VM_memory[RF[rs] + immediate + 2] = (uint8_t)((RF[rt] & 0xFF00) >> 8);
VM_memory[RF[rs] + immediate + 3] = (uint8_t)(RF[rt] & 0xFF);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|slt\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = (RF[rs] < RF[rt])?1:0;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


bnePLUSsllPLUSor:
#if INDIRECT_DEBUG
printf("%d|bne\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
if (RF[rs] != RF[rt])
{
  immediate = (instr0 >> 0) & 0xFFFF;
  PC  =  nPC;
  nPC  += (immediate << 2);
    if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


}
else
{
  PC  =  nPC;
  nPC  += 4;
}

#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr1 >> 6) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|or\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rs] | RF[rt];
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


bnePLUSadduPLUSandi:
#if INDIRECT_DEBUG
printf("%d|bne\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
if (RF[rs] != RF[rt])
{
  immediate = (instr0 >> 0) & 0xFFFF;
  PC  =  nPC;
  nPC  += (immediate << 2);
    if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


}
else
{
  PC  =  nPC;
  nPC  += 4;
}

#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|andi\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
RF[rt] = RF[rs] & (uint32_t)immediate;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


jrPLUSsllPLUSlw:
#if INDIRECT_DEBUG
printf("%d|jr\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
PC = nPC;
nPC = RF[rs];
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;



#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr1 >> 6) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|lw\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)(VM_memory[RF[rs] + immediate]) << 24) | ((uint32_t)(VM_memory[RF[rs] + immediate + 1]) << 16) | ((uint32_t)(VM_memory[RF[rs] + immediate + 2]) << 8) | ((uint32_t)VM_memory[RF[rs] + immediate + 3]);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


swPLUSbnePLUSaddu:
#if INDIRECT_DEBUG
printf("%d|sw\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
VM_memory[RF[rs] + immediate] = (uint8_t)((RF[rt] & 0xFF000000) >> 24);
VM_memory[RF[rs] + immediate + 1] = (uint8_t)((RF[rt] & 0xFF0000) >> 16);
VM_memory[RF[rs] + immediate + 2] = (uint8_t)((RF[rt] & 0xFF00) >> 8);
VM_memory[RF[rs] + immediate + 3] = (uint8_t)(RF[rt] & 0xFF);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|bne\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
if (RF[rs] != RF[rt])
{
  immediate = (instr1 >> 0) & 0xFFFF;
  PC  =  nPC;
  nPC  += (immediate << 2);
    if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


}
else
{
  PC  =  nPC;
  nPC  += 4;
}

#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


orPLUSsrlPLUSandi:
#if INDIRECT_DEBUG
printf("%d|or\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rs] | RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|srl\n",counter);
counter++;
#endif
shamt = (instr1 >> 6) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rt] >> shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|andi\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
RF[rt] = RF[rs] & (uint32_t)immediate;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


addiuPLUSluiPLUSaddiu:
#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|lui\n",counter);
counter++;
#endif
// NOTHING IMPLEMENTED, COPIED FROM BELOW
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)immediate) << 16;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


swPLUSaddiuPLUSsw:
#if INDIRECT_DEBUG
printf("%d|sw\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
VM_memory[RF[rs] + immediate] = (uint8_t)((RF[rt] & 0xFF000000) >> 24);
VM_memory[RF[rs] + immediate + 1] = (uint8_t)((RF[rt] & 0xFF0000) >> 16);
VM_memory[RF[rs] + immediate + 2] = (uint8_t)((RF[rt] & 0xFF00) >> 8);
VM_memory[RF[rs] + immediate + 3] = (uint8_t)(RF[rt] & 0xFF);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sw\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
VM_memory[RF[rs] + immediate] = (uint8_t)((RF[rt] & 0xFF000000) >> 24);
VM_memory[RF[rs] + immediate + 1] = (uint8_t)((RF[rt] & 0xFF0000) >> 16);
VM_memory[RF[rs] + immediate + 2] = (uint8_t)((RF[rt] & 0xFF00) >> 8);
VM_memory[RF[rs] + immediate + 3] = (uint8_t)(RF[rt] & 0xFF);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


sllPLUSjalPLUSaddu:
#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr0 >> 6) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|jal\n",counter);
counter++;
#endif
RF[31] = PC + 8;
PC = nPC;
address = (instr1 >> 0) & 0x3FFFFFF;
nPC = address << 2;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;



#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


sllPLUSsllPLUSxor:
#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr0 >> 6) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr1 >> 6) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|xor\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rs] ^ RF[rt];
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


lwPLUSlwPLUSjal:
#if INDIRECT_DEBUG
printf("%d|lw\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)(VM_memory[RF[rs] + immediate]) << 24) | ((uint32_t)(VM_memory[RF[rs] + immediate + 1]) << 16) | ((uint32_t)(VM_memory[RF[rs] + immediate + 2]) << 8) | ((uint32_t)VM_memory[RF[rs] + immediate + 3]);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|lw\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)(VM_memory[RF[rs] + immediate]) << 24) | ((uint32_t)(VM_memory[RF[rs] + immediate + 1]) << 16) | ((uint32_t)(VM_memory[RF[rs] + immediate + 2]) << 8) | ((uint32_t)VM_memory[RF[rs] + immediate + 3]);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|jal\n",counter);
counter++;
#endif
RF[31] = PC + 8;
PC = nPC;
address = (instr2 >> 0) & 0x3FFFFFF;
nPC = address << 2;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


lwPLUSadduPLUSaddu:
#if INDIRECT_DEBUG
printf("%d|lw\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)(VM_memory[RF[rs] + immediate]) << 24) | ((uint32_t)(VM_memory[RF[rs] + immediate + 1]) << 16) | ((uint32_t)(VM_memory[RF[rs] + immediate + 2]) << 8) | ((uint32_t)VM_memory[RF[rs] + immediate + 3]);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


luiPLUSoriPLUSaddu:
#if INDIRECT_DEBUG
printf("%d|lui\n",counter);
counter++;
#endif
// NOTHING IMPLEMENTED, COPIED FROM BELOW
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)immediate) << 16;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|ori\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = RF[rs] | (uint32_t)immediate;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


oriPLUSsllPLUSxor:
#if INDIRECT_DEBUG
printf("%d|ori\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = RF[rs] | (uint32_t)immediate;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr1 >> 6) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|xor\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rs] ^ RF[rt];
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


beqPLUSadduPLUSslt:
#if INDIRECT_DEBUG
printf("%d|beq\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
if (RF[rs] == RF[rt])
{
  immediate = (instr0 >> 0) & 0xFFFF;
  PC  =  nPC;
  nPC  += (immediate << 2);
    if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


}
else
{
  PC  =  nPC;
  nPC  += 4;
}

#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|slt\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = (RF[rs] < RF[rt])?1:0;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


andPLUSorPLUSsll:
#if INDIRECT_DEBUG
printf("%d|and\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rs] & RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|or\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rs] | RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr2 >> 6) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


sllPLUSsltPLUSbne:
#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr0 >> 6) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|slt\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = (RF[rs] < RF[rt])?1:0;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|bne\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
if (RF[rs] != RF[rt])
{
  immediate = (instr2 >> 0) & 0xFFFF;
  PC  =  nPC;
  nPC  += (immediate << 2);
    if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


}
else
{
  PC  =  nPC;
  nPC  += 4;
}
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


beqPLUSadduPLUSsll:
#if INDIRECT_DEBUG
printf("%d|beq\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
if (RF[rs] == RF[rt])
{
  immediate = (instr0 >> 0) & 0xFFFF;
  PC  =  nPC;
  nPC  += (immediate << 2);
    if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


}
else
{
  PC  =  nPC;
  nPC  += 4;
}

#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr2 >> 6) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


sllPLUSsltiPLUSbeq:
#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr0 >> 6) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|slti\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] < immediate)?1:0;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|beq\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
if (RF[rs] == RF[rt])
{
  immediate = (instr2 >> 0) & 0xFFFF;
  PC  =  nPC;
  nPC  += (immediate << 2);
    if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


}
else
{
  PC  =  nPC;
  nPC  += 4;
}
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


swPLUSjumpPLUSsll:
#if INDIRECT_DEBUG
printf("%d|sw\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
VM_memory[RF[rs] + immediate] = (uint8_t)((RF[rt] & 0xFF000000) >> 24);
VM_memory[RF[rs] + immediate + 1] = (uint8_t)((RF[rt] & 0xFF0000) >> 16);
VM_memory[RF[rs] + immediate + 2] = (uint8_t)((RF[rt] & 0xFF00) >> 8);
VM_memory[RF[rs] + immediate + 3] = (uint8_t)(RF[rt] & 0xFF);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|jump\n",counter);
counter++;
#endif
PC = nPC;
address = (instr1 >> 0) & 0x3FFFFFF;
nPC = address << 2;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;



#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr2 >> 6) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


swPLUSlwPLUSbeq:
#if INDIRECT_DEBUG
printf("%d|sw\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
VM_memory[RF[rs] + immediate] = (uint8_t)((RF[rt] & 0xFF000000) >> 24);
VM_memory[RF[rs] + immediate + 1] = (uint8_t)((RF[rt] & 0xFF0000) >> 16);
VM_memory[RF[rs] + immediate + 2] = (uint8_t)((RF[rt] & 0xFF00) >> 8);
VM_memory[RF[rs] + immediate + 3] = (uint8_t)(RF[rt] & 0xFF);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|lw\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)(VM_memory[RF[rs] + immediate]) << 24) | ((uint32_t)(VM_memory[RF[rs] + immediate + 1]) << 16) | ((uint32_t)(VM_memory[RF[rs] + immediate + 2]) << 8) | ((uint32_t)VM_memory[RF[rs] + immediate + 3]);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|beq\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
if (RF[rs] == RF[rt])
{
  immediate = (instr2 >> 0) & 0xFFFF;
  PC  =  nPC;
  nPC  += (immediate << 2);
    if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


}
else
{
  PC  =  nPC;
  nPC  += 4;
}
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


andPLUSsrlPLUSxor:
#if INDIRECT_DEBUG
printf("%d|and\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rs] & RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|srl\n",counter);
counter++;
#endif
shamt = (instr1 >> 6) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rt] >> shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|xor\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rs] ^ RF[rt];
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


lwPLUSerrorPLUSerror:
#if INDIRECT_DEBUG
printf("%d|lw\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)(VM_memory[RF[rs] + immediate]) << 24) | ((uint32_t)(VM_memory[RF[rs] + immediate + 1]) << 16) | ((uint32_t)(VM_memory[RF[rs] + immediate + 2]) << 8) | ((uint32_t)VM_memory[RF[rs] + immediate + 3]);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("Error, unknown instr1uction %d.\n", instr1);
#endif
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("Error, unknown instr2uction %d.\n", instr2);
#endif
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


adduPLUSlwPLUSbeq:
#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|lw\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)(VM_memory[RF[rs] + immediate]) << 24) | ((uint32_t)(VM_memory[RF[rs] + immediate + 1]) << 16) | ((uint32_t)(VM_memory[RF[rs] + immediate + 2]) << 8) | ((uint32_t)VM_memory[RF[rs] + immediate + 3]);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|beq\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
if (RF[rs] == RF[rt])
{
  immediate = (instr2 >> 0) & 0xFFFF;
  PC  =  nPC;
  nPC  += (immediate << 2);
    if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


}
else
{
  PC  =  nPC;
  nPC  += 4;
}
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


jumpPLUSsllPLUSsw:
#if INDIRECT_DEBUG
printf("%d|jump\n",counter);
counter++;
#endif
PC = nPC;
address = (instr0 >> 0) & 0x3FFFFFF;
nPC = address << 2;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;



#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr1 >> 6) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sw\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
VM_memory[RF[rs] + immediate] = (uint8_t)((RF[rt] & 0xFF000000) >> 24);
VM_memory[RF[rs] + immediate + 1] = (uint8_t)((RF[rt] & 0xFF0000) >> 16);
VM_memory[RF[rs] + immediate + 2] = (uint8_t)((RF[rt] & 0xFF00) >> 8);
VM_memory[RF[rs] + immediate + 3] = (uint8_t)(RF[rt] & 0xFF);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


adduPLUSsllPLUSsll:
#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr1 >> 6) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr2 >> 6) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


lwPLUSadduPLUSslt:
#if INDIRECT_DEBUG
printf("%d|lw\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)(VM_memory[RF[rs] + immediate]) << 24) | ((uint32_t)(VM_memory[RF[rs] + immediate + 1]) << 16) | ((uint32_t)(VM_memory[RF[rs] + immediate + 2]) << 8) | ((uint32_t)VM_memory[RF[rs] + immediate + 3]);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|slt\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = (RF[rs] < RF[rt])?1:0;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


lwPLUSadduPLUSsll:
#if INDIRECT_DEBUG
printf("%d|lw\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)(VM_memory[RF[rs] + immediate]) << 24) | ((uint32_t)(VM_memory[RF[rs] + immediate + 1]) << 16) | ((uint32_t)(VM_memory[RF[rs] + immediate + 2]) << 8) | ((uint32_t)VM_memory[RF[rs] + immediate + 3]);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr2 >> 6) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


andPLUSorPLUSsrl:
#if INDIRECT_DEBUG
printf("%d|and\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rs] & RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|or\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rs] | RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|srl\n",counter);
counter++;
#endif
shamt = (instr2 >> 6) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rt] >> shamt;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


sllPLUSadduPLUSaddu:
#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr0 >> 6) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


adduPLUSadduPLUSsw:
#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sw\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
VM_memory[RF[rs] + immediate] = (uint8_t)((RF[rt] & 0xFF000000) >> 24);
VM_memory[RF[rs] + immediate + 1] = (uint8_t)((RF[rt] & 0xFF0000) >> 16);
VM_memory[RF[rs] + immediate + 2] = (uint8_t)((RF[rt] & 0xFF00) >> 8);
VM_memory[RF[rs] + immediate + 3] = (uint8_t)(RF[rt] & 0xFF);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


sltuPLUSbeqPLUSsll:
#if INDIRECT_DEBUG
printf("%d|sltu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = (RF[rs] < RF[rt])?1:0;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|beq\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
if (RF[rs] == RF[rt])
{
  immediate = (instr1 >> 0) & 0xFFFF;
  PC  =  nPC;
  nPC  += (immediate << 2);
    if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


}
else
{
  PC  =  nPC;
  nPC  += 4;
}

#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr2 >> 6) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


sltiPLUSswPLUSslti:
#if INDIRECT_DEBUG
printf("%d|slti\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] < immediate)?1:0;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sw\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
VM_memory[RF[rs] + immediate] = (uint8_t)((RF[rt] & 0xFF000000) >> 24);
VM_memory[RF[rs] + immediate + 1] = (uint8_t)((RF[rt] & 0xFF0000) >> 16);
VM_memory[RF[rs] + immediate + 2] = (uint8_t)((RF[rt] & 0xFF00) >> 8);
VM_memory[RF[rs] + immediate + 3] = (uint8_t)(RF[rt] & 0xFF);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|slti\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] < immediate)?1:0;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


xorPLUSsrlPLUSxor:
#if INDIRECT_DEBUG
printf("%d|xor\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rs] ^ RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|srl\n",counter);
counter++;
#endif
shamt = (instr1 >> 6) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rt] >> shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|xor\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rs] ^ RF[rt];
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


srlPLUSluiPLUSori:
#if INDIRECT_DEBUG
printf("%d|srl\n",counter);
counter++;
#endif
shamt = (instr0 >> 6) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rt] >> shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|lui\n",counter);
counter++;
#endif
// NOTHING IMPLEMENTED, COPIED FROM BELOW
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)immediate) << 16;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|ori\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
RF[rt] = RF[rs] | (uint32_t)immediate;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


beqPLUSsllPLUSlui:
#if INDIRECT_DEBUG
printf("%d|beq\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
if (RF[rs] == RF[rt])
{
  immediate = (instr0 >> 0) & 0xFFFF;
  PC  =  nPC;
  nPC  += (immediate << 2);
    if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


}
else
{
  PC  =  nPC;
  nPC  += 4;
}

#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr1 >> 6) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|lui\n",counter);
counter++;
#endif
// NOTHING IMPLEMENTED, COPIED FROM BELOW
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)immediate) << 16;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


oriPLUSaddiuPLUSerror:
#if INDIRECT_DEBUG
printf("%d|ori\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = RF[rs] | (uint32_t)immediate;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("Error, unknown instr2uction %d.\n", instr2);
#endif
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


adduPLUSlwPLUSaddu:
#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|lw\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)(VM_memory[RF[rs] + immediate]) << 24) | ((uint32_t)(VM_memory[RF[rs] + immediate + 1]) << 16) | ((uint32_t)(VM_memory[RF[rs] + immediate + 2]) << 8) | ((uint32_t)VM_memory[RF[rs] + immediate + 3]);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


andiPLUSxorPLUSandi:
#if INDIRECT_DEBUG
printf("%d|andi\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = RF[rs] & (uint32_t)immediate;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|xor\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rs] ^ RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|andi\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
RF[rt] = RF[rs] & (uint32_t)immediate;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


beqPLUSsllPLUSlw:
#if INDIRECT_DEBUG
printf("%d|beq\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
if (RF[rs] == RF[rt])
{
  immediate = (instr0 >> 0) & 0xFFFF;
  PC  =  nPC;
  nPC  += (immediate << 2);
    if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


}
else
{
  PC  =  nPC;
  nPC  += 4;
}

#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr1 >> 6) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|lw\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)(VM_memory[RF[rs] + immediate]) << 24) | ((uint32_t)(VM_memory[RF[rs] + immediate + 1]) << 16) | ((uint32_t)(VM_memory[RF[rs] + immediate + 2]) << 8) | ((uint32_t)VM_memory[RF[rs] + immediate + 3]);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


addiuPLUSjumpPLUSsll:
#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|jump\n",counter);
counter++;
#endif
PC = nPC;
address = (instr1 >> 0) & 0x3FFFFFF;
nPC = address << 2;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;



#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr2 >> 6) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


adduPLUSlwPLUSsw:
#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|lw\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)(VM_memory[RF[rs] + immediate]) << 24) | ((uint32_t)(VM_memory[RF[rs] + immediate + 1]) << 16) | ((uint32_t)(VM_memory[RF[rs] + immediate + 2]) << 8) | ((uint32_t)VM_memory[RF[rs] + immediate + 3]);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sw\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
VM_memory[RF[rs] + immediate] = (uint8_t)((RF[rt] & 0xFF000000) >> 24);
VM_memory[RF[rs] + immediate + 1] = (uint8_t)((RF[rt] & 0xFF0000) >> 16);
VM_memory[RF[rs] + immediate + 2] = (uint8_t)((RF[rt] & 0xFF00) >> 8);
VM_memory[RF[rs] + immediate + 3] = (uint8_t)(RF[rt] & 0xFF);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


andPLUSandiPLUSsubu:
#if INDIRECT_DEBUG
printf("%d|and\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rs] & RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|andi\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = RF[rs] & (uint32_t)immediate;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|subu\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rs] - RF[rt];
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


srlPLUSsllPLUSsll:
#if INDIRECT_DEBUG
printf("%d|srl\n",counter);
counter++;
#endif
shamt = (instr0 >> 6) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rt] >> shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr1 >> 6) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr2 >> 6) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


srlPLUSadduPLUSsll:
#if INDIRECT_DEBUG
printf("%d|srl\n",counter);
counter++;
#endif
shamt = (instr0 >> 6) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rt] >> shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr2 >> 6) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


addiuPLUSadduPLUSaddu:
#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


jrPLUSaddiuPLUSaddiu:
#if INDIRECT_DEBUG
printf("%d|jr\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
PC = nPC;
nPC = RF[rs];
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;



#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


xorPLUSsrlPLUSsll:
#if INDIRECT_DEBUG
printf("%d|xor\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rs] ^ RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|srl\n",counter);
counter++;
#endif
shamt = (instr1 >> 6) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rt] >> shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr2 >> 6) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


lwPLUSsltuPLUSaddiu:
#if INDIRECT_DEBUG
printf("%d|lw\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)(VM_memory[RF[rs] + immediate]) << 24) | ((uint32_t)(VM_memory[RF[rs] + immediate + 1]) << 16) | ((uint32_t)(VM_memory[RF[rs] + immediate + 2]) << 8) | ((uint32_t)VM_memory[RF[rs] + immediate + 3]);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sltu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = (RF[rs] < RF[rt])?1:0;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


bnePLUSswPLUSlw:
#if INDIRECT_DEBUG
printf("%d|bne\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
if (RF[rs] != RF[rt])
{
  immediate = (instr0 >> 0) & 0xFFFF;
  PC  =  nPC;
  nPC  += (immediate << 2);
    if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


}
else
{
  PC  =  nPC;
  nPC  += 4;
}

#if INDIRECT_DEBUG
printf("%d|sw\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
VM_memory[RF[rs] + immediate] = (uint8_t)((RF[rt] & 0xFF000000) >> 24);
VM_memory[RF[rs] + immediate + 1] = (uint8_t)((RF[rt] & 0xFF0000) >> 16);
VM_memory[RF[rs] + immediate + 2] = (uint8_t)((RF[rt] & 0xFF00) >> 8);
VM_memory[RF[rs] + immediate + 3] = (uint8_t)(RF[rt] & 0xFF);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|lw\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)(VM_memory[RF[rs] + immediate]) << 24) | ((uint32_t)(VM_memory[RF[rs] + immediate + 1]) << 16) | ((uint32_t)(VM_memory[RF[rs] + immediate + 2]) << 8) | ((uint32_t)VM_memory[RF[rs] + immediate + 3]);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


luiPLUSluiPLUSlui:
#if INDIRECT_DEBUG
printf("%d|lui\n",counter);
counter++;
#endif
// NOTHING IMPLEMENTED, COPIED FROM BELOW
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)immediate) << 16;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|lui\n",counter);
counter++;
#endif
// NOTHING IMPLEMENTED, COPIED FROM BELOW
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)immediate) << 16;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|lui\n",counter);
counter++;
#endif
// NOTHING IMPLEMENTED, COPIED FROM BELOW
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)immediate) << 16;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


adduPLUSadduPLUSbne:
#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|bne\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
if (RF[rs] != RF[rt])
{
  immediate = (instr2 >> 0) & 0xFFFF;
  PC  =  nPC;
  nPC  += (immediate << 2);
    if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


}
else
{
  PC  =  nPC;
  nPC  += 4;
}
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


adduPLUSlwPLUSaddiu:
#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|lw\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)(VM_memory[RF[rs] + immediate]) << 24) | ((uint32_t)(VM_memory[RF[rs] + immediate + 1]) << 16) | ((uint32_t)(VM_memory[RF[rs] + immediate + 2]) << 8) | ((uint32_t)VM_memory[RF[rs] + immediate + 3]);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


orPLUSsltuPLUSlw:
#if INDIRECT_DEBUG
printf("%d|or\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rs] | RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sltu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = (RF[rs] < RF[rt])?1:0;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|lw\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)(VM_memory[RF[rs] + immediate]) << 24) | ((uint32_t)(VM_memory[RF[rs] + immediate + 1]) << 16) | ((uint32_t)(VM_memory[RF[rs] + immediate + 2]) << 8) | ((uint32_t)VM_memory[RF[rs] + immediate + 3]);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


bnePLUSsllPLUSblez:
#if INDIRECT_DEBUG
printf("%d|bne\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
if (RF[rs] != RF[rt])
{
  immediate = (instr0 >> 0) & 0xFFFF;
  PC  =  nPC;
  nPC  += (immediate << 2);
    if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


}
else
{
  PC  =  nPC;
  nPC  += 4;
}

#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr1 >> 6) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|blez\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
if ((int32_t)RF[rs] <= 0)
{
  immediate = (instr2 >> 0) & 0xFFFF;
  PC  =  nPC;
  nPC  += (immediate << 2);
    if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


}
else
{
  PC  =  nPC;
  nPC  += 4;
}
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


sltiPLUSbeqPLUSaddu:
#if INDIRECT_DEBUG
printf("%d|slti\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] < immediate)?1:0;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|beq\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
if (RF[rs] == RF[rt])
{
  immediate = (instr1 >> 0) & 0xFFFF;
  PC  =  nPC;
  nPC  += (immediate << 2);
    if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


}
else
{
  PC  =  nPC;
  nPC  += 4;
}

#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


adduPLUSaddiuPLUSaddiu:
#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


adduPLUSlwPLUSslt:
#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|lw\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)(VM_memory[RF[rs] + immediate]) << 24) | ((uint32_t)(VM_memory[RF[rs] + immediate + 1]) << 16) | ((uint32_t)(VM_memory[RF[rs] + immediate + 2]) << 8) | ((uint32_t)VM_memory[RF[rs] + immediate + 3]);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|slt\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = (RF[rs] < RF[rt])?1:0;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


beqPLUSswPLUSaddiu:
#if INDIRECT_DEBUG
printf("%d|beq\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
if (RF[rs] == RF[rt])
{
  immediate = (instr0 >> 0) & 0xFFFF;
  PC  =  nPC;
  nPC  += (immediate << 2);
    if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


}
else
{
  PC  =  nPC;
  nPC  += 4;
}

#if INDIRECT_DEBUG
printf("%d|sw\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
VM_memory[RF[rs] + immediate] = (uint8_t)((RF[rt] & 0xFF000000) >> 24);
VM_memory[RF[rs] + immediate + 1] = (uint8_t)((RF[rt] & 0xFF0000) >> 16);
VM_memory[RF[rs] + immediate + 2] = (uint8_t)((RF[rt] & 0xFF00) >> 8);
VM_memory[RF[rs] + immediate + 3] = (uint8_t)(RF[rt] & 0xFF);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


beqPLUSswPLUSsll:
#if INDIRECT_DEBUG
printf("%d|beq\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
if (RF[rs] == RF[rt])
{
  immediate = (instr0 >> 0) & 0xFFFF;
  PC  =  nPC;
  nPC  += (immediate << 2);
    if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


}
else
{
  PC  =  nPC;
  nPC  += 4;
}

#if INDIRECT_DEBUG
printf("%d|sw\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
VM_memory[RF[rs] + immediate] = (uint8_t)((RF[rt] & 0xFF000000) >> 24);
VM_memory[RF[rs] + immediate + 1] = (uint8_t)((RF[rt] & 0xFF0000) >> 16);
VM_memory[RF[rs] + immediate + 2] = (uint8_t)((RF[rt] & 0xFF00) >> 8);
VM_memory[RF[rs] + immediate + 3] = (uint8_t)(RF[rt] & 0xFF);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr2 >> 6) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


blezPLUSsllPLUSlw:
#if INDIRECT_DEBUG
printf("%d|blez\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
if ((int32_t)RF[rs] <= 0)
{
  immediate = (instr0 >> 0) & 0xFFFF;
  PC  =  nPC;
  nPC  += (immediate << 2);
    if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


}
else
{
  PC  =  nPC;
  nPC  += 4;
}

#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr1 >> 6) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
rd = (instr1 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|lw\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)(VM_memory[RF[rs] + immediate]) << 24) | ((uint32_t)(VM_memory[RF[rs] + immediate + 1]) << 16) | ((uint32_t)(VM_memory[RF[rs] + immediate + 2]) << 8) | ((uint32_t)VM_memory[RF[rs] + immediate + 3]);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


adduPLUSlwPLUSsll:
#if INDIRECT_DEBUG
printf("%d|addu\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
rd = (instr0 >> 11) & 0x1F;
RF[rd] = RF[rs] + RF[rt];
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|lw\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)(VM_memory[RF[rs] + immediate]) << 24) | ((uint32_t)(VM_memory[RF[rs] + immediate + 1]) << 16) | ((uint32_t)(VM_memory[RF[rs] + immediate + 2]) << 8) | ((uint32_t)VM_memory[RF[rs] + immediate + 3]);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|sll\n",counter);
counter++;
#endif
shamt = (instr2 >> 6) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
rd = (instr2 >> 11) & 0x1F;
RF[rd] = RF[rt] << shamt;
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


swPLUSluiPLUSaddiu:
#if INDIRECT_DEBUG
printf("%d|sw\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
VM_memory[RF[rs] + immediate] = (uint8_t)((RF[rt] & 0xFF000000) >> 24);
VM_memory[RF[rs] + immediate + 1] = (uint8_t)((RF[rt] & 0xFF0000) >> 16);
VM_memory[RF[rs] + immediate + 2] = (uint8_t)((RF[rt] & 0xFF00) >> 8);
VM_memory[RF[rs] + immediate + 3] = (uint8_t)(RF[rt] & 0xFF);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|lui\n",counter);
counter++;
#endif
// NOTHING IMPLEMENTED, COPIED FROM BELOW
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)immediate) << 16;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|addiu\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
immediate = (instr2 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] + immediate);
PC  =  nPC;
nPC  += 4;
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


lwPLUSsltiPLUSbeq:
#if INDIRECT_DEBUG
printf("%d|lw\n",counter);
counter++;
#endif
rs = (instr0 >> 21) & 0x1F;
rt = (instr0 >> 16) & 0x1F;
immediate = (instr0 >> 0) & 0xFFFF;
RF[rt] = ((uint32_t)(VM_memory[RF[rs] + immediate]) << 24) | ((uint32_t)(VM_memory[RF[rs] + immediate + 1]) << 16) | ((uint32_t)(VM_memory[RF[rs] + immediate + 2]) << 8) | ((uint32_t)VM_memory[RF[rs] + immediate + 3]);
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|slti\n",counter);
counter++;
#endif
rs = (instr1 >> 21) & 0x1F;
rt = (instr1 >> 16) & 0x1F;
immediate = (instr1 >> 0) & 0xFFFF;
RF[rt] = (RF[rs] < immediate)?1:0;
PC  =  nPC;
nPC  += 4;

#if INDIRECT_DEBUG
printf("%d|beq\n",counter);
counter++;
#endif
rs = (instr2 >> 21) & 0x1F;
rt = (instr2 >> 16) & 0x1F;
if (RF[rs] == RF[rt])
{
  immediate = (instr2 >> 0) & 0xFFFF;
  PC  =  nPC;
  nPC  += (immediate << 2);
    if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


}
else
{
  PC  =  nPC;
  nPC  += 4;
}
  if(mark3[PC] < 0) {
  instr0 = (((uint32_t)VM_memory[PC] <<24) | ((uint32_t)VM_memory[PC+1] <<16) | ((uint32_t)VM_memory[PC+2] <<8) | ((uint32_t)VM_memory[PC+3]));
  op0 = (instr0 >> 26) & 0x3F;
  if(op0 == 0x0) {
    	funct = (instr0 >> 0) & 0x3F;
    	op0 = op0 + funct;
    }
    else {
    	op0 = op0 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[PC]))) = instr0;
    mark3[PC] = op0;
  }
  else {
    instr0 = *((uint32_t *)(&(VM_memory[PC])));
    op0 = mark3[PC];
  }

p = array;
p = p[op0].next_level;

  if(mark3[nPC] < 0) {
  instr1 = (((uint32_t)VM_memory[nPC] <<24) | ((uint32_t)VM_memory[nPC+1] <<16) | ((uint32_t)VM_memory[nPC+2] <<8) | ((uint32_t)VM_memory[nPC+3]));
  op1 = (instr1 >> 26) & 0x3F;
  if(op1 == 0x0) {
    	funct = (instr1 >> 0) & 0x3F;
    	op1 = op1 + funct;
    }
    else {
    	op1 = op1 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC]))) = instr1;
    mark3[nPC] = op1;
  }
  else {
    instr1 = *((uint32_t *)(&(VM_memory[nPC])));
    op1 = mark3[nPC];
  }

p = p[op1].next_level;

  if(mark3[nPC + 4] < 0) {
  instr2 = (((uint32_t)VM_memory[nPC + 4] <<24) | ((uint32_t)VM_memory[nPC + 4+1] <<16) | ((uint32_t)VM_memory[nPC + 4+2] <<8) | ((uint32_t)VM_memory[nPC + 4+3]));
  op2 = (instr2 >> 26) & 0x3F;
  if(op2 == 0x0) {
    	funct = (instr2 >> 0) & 0x3F;
    	op2 = op2 + funct;
    }
    else {
    	op2 = op2 + FIX_OP;
    }
    *((uint32_t *) (&(VM_memory[nPC + 4]))) = instr2;
    mark3[nPC + 4] = op2;
  }
  else {
    instr2 = *((uint32_t *)(&(VM_memory[nPC + 4])));
    op2 = mark3[nPC + 4];
  }

goto *p[op2].code;


end:
if(opt) {
  print_memory();
  print_registers();
}

}
