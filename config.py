# Must be divisible by 8 (1 byte) and <= 64
bits_per_instruction = 32
endianess = ">"             # < : little-endian ; > : big-indian
expected_extension = ".x"
appended_extension = ".bt"

INIT_POS = 0
BITS_POS = 1

# Variables used to parse
opcode_init = 0
bits_per_opcode = 6
opcode = [opcode_init, bits_per_opcode]

function_init = 26
bits_per_function = 6
function = [function_init, bits_per_function]

TYPE_POS = 0
VALUE_POS = 1
NEW_VALUE_POS = 2
NAME_POS = 3

# Update format: [ [ [opcode, function], [opcode_value, function_value], [newOpcode, newFunction] ] * n ]
translate_table = [
# 0x0  #000000 => Register encoding.
[[opcode, function], [0b000000, 0b001011], [0b000000, 0b001011], 'movn'],   #0 001010 				if(rt!=0) rd = rs
[[opcode, function], [0b000000, 0b001010], [0b000001, 0b001010], 'movz'],   #1 001010 				if(rt==0) rd = rs
[[opcode, function], [0b000000, 0b100000], [0b000010, 0b100000], 'add'],    #2 100000	ArithLog	$d = $s + $t
[[opcode, function], [0b000000, 0b100001], [0b000011, 0b100001], 'addu'],   #3 100001	ArithLog	$d = $s + $t
[[opcode, function], [0b000000, 0b100100], [0b000100, 0b100100], 'and'],    #4 100100	ArithLog	$d = $s & $t
[[opcode, function], [0b000000, 0b011010], [0b000101, 0b011010], 'div'],    #5 011010  DivMult		lo = $s / $t; hi = $s % $t
[[opcode, function], [0b000000, 0b011011], [0b000110, 0b011011], 'divu'],   #6 011011  DivMult		lo = $s / $t; hi = $s % $t
[[opcode, function], [0b000000, 0b011000], [0b000111, 0b011000], 'mult'],   #7 011000  DivMult		hi:lo = $s * $t
[[opcode, function], [0b000000, 0b011001], [0b001000, 0b011001], 'multu'],  #8 011001	DivMult		hi:lo = $s * $t
[[opcode, function], [0b000000, 0b100111], [0b001001, 0b100111], 'nor'],    #9 100111	ArithLog	$d = ~($s | $t)
[[opcode, function], [0b000000, 0b100101], [0b001010, 0b100101], 'or'],     #10 100101	ArithLog	$d = $s | $t
[[opcode, function], [0b000000, 0b000000], [0b001011, 0b000000], 'sll'],	#11 000000	Shift		$d = $t << a
[[opcode, function], [0b000000, 0b000100], [0b001100, 0b000100], 'sllv'],	#12 000100	ShiftV		$d = $t << $s
[[opcode, function], [0b000000, 0b000011], [0b001101, 0b000011], 'sra'],    #13 000011	Shift		$d = $t >> a
[[opcode, function], [0b000000, 0b000111], [0b001110, 0b000111], 'srav'],   #14 000111	ShiftV		$d = $t >> $s
[[opcode, function], [0b000000, 0b000010], [0b001111, 0b000010], 'srl'],    #15 000010	Shift		$d = $t >>> a
[[opcode, function], [0b000000, 0b000110], [0b010000, 0b000110], 'srlv'],   #16 000110	ShiftV		$d = $t >>> $s
[[opcode, function], [0b000000, 0b100010], [0b010001, 0b100010], 'sub'],    #17 100010	ArithLog	$d = $s - $t
[[opcode, function], [0b000000, 0b100011], [0b010010, 0b100011], 'subu'],   #18 100011	ArithLog	$d = $s - $t
[[opcode, function], [0b000000, 0b100110], [0b010011, 0b100110], 'xor'],    #19 100110  ArithLog	$d = $s ^ $t
[[opcode, function], [0b000000, 0b101010], [0b010100, 0b101010], 'slt'],    #20 101010	ArithLog	$d = ($s < $t)
[[opcode, function], [0b000000, 0b101011], [0b010101, 0b101011], 'sltu'],   #21 101011	ArithLog	$d = ($s < $t)
[[opcode, function], [0b000000, 0b001001], [0b010110, 0b001001], 'jalr'],   #22 001001	JumpR		$31 = pc; pc = $s
[[opcode, function], [0b000000, 0b001000], [0b010111, 0b001000], 'jr'],     #23 001000	JumpR		pc = $s
[[opcode, function], [0b000000, 0b010000], [0b011000, 0b010000], 'mfhi'],   #24 010000	MoveFrom	$d = hi
[[opcode, function], [0b000000, 0b010010], [0b011001, 0b010010], 'mflo'],   #25 010010	MoveFrom	$d = lo
[[opcode, function], [0b000000, 0b010001], [0b011010, 0b010001], 'mthi'],   #26 010001	MoveTo		hi = $s
[[opcode, function], [0b000000, 0b010011], [0b011011, 0b010011], 'mtlo'],   #27 010011	MoveTo		lo = $s
[[opcode, function], [0b000000, 0b001100], [0b011100, 0b001100], 'syscall'],#28 001100	syscall		$2	seen on the .s generated by the ecc compiler
[[opcode], [0b001000], [0b011101], 'addi'],    #29 001000  ArithLogI       $t = $s + SE(i)
[[opcode], [0b001001], [0b011110], 'addiu'],   #30 001001  ArithLogI       $t = $s + SE(i)
[[opcode], [0b001100], [0b011111], 'andi'],    #31 001100  ArithLogI       $t = $s & ZE(i)
[[opcode], [0b001101], [0b100000], 'ori'],     #32 001101  ArithLogI       $t = $s | ZE(i)
[[opcode], [0b001110], [0b100001], 'xori'],    #33 001110  ArithLogI       $d = $s ^ ZE(i)
[[opcode], [0b001111], [0b100010], 'lui'],     #34 001111          Rdest, imm: Load Upper Immediate
[[opcode], [0b011001], [0b100011], 'lhi'],     #35 011001  LoadI   HH ($t) = i
[[opcode], [0b011000], [0b100100], 'llo'],     #36  011000  LoadI   LH ($t) = i
[[opcode], [0b001010], [0b100101], 'slti'],    #37 001010  ArithLogI       $t = ($s < SE(i))
[[opcode], [0b001011], [0b100110], 'sltiu'],   #38 001011  ArithLogI       $t = ($s < SE(i))
[[opcode], [0b000001], [0b100111], 'bgez'],    #39 (bgezal/bltz/beq/bltzal
[[opcode], [0b000001], [0b100111], 'bgezal'],  #40 (bgezal/bltz/beq/bltzal
[[opcode], [0b000001], [0b100111], 'bltz'],    #41 (bgezal/bltz/beq/bltzal
[[opcode], [0b000001], [0b100111], 'bltzal'],  #42 (bgezal/bltz/beq/bltzal
[[opcode], [0b000100], [0b101000], 'beq'],     #43 000100  Branch  if ($s == $t) pc += i << 2
[[opcode], [0b000111], [0b101001], 'bgtz'],    #44 000111  BranchZ if ($s > 0) pc += i << 2
[[opcode], [0b000110], [0b101010], 'blez'],    #45 000110  BranchZ if ($s <= 0) pc += i << 2
[[opcode], [0b000101], [0b101011], 'bne'],     #46 000101  Branch  if ($s != $t) pc += i << 2
[[opcode], [0b100000], [0b101100], 'lb'],      #47 100000  LoadStore       $t = SE (MEM [$s + i]:1)
[[opcode], [0b100100], [0b101101], 'lbu'],     #48 100100  LoadStore       $t = ZE (MEM [$s + i]:1)
[[opcode], [0b100001], [0b101110], 'lh'],      #49 100001  LoadStore       $t = SE (MEM [$s + i]:2)
[[opcode], [0b100101], [0b101111], 'lhu'],     #50 100101  LoadStore       $t = ZE (MEM [$s + i]:2)
[[opcode], [0b100011], [0b110000], 'lw'],      #51 100011  LoadStore       $t = MEM [$s + i]:4
[[opcode], [0b101000], [0b110001], 'sb'],      #52 101000  LoadStore       MEM [$s + i]:1 = LB ($t)
[[opcode], [0b101001], [0b110010], 'sh'],      #53 101001  LoadStore       MEM [$s + i]:2 = LH ($t)
[[opcode], [0b101011], [0b110011], 'sw'],      #54 101011  LoadStore       MEM [$s + i]:4 = $t
[[opcode], [0b000010], [0b110100], 'j'],       #55 000010  Jump    pc = i << 2
[[opcode], [0b000011], [0b110101], 'jal'],     #56 000011  Jump    $31 = pc; pc = i << 2
[[opcode], [0b011010], [0b110110], 'trap'],    #57 011010  Trap    Dependent on operating system;
[[opcode], [0b101010], [0b110111], 'swl'],     #58 Rsrc1, imm(Rsrc2): Store Word Left
[[opcode], [0b101110], [0b111000], 'swr'],     #59 Rsrc1, imm(Rsrc2): Store Word Right
[[opcode], [0b100010], [0b111001], 'lwl'],     #60 Rdest, imm(Rsrc): Load Word Left
[[opcode], [0b100110], [0b111010], 'lwr']      #61 Rdest, imm(Rsrc): Load Word Right
]

# codegen related variables

codegen_defines = '''#include "vm.h"
#include "syscall.h"
#include <inttypes.h>
#include <stdio.h>

#if DEBUGING
void print_memory(void);
void print_registers(void);
#endif

#include "HAL.h"

'''

codegen_global = '''/* Register file. */
uint32_t RF[32];
/*VM memory vector*/
uint8_t VM_memory[VM_MEMORY_SZ] = {0};

uint32_t PC = 0;
uint32_t nPC = 4;

'''

codegen_print_functions = '''#if DEBUGING
void print_memory(void)
{
  int i;
  for (i = 0; i < VM_MEMORY_SZ; i = i+4) {
    printf ("%2x%2x%2x%2x\n", VM_memory[i], VM_memory[i + 1], VM_memory[i + 2], VM_memory[i + 3]);
  }
}
void print_registers(void)
{
  int i;
  for (i = 0; i < 32; i++) {
    printf ("%d:%x\n",i+1 ,RF[i]);
  }
}
#endif

'''

codegen_advance_pc = '''PC  =  nPC;
nPC  += $offset;
'''

codegen_signature = 'void vm_cpu(uint32_t newPC)'

codegen_initialisation = '''  PC = newPC;
  nPC = 4;
  RF[0] = 0; //Register $zero must always be zero
  RF[31] = 1; //Return default (if the program does not set to zero, should put error)
  uint32_t HI = 0, LO = 0;
  uint32_t offset = 4;
  uint8_t halted = 0;
'''

codegen_while = 'while (!halted)'
