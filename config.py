# Must be divisible by 8 (1 byte) and <= 64
bits_per_instruction = 32
endianess = ">"             # < : little-endian ; > : big-indian
expected_extension = ".x"
appended_extension = ".bt"

INIT_POS = 0
BITS_POS = 1

# Variables used to parse
opcode_init = 0
bits_per_opcode = 6
opcode = [opcode_init, bits_per_opcode]

function_init = 26
bits_per_function = 6
function = [function_init, bits_per_function]

TYPE_POS = 0
VALUE_POS = 1
NEW_VALUE_POS = 2

# Update format: [ [ [opcode, function], [opcode_value, function_value], [newOpcode, newFunction] ] * n ]
translate_table = [
# 0x0  #000000 => Register encoding.
[[opcode, function], [0b000000, 0b001011], [0b000000, 0b001011]],	# movn	001010 				if(rt!=0) rd = rs
[[opcode, function], [0b000000, 0b001010], [0b000001, 0b001010]],   # movz	001010 				if(rt==0) rd = rs
[[opcode, function], [0b000000, 0b100000], [0b000010, 0b100000]],   # add	100000	ArithLog	$d = $s + $t
[[opcode, function], [0b000000, 0b100001], [0b000011, 0b100001]],   # addu	100001	ArithLog	$d = $s + $t
[[opcode, function], [0b000000, 0b100100], [0b000100, 0b100100]],   # and	100100	ArithLog	$d = $s & $t
[[opcode, function], [0b000000, 0b011010], [0b000101, 0b011010]],   # div	011010  DivMult		lo = $s / $t; hi = $s % $t
[[opcode, function], [0b000000, 0b011011], [0b000110, 0b011011]],   # divu	011011  DivMult		lo = $s / $t; hi = $s % $t
[[opcode, function], [0b000000, 0b011000], [0b000111, 0b011000]],   # mult	011000  DivMult		hi:lo = $s * $t
[[opcode, function], [0b000000, 0b011000], [0b000111, 0b011000]],   # mult	011000  DivMult		hi:lo = $s * $t
[[opcode, function], [0b000000, 0b011001], [0b001000, 0b011001]],   # multu	011001	DivMult		hi:lo = $s * $t
[[opcode, function], [0b000000, 0b100111], [0b001001, 0b100111]],   # nor	100111	ArithLog	$d = ~($s | $t)
[[opcode, function], [0b000000, 0b100101], [0b001010, 0b100101]],   # or	100101	ArithLog	$d = $s | $t
[[opcode, function], [0b000000, 0b000000], [0b001011, 0b000000]],   # sll	000000	Shift		$d = $t << a
[[opcode, function], [0b000000, 0b000100], [0b001100, 0b000100]],   # sllv	000100	ShiftV		$d = $t << $s
[[opcode, function], [0b000000, 0b000011], [0b001101, 0b000011]],   # sra	000011	Shift		$d = $t >> a
[[opcode, function], [0b000000, 0b000111], [0b001110, 0b000111]],   # srav	000111	ShiftV		$d = $t >> $s
[[opcode, function], [0b000000, 0b000010], [0b001111, 0b000010]],   # srl	000010	Shift		$d = $t >>> a
[[opcode, function], [0b000000, 0b000110], [0b010000, 0b000110]],   # srlv	000110	ShiftV		$d = $t >>> $s
[[opcode, function], [0b000000, 0b100010], [0b010001, 0b100010]],   # sub	100010	ArithLog	$d = $s - $t
[[opcode, function], [0b000000, 0b100011], [0b010010, 0b100011]],   # subu	100011	ArithLog	$d = $s - $t
[[opcode, function], [0b000000, 0b100110], [0b010011, 0b100110]],   # xor	100110  ArithLog	$d = $s ^ $t
[[opcode, function], [0b000000, 0b101010], [0b010100, 0b101010]],   # slt	101010	ArithLog	$d = ($s < $t)
[[opcode, function], [0b000000, 0b101011], [0b010101, 0b101011]],   # sltu	101011	ArithLog	$d = ($s < $t)
[[opcode, function], [0b000000, 0b001001], [0b010110, 0b001001]],   # jalr	001001	JumpR		$31 = pc; pc = $s
[[opcode, function], [0b000000, 0b001000], [0b010111, 0b001000]],   # jr	001000	JumpR		pc = $s
[[opcode, function], [0b000000, 0b010000], [0b011000, 0b010000]],   # mfhi	010000	MoveFrom	$d = hi
[[opcode, function], [0b000000, 0b010010], [0b011001, 0b010010]],   # mflo	010010	MoveFrom	$d = lo
[[opcode, function], [0b000000, 0b010001], [0b011010, 0b010001]],   # mthi	010001	MoveTo		hi = $s
[[opcode, function], [0b000000, 0b010011], [0b011011, 0b010011]],   # mtlo	010011	MoveTo		lo = $s
[[opcode, function], [0b000000, 0b001100], [0b011100, 0b001100]],   # syscall 	001100	syscall		$2	seen on the .s generated by the ecc compiler
[[opcode], [0b001000], [0b011101]],                                 # addi    001000  ArithLogI       $t = $s + SE(i)
[[opcode], [0b001001], [0b011110]],                                 # addiu   001001  ArithLogI       $t = $s + SE(i)
[[opcode], [0b001100], [0b011111]],                                 # andi    001100  ArithLogI       $t = $s & ZE(i)
[[opcode], [0b001101], [0b100000]],                                 # ori     001101  ArithLogI       $t = $s | ZE(i)
[[opcode], [0b001110], [0b100001]],                           		# xori    001110  ArithLogI       $d = $s ^ ZE(i)
[[opcode], [0b001111], [0b100010]],                           		# lui	   001111          Rdest, imm: Load Upper Immediate
[[opcode], [0b011001], [0b100011]],                           		# lhi     011001  LoadI   HH ($t) = i
[[opcode], [0b011000], [0b100100]],                           		# llo     011000  LoadI   LH ($t) = i
[[opcode], [0b001010], [0b100101]],                           		# slti    001010  ArithLogI       $t = ($s < SE(i))
[[opcode], [0b001011], [0b100110]],                           		# sltiu   001011  ArithLogI       $t = ($s < SE(i))
[[opcode], [0b000001], [0b100111]],                           		# bgez(bgezal/bltz/beq/bltzal
[[opcode], [0b000100], [0b101000]],                           		# beq     000100  Branch  if ($s == $t) pc += i << 2
[[opcode], [0b000111], [0b101001]],                           		# bgtz    000111  BranchZ if ($s > 0) pc += i << 2
[[opcode], [0b000110], [0b101010]],                           		# blez    000110  BranchZ if ($s <= 0) pc += i << 2
[[opcode], [0b000101], [0b101011]],                           		# bne     000101  Branch  if ($s != $t) pc += i << 2
[[opcode], [0b100000], [0b101100]],                           		# lb      100000  LoadStore       $t = SE (MEM [$s + i]:1)
[[opcode], [0b100100], [0b101101]],                           		# lbu     100100  LoadStore       $t = ZE (MEM [$s + i]:1)
[[opcode], [0b100001], [0b101110]],                           		# lh      100001  LoadStore       $t = SE (MEM [$s + i]:2)
[[opcode], [0b100101], [0b101111]],                           		# lhu     100101  LoadStore       $t = ZE (MEM [$s + i]:2)
[[opcode], [0b100011], [0b110000]],                           		# lw      100011  LoadStore       $t = MEM [$s + i]:4
[[opcode], [0b101000], [0b110001]],                           		# sb      101000  LoadStore       MEM [$s + i]:1 = LB ($t)
[[opcode], [0b101001], [0b110010]],                           		# sh      101001  LoadStore       MEM [$s + i]:2 = LH ($t)
[[opcode], [0b101011], [0b110011]],                           		# sw      101011  LoadStore       MEM [$s + i]:4 = $t
[[opcode], [0b000010], [0b110100]],                           		# j       000010  Jump    pc = i << 2
[[opcode], [0b000011], [0b110101]],                           		# jal     000011  Jump    $31 = pc; pc = i << 2
[[opcode], [0b011010], [0b110110]],                           		# trap    011010  Trap    Dependent on operating system;
[[opcode], [0b101010], [0b110111]],                           		# swl Rsrc1, imm(Rsrc2): Store Word Left
[[opcode], [0b101110], [0b111000]],                           		# swr Rsrc1, imm(Rsrc2): Store Word Right
[[opcode], [0b100010], [0b111001]],                           		# lwl Rdest, imm(Rsrc): Load Word Left
[[opcode], [0b100110], [0b111010]]                           		# lwr Rdest, imm(Rsrc): Load Word Right
]
